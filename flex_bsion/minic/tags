!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSIGN	minic.tab.c	/^     ASSIGN = 272,$/;"	e	enum:yytokentype	file:
ASSIGN	minic.tab.h	/^     ASSIGN = 272,$/;"	e	enum:yytokentype
BEGIN	lex.yy.c	124;"	d	file:
CC	Makefile	/^CC=		gcc$/;"	m
CC_FILES	Makefile	/^CC_FILES=	util.c names.c symtab.c types.c check.c$/;"	m
CFLAGS	Makefile	/^CFLAGS=		-Wall -g$/;"	m
CHECK_H	check.h	2;"	d
COMMA	minic.tab.c	/^     COMMA = 274,$/;"	e	enum:yytokentype	file:
COMMA	minic.tab.h	/^     COMMA = 274,$/;"	e	enum:yytokentype
DIVIDE	minic.tab.c	/^     DIVIDE = 279,$/;"	e	enum:yytokentype	file:
DIVIDE	minic.tab.h	/^     DIVIDE = 279,$/;"	e	enum:yytokentype
DOT	minic.tab.c	/^     DOT = 275,$/;"	e	enum:yytokentype	file:
DOT	minic.tab.h	/^     DOT = 275,$/;"	e	enum:yytokentype
ECHO	lex.yy.c	601;"	d	file:
ELSE	minic.tab.c	/^     ELSE = 263,$/;"	e	enum:yytokentype	file:
ELSE	minic.tab.h	/^     ELSE = 263,$/;"	e	enum:yytokentype
EOB_ACT_CONTINUE_SCAN	lex.yy.c	159;"	d	file:
EOB_ACT_END_OF_FILE	lex.yy.c	160;"	d	file:
EOB_ACT_LAST_MATCH	lex.yy.c	161;"	d	file:
EQUAL	minic.tab.c	/^     EQUAL = 280,$/;"	e	enum:yytokentype	file:
EQUAL	minic.tab.h	/^     EQUAL = 280,$/;"	e	enum:yytokentype
FLEXINT_H	lex.yy.c	29;"	d	file:
FLEX_BETA	lex.yy.c	13;"	d	file:
FLEX_SCANNER	lex.yy.c	8;"	d	file:
FLOAT	minic.tab.c	/^     FLOAT = 259,$/;"	e	enum:yytokentype	file:
FLOAT	minic.tab.h	/^     FLOAT = 259,$/;"	e	enum:yytokentype
HH_FILES	Makefile	/^HH_FILES=	util.h names.h symtab.h types.h check.h$/;"	m
IF	minic.tab.c	/^     IF = 262,$/;"	e	enum:yytokentype	file:
IF	minic.tab.h	/^     IF = 262,$/;"	e	enum:yytokentype
INCREMENT_SIZE	names.c	12;"	d	file:
INITIAL	lex.yy.c	514;"	d	file:
INT	minic.tab.c	/^     INT = 258,$/;"	e	enum:yytokentype	file:
INT	minic.tab.h	/^     INT = 258,$/;"	e	enum:yytokentype
INT16_MAX	lex.yy.c	72;"	d	file:
INT16_MIN	lex.yy.c	63;"	d	file:
INT32_MAX	lex.yy.c	75;"	d	file:
INT32_MIN	lex.yy.c	66;"	d	file:
INT8_MAX	lex.yy.c	69;"	d	file:
INT8_MIN	lex.yy.c	60;"	d	file:
INVARIANT	names.c	19;"	d	file:
LBRACE	minic.tab.c	/^     LBRACE = 268,$/;"	e	enum:yytokentype	file:
LBRACE	minic.tab.h	/^     LBRACE = 268,$/;"	e	enum:yytokentype
LBRACK	minic.tab.c	/^     LBRACK = 270,$/;"	e	enum:yytokentype	file:
LBRACK	minic.tab.h	/^     LBRACK = 270,$/;"	e	enum:yytokentype
LOW	minic.tab.c	/^     LOW = 281,$/;"	e	enum:yytokentype	file:
LOW	minic.tab.h	/^     LOW = 281,$/;"	e	enum:yytokentype
LPAR	minic.tab.c	/^     LPAR = 266,$/;"	e	enum:yytokentype	file:
LPAR	minic.tab.h	/^     LPAR = 266,$/;"	e	enum:yytokentype
MINUS	minic.tab.c	/^     MINUS = 277,$/;"	e	enum:yytokentype	file:
MINUS	minic.tab.h	/^     MINUS = 277,$/;"	e	enum:yytokentype
NAME	minic.tab.c	/^     NAME = 260,$/;"	e	enum:yytokentype	file:
NAME	minic.tab.h	/^     NAME = 260,$/;"	e	enum:yytokentype
NAMES_H	names.h	2;"	d
NUMBER	minic.tab.c	/^     NUMBER = 265,$/;"	e	enum:yytokentype	file:
NUMBER	minic.tab.h	/^     NUMBER = 265,$/;"	e	enum:yytokentype
PLUS	minic.tab.c	/^     PLUS = 276,$/;"	e	enum:yytokentype	file:
PLUS	minic.tab.h	/^     PLUS = 276,$/;"	e	enum:yytokentype
RBRACE	minic.tab.c	/^     RBRACE = 269,$/;"	e	enum:yytokentype	file:
RBRACE	minic.tab.h	/^     RBRACE = 269,$/;"	e	enum:yytokentype
RBRACK	minic.tab.c	/^     RBRACK = 271,$/;"	e	enum:yytokentype	file:
RBRACK	minic.tab.h	/^     RBRACK = 271,$/;"	e	enum:yytokentype
REJECT	lex.yy.c	476;"	d	file:
RETURN	minic.tab.c	/^     RETURN = 264,$/;"	e	enum:yytokentype	file:
RETURN	minic.tab.h	/^     RETURN = 264,$/;"	e	enum:yytokentype
RPAR	minic.tab.c	/^     RPAR = 267,$/;"	e	enum:yytokentype	file:
RPAR	minic.tab.h	/^     RPAR = 267,$/;"	e	enum:yytokentype
SEMICOLON	minic.tab.c	/^     SEMICOLON = 273,$/;"	e	enum:yytokentype	file:
SEMICOLON	minic.tab.h	/^     SEMICOLON = 273,$/;"	e	enum:yytokentype
SOURCE	Makefile	/^SOURCE=		Makefile $(CC_FILES) $(HH_FILES) minic.y lex.l mct.sh$/;"	m
STRUCT	minic.tab.c	/^     STRUCT = 261,$/;"	e	enum:yytokentype	file:
STRUCT	minic.tab.h	/^     STRUCT = 261,$/;"	e	enum:yytokentype
SYMBOL_H	symtab.h	2;"	d
SYM_INFO	symtab.h	/^	} SYM_INFO;$/;"	t	typeref:struct:syminfo
SYM_LIST	symtab.h	/^	} SYM_LIST;$/;"	t	typeref:struct:symcell
SYM_TAB	symtab.h	/^	} SYM_TAB;$/;"	t	typeref:struct:symtab
TIMES	minic.tab.c	/^     TIMES = 278,$/;"	e	enum:yytokentype	file:
TIMES	minic.tab.h	/^     TIMES = 278,$/;"	e	enum:yytokentype
TYPES_H	types.h	2;"	d
T_ARRAY	types.h	/^	} T_ARRAY;$/;"	t	typeref:struct:array_type
T_CONS	types.h	/^typedef enum { int_t, float_t, fun_t, record_t, array_t } T_CONS; \/* type constructors *\/$/;"	t	typeref:enum:__anon1
T_FUN	types.h	/^	} T_FUN;$/;"	t	typeref:struct:__anon3
T_INFO	types.h	/^	} T_INFO;$/;"	t	typeref:struct:type_info
T_LIST	types.h	/^	} T_LIST;$/;"	t	typeref:struct:types_list
T_RECORD	types.h	/^	} T_RECORD;$/;"	t	typeref:struct:__anon2
UINT16_MAX	lex.yy.c	81;"	d	file:
UINT32_MAX	lex.yy.c	84;"	d	file:
UINT8_MAX	lex.yy.c	78;"	d	file:
UMINUS	minic.tab.c	/^     UMINUS = 282$/;"	e	enum:yytokentype	file:
UMINUS	minic.tab.h	/^     UMINUS = 282$/;"	e	enum:yytokentype
UTIL_H	util.h	2;"	d
YYABORT	minic.tab.c	665;"	d	file:
YYACCEPT	minic.tab.c	664;"	d	file:
YYBACKUP	minic.tab.c	677;"	d	file:
YYBISON	minic.tab.c	46;"	d	file:
YYBISON_VERSION	minic.tab.c	49;"	d	file:
YYCOPY	minic.tab.c	367;"	d	file:
YYCOPY	minic.tab.c	370;"	d	file:
YYDEBUG	minic.tab.c	105;"	d	file:
YYDPRINTF	minic.tab.c	757;"	d	file:
YYDPRINTF	minic.tab.c	906;"	d	file:
YYEMPTY	minic.tab.c	661;"	d	file:
YYEOF	minic.tab.c	662;"	d	file:
YYERRCODE	minic.tab.c	696;"	d	file:
YYERROR	minic.tab.c	666;"	d	file:
YYERROR_VERBOSE	minic.tab.c	110;"	d	file:
YYERROR_VERBOSE	minic.tab.c	111;"	d	file:
YYERROR_VERBOSE	minic.tab.c	113;"	d	file:
YYFAIL	minic.tab.c	673;"	d	file:
YYFINAL	minic.tab.c	400;"	d	file:
YYFPRINTF	minic.tab.c	754;"	d	file:
YYFREE	minic.tab.c	333;"	d	file:
YYID	minic.tab.c	/^YYID (int yyi)$/;"	f	file:
YYID	minic.tab.c	257;"	d	file:
YYINITDEPTH	minic.tab.c	915;"	d	file:
YYLAST	minic.tab.c	402;"	d	file:
YYLEX	minic.tab.c	744;"	d	file:
YYLEX	minic.tab.c	746;"	d	file:
YYLLOC_DEFAULT	minic.tab.c	705;"	d	file:
YYLSP_NEEDED	minic.tab.c	64;"	d	file:
YYMALLOC	minic.tab.c	326;"	d	file:
YYMAXDEPTH	minic.tab.c	926;"	d	file:
YYMAXUTOK	minic.tab.c	415;"	d	file:
YYNNTS	minic.tab.c	407;"	d	file:
YYNRULES	minic.tab.c	409;"	d	file:
YYNSTATES	minic.tab.c	411;"	d	file:
YYNTOKENS	minic.tab.c	405;"	d	file:
YYPACT_NINF	minic.tab.c	577;"	d	file:
YYPOPSTACK	minic.tab.c	1266;"	d	file:
YYPULL	minic.tab.c	61;"	d	file:
YYPURE	minic.tab.c	55;"	d	file:
YYPUSH	minic.tab.c	58;"	d	file:
YYRECOVERING	minic.tab.c	675;"	d	file:
YYRHSLOC	minic.tab.c	703;"	d	file:
YYSIZE_MAXIMUM	minic.tab.c	234;"	d	file:
YYSIZE_T	minic.tab.c	222;"	d	file:
YYSIZE_T	minic.tab.c	224;"	d	file:
YYSIZE_T	minic.tab.c	228;"	d	file:
YYSIZE_T	minic.tab.c	230;"	d	file:
YYSKELETON_NAME	minic.tab.c	52;"	d	file:
YYSTACK_ALLOC	minic.tab.c	280;"	d	file:
YYSTACK_ALLOC	minic.tab.c	284;"	d	file:
YYSTACK_ALLOC	minic.tab.c	289;"	d	file:
YYSTACK_ALLOC	minic.tab.c	312;"	d	file:
YYSTACK_ALLOC_MAXIMUM	minic.tab.c	309;"	d	file:
YYSTACK_ALLOC_MAXIMUM	minic.tab.c	315;"	d	file:
YYSTACK_BYTES	minic.tab.c	359;"	d	file:
YYSTACK_FREE	minic.tab.c	303;"	d	file:
YYSTACK_FREE	minic.tab.c	313;"	d	file:
YYSTACK_GAP_MAXIMUM	minic.tab.c	355;"	d	file:
YYSTACK_RELOCATE	minic.tab.c	386;"	d	file:
YYSTATE	lex.yy.c	131;"	d	file:
YYSTYPE	minic.tab.c	/^typedef union YYSTYPE$/;"	u	file:
YYSTYPE	minic.tab.c	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE	minic.tab.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE	minic.tab.h	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE_IS_DECLARED	minic.tab.c	179;"	d	file:
YYSTYPE_IS_DECLARED	minic.tab.h	93;"	d
YYSTYPE_IS_TRIVIAL	minic.tab.c	177;"	d	file:
YYSTYPE_IS_TRIVIAL	minic.tab.h	91;"	d
YYTABLES_NAME	lex.yy.c	1922;"	d	file:
YYTABLE_NINF	minic.tab.c	604;"	d	file:
YYTERROR	minic.tab.c	695;"	d	file:
YYTOKENTYPE	minic.tab.c	124;"	d	file:
YYTOKENTYPE	minic.tab.h	38;"	d
YYTOKEN_TABLE	minic.tab.c	118;"	d	file:
YYTRANSLATE	minic.tab.c	417;"	d	file:
YYUNDEFTOK	minic.tab.c	414;"	d	file:
YYUSE	minic.tab.c	250;"	d	file:
YYUSE	minic.tab.c	252;"	d	file:
YY_	minic.tab.c	240;"	d	file:
YY_	minic.tab.c	244;"	d	file:
YY_AT_BOL	lex.yy.c	330;"	d	file:
YY_BREAK	lex.yy.c	680;"	d	file:
YY_BUFFER_EOF_PENDING	lex.yy.c	246;"	d	file:
YY_BUFFER_NEW	lex.yy.c	234;"	d	file:
YY_BUFFER_NORMAL	lex.yy.c	235;"	d	file:
YY_BUFFER_STATE	lex.yy.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	lex.yy.c	143;"	d	file:
YY_CHAR	lex.yy.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	lex.yy.c	262;"	d	file:
YY_CURRENT_BUFFER_LVALUE	lex.yy.c	269;"	d	file:
YY_DECL	lex.yy.c	668;"	d	file:
YY_DECL_IS_OURS	lex.yy.c	664;"	d	file:
YY_DO_BEFORE_ACTION	lex.yy.c	355;"	d	file:
YY_END_OF_BUFFER	lex.yy.c	363;"	d	file:
YY_END_OF_BUFFER_CHAR	lex.yy.c	139;"	d	file:
YY_EXIT_FAILURE	lex.yy.c	1720;"	d	file:
YY_EXTRA_TYPE	lex.yy.c	525;"	d	file:
YY_FATAL_ERROR	lex.yy.c	655;"	d	file:
YY_FLEX_MAJOR_VERSION	lex.yy.c	9;"	d	file:
YY_FLEX_MINOR_VERSION	lex.yy.c	10;"	d	file:
YY_FLEX_SUBMINOR_VERSION	lex.yy.c	11;"	d	file:
YY_FLUSH_BUFFER	lex.yy.c	298;"	d	file:
YY_INPUT	lex.yy.c	608;"	d	file:
YY_INT_ALIGNED	lex.yy.c	4;"	d	file:
YY_LESS_LINENO	lex.yy.c	163;"	d	file:
YY_LOCATION_PRINT	minic.tab.c	731;"	d	file:
YY_LOCATION_PRINT	minic.tab.c	736;"	d	file:
YY_MORE_ADJ	lex.yy.c	478;"	d	file:
YY_NEW_FILE	lex.yy.c	137;"	d	file:
YY_NULL	lex.yy.c	111;"	d	file:
YY_NUM_RULES	lex.yy.c	362;"	d	file:
YY_READ_BUF_SIZE	lex.yy.c	593;"	d	file:
YY_REDUCE_PRINT	minic.tab.c	896;"	d	file:
YY_REDUCE_PRINT	minic.tab.c	909;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	lex.yy.c	479;"	d	file:
YY_RULE_SETUP	lex.yy.c	683;"	d	file:
YY_SC_TO_UI	lex.yy.c	118;"	d	file:
YY_STACK_PRINT	minic.tab.c	858;"	d	file:
YY_STACK_PRINT	minic.tab.c	908;"	d	file:
YY_START	lex.yy.c	130;"	d	file:
YY_START_STACK_INCR	lex.yy.c	650;"	d	file:
YY_STATE_BUF_SIZE	lex.yy.c	148;"	d	file:
YY_STATE_EOF	lex.yy.c	134;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	lex.yy.c	187;"	d	file:
YY_SYMBOL_PRINT	minic.tab.c	763;"	d	file:
YY_SYMBOL_PRINT	minic.tab.c	907;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	lex.yy.c	151;"	d	file:
YY_TYPEDEF_YY_SIZE_T	lex.yy.c	182;"	d	file:
YY_USER_ACTION	lex.yy.c	675;"	d	file:
YY_USER_INIT	lex.yy.c	510;"	d	file:
YY_USE_CONST	lex.yy.c	92;"	d	file:
YY_USE_CONST	lex.yy.c	99;"	d	file:
_STDLIB_H	minic.tab.c	294;"	d	file:
_STDLIB_H	minic.tab.c	322;"	d	file:
__STDC_LIMIT_MACROS	lex.yy.c	39;"	d	file:
alloca	minic.tab.c	287;"	d	file:
array	types.h	/^		T_ARRAY		array;$/;"	m	union:type_info::__anon4
array_t	types.h	/^typedef enum { int_t, float_t, fun_t, record_t, array_t } T_CONS; \/* type constructors *\/$/;"	e	enum:__anon1
array_type	types.h	/^typedef struct array_type {$/;"	s
base	minic.tab.c	/^char		*base;		\/* basename of command line argument *\/$/;"	v
base	types.h	/^	struct type_info	*base;$/;"	m	struct:array_type	typeref:struct:array_type::type_info
block	minic.y	/^block		: LBRACE 		{  scope = symtab_open(scope); }$/;"	l
buf	names.c	/^static	char*	buf		= 0;$/;"	v	file:
buf_avail	names.c	/^static	size_t	buf_avail	= 0;	\/* free bytes in buf *\/$/;"	v	file:
buf_size	names.c	/^static	int	buf_size	= 0;	\/* total size of buffer *\/$/;"	v	file:
check_arith_op	check.c	/^check_arith_op(int token,T_INFO* t1,T_INFO* t2)$/;"	f
check_array_access	check.c	/^check_array_access(T_INFO* ta,T_INFO* ti)$/;"	f
check_assignment	check.c	/^check_assignment(T_INFO* tlexp,T_INFO* texp)$/;"	f
check_fun_call	check.c	/^check_fun_call(SYM_TAB* scope,char* name,T_LIST** args)$/;"	f
check_record_access	check.c	/^check_record_access(T_INFO* t,char* field)$/;"	f
check_relop	check.c	/^check_relop(int token,T_INFO* t1,T_INFO* t2)$/;"	f
check_symbol	check.c	/^check_symbol(SYM_TAB* scope,char* name)$/;"	f
cons	types.h	/^	T_CONS 	cons;$/;"	m	struct:type_info
declaration	minic.y	/^declaration	: fun_declaration$/;"	l
declarations	minic.y	/^declarations	: declaration declarations$/;"	l
error	check.c	/^error(char *s1,char *s2,T_INFO* t1,char* s3,char* s4,T_INFO* t2)$/;"	f	file:
exp	minic.y	/^exp		: exp DOT NAME		{ $$ = check_record_access($1,$3); }$/;"	l
exps	minic.y	/^exps		: exp 			{ $$ = types_list_insert(0,$1); }$/;"	l
field	minic.y	/^field		: type NAME SEMICOLON	{ $$ = symtab_info_new($2,$1); }$/;"	l
fields	minic.y	/^fields		: field fields		{ $$ = symtab_list_insert($2,$1); }$/;"	l
fields	types.h	/^	SYM_LIST		*fields;$/;"	m	struct:__anon2
flex_int16_t	lex.yy.c	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	lex.yy.c	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	lex.yy.c	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	lex.yy.c	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	lex.yy.c	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	lex.yy.c	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	lex.yy.c	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	lex.yy.c	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	lex.yy.c	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	lex.yy.c	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint8_t	lex.yy.c	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	lex.yy.c	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
float_t	types.h	/^typedef enum { int_t, float_t, fun_t, record_t, array_t } T_CONS; \/* type constructors *\/$/;"	e	enum:__anon1
fmalloc	util.c	/^void	*fmalloc(size_t s)$/;"	f
fun	types.h	/^		T_FUN		fun;$/;"	m	union:type_info::__anon4
fun_declaration	minic.y	/^fun_declaration	: type NAME {	\/* this is $3 *\/$/;"	l
fun_t	types.h	/^typedef enum { int_t, float_t, fun_t, record_t, array_t } T_CONS; \/* type constructors *\/$/;"	e	enum:__anon1
function	symtab.h	/^	SYM_INFO	*function; \/* enclosing this scope *\/$/;"	m	struct:symtab
info	symtab.h	/^	SYM_INFO	*info;$/;"	m	struct:symcell
info	types.h	/^		} info;$/;"	m	struct:type_info	typeref:union:type_info::__anon4
int_t	types.h	/^typedef enum { int_t, float_t, fun_t, record_t, array_t } T_CONS; \/* type constructors *\/$/;"	e	enum:__anon1
lex_init	lex.yy.c	/^lex_init()$/;"	f
lexp	minic.y	/^lexp		: var			{ $$ = $1->type; }$/;"	l
lineno	minic.tab.c	/^int		lineno	= 1;	\/* number of current source line *\/$/;"	v
list	symtab.h	/^	SYM_LIST	*list;$/;"	m	struct:symtab
main	minic.tab.c	/^main(int argc,char *argv[])$/;"	f
more_parameters	minic.y	/^more_parameters	: parameter COMMA more_parameters$/;"	l
name	minic.tab.c	/^	char*		name;$/;"	m	union:YYSTYPE	file:
name	minic.tab.h	/^	char*		name;$/;"	m	union:YYSTYPE
name	symtab.h	/^	char			*name;$/;"	m	struct:syminfo
names_find	names.c	/^names_find(char *s)$/;"	f
names_find_or_add	names.c	/^names_find_or_add(char *s)$/;"	f
names_grow	names.c	/^names_grow(size_t size)$/;"	f	file:
names_insert	names.c	/^names_insert(char* s)$/;"	f
next	symtab.h	/^	struct symcell	*next;$/;"	m	struct:symcell	typeref:struct:symcell::symcell
next	types.h	/^	struct types_list	*next;$/;"	m	struct:types_list	typeref:struct:types_list::types_list
next_name	names.c	/^static	char*	next_name	= 0;	\/* address available for next string *\/$/;"	v	file:
parameter	minic.y	/^parameter	: type NAME {$/;"	l
parameters	minic.y	/^parameters	: more_parameters	{ $$ = $1; }$/;"	l
parent	symtab.h	/^	struct symtab	*parent;$/;"	m	struct:symtab	typeref:struct:symtab::symtab
program	minic.y	/^program		: declarations$/;"	l
record	types.h	/^		T_RECORD	record;$/;"	m	union:type_info::__anon4
record_t	types.h	/^typedef enum { int_t, float_t, fun_t, record_t, array_t } T_CONS; \/* type constructors *\/$/;"	e	enum:__anon1
scope	minic.tab.c	/^SYM_TAB 	*scope;		\/* current symbol table, initialized in lex.l *\/$/;"	v
short	minic.tab.c	190;"	d	file:
slist	minic.tab.c	/^	SYM_LIST*	slist;$/;"	m	union:YYSTYPE	file:
slist	minic.tab.h	/^	SYM_LIST*	slist;$/;"	m	union:YYSTYPE
source	types.h	/^	struct types_list	*source;$/;"	m	struct:__anon3	typeref:struct:__anon3::types_list
statement	minic.y	/^statement	: IF LPAR exp RPAR statement 		%prec LOW$/;"	l
statements	minic.y	/^statements	: statement SEMICOLON statements$/;"	l
sym	minic.tab.c	/^	SYM_INFO*	sym;$/;"	m	union:YYSTYPE	file:
sym	minic.tab.h	/^	SYM_INFO*	sym;$/;"	m	union:YYSTYPE
symcell	symtab.h	/^typedef struct symcell {$/;"	s
syminfo	symtab.h	/^typedef struct syminfo {$/;"	s
symtab	symtab.h	/^typedef struct symtab {$/;"	s
symtab_find	symtab.c	/^symtab_find(SYM_TAB *st,char *name)$/;"	f
symtab_info_equal	symtab.c	/^symtab_info_equal(SYM_INFO* i1,SYM_INFO* i2)$/;"	f	file:
symtab_info_new	symtab.c	/^symtab_info_new(char* name,T_INFO* t)$/;"	f
symtab_info_print	symtab.c	/^symtab_info_print(FILE* f,SYM_INFO* info)$/;"	f
symtab_insert	symtab.c	/^symtab_insert(SYM_TAB *st,char *name,T_INFO* t)$/;"	f
symtab_list_equal	symtab.c	/^symtab_list_equal(SYM_LIST* l1,SYM_LIST* l2)$/;"	f
symtab_list_find	symtab.c	/^symtab_list_find(SYM_LIST* l,char* name)$/;"	f
symtab_list_insert	symtab.c	/^symtab_list_insert(SYM_LIST* l,SYM_INFO* i)$/;"	f
symtab_list_print	symtab.c	/^symtab_list_print(FILE* f,SYM_LIST* l,char* separator)$/;"	f
symtab_list_release	symtab.c	/^symtab_list_release(SYM_LIST* l)$/;"	f
symtab_open	symtab.c	/^symtab_open(SYM_TAB * enclosing_scope)$/;"	f
symtab_print	symtab.c	/^symtab_print(FILE *f,SYM_TAB *tab)$/;"	f
target	types.h	/^	struct type_info	*target;$/;"	m	struct:__anon3	typeref:struct:__anon3::type_info
tlist	minic.tab.c	/^	T_LIST*		tlist;$/;"	m	union:YYSTYPE	file:
tlist	minic.tab.h	/^	T_LIST*		tlist;$/;"	m	union:YYSTYPE
type	minic.tab.c	/^	T_INFO*		type;$/;"	m	union:YYSTYPE	file:
type	minic.tab.h	/^	T_INFO*		type;$/;"	m	union:YYSTYPE
type	minic.y	/^type		: INT			{ $$ = types_simple(int_t); }$/;"	l
type	symtab.h	/^	struct type_info	*type;$/;"	m	struct:syminfo	typeref:struct:syminfo::type_info
type	types.h	/^	T_INFO			*type;$/;"	m	struct:types_list
type_info	types.h	/^typedef struct type_info {$/;"	s
types	types.c	/^static T_LIST	*types	= 0;$/;"	v	file:
types_array	types.c	/^types_array(T_INFO *base)$/;"	f
types_equal	types.c	/^types_equal(T_INFO *t1, T_INFO *t2)$/;"	f	file:
types_find	types.c	/^types_find(T_INFO *t)$/;"	f	file:
types_fun	types.c	/^types_fun(T_INFO* target,T_LIST *source)$/;"	f
types_list	types.h	/^typedef struct types_list {$/;"	s
types_list_equal	types.c	/^types_list_equal(T_LIST* t1,T_LIST *t2)$/;"	f
types_list_insert	types.c	/^types_list_insert(T_LIST* l,T_INFO *t)$/;"	f
types_list_print	types.c	/^types_list_print(FILE* f,T_LIST* tl,char* separator)$/;"	f
types_list_release	types.c	/^types_list_release(T_LIST* l)$/;"	f
types_new	types.c	/^types_new(T_CONS c)$/;"	f	file:
types_print	types.c	/^types_print(FILE* f,T_INFO *t)$/;"	f
types_print_all	types.c	/^types_print_all(FILE* f)$/;"	f
types_record	types.c	/^types_record(SYM_LIST *fields)$/;"	f
types_simple	types.c	/^types_simple(T_CONS c)$/;"	f
unput	lex.yy.c	179;"	d	file:
value	minic.tab.c	/^	int		value;$/;"	m	union:YYSTYPE	file:
value	minic.tab.h	/^	int		value;$/;"	m	union:YYSTYPE
var	minic.y	/^var		: NAME 			{ $$ = check_symbol(scope,$1); }$/;"	l
var_declaration	minic.y	/^var_declaration	: type NAME SEMICOLON	{ symtab_insert(scope,$2,$1); }$/;"	l
var_declarations	minic.y	/^var_declarations: var_declaration var_declarations$/;"	l
yy_accept	lex.yy.c	/^static yyconst flex_int16_t yy_accept[52] =$/;"	v	file:
yy_at_bol	lex.yy.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	lex.yy.c	/^static yyconst flex_int16_t yy_base[53] =$/;"	v	file:
yy_bs_column	lex.yy.c	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	lex.yy.c	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	lex.yy.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	lex.yy.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	lex.yy.c	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	file:
yy_buffer_stack_max	lex.yy.c	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	file:
yy_buffer_stack_top	lex.yy.c	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	file:
yy_buffer_state	lex.yy.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	lex.yy.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	lex.yy.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	lex.yy.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	lex.yy.c	/^static yyconst flex_int16_t yy_chk[89] =$/;"	v	file:
yy_create_buffer	lex.yy.c	/^    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )$/;"	f
yy_def	lex.yy.c	/^static yyconst flex_int16_t yy_def[53] =$/;"	v	file:
yy_delete_buffer	lex.yy.c	/^    void yy_delete_buffer (YY_BUFFER_STATE  b )$/;"	f
yy_did_buffer_switch_on_eof	lex.yy.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	lex.yy.c	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	lex.yy.c	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	file:
yy_fill_buffer	lex.yy.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	lex.yy.c	/^int yy_flex_debug = 0;$/;"	v
yy_flex_strlen	lex.yy.c	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	file:
yy_flex_strncpy	lex.yy.c	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	file:
yy_flush_buffer	lex.yy.c	/^    void yy_flush_buffer (YY_BUFFER_STATE  b )$/;"	f
yy_get_next_buffer	lex.yy.c	/^static int yy_get_next_buffer (void)$/;"	f	file:
yy_get_previous_state	lex.yy.c	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	file:
yy_hold_char	lex.yy.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	lex.yy.c	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	lex.yy.c	/^    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	file:
yy_init_globals	lex.yy.c	/^static int yy_init_globals (void)$/;"	f	file:
yy_input_file	lex.yy.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	lex.yy.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	lex.yy.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	lex.yy.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	lex.yy.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	lex.yy.c	/^static void yy_load_buffer_state  (void)$/;"	f	file:
yy_meta	lex.yy.c	/^static yyconst flex_int32_t yy_meta[32] =$/;"	v	file:
yy_n_chars	lex.yy.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	lex.yy.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	lex.yy.c	308;"	d	file:
yy_nxt	lex.yy.c	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	lex.yy.c	/^static yyconst flex_int16_t yy_nxt[89] =$/;"	v	file:
yy_reduce_print	minic.tab.c	/^yy_reduce_print (YYSTYPE *yyvsp, int yyrule)$/;"	f	file:
yy_scan_buffer	lex.yy.c	/^YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )$/;"	f
yy_scan_bytes	lex.yy.c	/^YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f
yy_scan_string	lex.yy.c	/^YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )$/;"	f
yy_set_bol	lex.yy.c	320;"	d	file:
yy_set_interactive	lex.yy.c	310;"	d	file:
yy_size_t	lex.yy.c	/^typedef size_t yy_size_t;$/;"	t	file:
yy_stack_print	minic.tab.c	/^yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)$/;"	f	file:
yy_start	lex.yy.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_state_type	lex.yy.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	lex.yy.c	/^    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f
yy_symbol_print	minic.tab.c	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_symbol_value_print	minic.tab.c	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_trans_info	lex.yy.c	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	lex.yy.c	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	file:
yy_verify	lex.yy.c	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalloc	lex.yy.c	/^void *yyalloc (yy_size_t  size )$/;"	f
yyalloc	minic.tab.c	/^union yyalloc$/;"	u	file:
yychar	minic.tab.c	/^int yychar;$/;"	v
yycheck	minic.tab.c	/^static const yytype_int8 yycheck[] =$/;"	v	file:
yyclearin	minic.tab.c	660;"	d	file:
yyconst	lex.yy.c	105;"	d	file:
yyconst	lex.yy.c	107;"	d	file:
yydebug	minic.tab.c	/^int yydebug;$/;"	v
yydefact	minic.tab.c	/^static const yytype_uint8 yydefact[] =$/;"	v	file:
yydefgoto	minic.tab.c	/^static const yytype_int8 yydefgoto[] =$/;"	v	file:
yydestruct	minic.tab.c	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	file:
yyensure_buffer_stack	lex.yy.c	/^static void yyensure_buffer_stack (void)$/;"	f	file:
yyerrok	minic.tab.c	659;"	d	file:
yyerror	minic.tab.c	/^yyerror(char *s)$/;"	f
yyfree	lex.yy.c	/^void yyfree (void * ptr )$/;"	f
yyget_debug	lex.yy.c	/^int yyget_debug  (void)$/;"	f
yyget_in	lex.yy.c	/^FILE *yyget_in  (void)$/;"	f
yyget_leng	lex.yy.c	/^int yyget_leng  (void)$/;"	f
yyget_lineno	lex.yy.c	/^int yyget_lineno  (void)$/;"	f
yyget_out	lex.yy.c	/^FILE *yyget_out  (void)$/;"	f
yyget_text	lex.yy.c	/^char *yyget_text  (void)$/;"	f
yyin	lex.yy.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yyinput	lex.yy.c	/^    static int yyinput (void)$/;"	f	file:
yyleng	lex.yy.c	/^int yyleng;$/;"	v
yyless	lex.yy.c	166;"	d	file:
yyless	lex.yy.c	1731;"	d	file:
yyless	lex.yy.c	1732;"	d	file:
yylex_destroy	lex.yy.c	/^int yylex_destroy  (void)$/;"	f
yylineno	lex.yy.c	/^int yylineno = 1;$/;"	v
yylval	minic.tab.c	/^YYSTYPE yylval;$/;"	v
yymore	lex.yy.c	477;"	d	file:
yynerrs	minic.tab.c	/^int yynerrs;$/;"	v
yyout	lex.yy.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yypact	minic.tab.c	/^static const yytype_int16 yypact[] =$/;"	v	file:
yyparse	minic.tab.c	/^yyparse (void *YYPARSE_PARAM)$/;"	f
yypgoto	minic.tab.c	/^static const yytype_int8 yypgoto[] =$/;"	v	file:
yypop_buffer_state	lex.yy.c	/^void yypop_buffer_state (void)$/;"	f
yyprhs	minic.tab.c	/^static const yytype_uint8 yyprhs[] =$/;"	v	file:
yypush_buffer_state	lex.yy.c	/^void yypush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f
yyr1	minic.tab.c	/^static const yytype_uint8 yyr1[] =$/;"	v	file:
yyr2	minic.tab.c	/^static const yytype_uint8 yyr2[] =$/;"	v	file:
yyrealloc	lex.yy.c	/^void *yyrealloc  (void * ptr, yy_size_t  size )$/;"	f
yyrestart	lex.yy.c	/^    void yyrestart  (FILE * input_file )$/;"	f
yyrhs	minic.tab.c	/^static const yytype_int8 yyrhs[] =$/;"	v	file:
yyrline	minic.tab.c	/^static const yytype_uint8 yyrline[] =$/;"	v	file:
yyset_debug	lex.yy.c	/^void yyset_debug (int  bdebug )$/;"	f
yyset_in	lex.yy.c	/^void yyset_in (FILE *  in_str )$/;"	f
yyset_lineno	lex.yy.c	/^void yyset_lineno (int  line_number )$/;"	f
yyset_out	lex.yy.c	/^void yyset_out (FILE *  out_str )$/;"	f
yyss_alloc	minic.tab.c	/^  yytype_int16 yyss_alloc;$/;"	m	union:yyalloc	file:
yystos	minic.tab.c	/^static const yytype_uint8 yystos[] =$/;"	v	file:
yystpcpy	minic.tab.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	minic.tab.c	958;"	d	file:
yystrlen	minic.tab.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	minic.tab.c	935;"	d	file:
yystype	minic.tab.c	178;"	d	file:
yystype	minic.tab.h	92;"	d
yysyntax_error	minic.tab.c	/^yysyntax_error (char *yyresult, int yystate, int yychar)$/;"	f	file:
yytable	minic.tab.c	/^static const yytype_int8 yytable[] =$/;"	v	file:
yyterminate	lex.yy.c	645;"	d	file:
yytext	lex.yy.c	/^char *yytext;$/;"	v
yytext_ptr	lex.yy.c	345;"	d	file:
yytname	minic.tab.c	/^static const char *const yytname[] =$/;"	v	file:
yytnamerr	minic.tab.c	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	file:
yytokentype	minic.tab.c	/^   enum yytokentype {$/;"	g	file:
yytokentype	minic.tab.h	/^   enum yytokentype {$/;"	g
yytoknum	minic.tab.c	/^static const yytype_uint16 yytoknum[] =$/;"	v	file:
yytranslate	minic.tab.c	/^static const yytype_uint8 yytranslate[] =$/;"	v	file:
yytype_int16	minic.tab.c	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	file:
yytype_int16	minic.tab.c	/^typedef short int yytype_int16;$/;"	t	file:
yytype_int8	minic.tab.c	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	file:
yytype_int8	minic.tab.c	/^typedef short int yytype_int8;$/;"	t	file:
yytype_int8	minic.tab.c	/^typedef signed char yytype_int8;$/;"	t	file:
yytype_uint16	minic.tab.c	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	file:
yytype_uint16	minic.tab.c	/^typedef unsigned short int yytype_uint16;$/;"	t	file:
yytype_uint8	minic.tab.c	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	file:
yytype_uint8	minic.tab.c	/^typedef unsigned char yytype_uint8;$/;"	t	file:
yyunput	lex.yy.c	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	file:
yyvs_alloc	minic.tab.c	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	file:
yywrap	lex.yy.c	/^yywrap()$/;"	f
