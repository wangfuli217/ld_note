http://tinf2.vub.ac.be/~dvermeir/courses/compilers/bison-1.25/bison_toc.html

synopsis analyser : parsing  # 确定词块之间是如何关联的。
1. YACC 可以解析由已经确认的标示组成的输入流，这清楚的描述了 YACC 和 Lex 之间的关系，YACC 不知道输入流是什么，他需要预先处理好的标示
   当然你也可以写自己的标示化程序，我们将这个部分的工作交给了 Lex。
   
yacc(){
    Yacc 提供了一个通用工具来描述计算机程序的输入。Yacc 用户规定它的输入的结构，(输入结构)
连同在识别每个这种结构的时候调用的代码。Yacc 把这样的规定转换成操作输入处理的一个子例程；
用这个子例程处理用户应用中的多数控制流经常是方便和适当的。
    Yacc 提供了一个通用工具来在计算机程序的输入上施加结构。Yacc 用户准备输入处理的规定；
它包括描述输入结构的规则，在识别了这些规则的时候调用的代码，和做基本输入的一个低层例程。
Yacc 接着生成一个函数来控制输入处理。这个函数叫做解析器(parser)，它调用用户提供的低层输入
例程(词法分析器(analyzer))来从输入流中选取基本项目(叫做记号(token))。依据叫做文法规则的
输入结构规则来组织这些记号；在识别了这些规则中的某一个的时候，接着调用为这个规则提供的
叫做动作的用户代码；动作有能力返回值并使用其他动作的值。

    词法分析器识别的结构叫做终结符(terminal symbol)，而解析器识别的结构叫做非终结符(nonterminal symbol)。
为了避免混淆，终结符通常会称呼为记号。

机器对它只能获得四个动作，叫做移进(shift)、归约(reduce)、接受和错误。解析器的移动按如下规则进行:
    1. 基于它的当前状态，解析器决定是否需要一个超前记号来决定应当做什么动作；如果需要并且没有读取，
则调用 yylex 来获得下一个记号。
    2. 使用当前状态，和超前记号(如果需要的话)，解析器决定它的下一个状态，并完成它。这可能导致状态
压入栈中，或从栈中弹出来，和导致超前记号被处理或保留。 
    
# 规约
如果某些输入字符串可以按两种或更多方式来构造，则这组文法是有歧义的。例如，文法规则
expr : expr '-' expr
    是表达算术表达式的一种自然的方式，把两个其他表达式放在一起并在中间的放一个减号就形成了算术表达式。
不幸的是，这个文法规则没有完全的规定构造所有复杂输入的方式。例如，如果输入是
    expr - expr - expr
规则允许这个输入被构造为
    ( expr - expr ) - expr
或者是
    expr - ( expr - expr )
(第一个叫左结合(association)，第二个叫右结合。
}

   
找出词块之间的关系。一种常见的关系表达方式是语法分析树。
为了编写一个语法分析器，我们需要一定的方法来描述语法分析器所使用的把一系列词块转化为语法分析树的规则。
规则：与上下文无关的语法；Context Free Grammer， 称作BNF范式

Yacc(有效序列的规范称为语法){
将任何一种编程语言的所有语法翻译成针对此种语言的 Yacc 语法解析器。
BNF(Backus Naur Form):巴科斯范式
yacc <options>
 <filename ending with .y>
Yacc 语法文件包括语法规范。还包含了序列匹配时你想要做的事。
}

Yacc(bison编程){
1. 通过在语法文件上运行 Yacc 生成一个解析器。
2. 说明语法：
    编写一个 .y 的语法文件（同时说明 C 在这里要进行的动作）。
    编写一个词法分析器来处理输入并将标记传递给解析器。 这可以使用 Lex 来完成。
    编写一个函数，通过调用 yyparse() 来开始解析。
    编写错误处理例程（如 yyerror()）。
3. 编译 Yacc 生成的代码以及其他相关的源文件。
4. 将目标文件链接到适当的可执行解析器库。

一个 Yacc 程序分为三个段：
    声明： C 声明可能会定义动作中使用的类型和变量，以及宏。 还可以包含头文件。
语法规则：
 C 代码 ：
}
Yacc(名词){
终端符号 : 代表一类在语法结构上等效的标记。 终端符号有三种类型：
    命名标记: 这些由 %token 标识符来定义。 按照惯例，它们都是大写。
    字符标记 : 字符常量的写法与 C 相同。例如, -- 就是一个字符标记。
    字符串标记 : 写法与 C 的字符串常量相同。例如，"<<" 就是一个字符串标记。

lexer 返回命名标记。

非终端符号 : 是一组非终端符号和终端符号组成的符号。 按照惯例，它们都是小写。 
在例子中，file 是一个非终端标记而 NAME 是一个终端标记。
}

yacc(Yacc语法){
yacc语法包括三部分：定义段、规则段和用户子例程段
...定义段...
%%
...规则段...
%%
...用户子例程段...
各部分由以两个百分号开头的行分开，尽管某一个部分可以为空，但是前两部分是必须的，第三部分和前面的百分号可以省略。

1.符号
    yacc 语法由符号组成，即语法的"词"。符号是一串不以数字开头的字母、数字、句点和下划线。符号error专用于错误恢复，
另外，yacc对任何符号都不会附加"先验"的意义。
    由词法分析程序产生的符号叫做终结符号或者标记。定义在规则左侧的叫做非终结符号或者非终结。标记也可能是字面上
引用的字符，通常遵循约定：标记大写，非终结符号小写。

2. 定义段
定义段包括文字块，逐字拷贝到生成的C文件开头部分的C代码，通常包括声明和#include行。可能有%union %start %token %type %left %right和%nonassoc声明。
也可以包含普通的C语言风格的注释，所有这些都是可选的，在简单的语法分析程序中，定义段可能完全是空的。

3. 规则段
规则段由语法规则和包括C代码的动作组成。

4. 用户子例程段
yacc 将用户子例程段的内容完全拷贝到C文件中，通常这部分包括从动作调用的例程。

5. 动作
动作是yacc与在语法中规则相符时执行的C代码，动作一定是C复合语句。
通过使用后面跟有数字的美元符号，动作可以查阅在规则中与符号有关的值,冒号后面跟的第一个符号是数字1，例如：
date：month  '/'  day   '/'  year
         { printf ("date %d-%d-%d  found",$1,$3,$5);}

而名字，$$是指冒号左边符号的值，符号值可以有不同的C类型。
}
yacc(特殊字符){
1. %
具有两个%标记的行将yacc语法分成了几部分；
定义段的所有声明都是以%开始，包括%{ %}    %union  %start   %token   %type   %left  %right  和 %nonassoc声明。
2. \
反斜线符号是废弃的百分号同义词，在动作中，C语言字符串中有其通常作用。
3. $
在动作中，美元符号引入一个值引用，举例来说，$3表示规则右端第3个符号的值。
4. '
文字标记由一个单引号结束，例如 'z' 。'
5. <>
在一个动作的值引用中，可以不考虑尖括号包围起来的默认类型。
6. "
有些yacc版本在文字标记中将单引号和双引号同等对待，这样使用根本不方便。"
7. {}
动作中C代码在大括号中。
8. ;
除了后面紧接着是以竖线开头的规则外，规则部分每个都是以分号结束。
9. |
当连续两个规则具有相同的左端，第二个规则可用一个 | 代替符号和冒号。
10. :
在每一条规则里，左端的每个符号后面都跟着一个冒号。
11. _
符号可以包括和字母、数字以及句点在一起的下划线。
12. .
符号可以包括与字母、数字、下划线一起的句点。
}
yacc(歧义和冲突){
由于语法有歧义或者包含冲突，yacc对于语法规范的翻译可能会失败。
一些情况下，语法确实有歧义，也就是说对于一个单独的输入字符串有两种可能的分析而且yacc处理不了。
另外一些情况，语法并无歧义，但yacc使用的语法分析技术不足以分析这个语法。
1. 移进/归约冲突
当一个输入字符串有两种可能的分析时，而且其中一个分析完成一个规则（归约选项），而另一个却没有（移进选项）时，移进/归约冲突便发生了。
当一个输入字符串有两种可能的分析时，而且其中一个分析完成一个规则（归约选项），而另一个却没有（移进选项）时，移进/归约冲突便发生了。

例如：
%%
e:                   'X'
                       |   e  '+'   e
                       ;
对于输入字符串"X+X+X"，有两种可能的分析："(X+X)+X"或者"X+(X+X)"，采用归约选项使得语法分析程序使用第一个分析，而采用移进选项则使用另一个。
2. 归约/归约冲突
当同样的标记可以完成两个不同的规则时，就会发生归约/归约冲突。
例如：
%%
prog:    proga | progb
proga:       'X' ;
progb:       'Y' ;
一个"X"可能是proga，也可能是progb。
大多数归约/归约冲突没这么明显，但是几乎在任何情况下它们在语法中都表现为错误。
}
y.code.c
y.tab.c
y.tab.h
y.output
/tmp/yacc.aXXXXXX
/tmp/yacc.tXXXXXX
/tmp/yacc.uXXXXXX
bison(命令){
yacc [ -dlrtv ] [ -b file_prefix ] [ -p symbol_prefix ] filename

-b   file_prefix  -b 选项改变的是为输出的文件名准备的前缀，这个字符串用 file_prefix 指定，缺省的前缀是 y.。
-d   -d -d 选项导致多写一个 y.tab.h 头文件。(包含一些词法定义)
-l   如果没有指定  -l  选项，则  yacc  将在生成的代码中插入  #line  宏命令  (directive)。  #line  宏命令用于让 C
     编译器把在生成的 C 代码中的 错误与用户的原始 yacc 代码联系起来。如果指定了 -l 选项，yacc  将  不插入  #line
     宏命令。用户指定的 #line 宏命令还是将被保留的。
-p   symbol_prefix
     -p 选项改变的是为 Yacc生成的符号(symbols)准备的前缀，这个字符串用 symbol_prefix 指定，缺省的前缀是 yy。

-r   -r 选项导致 yacc 生成生成分开的代码和表文件。代码文件名是 y.code.c， 表文件名是 y.tab.c。
-v   -v 选项导致在文件 y.output 中写出可被人阅读的对生成的分析器的描述。

cc <source file names> -ly
}

yacc(func){
1. yyerror()
所有版本也都提供简单的错误报告例程，它也是非常简单：
yyerror(char *errmsg){
    printf("%s\n",errmsg);
}
这有时能够满足要求，但是一个好的错误报告例程至少能报告行号和最近的标记（如果词法分析程序是用lex写的，那么会在yytext中），这将会对语法分析程序更有用。

2. YYABORT
特殊语句
YYABORT
在动作中使得语法分析例程yyparse()以一个非零值立即返回，显示失败。
当动作例程探测到错误非常严重以致于没有继续分析的点时是很有用的。
由于语法分析程序可以向前查看一个标记，所以在语法分析程序读到另一个标记前，包括YYABORT的规则动作可不被归约。

3. YYACCEPT
特殊语句
                YYACCEPT
在动作中使得语法分析例程yyparse()以一个零值立即返回，显示成功。
在词法分析程序不能告知输入数据何时结束而语法分析程序能告知的情况下是很有用的。
由于语法分析程序可以向前查看一个标记，所以在语法分析程序读到另一个标记前，包括YYACCEPT的规则动作可不被归约。

4. YBACKUP
宏YYBACKUP使得你可以移出当前记号并把它替换为另一个记号，该语法为：
sym：      TOKEN   {YYBACKUP(newtok,newval);}
它放弃已经被归约的符号sym，并且假装词法分析器刚刚读到记号newtok，其值为newval。如果此时存在一个向前查看的记号或者该规则在右部的符号超过一个的话，这个规则将通过调用yyerror()来宣告失败。
正确使用YYBACKUP非常困难，一般不用。

5. YYDEBUG
由于跟踪代码又大又慢，所以不能自动编译到目标程序中。为了包含跟踪代码，使用yacc命令行上的-t标志，或者要么在C编译程序命令行上，或者通过在定义段包含类似下面的句式，来定义C预处理程序符号YYDEBUG为非零值：
%{
       #define YYDEBUG  1
%}
6. YYERROR
有时动作代码能探测到上下文相关的而语法分析程序本身却不能检测到的语法错误。如果代码检测到一个语法错误，就可以调用宏YYERROR，生成的效果与语法分析程序读到一个被语法禁止的标记时完全一样。一调用YYERROR，语法分析程序就访问yyerror()，进入错误恢复模式，寻找可以移进error标记的状态。

7. yyerror()
只要yacc语法分析程序探测到语法错误就调用yyerror()函数，将错误报告给用户。传递单个参数即描述这个错误的字符串，yacc库中的yyerror的默认版本仅仅是在标准输出文件中打印参数。
下面是返回更多信息的版本：
yyerror(const char *msg){
       printf("%d:  %s  at  '%s'  \n",yylineno,msg,yytext);
}
yylineno是当前行号，yytext是包含当前标记的lex标记缓冲器。
}
yacc_lex(){
一个程序通常在每次返回一个标记时都要调用 yylex() 函数。只有在文件结束或者出现错误标记时才会终止。
一个由 Yacc 生成的解析器调用 yylex() 函数来获得标记。 yylex() 可以由 Lex 来生成或完全由自己来编写。 
对于由 Lex 生成的 lexer 来说，要和 Yacc 结合使用，每当 Lex 中匹配一个模式时都必须返回一个标记。 
因此 Lex 中匹配模式时的动作一般格式为：
{pattern} { /* do smthg*/
 return TOKEN_NAME; }
}




bison -d fb1-5.y
-d:会创建fb1-5.tab.c和fb1-5.tab.h
flex:来创建lex.yy.c
cc -o $@ fb1-5.tab.c lex.yy.c -lfl

format()
{
1. 声明和选项设置                               %{ ... ... %}
2. 动作和模式                                   %% ... ... %%
3. 会被拷贝到生成的词法分析器里面的C语言代码。 

记号总是使用大写字母。
任何没有被声明为记号的语法符号必须出现在至少一条规则的左边。

bison会自动帮你分析语法，记住每条被匹配的规则，所以动作代码只需要维护每个语法符号关联的语义值。
bison语法分析器也执行一些额外动作，比如创建数据结构以便后续使用。

每个bison规则中的语法符号都有一个语义值，目标符号的值在动作中代码使用$$代替，右边语法符号的语义值依次为$1,$2.直到这条规则的结束。
当词法分析器返回记号时，记号值总是存储在yyval里，其他语法符号的语义则在语法分析器的规则里进行佘子涵。
}

移进/归约冲突和操作符优先级
    可以再语法规则外单独描述优先级，%left %right %noassoc的出现顺序决定了由低到高的优先级
    %left表示左结合、%right右结合、%noassoc表示没有结合性
    UMINUS单目负号操作的伪标记
    %prec UMINUS将较低优先级的单目负号拥有比乘法更高的优先级
