7 输入是如何匹配的？
    当生成的扫描器运行时，它会分析它的输入并查找任何匹配其模式的字符串。若找到多个匹配，
则匹配较长的那个文本(对于尾附的上下文规则，这里的长度包含尾巴的长度，纵然接下来尾巴要返回
到输入中-也即该尾巴接下来也作为输入)。如果它找到两个或多个长度一样的匹配，则会选择flex输入
文件的列表中的第一个(匹配)。

    一旦匹配确定下来，跟匹配项关联的文本(称为token)就可以在全局指针yytext中获取，
并且其长度在全局整型(变量)yyleng中。接着跟匹配模式关联的action就会执行(见Action)，
接着剩下的输入也会被扫描并进行下一个匹配。

    如果没有找到匹配，则默认规则就会执行：输入中的下一个字符会被认为(跟默认规则)匹配，
并将该字符拷贝到标准输出中。所以，最简单并正确的flex输入为：
        %%
它生成一个扫描器，简单的将其输入拷贝（每次拷贝一个字符）到标准输出中。

注意，yytext可以用两种不同的方式来定义：要么是一个字符指针或一个字符数组。你可以
通过在flex输入文件中的中的第一部分(即指令部分)包含两个特殊指令之一：%pointer或
%array。默认情形是%pointer，除非你使用'-l'的lex兼容选项，此时，yytext就是一个数
组。使用%pointer的好处是扫描的速度极快，并且在匹配非常长的标识符(tokens)时不会
有缓冲区溢出(除非你的动态内存都用完了)。缺点是你修改yytext时会受限(参见Actions)，
并且在调用unput()函数时，会销毁之前的yytext中的内容，这会导致在不同lex版本间迁移
时出现非常头疼的问题。

    使用%array的优点是你可以在你的关心的内容中修改yytext的内容，而在调用unput()
时不会销毁yytext()(参见Actions)。更甚者，已生成的lex程序有时会在外部访问yytext的内容，
使用以下这种声明：
    extern char yytext[];
当用%pointer时，这种声明方式是错误的，但如果是%array，则可以这样声明。

%array声明将yytext定义为一个长度为YYLMAX个字节的数组，YYLMAX默认为一个相当大的值
。你可以在flex输入文件的第一部分通过#define语句轻易的将YYLMAX的值定义为一个不同
的值。如上面提到的，用%pointer的话，yytext会动态增长，以容纳巨大的标识符。这意味
着带%pointer的扫描器可以容纳非常大的标识符(tokens)(如匹配整个注释块)，但记住，
扫描器必须每次重新调整yytext的长度，而且必须从头重新扫描整个标识符(token)，所以
匹配这样的标识符绝对会(比较)慢。现在的yytext不会动态增长了，如果unput的输出结
果很长，那么这个调用会被驳回并出现一个运行时错误。

同时注意，你不能在C++的扫描类中使用%array(参见Cxx)。