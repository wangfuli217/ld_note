8 行为
    规则中的每个模式都有相应的行为，它们可以是任意的C语句。模式(部分)以第一个非空
空白字符作为结束；该行剩下来的部分就是该模式的行为。如果该行为为空，那么，当该模
式被匹配到时，那么仅仅将输入的标识符丢弃。例如，下面是一个程序中的代码，它删除输
入中出现的'zap me'：
    %%
    "zap me"

这个示例将拷贝输入中所有(除"zap me"以外的)字符到输出中，因为它们会被默认模式匹配。

这里是一个压缩多个空白或制表符到一个空白的程序，并且抛弃行末发现的任何空白字符：
    %%
    [ \t]+      putchar(' ');
    [ \t]+$     /* 忽略'$'字符 */

如果行为包含一个'{'字符，那么在遇到匹配的'}'之前，该行为就跨越这段空间，从而这个
行为可能会跨越多行。flex能识别C的字符串和注释，并不会被其中(指字符串和注释)的
花括号所愚弄，并且还允许行为以'%{'开头，并将该行为视作一个文本，直到下一个'%}'
(无视该行为中的寻常花括号)。

    一个只由一个竖线('|')组成的行为意味着"该行为对下一个规则同样有效"。后面会有一
个(例子)说明。

    行为可以包含任意的C代码，包括return语句来返回一个由某函数调用yylex()后所返回的值。
每次yylex()都会被调用，以用来处理最后的那个标识符，直到它要么达到了文件尾或遇
到一个return语句。

    行为可以自由的修改yytext的内容，但不能修改其长度(增加字符到其尾部，将会覆盖输入
流中的后续字符)。但如果应用%array的话，就没有该功能(即修改yylex，见Matching)。
在这种情况下，可以任意修改yytext。

    行为可以自由的修改yyleng，除非――如果行为同时也可以使用yymore(见下文),则行为不应
该修改yyleng。

有多个特殊指令可以被包含在规则内部：
  ECHO
    拷贝yytext(的内容)到扫描器的输出中。
  BEGIN
    跟在一个起始规则的后面，将扫描器置于相应起始规则的位置(参见下文)。
  REJECT
    指示扫描器处理"第二个"规则，该规则将匹配输入(或者是输入的前缀)。该规则会如
同在Matching所描述的那样被选择，并且会正确的设置yytext和yyleng。它要么匹配尽可能
多的文本，作为原来的选择规则，但只是在flex的输入文件中较晚出现，或者匹配尽可能少
的文本。例如下面的(规则)将统计输入中字的个数并在看到'frob'时调用函数special()
        int word_count = 0;
    %%
    frob        special(); REJECT;
    [^ \t\n]+   ++word_count;
    
    在此处如果没有REJECT，任何输入中的'frob'将不会被计数为一个单词，因为扫描器一般只
对一个标识符(token)执行一个动作。可以多次使用REJECT，每次(使用)都会寻找下一个最好的
选择到当前的规则规则动作中。例如，当下面的扫描器扫描到标识符'abcd'时，它会
将'abcdabcaba'写入到输出中：
    %%
    a           |
    ab          |
    abc         |
    abcd        ECHO; REJECT;
    .|\n        /*eat up any unmatched character */
前面的三个规则共享第四个规则的行为，因为它们使用了一个特殊的行为――'|'。

从扫描器性能的角度而言，REJECT是一个开销特别大的特性；如果在任何扫描器的行为中都
使用该特性，那么它将减慢所有扫描器的匹配速度。更甚者，REJECT不能跟'-Cf'或'-CF'选
项一起使用，参见(Scanner Options)。

还需注意的是，跟其它特定的行为不同，REJECT是一个分支(译注：类似switch语句中的case分支)。
行为中跟其后的代码并不会马上执行。

  yymore()
    它告诉我们扫描器下次会匹配一个规则，(该规则)相应的行为应该是附属到了当前yytext
的值中，而不是取代它(译注：指当前yytext的值)。例如，给定输入'mega-kludge'，下面
(的规则)会将'mega-mega-kludge'写入到输出中：
    %%
    mega-       ECHO; yymore();
    kludge      ECHO;
首先，'mega-'被匹配并输出到输出中。接着'kludge'被匹配，但是之前的'mega-'仍旧呆在
yytext的开始部分，所以，'kludge'规则的ECHO(行为)实际会将'mega-kludge'写入到输
出中。

对于使用yymore()有两点需要注意，第一，yymore()依赖于yyleng的值，该值正确的反应了
当前标识符(token)的长度。所以，在使用yymore()时绝对不能修改yyleng的值。第二，
扫描器中yymore()的出现会导致匹配速度上的性能的一点点损失。

  yyless(n)返回输入流中当前标识符(token)中除去前面n个字符的所有字符，当扫描器寻
找下一个匹配时，这些字符将会被再次扫描。yytext以及yyleng会适当的做一些调整(比如
，yyleng会和n相等)。例如，对于输入'foobar'，下面(的规则)将写入'foobarbar'到输
出中：
    %%
    foobar      ECHO; yyless(3);
    [a-z]+      ECHO;

如果用0作为yyless()的参数，将会导致重新扫描当前输入的字符串。除非你对"扫描器将
如何处理其随后的输入"做了一些修改(例如，用BEGIN)，这将导致一个死循环。
注意，yyless()是一个宏，你只能将其用在lex的输入文件中，而不能在其它源文件中使用它。

  unput(c)
    将字符c送回到输入中。该字符将是下一个被扫描到的字符。下面的行为将把当前标识
符(token)(送到输入中)并使得它在括号中被重新扫描一遍：
    {
    int i;
    /* 拷贝yytext，因为unput会损坏yytext的内容 */
    char *yycopy = strdup(yytext);
    unput(')');
    for (i = yyleng - 1; i >= 0; --i)
        unput(yycopy[i]);
    unput('(');
    free(yycopy);
    }

注意，由于unput()会将给定的字符置于输入流的开始部位，这个操作必须以从后面往前面
的顺序来完成(译注：在上面的for循环中可以看出来)。

在使用unput()时有一个严重的潜在隐患，即如果你使用了%pointer（默认选项），unput()
调用将会破坏yytext的内容，(它从yytext的)最左边位置开始，每次调用都会吞噬yytext
左边的一个字符。如果你需在调用unput()之后保护yytext的值(例如上例)，你必须要么
将其拷贝到某处，或者用%array(来取代%pointer)来编译你的扫描器(参见Matching)。
最后请注意，你不能将'EOF'返送给输入流，并以此来企图将输入流标记为一个文件结束符。

  input()
    它从输入流中读取下一个字符。例如，下面的规则是一种忽略C注释的方式：
    %%
    "/*"        {
        register int c;
        for (;;) {
            while ((c = input()) ！= ’*‘ && c != EOF)
                  ;  /* 忽略输入注释文本 */
            if (c == '*') {
               while ((c = input()) == '*')
                  ;
               if (c == '/')
                  break; /* 找到结束位置 */
            }
            if (c == EOF) {
                error("EOF in comment");
                break;
            }
        }
    }

（注意，如果扫描器使用C++来编译的话，input()会被yyinput()所取代，目的是为了避免
和C++的流操作名input相冲突。)
  YY_FLUSH_BUFFER()
    刷新扫描器内部缓冲区，使得扫描器下次试图去匹配一个标识符(token)时，它将首
先用YY_INPUT()重新填充该缓冲区(见Generated Scaner)。该行为在多个常用的yy_flush_buffer()
中是个特殊情况，在下文描述（见Multiple Input Buffers）。
  yyterminate()
    可以用来替代一个规则中的return语句。它结束扫描器执行并返回0给扫描器调用者，
暗示着“任务完成”。默认情况下，当遇到一个文件结束符时，yyterminate()也会被调用。
它是一个宏，可以被重定义。
