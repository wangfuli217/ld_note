lex和yacc都分为3段,定义段,规则段,用户子例程段
%{
	//定义段,最终原样拷到c的代码,可以编写任何有效的c代码
%}
这里也是定义部分,如
%s FNAME	(%s=%x+INITIAL)	
在词法分析程序中创建新的起始状态,在规则部分添加"<FNAME>"开始的规则,这些规则只在词法分析程序处于FNAME状态时被识别,在其他规则的动作中可以使用BEGIN FNAME来启用此规则匹配,BEGIN语句用来输入一条新状态,要改为默认状态可以使用BEGIN 0(默认地,状态零称为INITIAL)
%%	//标记段结束


flex2.4默认将yywrap()从宏改成库例程,这样,不定义自己yywrap()的扫描程序就需要与库fl连接在一起
//规则段,每个规则由2部分组成,lex模式只匹配输入字符或字符串一次,lex执行当前输入的最长可能匹配的动作,一样长匹配最先出现的规则
模式(unix样式正则表达式)     动作(	 动作是c或c++代码
"<<EOF>>"模式匹配文件结尾	yytext变量是lex已经定义好的指向当前匹配内容的变量,是个char数组,可用%s来打印
							 yylex()	lex产生的词法分析程序入口
							;  		忽略输入
							|  		应用下个模式的动作
							ECHO 	输出匹配的模式
							多个动作可用{}括起来
							yyin	lex从标准I/O文件中的yyin读取输入,因为需要时可以改变yyin,yyin默认是stdin标准输入
							yyout	修改yyout文件指针,ECHO输出可以被重定向
							int yywrap(void)	当yylex到达输入文件尾端时,会调用yywrap,返回0(yylex会假设yywrap已经打开了另一个文件,而且继续读取yyin)或1(程序完成而且没有输入),默认问题返回1,有时要自己定义yywrap时,需要在定义段#undef yywrap,因为可能yywrap是一个宏
							int input(void)		读取输入流下一个字符,flex不允许重新定义宏input和unput
							void unput(char c)	将c字符重新放入输入流,不识别的输入会被回送,会调用unput(c)
							yyleng		和strlen(yytext)作用相同
						  )
%%	//标记段结束

//用户子例程段
任意合法的c代码组成
flex *.l(生成lex.yy.c)  => gcc -ll *.c -o target	(-ll是为了链接lex库l,flex的库名为fl)

yacc(bison -d生成定义.h和.c,通常生成如*.tab.h文件,可以被lex文件包含,编译时要加上-ly链接yacc库)
yyparse()			yacc产生的语法分析程序入口,返回结果为0表示分析成功
yyerror(char *)		yacc调用lex程序必须提供的2个函数之一,还有一个是main,yacc分析到无效的标记列表会调用yyerror

yacc的规则段
规则名字:	符号列表  动作代码(以{号开始以}结束的C代码)   指示规则结尾的分号   默认情况下,第一条规则是最高级别的规则
符号列表之间的|号表示引入和前一条规则相同的左侧规则,可以递归(一条规则直接或间接调用它本身)
$1,$2...可以引用规则右侧符号的值,通过$$可以设置规则左侧的值,默认返回$$,在执行任何明确的动作代码之前,会将$1赋予$$

yacc指定优先级有2种方式,显式和隐式,隐式地按照规则出现的顺序,越在下面的规则优先级越高,且默认左结合
yacc指定规则右侧最右边标记的优先级作为该规则的优先级,如果这条规则不包含具有优先级的标记,那么这条规则就没有自己的优先级
可在yacc的定义段与%%之间定义
%token  NAME		 	定义终结符
%token	<来自union中数据类型适当的字段名>	NAME	定义有类型的终结符,也可以在left,right,nonassoc中设置类型
在动作代码中,自动根据类型确定符号的引用值,如$1为NUMBER,引用$1的动作就类似$1.dval
%left	'+' '-'			同为终结符,且有优先级和结合性,左结合
%right	 				右结合
%nonassoc 	UMIMUS		不可结合（即它定义的终结符不能连续出现：例如<，如果文法中不允许出现形如a<b<c的句子，则<就是不可结合的）
而优先级关系则是以他们定义出现的顺序决定的，先定义的优先级低，最后定义的优先级最高，同时定义的优先级相同
%union					声明的内容被逐字拷贝到输出文件,成为c的typedef语句中定义YYSTYPE类型的union声明,可以在词法分析程序中使用
{
	double dval;
	int vblno;
}

%prec	UMINUS			%prec告诉yacc这条规则使用UMIMUS的优先级(在规则段)

终结符:	通俗来说是不能出现在推导式左边的符号,也就是说终结符不能再进行推导,如a->b,则a必然是个非终结符
一般非终结符用大写符号来表示,终结符用小写符号

非终结符
%start指定文法的开始符号（非终结符），定义形式为： %start startsym ，其中startsym为文法的开始符号。如果不使用%start定义文法开始符号，则默认在第二部分规则段中定义的第一条产生式规则的左部非终结符为开始符号。

%type	<类型>	定义非终结符,类型是必须项

当语法分析程序读取标记时,每次它读取一个未完成规则的标记,就把它压入内部堆栈中并切换到一种反映它刚刚读取的标记的新状态,这个动作称为移进(shift),当它发现组成某条规则右侧的全部符号时,它就把右侧符号弹出堆栈,面将左侧符号压入堆栈,并且切换到反映堆栈上新符号的新状态,这个动作称为归约(reduction)

yacc不能处理需要向前看多于一个的标记才能确定它是否已经匹配一条规则的语法
默认情况下,yacc使所有值的类型为int

由文法产生语言句子的基本思想是： 
从识别符号开始，把当前产生的符号串中的非终结符号替换为相应规则右部的符号串，直到最终全由终结符号组成。这种替换过程称为推导或产生句子的过程，每一步成为直接推导或直接产生

lex返回给yacc的是标记,将标记代码作为一个值返回,这些标记定义在yacc中,lex通过包含*.tab.h来使用
无论词法分析程序何时将标记返回给语法分析程序,如果标记有相关的值,词法分析程序必须在返回前将值存储在yylval(类型为YYSTYPE)中