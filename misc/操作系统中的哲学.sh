    操作系统的设计者必须在硬件相关的代码与硬件无关的代码之间划出清楚的界限，以便于一个操作系
统很容易地移植到不同的平台。

philosophy(陈莉君)
{
1. 哲学像影子，说它存在，摸不着；说不存在，又无处不在。自己一直喜欢哲学，但从来没有啃过哪一个哲学家的大部头著作，因此，
   也算不上一个真正的哲学爱好者，充其量是哲学的实用者。

2. 讲授操作系统多年后，才发现操作系统的设计无处不体现哲学思想。比如，操作系统的整体设计目标为：方便用户，提高效率。这和
   现实世界中众多事情所追求的目标没有什么差异。但操作系统的具体实现没有把这样的目标停留在口头上，而是不遗余力地付之实施。
   比如那个快被人遗忘的DOS操作系统，它简单，但使用不方便，不能指望两岁的小孩就会使用DOS，但那个招惹小孩的Windows，把方便
   使用放在头等重要的位置。至于效率，一个没有效率的操作系统注定胎死腹中，比如微内核操作系统MACH，尽管学术意义无可比拟，
   但终究没有在市场占一席之地。

3. 操作系统设计中对"折中"的应用更是淋漓尽致。比如说，方便和高效就是一对矛盾，追求方便的同时势必影响效率的提高。别以为Windows
   华丽的外表就是天生丽质，如果没有硬件兄弟（比如Intel老大哥）的帮忙，我们只能在按下一次鼠标后，再喝一口茶，看看是否得到我们
   要的结果了。

4. 如果说操作系统是至高无上的管理者，那么另一方面，也可以说它是鞠躬尽瘁的丫环。只所以这么说是因为它见谁管谁，CPU、内存、外存、
   各种外设以及文件等等，无一不在它的管辖之下。但它并没有居功自傲，同时还卑微地为大家服务，不管让它干什么，都毫无怨言地一一去做，
   除非招惹了它，可能也罢工，甚至让整个机子瘫痪。
}

learn(资料收集)
{
1．CPUFreq机制。
2．performance、powersave、userspace、ondemand、conservative调频策略。
3．/driver/cpufreq/。
4．/documention/cpufreq。
5．P state和C state。
}

learn(源码定位)
{
我们更关心的是待分析代码的主要机制，而非与机器相关的特化代码（这样更有助于我们理解内核的本质）。

1. 关注到/driver/cpufreq/cpufreq.c这个源文件。
2. cpufreq_performance.c、cpufreq_powersave.c、cpufreq_userspace.c、cpufreq_ondemand、cpufreq_conservative.c这五个源文件。
3. freq_table.c、cpufreq_stats.c和/include/linux/cpufreq.h。
}

learn(简单注释)
{
1. 在已定位好的源码文件中，分析每个变量、宏、函数、结构体等代码元素的大致含义和功能。
2. www.stackoverflow.com

}

learn(详细注释)
{
1．变量定义在何时被使用。
2．宏定义的代码何时被使用。
3．函数的参数和返回值的含义。
4．函数的执行流程和调用关系。
5．结构体字段的具体含义和使用条件。
}

learn(模块内部标识符依赖关系)
{
1. 根据它们调用的函数（自己定义的或者其他模块的函数）和使用的关键变量（本文件内的全局变量或者其他模块的外部变量）
   画出"函数-变量-函数"依赖关系图――我们称为标识符依赖关系图。
2. 我们根据函数本身的含义，将模块进行子功能划分，抽取出每个子功能的标识符依赖树。

  
}

learn(模块间相互依赖关系)
{

}

learn(模块架构图)
{
1. 如cpufreq的模块依赖关系图所示，我们可以很清楚的看到所有的调频策略模块都是依赖于核心模块cpufreq、cpufreq_stats和freq_table的。
   如果我们把被依赖的三个模块抽象为代码的核心框架的话，这些调频策略模块都是建立在这个框架之上的，它们负责和用户层交互。
   而核心模块cpufreq提供了驱动等相关的接口负责与系统底层交互。
}
Linux内核的设计与实现