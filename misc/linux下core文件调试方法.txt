linux下core文件调试方法
在程序不寻常退出时，内核会在当前工作目录下生成一个core文件（是一个内存映像，同时加上调试信息）。使用gdb来查看core文件，可以指示出导致程序出错的代码所在文件和行数。

1.core文件的生成开关和大小限制
 （1）使用ulimit -c命令可查看core文件的生成开关。若结果为0，则表示关闭了此功能，不会生成core文件。
 （2）使用ulimit -c filesize命令，可以限制core文件的大小（filesize的单位为kbyte）。若ulimit -c unlimited，则表示core文件的大小不受限制。如果生成的信息超过此大小，将会被裁剪，最终生成一个不完整的core文件。在调试此core文件的时候，gdb会提示错误。

2.core文件的名称和生成路径
core文件生成路径:
输入可执行文件运行命令的同一路径下。
若系统生成的core文件不带其它任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。

（1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。
可通过以下命令修改此文件：
echo "1" > /proc/sys/kernel/core_uses_pid

（2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。
可通过以下命令修改此文件：
echo "/corefile/core-%e-%p-%t" > core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳
以下是参数列表:
    %p - insert pid into filename 添加pid
    %u - insert current uid into filename 添加当前uid
    %g - insert current gid into filename 添加当前gid
    %s - insert signal that caused the coredump into the filename 添加导致产生core的信号
    %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
    %h - insert hostname where the coredump happened into filename 添加主机名
    %e - insert coredumping executable name into filename 添加命令名

 3.core文件的查看
 core文件需要使用gdb来查看。
 gdb ./a.out
 core-file core.xxxx
 使用bt命令即可看到程序出错的地方。 
以下两种命令方式具有相同的效果，但是在有些环境下不生效，所以推荐使用上面的命令。 
（1）gdb -core=core.xxxx
file ./a.out
bt 
（2）gdb -c core.xxxx
file ./a.out
bt

 4.开发板上使用core文件调试
如果开发板的操作系统也是linux，core调试方法依然适用。如果开发板上不支持gdb，可将开发板的环境（依赖库）、可执行文件和core文件拷贝到PC的linux下。
在 PC上调试开发板上产生的core文件，需要使用交叉编译器自带的gdb，并且需要在gdb中指定solib-absolute-prefix和 solib-search-path两个变量以保证gdb能够找到可执行程序的依赖库路径。有一种建立配置文件的方法，不需要每次启动gdb都配置以上变量，即：在待运行gdb的路径下建立.gdbinit。
配置文件内容：
set solib-absolute-prefix YOUR_CROSS_COMPILE_PATH
set solib-search-path YOUR_CROSS_COMPILE_PATH
set solib-search-path YOUR_DEVELOPER_TOOLS_LIB_PATH
handle SIG32 nostop noprint pass

注意：待调试的可执行文件，在编译的时候需要加-g，core文件才能正常显示出错信息！有时候core信息很大，超出了开发板的空间限制，生成的core信息会残缺不全而无法使用，可以通过挂载到PC的方式来规避这一点。

摘自《UNIX环境高级编程》第10章 信号。


使用core文件调试程序


看下面的例子：
/*core_dump_test.c*/
    #include <stdio.h>
    const char *str = "test";
    void core_test()
    {
        str[1] = 'T';
    }
    int main()
    {
        core_test();
        return 0;
    }
编译：
[zhanghua@localhost core_dump]$ gcc –g core_dump_test.c -o core_dump_test
如果需要调试程序的话，使用gcc编译时加上-g选项，这样调试core文件的时候比较容易找到错误的地方。
执行：
[zhanghua@localhost core_dump]$ ./core_dump_test
段错误
运行core_dump_test程序出现了“段错误”，但没有产生core文件。这是因为系统默认core文件的大小为0，所以没有创建。可以用ulimit命令查看和修改core文件的大小。
[zhanghua@localhost core_dump]$ ulimit -c
0
[zhanghua@localhost core_dump]$ ulimit -c 1000
[zhanghua@localhost core_dump]$ ulimit -c
1000
-c 指定修改core文件的大小，1000指定了core文件大小。也可以对core文件的大小不做限制，如：
[zhanghua@localhost daemon]# ulimit -c unlimited
[zhanghua@localhost daemon]# ulimit -c
unlimited
如果想让修改永久生效，则需要修改配置文件，如 .bash_profile、/etc/profile或/etc/security/limits.conf。
再次执行：
[zhanghua@localhost core_dump]$ ./core_dump_test
段错误 (core dumped)
[zhanghua@localhost core_dump]$ ls core.*
core.6133
可以看到已经创建了一个core.6133的文件.6133是core_dump_test程序运行的进程ID。


在Linux下可以用GDB来调试core文件。

[zhanghua@localhost core_dump]$ gdb core_dump_test core.6133
GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu"...
Core was generated by `./core_dump_test'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/tls/libc.so.6...done.
Loaded symbols for /lib/tls/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
#0  0x080482fd in core_test () at core_dump_test.c:7
7          str[1] = 'T';
(gdb) bt
#0  0x080482fd in core_test () at core_dump_test.c:7
#1  0x08048317 in main () at core_dump_test.c:12
#2  0x42015574 in __libc_start_main () from /lib/tls/libc.so.6
 
GDB中键入bt，就会看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），gdb只显示最近几个），我们很容易找到我们的程序在最后崩溃的时候调用了core_dump_test.c 第7行的代码，导致程序崩溃。注意：在编译程序的时候要加入选项-g。您也可以试试其他命令，如　fram、list等。更详细的用法，请查阅GDB文档。
什么时候不产生core文件
在下列条件下不产生core文件：
( a )进程是设置-用户-ID，而且当前用户并非程序文件的所有者；
( b )进程是设置-组-ID，而且当前用户并非该程序文件的组所有者；
( c )用户没有写当前工作目录的许可权；
( d )文件太大。core文件的许可权(假定该文件在此之前并不存在)通常是用户读/写，组读和其他读。
