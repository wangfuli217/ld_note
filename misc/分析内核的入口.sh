
intel(8086)
{
青铜时期
1. 段描述了一块有限的内存区域，区域的起始位置存在专门的寄存器（段寄存器）中。
2. 8086处理器地址线扩展到了20位，寻址空间到了1M 也就是把1M大的空间分成数个64k的段来管理（化整
    为零了）。
3. 把16位的段地址左移动4位后，再与16位的偏移量相加便可获得一个20位的内存地址，
}

intel(80286)
{
白银时期
1. 地址总线位数增加到了24位 。
2. 从此开始引进了一个全新理念―保护模式
3. 访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查 。

}

intel(80386)
{
黄金时期
80386是一个32位的CPU，其寻址能力达到4GB
1. Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位
2. 在保护模式下,它的段范围不再受限于64K，可以达到4G

从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号,但基本上属于同一种系统结
构的改进与加强，而无本质的变化,所以我们把80386以后的处理器统称为IA32（32 Bit Intel Architecture）。

}

intel(寄存器)
{

# 通用寄存器
1. 8个通用寄存器是8086寄存器的超集，它们分别为：EAX ，EBX ，ECX ，EDX ，EBP ，EBP，ESI及 EDI

# 段寄存器
1. 8086中有4个16位的段寄存器：CS、DS、SS、ES，分别用于存放可执行代码的代码段、数据段、
堆栈段和其他段的基地址。
2. 这些段寄存器中存放的不再是某个段的基地址，而是某个段的选择符（Selector）
3. 段基地址存放在段描述符表（Descriptor ）中，表的索引就是选择符

# 指令指针寄存器
1. 指令指针寄存器EIP中存放下一条将要执行指令的偏移量（offset ），这个偏移量是相对于目
前正在运行的代码段寄存器CS而言的。偏移量加上当前代码段的基地址，就形成了下一条指令的地址。
2. EIP中的低16位可以被单独访问，给它起名叫指令指针IP寄存器，用于16位寻址。

#标志寄存器
1. 标志寄存器EFLAGS存放有关处理器的控制标志，很多标志与16位FLAGS中的标志含义一样。

}

intel(地址空间)
{
... 物理地址、虚拟地址、线性地址
1. 将主板上的物理内存条所提供的内存空间定义为物理内存空间，其中每个内存单元的实际地址就是物理地址
2. 将应用程序员看到的内存空间定义为虚拟地址空间(或地址空间)，其中的地址就叫虚拟地址(或虚地址)， 一般用"段：偏移量"的形式来描述
3. 线性地址空间是指一段连续的，不分段的，范围为0到4GB的地址空间，一个线性地址就是线性地址空间的一个绝对地址。

MMU： CPU把虚地址送给MMU <--->  MMU把物理地址送给存储器

全局描述符表GDT（Gloabal Descriptor Table）
中断描述符表IDT（Interrupt Descriptor Table）
局部描述符表LDT（Local Descriptor Table）
为了加快对这些表的访问，Intel设计了专门的寄存器，以存放这些表的基地址及表的长度界限 。这些寄存器只供操作系统使用。

保护模式规定，高特权级可以访问低特权级，而低特权级不能随便访问高特权级。


1. 对于页表，页的保护是由属性部分的U/S标志和R/W标志来控制的。当U/S标志为0时，只有处于内核态的操作系统
才能对此页或页表进行寻址。当这个标志为1时，则不管在内核态还是用户态，总能对此页进行寻址。

2. 此外，与段的三种存取权限（读、写、执行）不同，页的存取权限只有两种（读、写）。如果页目录项或页表项
的读写标志为0，说明相应的页表或页是只读的，否则是可读写的。


Linux主要采用分页机制来实现虚拟存储器管理,因为:
1. Linux的分段机制使得所有的进程都使用相同的段寄存器值，这就使得内存管理变得简单，也就
是说，所有的进程都使用同样的线性地址空间（0~4G）。
2. Linux设计目标之一就是能够把自己移植到绝大多数流行的处理器平台。但是，许多RISC处理器
支持的段功能非常有限。
3. 为了保持可移植性，Linux采用三级分页模式而不是两级
}

mem(寻址方式)
{
1. 在操作系统教学的过程中，让我如噎在喉就是感到那虚拟内存管理像虚无飘渺的海市。分段，分页，地址转换，虚拟内存，快表……就像云层
   里的星星，我们只能仰望，而无法触摸。
2. 汤子赢96版《计算机操作系统》一书在OS/2存储器管理中，提到了Intel80386的寻址方式和其存储管理方式，虽然内容有限，但知道了GDT表
  （也就是段表），实实在在的页表，CR3寄存器等等这些力挺虚存管理的硬件兄弟。于是，保护模式成了我们从云端站到地上的一座灯塔，
   几经搜索，找到了《保护模式下80386及其编程》这本书。
3. 依然记得硬啃这本书时的那种艰辛。段，那个出现在8086中的概念，在80386（简称IA32）中变得复杂繁琐。这不仅是因为从16位寻址到32位
   寻址的变化，还因为段在IA32中承载更多的东西：基地址（32位），界限（20位），属性（12位）。显然，16位的段寄存器无法容纳这总共
   64位的信息，于是这些信息进段表（所谓的段描述符表），而段寄存器存放的就是段号（其实就是这么简单，尽管英文中把段寄存器存放的
   内容称为选择符selector）。
4. 在IA32上任意给出的地址都是一个虚拟地址，即任意一个地址都是通过"选择符:偏移量"的方式给出的，这是段机制存访问模式的基本特点。
   所以在IA32上设计操作系统时无法回避使用段机制。一个虚拟地址最终会通过"段基地址＋偏移量"的方式转化为一个线性地址。但是，由于
   绝大多数硬件平台都不支持段机制，只支持分页机制，所以为了让Linux具有更好的可移植性，我们需要去掉段机制而只使用分页机制。
5. 但不幸的是，IA32规定段机制是不可禁止的，因此不可能绕过它直接给出线性地址空间的地址。万般无奈之下，Linux的设计人员干脆让段
   的基地址为0，而段的界限为4GB，这时任意给出一个偏移量，则等式为"0+偏移量=线性地址"，也就是说"偏移量＝线性地址"。另外由于段机制
   规定"偏移量 < 4GB"，所以偏移量的范围为0H～FFFFFFFFH，这恰好是线性地址空间范围，也就是说虚拟地址直接映射到了线性地址。
   看来，Linux在没有回避段机制的情况下巧妙地把段机制给绕过去了。
6. 另外，由于IA32段机制还规定，必须为代码段和数据段创建不同的段，所以Linux必须为代码段和数据段分别创建一个基地址为0，段界限为4GB的
   段描述符。不仅如此，由于Linux内核运行在特权级0，而用户程序运行在特权级别3，根据IA32的段保护机制规定，特权级3的程序是无法访问
   特权级为0的段的，所以Linux必须为内核和用户程序分别创建其代码段和数据段。这就意味着Linux必须创建4个段描述符――特权级0的代码段
   和数据段，特权级3的代码段和数据段。
7. 如果这么定义段，则段保护的第一个作用就失去了，因为这些段使用完全相同的线性地址空间（0～4GB），它们互相覆盖。可以设想，如果
   不使用分页的话，线性地址空间直接被映射到物理空间，则你修改任何一个段的数据，都会同时修改其它段的数据，段机制所提供的通过
   "基地址：界限"方式本来将线性地址空间分割，以让段与段之间完全隔离，这种实现段保护的方式根本就不起作用了。那么，这是不是意味着
   用户可以随意修改内核数据？显然不是的，这是因为，一方面用户段和内核段具有不同的特权级别，另一方面，Linux之所以这么定义段，
   正是为了实现一个纯的分页，而分页机制会提供给我们所需要的保护。
   
}


intel(中断)
{
1. 中断控制的主要优点：CPU只有在I/O需要服务时才响应
2. 外部中断：外部设备所发出的I/O请求
3. 内部中断：也称之为“异常”，是为解决机器运行时所出现的某些随机事件及编程方便而出现的

4. 中断向量 ： 中断源的编号[中断向量－每个中断源都被分配一个8位无符号整数作为类型码，即中断向量]
5. 外设可屏蔽中断：屏蔽外部I/O请求
6. 异常及非屏蔽中断 ：CPU内部中断或计算机内部硬件出错引起的异常
7. 中断描述符表 ：描述中断的相关信息

中断的种类：
C 中断：外部可屏蔽中断, 外部非屏蔽中断
C 异常：不使用中断控制器，不能被屏蔽: 故障, 陷阱

外部I/O请求的屏蔽:
从CPU的角度， 清除eflag的中断标志位
从中断控制器的角度，将中断屏蔽寄存器的相应位置位

在CPU执行一个异常处理程序时，就不再为其他异常或可屏蔽中断请求服务.

1. 调用过程指令CALL ：CALL 过程名
2. 调用中断过程的指令INT:INT 中断向量
3. 中断返回指令IRET: IRET
4. 加载中断描述符表的指令LIDT: LIDT 48位的伪描述符

Linux内核在系统的初始化阶段要初始化可编程控制器8259A；将中断描述符表的起始地址装入IDTR寄存器，
并初始化表中的每一项

}
intel(中断-function)
{
IDT表项的设置通过_set_gaet()函数实现
? 调用该函数在IDT表中插入一个中断门：
set_intr_gate(unsigned int n, void *addr)
? 调用该函数在IDT表中插入一个陷阱门：
set_trap_gate(unsigned int n, void *addr)
? 调用该函数在IDT表中插入一个系统门：
set_system_gate(unsigned int n, void *addr)

trap_init()函数用于设置中断描述符表开头的19个陷阱门和系统门
? 这些中断向量都是CPU保留用于异常处理的 ，例：
? set_trap_gate(0,&divide_error);
set_trap_gate(1,&debug);
set_trap_gate(19,&simd_coprocessor_error);
set_system_gate(SYSCALL_VECTOR,&system
_call);

}
