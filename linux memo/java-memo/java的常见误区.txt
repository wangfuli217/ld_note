1. 在Java中，没有goto语句。因为大量使用goto语句会降低程序的可读性和可维护性，所以Java语言取消了goto的使用。
   同时，为了避免程序员自行使用goto所带来的混乱，java语言仍将goto定义为一个关键字，但是没有定义任何语法，
   故称为"保留字"
2. true、false和null在IDE中虽然以不同的颜色显示，但是并不是关键字，而是"字面常量"，就和String类型的abc一样。
3. 定义名称时尽量避免使用$，因为编译器在对.java文件进行编译的时候，会将$编译成顶层类型与底层类型的连接符。
4. Unicode转义字符处理的非常早，在解析程序前。例如：
   char c1='u00a';
   char c2='u00d';
   在程序中出现这两行代码编译报错。这两个Unicode码分别表示换行和回车，所以，在编译器编译的时候，代码是这样的：
   char c1='
   ';
   char c2='
   ';
5. Unicode码使用16位字符编码，在Java中用char类型来表示。现在Unicode已经扩展到一个百万个字符，超出16位限制的
   称谓增补字符，所有增补字符都不能用字符常量表示；
6. 当short,byte,char参加运算时，结果为int型，而非与较高的类型相同。如果变量是byte,short类型，当对其赋予
   编译时期的常量，而该常量又没有超过变量的取值范围时，编译器就可以进行隐式的收缩转换。这种隐式的收缩转换是
   安全的，因为该收缩转换只适用于变量的赋值，即不适用于方法调用时的参数传递。
7. 注意char类型，这是一个无符号类型。因此，char与short或char与byte之间的转换必须显式地使用类型转换。从byte到
   char的转换为扩展收缩转换，该转换比较特殊，即先将byte扩展转化到int，然后再收缩到char。
8. 在整数数据间的扩展转换中，如果操作数是char类型(无符号类型)，则进行无符号扩展，扩展位为0，如果操作数是byte、short
   或int，则进行有符号扩展，扩展位为该变量的符号位。   
9. 整数数据之间的收缩转换，仅仅是截断并丢弃高位，不做任何其他处理。
10. 0.1+0.2 不等于0.3 
11. float类型可以保留7~8个有效数字，而double类型可以保留15~16个有效数字，因而当int类型或long类型值多于double或float
   的有效数值时，该值的一些低有效位就会丢失，从而照成精度丢失。   
12. +0与-0在浮点类型变量存储中，符号位是不同的。当-0与+0参数浮点类型的相关运算时，可以产生不同的结果。
13. 浮点的相除与求余不同于整数的相除与求余运算，当除数为0时，浮点运算不会产生ArithmeticException异常。
14. String类是非可变类，其对象一旦创建，就不可销毁。String类哪些看似修改字符序列的方法实际上都是返回新创建的String
    对象，而不是修改自身对象。
15. 由于String对象是不可改变的，因此具有线程安全性，可以自由的实现共享。
16. 在String类内部，是使用一个字符数组来维护字符序列。String的最大长度也就是字符数组的最大长度，理论上最大长度为int
    类型的最大值，即2174486647.实际中，一般可获取的最大值小于理论最大值。
17. main()方法在表现行为上，与其他方法基本相同，可以重载，有其他方法调用、继承、隐藏，也可以抛出异常，带有类型参数。
   我们可以在一个程序中通过反射来调用main方法。
18. 当两个或多个方法的名称相同，而参数列表不同时，这几个方法就构成了重载。重载方法可以根据参数列表对应的类型与参数
    的个数来区分。但是，参数的名称、方法的返回类型、方法的异常列表与类型参数不能作为区分重载方法的条件。
19. 构造器是递归调用的，子类的构造器会调用父类的构造器，直到调用Object类的构造器为止。
20. 默认的构造器不为空，该构造器会调用父类的无参构造器，并可能执行实例成员变量的初始化，    