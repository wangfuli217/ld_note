设备驱动程序：是某个特定硬件响应一个定义良好的内部编程接口，这些接口完全隐藏了设备的工作细节。用户的操作通过一组标准化的调用
              执行，而这些调用独立于特定的驱动程序。将这些调用映射到作用于实际硬件的设备特有操作上，则是设备驱动程序的任务。

机制和策略：  需要提供什么功能-机制 和 如何使用这些功能-策略。如果这两个问题由程序的不同部分来处理，或者甚至由不同的程序来处理
              ，则这个软件包更容易开发也更容易根据需要来调整。
              驱动程序应该处理如何使硬件可用的问题，而将怎样使用硬件的问题留给上层应用程序。
驱动程序开发要求：提供给用户尽量多的选项；编写驱动程序需要占用的时间；尽量保持程序简单而不至于错误丛生。

不带策略的驱动程序：同时支持同步和异步操作；驱动程序能够被多次打开；充分利用硬件特性；不具备用来"简化任务"的或提供与策略相关的软件层。			  

驱动程序配置：　用户程序是软件包的有机组成部分，即使不带策略的软件包，也会同时发布配置文件为下层机制提供默认配置。

文件系统：　　　内核在没有结构的硬件上构造结构化的文件系统，而文件系统在这个系统中广泛使用。
	
http://lwn.net/Kerenl/LDD2
	
1、不管内核来自哪里，要想为2.6.x内核构造模块，还必须在自己的系统中配置并构造好内核数；
   yum install kernel-devel-2.6.32-279.el6.x86_64
   kernel.org 获取并安装：
   makefile能够找到的地方/usr/src/linux-2.6.10正确配置和构造了内核树。
2、module_init和module_exit使用了内核的特殊宏来表示这个两个函数所扮演的角色。
   MODULE_LICENSE 用来告诉内核，该模块采用自由许可证；  
3、 1： 模块能调用printk是因为在insmod函数装入模块后，模块就连接到内核，因而可以访问内核的公用符号。(包括函数和变量)
    2： insmod和ld有点类似。它将模块的代码和数据装入内核，然后使用内核的符号表解析模块中任何未解析的符号。然而，与连接器不同的是
	     内核不会修改模块的磁盘文件，而仅仅修改内存中的副本。
	3： modprobe会考虑装载的模块是否引用了一些当前内核不存在的符号；如果有这类引用，modprobe会在当前模块搜索路径中查找定义了这些符号的其他模块。
	    如果modprobe找到了这些模块，会同时将这些模块装入到内核。
		rmmod：如果内核认为模块仍然在使用状态，或者内核被配置为禁止移除模块，则无法移除该模块。
    4、lsmod通过读取/proc/modules虚拟文件系统获得这些信息
	   有关当前已装模块模块的信息也可以在sysfs虚拟文件系统的/sys/module下找到。
	
4、具有默认优先级的消息可能不会输出到控制台上，它依赖内核版本、klogd守护进程的版本以及具体的配置。
5、insmod和rmmod对于Windows系统下的终端仿真软件，在屏幕上看不到任何输出；实际上，它可能输出到某个系统日志文件里/var/log/messages
6、大多数相关头文件保存在include/linux和include/asm目录中，但是include的其他子目录中保持有与特定内核子系统相关的头文件。
7、内核编程和应用程序编程的差异：
   1、大多数小规模及中规模应用程序是从头到尾执行单个任务，而模块确只是预先注册自己以便服务于将来的某个请求，然后它的初始化函数就立即结束。
   2、事件驱动应用程序和内核模块差别：应用程序在退出时，可以不管资源的释放或者其他清理工作，但模块的退出函数却必须仔细撤销初始化函数所作的一切；
      否则，在系统重新引导之前某些东西就会残留在系统中。
   3、各环境下处理错误的方式不同：应用程序开发过程中的段错误是无害的，并且总是可以使用调试器跟踪到源代码中的问题所在，而一个内核错误即使不
      影响整个系统，也至少会杀死当前进程。
   4、应用程序在虚拟内存中布局，并具有一块很大的栈空间。内核具有非常小的栈，它可能只有和一个4096字节大小的页那样小。
      我们自己的函数必须和整个内核空间调用链一同共享这个栈。因此，声明大的自动变量并不是一个好主意，我盟需要大的结构，应该在调用时动态分配该结构。
	  
8、操作系统必须负责程序的独立操作并保护资源不受非法访问，这个重要任务只有在CPU能够保护系统软件不受应用程序破坏时才能完成。
   CPU通过门中断控制着对硬件的直接访问以及对内存的非授权访问。
   内核空间和用户空间：不仅说明两种模式具有不同的优先等级，而且还说明每个模式都有自己的内存映射，也即自己的地址空间。	 
9、驱动程序的两类任务：模块中的某些函数作为系统调用的一部分而执行；而其他函数则负责中断处理。
   内核中的并发：Linux系统中通常正在运行多个并发进程，并且可能有多个进程同时使用我们的驱动程序。
                 大多数设备能够中断处理器，而中断处理器程序异步运行，而且可能在驱动程序正试图处理其他任务时被调用。
				 有一些软件抽象(内核定时器)也在异步运行着
				 Linux还可以运行在对称多处理器系统上。因此可能同时不止一个CPU运行我们的驱动
	内核代码必须是可重入的，它必须能够同时运行在多个上下文中。
	编程人员常见错误：认为某段代码没有进入睡眠状态或者阻塞，就不会产生并发问题。即使在先前非抢占内核中，这种假设也是错误的。
10、当前进程：
    内核代码可以通过访问全局项current来获取当前进程。current在<asm/current.h>中定义，这是指向一个struct task_struct的指针，
    task_struct结构在<linux/sched.h>文件中定义。current指针指向当前正在运行的进程。

    内核开发者设计了一种能找运行在相关CPU上的当前进程的机制。这种机制是快速的，因为对current的引用会频繁发生。这样，一种不依赖特定架构的机制
    通常是：将指向task_struct结构的指针隐藏在内核栈中。	
11、两个下划线前缀(__)的函数名，具有这种名称的函数通常是接口的底层组件，应谨慎调用。
    有且只有系统调用的名字前带sys_前缀，而且其他任何函数都没有这个前缀。
	
12、代码不能实现浮点型运算。

编译模块：
------ 准备工作 ------
documentation/kbuild/
       00-INDEX
	   kbuild.txt
	   kconfig.txt
       kconfig-language.txt
       makefiles.txt
       modules.txt
documentation/changes 编译器、模块工具、及其他必要的工具的版本   
内核树
------ makefile ------
	obj-m := module.o
	module-objs := file1.o file2.o

make -C ~/kernel-2.6 M='pwd' modules

make -C /usr/src/linux-`uname -r` SUBDIRS=$PWD modules
----- Makefile ------
## makefile

# 如果已定义KERNELRELEASE，则说明是从内核构造系统调用的，
# 因此可利用其内建语句。
ifneq ($(KERNELRELEASE),)
	obj-m := hello.o
# 否则，是直接从命令行调用的
# 这时要调用内核构造系统
else
	KERNELDIR ?= /lib/modules/$(pwd uname -r)/build
	PWD := $(shell pwd)
	default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
	
endif

# 如果读者实际运行的内核并不是要构造的内核，则可以在命令行提供KERNELDIR=选项或者设置KERNELDIR环境变量，也可以修改来设置KERNELDIR的行。
# 在找到内核源代码数之后，这个makefile会调用default目标。
# 在第二次调用makefile文件时，它设置了obj-m，而内核的Makefie负责真正的构造模块。


13、版本依赖
    1. 要记住，在缺少modversions的情况下，我们的模块必须针对要链接的每个版本的内核重新编译。 
	    modversions和开发者相比，它对发行版本制作者更为重要。
	2. 内核不会假定一个给定的模块是针对正确的内核版本构造的。我们在构造过程中，可以将自己的模块和当前内核树中的一个文件
	   vermagic.o链接；该目标文件包含了大量有关内核的信息，包括目标内核版本、编译器版本以及一些重要配置变量的设置。在试图
	   装载模块时，这些信息可以用来检索模块和当前正在运行的内核的兼容性，如果有任何不匹配，就不会装载该模块，同时可以看到
	   如下信息：
	   # insmod hello.ko
	   Error inserting './hello.ko': -1 Invalid module format
	3. 如果读者打算编写一个能够和多个内核版本一起工作的模块(尤其是必须块主发行号工作)，则必须使用宏以及#ifdef来构造并编译
	   自己的代码。
	linux/version.h
	UTS_RELEASE : 宏UTS_RELEASE扩展为一个描述内核版本的字符串，例如："2.6.10"
	LINUX_VERSION_CODE　：LINUX_VERSION_CODE扩展为内核版本的二进制表示，版本发行号中的每一部分对应一个字节：2.6.20(0x0206a)
	KERNEL_VERSION(major,minor,release):KERNEL_VERSION以组成版本号的三部分为参数，创建整数的版本号：2.6.20(132618)
    4. 通过检查LINUX_VERSION_CODE和KERNEL_VERSION而使用预处理条件，能够解决大部分内核版本的依赖性问题。
	见fuse 和 flashcache #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9) 

14、平台依赖
在转载模块时，内核会检查处理器相关的配置选项以便确保模块匹配于运行中的内核。如果模块在不同选项下编译，则不会装载该模块。
80386处理器 IA32处理器 i3处理器 i5处理器 i7处理器

15、内核符号表
公共内核符号表中包含了所有的全局内核项(即函数和变量)的地址，这是实现模块化驱动程序所必须的。
当内核被装入内核后，它所导出的任何符号都会变成内核符号表的一部分。
EXPORT_SYMBOL(name)    : 
EXPORT_SYMBOL_GPL(name):
_GPL版本使得要导出的模块只能被GPL许可证下的模块使用。符号必须在模块文件的全局部分导出，不能在函数中导出。
这是因为上面这两个宏将被扩展为一个特殊的变量的声明，而该变量必须是全局的。

16、预备知识
MODULE_LICENSE("GPL");指定代码使用哪个许可
       内核认识的特定许可有, 
            "GPL"( 适用 GNU 通用公共许可的任何版本 ), 
            "GPL v2"( 只适用 GPL 版本 2 ), 
            "GPL and additional rights", 
            "Dual BSD/GPL", 
            "Dual MPL/GPL", 
            "Proprietary".

      MODULE_AUTHOR ( 声明谁编写了模块 ), 
      MODULE_DESCRIPION( 一个人可读的关于模块做什么的声明 ), 
      MODULE_VERSION ( 一个代码修订版本号)，
      MODULE_ALIAS ( 模块为人所知的另一个名子 ), 
      MODULE_DEVICE_TABLE ( 来告知用户空间, 模块支持那些设备).

linux/errno.h 用户程序可以使用perror或类似的途径将它们转换为有意义的字符串。

17、模块参数
可在运行insmod或modprobe命令装载时赋值，而modprobe还可以从它的配置文件/etc/modprob.conf中读取参数值。这些命令可以在命令行
接收几种参数类型的赋值。
moduleparam.h 中定义 module_param需要三个参数：变量的名称、类型、以及用于sysfs入口项的访问许可掩码；
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);

支持类型 bool invbool charp int long short uint ulong ushort
数组：   module_param(name, type, num, perm)

注意：如果一个参数通过sysfs而被修改，则如同模块修改了这个参数的值一样，但是内核不会以任何方式通知模块。


快速参考；
insmod
modprobe
rmmod

#include <linux/init.h>
module_init(init_function)
module_exit(cleanup_function)

__init
__initdata
__exit
__exitdata
仅用于模块初始化或清除阶段的函数(__init和__exit)和数据(__initdata和__exitdata)标记。标记为初始化的项目会在初始化结束后丢弃；
而退出项目在内未被配置为可卸载的情况下被丢弃。内核通过将相应的目标对象放置在可执行文件的特殊ELF段中而让这些标记起作用。
#include <linux/sched.h>
