https://www.ibm.com/developerworks/cn/linux/l-cn-cncrrc-mngd-wkq/

------ 并发可管理工作队列的出现 ------
	在内核代码中，经常希望延缓部分工作到将来某个时间执行，这样做的原因很多，比如：在持有锁时做大量（或者说费时的）工作不合适；
或希望将工作聚集以获取批处理的性能；或调用了一个可能导致睡眠的函数使得在此时执行新调度非常不合适等。

	内核中提供了许多机制来提供延迟执行，如中断的下半部处理可延迟中断上下文中的部分工作；定时器可指定延迟一定时间后执行某工作；
工作队列则允许在进程上下文环境下延迟执行等。除此之外，内核中还曾短暂出现过慢工作机制 (slow work mechanism)，还有异步函数调用 
(asynchronous function calls) 以及各种私有实现的线程池等。在上面列出的如此多的内核基础组件中，使用最多则是工作队列。

------ 工作队列 (workqueues) ------
在讨论之前，先定义几个内核中使用工作队列时用到的术语方便后面描述。

    workqueues：所有工作项被 ( 需要被执行的工作 ) 排列于该队列，因此称作工作队列 (workqueues) 。
    worker thread：工作者线程 (worker thread) 是一个用于执行工作队列中各个工作项的内核线程，当工作队列中没有工作项时，该线程将变为 idle 状态。
    single threaded(ST) ：工作者线程的表现形式之一，在系统范围内，只有一个工作者线程为工作队列服务
    multi threaded(MT)：工作者线程的表现形式之一，在多 CPU 系统上每个 CPU 上都有一个工作者线程为工作队列服务

工作队列之所以成为使用最多的延迟执行机制，得益于它的实现中的一些有意思的地方：使用的接口简单明了

对于使用者，基本上只需要做 3 件事情，依次为：
        创建工作队列 ( 如果使用内核默认的工作队列，连这一步都可以省略掉 )
        创建工作项
        向工作队列中提交工作项
执行在进程上下文中，这样使得它可以睡眠，被调度及被抢占

执行在进程上下文中是一个非常大的优势，其他的下半部工作机制，基本上都运行于中断上下文中，我们知道在中断上下文里，不能睡眠，不能阻塞；
原因是中断上下文并不与任何进程关联，如在中断上下文睡眠，调度器将不能将其唤醒，所以在中断上下文中不能有导致内核进入睡眠的行为，如持有信号量，
执行非原子的内存分配等。工作队列运行于进程上下文中 ( 他们通过内核线程执行 )，因此它完全可以睡眠，可以被调度，也可以被其他进程所抢占。

    在多核环境下的使用也非常友好

与 tasklet 机制相较而言，工作队列可以在不同 CPU 上同时运行是个优势。这使得该接口在多核情况下也非常适合，内核邮件列表中就曾经有过用软中断
和工作队列来替换不支持多 CPU 执行的 tasklet 的讨论。

总体说来，工作队列和定时器函数的处理有点类似，都是延迟执行相关的回调函数，但和定时器处理函数不同的是定时器回调函数只执行一次 ( 当然可以在
执行时再次注册以反复调用，但这需要显示的再次注册 )， 且执行定时器回调函数时在时钟中断环境 , 限制较多，因此回调函数不能太复杂；而工作队列是
通过内核线程实现，一直有效，可重复执行，执行时可以休眠，因此工作队列非常适合处理那些不是很紧急的任务，如垃圾回收处理等。




