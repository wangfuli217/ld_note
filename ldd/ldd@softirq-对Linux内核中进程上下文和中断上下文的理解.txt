------ 上下文context
上下文context：上下文简单说来就是一个环境，相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。
       一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。
       用户级上下文: 正文、数据、用户堆栈以及共享存储区；
       寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
       系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

------ 中断上下文
所谓的"中断上下文"，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被中断的进程环境）。
硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。

------ 进程上下文
所谓的"进程上下文"，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，
它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

------ 处理器状态
处理器总处于以下状态中的一种：
１、内核态，运行于进程上下文，内核代表进程运行于内核空间；
２、内核态，运行于中断上下文，内核代表硬件运行于内核空间；
３、用户态，运行于用户空间。

说明：运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。因此，内核会限制中断上下文的工作，不允许其执行如下操作：

------ 中断上下文环境限制
运行在进程上下文的内核代码是可以被抢占的（Linux2.6支持抢占）。但是一个中断上下文，通常都会始终占有CPU（当然中断可以嵌套，但我们一般不这样做），
不可以被打断。正因为如此，运行在中断上下文的代码就要受一些限制，不能做下面的事情：
1、睡眠或者放弃CPU。
      这样做的后果是灾难性的，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉
2、尝试获得信号量
      如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况
3、执行耗时的任务
      中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。
4、访问用户空间的虚拟地址
    因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在终端上下文无法访问用户空间的虚拟地址
5、 中断处理例程不应该设置成reentrant（可被并行或递归调用的例程）。
   因为中断发生时，preempt和irq都被disable，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，
   是不允许在SMP上并发运行的。
6、中断处理例程可以被更高级别的IRQ中断。
    如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。
	这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。	  
    
softirq()
{
软中断的工作过程模拟了实际的中断处理过程，当某一软中断事件发生后，首先需要设置对应的中断标记位，触发中断事务，
然后唤醒守护线程去检测中断状态寄存器。如果通过查询发现某一软中断事务发生，那么通过软中断向量表调用软中断服务
程序action(),这就是软中断的过程。
与硬中断唯一不同的地方是从中断标记到中断服务程序的映射过程。在CPU硬中断发生之后，CPU需要将硬件中断请求通过
向量表映射成具体的服务程序，这个过程是硬件自动完成的。但软中断不是，其需要守护线程去实现这个过程，这就是
软件模拟的中断，故称为软中断。

一部分代码和硬件关系紧密，这部分代码必须关闭中断来执行，以免被后面触发的中断打断，影响代码的正确执行。   ---- 中断处理函数
一部分代码和硬件关系不紧密，可以打开中断执行， -- 软中断上下文
}    
 
    
    