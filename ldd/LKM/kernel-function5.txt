################ 输入输出驱动程序 ################ 
内核的输入子系统是比较分散的、多种不同类别的输入设备（键盘、鼠标、跟踪球、操作杆、滚轮、触摸屏、加速计和手写板）进行统一处理的驱动程序。
1、统一了物理形态各异的相似的输入设备的处理功能；
2、提供了用于分发输入报告给用户应用程序的简单的事件接口。你的驱动程序不必创建、管理/dev节点以及相关的访问方法，因此它能很方便地调用输入
API已发送鼠标移动、键盘按键或触摸事件给用户控件。
3、抽取出了输入驱动程序的通用部分，简化了驱动程序，并引入了一致性。


输入设备驱动程序包括：事件驱动程序（硬件无关的抽象，以便和输入设备交互）和设备驱动程序（驱动程序代码编写处 -- 业务）
事件驱动程序负责和应用程序的接口，而设备驱动程序负责和底层输入设备的通信。
鼠标事件生成文件mousedev属于事件驱动程序；而PS/2鼠标驱动程序是设备驱动程序。

事件驱动程序和设备驱动程序都可以利用输入子系统的高效、无bug、可重用的核心提供的服务，而垓心还是输入子系统的关键特性。

事件驱动程序是标准的，对所有的输入类都是可用的，所以要实现的应该是设备驱动程序而不是事件驱动程序。设备驱动程序可以利用一个已经
存在的、合适的事件驱动程序通过输入核心和用于应用程序接口。设备驱动程序是指的输入设备驱动程序，而不是输入事件驱动程序。

输入子系统提供的事件接口已经发展成为很多图形窗口系统都是用的标准。事件驱动程序提供一个硬件无关的抽象，一边和输入设备交互，
如同帧缓冲接口提供一个通用的机制以便和显示设备通行一样，事件驱动程序和帧缓冲驱动一起，将GUI和各种各样的底层硬件隔离开来。

evdev是一个通用的输入事件驱动程序。--- 虚拟鼠标的输入设备驱动程序。
struct input_event {
	struct timeval time;
	__u16 type;
	__u16 code;
	__s32 value;
};



gpm ## yum provides */gpm
    ## yum install gpm

evdev是一个通用的输入事件驱动程序。include/linux/input.h中。 input_event结构体；

bash > gpm -m /dev/input/eventX -t evdev




input_event        include/linux/input.h                evdev产生的每个事件包都采用此格式
input_dev          include/linux/input.h                代表一个输入设备
input_handler      include/linux/serial_core.h          事件驱动程序支持的入口函数
psmouse_protocol   drivers/input/mouse/psmouse_base.c   所支持的PS/2鼠标协议驱动程序相关的信息
psmouse            drivers/input/mouse/psmouse.c        PS/2鼠标驱动程序支持的方法


input_register_device            drivers/input/input.c      向Input核心注册一个设备
input_unregister_device          drivers/input/input.c      从input核心移除一个设备
input_report_rel                 include/linux/input.h      在某个方向产生相对移动
input_report_abs                 include/linux/input.h      在某个方向产生绝对移动
input_report_key                 include/linux/input.h      产生一个按键或者按钮单击
input_sync                       include/linux/input.h      标明输入子系统能收集以前产生的时间，将这些事件组成一个evdev包，并通过/dev/input/inputx发送给用户空间
input_register_handler           drivers/input/input.c      注册一个用户事件驱动程序
sysfs_create_group               fs/sysfs/group.c           用特定属性创建sysfs节点组
sysfs_remove_group               fs/sysfs/group.c           移除用sysfs_create_group创建的sysfs节点组
tty_insert_flip_char             include/linux/tty_lip.h    发送一个字符给线路规程层
platform_device_register_simple  drivers/base/platform.c    创建一个简单平台设备
platform_device_unregister      drivers/base/platform.c    卸载一个平台设备


include/linux/input.h

struct input_dev {
    const char *name;                       /* 标识设备驱动特征,如总线类型、生产厂商、产品类型、版本 */
    struct input_id id;                     /* 表示能产生哪类事件 */
    unsigned long evbit[NBITS(EV_MAX)];     /* 表示能产生哪些按键 */
    unsigned long keybit[NBITS(KEY_MAX)];   /* 表示能产生哪些相对位移事件, x,y,滚轮 */
    unsigned long relbit[NBITS(REL_MAX)];   /* 表示能产生哪些绝对位移事件, x,y */
    unsigned long absbit[NBITS(ABS_MAX)];
    struct device dev;
    
    /* 用来链接他所支持的 input_handle 结构,然后用
    * input_handle 找到里面的 input_handler
    */
    struct list_head h_list;
    /* 链接到 input_handler_list,这个链表
    * 链接了所有注册到内核的事件处理器
    */
    struct list_head node;
    ...
}
 unsigned long evbit[BITS_TO_LONGS(EV_CNT)];//用于记录支持的事件类型的位图
 unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];//记录支持的按键值的位图
 unsigned long relbit[BITS_TO_LONGS(REL_CNT)];//记录支持的相对坐标的位图
 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];//记录支持的绝对坐标的位图

input_dev 结构体里有几个数组也是非常重要的,都是我们写硬件驱动需要进行设置的,所以我们务必认识一下它们。
(1) evbit[BITS_TO_LONGS(EV_CNT)]数组,这个数组以位掩码的形式,代表了这个设备支持哪类事件,比如:
#define EV_SYN            0x00               //表示设备支持所有事件
#define EV_KEY            0x01               //键盘或者按键，表示一个键码
#define EV_REL            0x02                //鼠标设备，表示一个相对的光标位置结果
#define EV_ABS            0x03               //手写板产生的值，其是一个绝对整数值
#define EV_MSC            0x04              //其他类型
#define EV_SW             0x05               
#define EV_LED            0x11               //LED设备
#define EV_SND            0x12              //蜂鸣器，输入声音
#define EV_REP            0x14              //允许重复按键类型
#define EV_FF            0x15
#define EV_PWR            0x16             //电源管理事件
#define EV_FF_STATUS        0x17
#define EV_MAX            0x1f
#define EV_CNT            (EV_MAX+1)

keybit[BITS_TO_LONGS(KEY_CNT)]数组,这个数组也是以位掩码的形式,代表这个设备支持哪些按键,比如:

#define KEY_ESC  1
#define KEY_1  2
#define KEY_2  3
#define KEY_3  4
#define KEY_TAB  15
#define KEY_ENTER  28
#define KEY_A  30
#define KEY_B  48
#define KEY_C  46

(3) relbit[BITS_TO_LONGS(REL_CNT)]数组,这个数组也是以位掩码的形式,代表这个设备支持哪些相对位移事件,比如:

#define REL_X  0x00
#define REL_Y  0x01
#define REL_Z  0x02
#define REL_WHEEL  0x08 //滚轮

(4) absbit[BITS_TO_LONGS(ABS_CNT)]数组,这个数组也是以位掩码的形式,代表这个设备支持哪些绝对位移事件,比如:

#define ABS_X  0x00
#define ABS_Y  0x01



input_handler 属于输入子系统三层中的事件处理层的一个重要结构体。主要成员有:其他成员请参考 include/linux/input.h

struct input_handler {
    /* 当事件处理器接收到了来自 input 设备传来的
    * 事件时调用的处理函数,负责处理事件。
    */
    void (*event)(struct input_handle *handle,unsigned int type, unsigned int code, int value);
    /* 当一个 input 设备注册到内核的时候被调用,将事件处理器与输入设备
    * 联系起来的函数,也就是将 input_dev 和 input_handler 配对的函数。
    */
    int (*connect)(struct input_handler *handler, struct input_dev *dev,const struct input_device_id *id);
    /* 与 connect 相反 */
    void (*disconnect)(struct input_handle *handle);
    /* 文件操作集,因为事件处理器要完成读写功能 */
    const struct file_operations  *fops;
    /* 事件处理器所支持的 input 设备 */
    const struct input_device_id *id_table;
    /* 链接他所支持的 input_handle 结构,然后用
    * input_handle 找到里面的 input_dev
    */
    struct list_head  h_list;
    /* 链接到 input_handler_list,这个链表
    * 链接了所有注册到内核的事件处理器
    */
    struct list_head node;
};

之所以称 input_handle(注意了,不是事件处理器 input_handler)为事件沟通者,是因为它代表一个成功配对的 input_dev 和 input_handler。主要成员有:其他成员请参考 include/linux/input.h

struct input_handle {
    /* 每个配对的事件处理器都会分配一个对应的设备结构,
    * 如 evdev 事件处理器的 evdev 结构,注意这个结构与
    * 设备驱动层的 input_dev 不同,初始化 handle 时,保存到这里。
    */
    void *private;
    /* 指向 input_dev 结构体实例 */
    struct input_dev *dev;
    /* 指向 input_handler 结构体实例 */
    struct input_handler *handler;
    /* input_handle 通过 d_node 连接到了 input_dev 上的 h_list 链表上 */
    struct list_head d_node;
    /* input_handle 通过 h_node 连接到了 input_handler 的 h_list 链表 */
    struct list_head h_node;
};

三个结构体之间的关系
input_dev 是硬件驱动层,代表一个 input 设备。通过全局的 input_dev_list 链接在一起。设备注册的时候实现这个操作。
input_handler 是事件处理层,代表一个事件处理器。通过全局的 input_handler_list 链接在一起。事件处理器注册的时候实现这个操作(事件处理器一般内核自带,一般不需要我们来写)
input_handle 个人认为属于核心层,代表一个配对的 input 设备与 input 事件处理器。它没有一个全局的链表,它注册的时候将自己分别挂在了 input_dev 和input_handler 的 h_list 上了。通过 input_dev 和 input_handler 就可以找到input_handle 在设备注册和事件处理器, 注册的时候都要进行配对工作,配对后就会实现链接。通过 input_handle 也可以找到 input_dev 和 input_handler。


主要有三个注册函数:

/* 向内核注册一个 input 设备 */
int input_register_device(struct input_dev *dev)
/* 向内核注册一个事件处理器 */
int input_register_handler(struct input_handler *handler)
/* 向内核注册一个 handle 结构 */
int input_register_handle(struct input_handle *handle)


input_register_device

/* 详细请参考 drivers/input/input.c */
int input_register_device(struct input_dev *dev)
{
struct input_handler *handler;
...
/* 设置输入设备支持同步类事件 */
__set_bit(EV_SYN, dev->evbit);
/* 将 device 加入到 linux 设备模型中去 */
device_add(&dev->dev);
...
/* 把 input_dev 放入 input_dev_list 链表 */
list_add_tail(&dev->node, &input_dev_list);
...
/* 对于 input_handler_list 链表的每一项,都调用 input_attach_handler
* 它根据 input_handler 的 id_table 判断能否支持这个 input_dev
*/
list_for_each_entry(handler, &input_handler_list, node)
input_attach_handler(dev, handler);
...
}

input_register_device 完成的主要功能就是:初始化一些默认的值,将自己的 device 结构添加到 linux 设备模型当中,将 input_dev 添加到 input_dev_list
链表中,对于 input_handler_list 链表的每一项,都调用 input_attach_handler它根据 input_handler 的 id_table 判断能否支持这个输入设备。



input_register_handle

/* 详细请参考 drivers/input/input.c */
int input_register_handle(struct input_handle *handle)
{
struct input_handler *handler = handle->handler;
struct input_dev *dev = handle->dev;
...
/* 把 handle->d_node 添加到 dev->h_list
* 这样,就可以从 dev->h_list 找到 handle,进而找到 handler
*/
list_add_tail_rcu(&handle->d_node, &dev->h_list);
...
/* 把 handle->h_node 添加到 handler->h_list
* 这样,就可以从 handler->h_list 找到 handle,进而找到 dev
*/
list_add_tail(&handle->h_node, &handler->h_list);
...
return 0;
}

input_register_handle 比较简单,主要把 handle 结构体通过 d_node 链表项链接到 input_dev 的 h_list;把 handle 结构体通过 h_node 链表项链接到
input_handler 的 h_list。这样一来,就可以通过 input_dev 的 h_list 找到 handle,进而找到 handle里的 handler;或者通过 input_handler 的 h_list 找到 handle,进而找到 handle里的 input_dev。


input_register_handler

/* 详细请参考 drivers/input/input.c */
int input_register_handler(struct input_handler *handler)
{
struct input_dev *dev;
......
INIT_LIST_HEAD(&handler->h_list);
/* 将 handler 放入 input_handler_list 链表 */
list_add_tail(&handler->node, &input_handler_list);
/* 对于每个 input_dev,调用 input_attach_handler(前面讲过)
* 它根据 input_handler 的 id_table 判断能否支持这个输入设备
* 如果支持,则调用 handler->connect 函数,建立"连接"
*/
list_for_each_entry(dev, &input_dev_list, node)
input_attach_handler(dev, handler);
......
return 0;
}

再一次强调 Input 子系统核心的功能是:向下提供硬件驱动层的接口,向上提供事件处理层的接口。

向下对硬件驱动层的接口主要有:input_allocate_device 这个函数主要是分配一个 input_dev 输入设备接口,并初始化一些基本的成员,这就是我们不能简单用 kmalloc 分配 input_dev 结构的原因,因为缺少了一些初始化。input_register_device 注册一个 input 设备,input_unregister_device 注销一个 input 设备。input_event()函数是硬件驱动层向 input 子系统核心报告事件的函数,这 4 个函数一般用在驱动工程师需要完成的具体硬件驱动程序中。
向上对事件处理层接口主要有:input_register_handler 注册一个事件处理器,input_register_handle注册一个 input_handle 结构,它将输入设备和事件处理器联系起来。


进入 drivers/input/目录可以发现,Linux 系统中有很多事件处理器, joydev、如mousedev、evdev 等等。因为 evdev 事件处理器可以处理所有的事件,按键、
触摸屏设备驱动用的时间处理器就是 evdev。比较通用,我们这里以 evdev 为例,分析事件处理器做了什么。

还记得前面说的吗?事件处理层与用户程序和输入子系统核心打交道,是他们两层的桥梁。如果忘了,就回去看看图 7.1 呗~~先看它的入口函数(参考 drivers/input/evdev.c):




struct evdev {
/* 打开标志 */
int open;
/* 通过 handle 可以找到输入设备和事件处理器 */
struct input_handle handle;
/* 等待队列,当进程读取设备,而没有事件
* 产生的时候,进程将在队列里休眠
*/
wait_queue_head_t wait;
/* 强制绑定的 evdev_client 结构 */
struct evdev_client __rcu *grab;
/* evdev_client 链表,这说明一个 evdev 设备可以处理
* 多个 evdev_client,可以有多个进程访问 evdev 设备
*/
struct list_head client_list;
spinlock_t client_lock; /* protects client_list */
struct mutex mutex;
struct device dev;
/* 字符设备结构 */
struct cdev cdev;
bool exist;
};


/* 参考 drivers/input/evdev.c */
struct evdev_client {
/* input_event 代表一个事件,基本成员:
* 类型(type)
,编码(code)
,值(value)
*/
struct input_event buffer[];
/* 针对 buffer 数组的索引 */
unsigned int head;
/* 针对 buffer 数组的索引,当 head 与 tail 相等的时候,说明没有事件 */
unsigned int tail;
unsigned int packet_head;
spinlock_t buffer_lock;
/* 异步通知函数 */
struct fasync_struct *fasync;
/* evdev 设备 */
struct evdev *evdev;
/* evdev_client 链表项 */
struct list_head node;
int clkid;
unsigned int bufsize;
};