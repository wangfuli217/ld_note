https://www.ibm.com/developerworks/cn/linux/l-pci/
drivers\net\pci-skeleton.c
drivers\pci\hotplug\pcihp_skeleton.c

1. PCI：获得在计算机和外设之间传输数据时更好的性能；尽可能的平台无关；简化往系统中添加和删除外设的功能。

2. PCI和驱动程序编写息息相关的问题是接口板的自动检测。
   PCI是无跳线设备，可在引导阶段自动配置，这样，驱动程序必须能够访问设备中的配置信息以便完成初始化。
   对PCI设备来说，这些工作无需探测就能完成。
   PCI接口标准在ISA之上的主要创新在于配置地址空间。
   
3.每个PCI外设由一个总线编号、一个设备编号、一个功能编号来表示。 CPI规范允许单个系统拥有高达256个总线，但是因为256
  个总线对于许多大型系统而言是不够的，因此，Linux目前支持PCI域。每个PCI域可以拥有最多256个总线。每个总线可以支持32个设备。
  而每个设备都可以是多功能板，最多可以有八种功能。
  所以，每种功能都可以在硬件级由一个16位的地址来标识。
  当前的工作站一般配置至少两个PCI总线。
  在单个系统中插入多个总线，可通过桥来完成，它是用来连接两个总线的特殊设备。

lspci http://mj.ucw.cz/pciutils.shtml
lspci -t 得到PCI总线和PCI设备组成的树状结构。
ls /sys/devices/pci0000:00/0000:00:1e.0/0000:02:00.0/0000:03:00.0/
net:eth2 -> Ethernet
ls /sys/devices/pci0000:00/0000:00:1e.0/0000:02:00.0/0000:03:00.1/
tty:ttyS1 -> Modem

lspci -x  # 256B的空间值，用于存放配置寄存器
ff:13.6 System peripheral: Intel Corporation Xeon E5/Core i7 Ring to QuickPath Interconnect Link 1 Performance Monitor (rev 07)
00: 86 80 45 3c 00 00 00 00 07 00 80 08 00 00 80 00
10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
20: 00 00 00 00 00 00 00 00 00 00 00 00 86 80 00 00
30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

od -x /sys/devices/pci0000:ff/0000:ff:13.6/config
0000000 8086 3c45 0000 0000 0007 0880 0000 0080
0000020 0000 0000 0000 0000 0000 0000 0000 0000
0000040 0000 0000 0000 0000 0000 0000 8086 0000
0000060 0000 0000 0000 0000 0000 0000 0000 0000
*
0000400

配置区偏移地址 含义
0              厂家ID             0x8086
2              设备ID             0x3c45
10             设备类型代码       0x0880              具体见include/linux/pci_ids.h
16~39          基址寄存器0~5      0x0000-...0x0000
44             子厂家ID           0x8086
46             子设备ID           0x0000



/proc/pci
/proc/pci/bus
在显示硬件地址时，有时显示两个值(一个8位的总线编号和一个8位的设备及功能编号)
                  有时显示三个值(总线、设备、功能)
				  有时显示四个值(域，总线、设备、功能)
lspci | cut -d: -f1-3
lspci -v 
lspci -vvvv

------ 域16位 总线8位 设备5位 功能3位 ------
#lspci | cut -d: -f1-3
ff:13.6 System peripheral: Intel Corporation Xeon E5/Core i7 Ring to QuickPath Interconnect Link 1 Performance Monitor (rev 07)
#cat /proc/bus/pci/devices | cut -f1
ff9e
[域、]总线ff、设备13、功能6
域16位 总线8位 设备5位 功能3位
------ 域16位 总线8位 设备5位 功能3位 ------

cat /proc/bus/pci/devices | cut -f1
tree /sys/bus/pci/devices  
   
1、每个外设板的硬件电路对如下三种地址空间的查询进行应答：内存位置，IO端口和配置寄存器。
前两种地址空间由同一PCI总线上的所有设备共享；也就是说：在访问内存位置时，该PCI总线上的所有设备将在同一时间看到总线周期；
2、另一方面，配置空间利用了地址寻找。配置查询每次只对一个槽寻址，因此它们根本会发生任何冲突。

3、对驱动而言，内存和IO区域是惯常的方式，即通过inb和readb等等进行访问。另一方面，配置事物是通过调用特定的内核函数访问配置寄存器来执行的。
4、关于中断，每个PCI槽有四个中断引脚，每个设备功能可使用其中的一个，而不用考虑这个引脚如何连接到CPU。这种路由是计算机平台的职责，
	实现PCI总线之外。因为PCI规范要求中断线是可以共享的，因此，即使IRQ线有限的处理器仍然可以容纳许多PCI接线板。
   
PCI总线中的IO空间使用32位地址总线，而内存空间可通过32位或64位地址来访问。

5、固件在系统引导时初始化PCI硬件，把每个区域映射到不同的地址以避免冲突，这些区域所映射到地址可从配置空中读取，因此，
Linux驱动程序不需要探测就能访问其设备。在读取配置寄存器之后，驱动程序就可以安全访问其硬件。   

通常将定地址对设备是唯一的，但是软件可能会错误地将两个设备配置成相同的地址，导致无法访问这两个设备。
但是，如果驱动程序不去访问那些不应该访问的寄存器，就不会发生这样的问题。
幸好，接口板提供的每个内存和IO地址区域，都可能通过配置事务的方式进行重新映射，也就是说，固件在引导时初始化PCI硬件，把每个区域映射到
不同的地址以避免冲突。这些区域所应到的地址可从配置空间中读取，因此Linux驱动程序不需要探测就能访问其设备。在读取设备寄存器之后，驱动程序
就可以安全访问其硬件。

6、配置空间256字节构成，PCI快速设备4KB的配置空间。 4个字节的唯一性ID。驱动程序通过查询外设的特定ID来识别其设备。
   这些寄存器中的信息随后可能被用来执行普通的IO寻址，而不再需要额外的物理寻址。
   
7、我们可从设备自己的硬件手册中找到ID，文件pci.ids中包含有一个清单，该文件时pciutils包和内和源代码的一部分。该文件并不完整，
   而只是列出了最著名的制造商及设备。该文件的内核版本将在未来的内核版本中删除。
   
8、当PCI设备上电时，硬件保持未激活状态，换句话说，该设备只会对配置事物作出相应。上电时，设备上不会有内存和IO端口映射到计算机的地址空间，
   其它设备相关功能，例如中断报告，也被禁止。
   每个PCI主板均配备有能够处理PCI的固件，称为BIOS、NVRAM或PROM，这取决于具体的平台。固件通过读写PCI控制器中的寄存器，提供了对设备配置地址空间的访问。
   
9、/proc/bus/pci/devices和/proc/bus/pci/*/*查看PCI设备清单和设备的配置寄存器。
   /proc/bus/pci/devices 十六进制的设备信息的文本文件。
   /proc/bus/pci/*/* 若干二进制文件，报告了每个设备的配置寄存器的快照，每个文件对应一个设备
   /sys/bus/pci/devices 一个PCI设备目录包含各种不同的文件。
   [root@agent109 devices]# tree 0000\:00\:00.0/
	0000:00:00.0/
	├── broken_parity_status
	├── class    PCI设备特定的值
	├── config   二进制文件，使原始PCI配置信息可以从设备读取(就像/proc/bus/pci/*/*所提供的)
	├── device   PCI设备特定的值
	├── enable
	├── irq      分配给该PCI设备的IRQ
	├── local_cpulist
	├── local_cpus
	├── modalias
	├── msi_bus
	├── numa_node
	├── power
	│?? └── wakeup
	├── remove
	├── rescan
	├── reset
	├── resource       显示该设备所分配的当前内存资源
	├── subsystem -> ../../../bus/pci
	├── subsystem_device  PCI设备特定的值
	├── subsystem_vendor  PCI设备特定的值
	├── uevent
	└── vendor             PCI设备特定的值

-------------------------------------------------------------------------------------------------
1、所有的PCI设备都有至少256字节的地址空间，前64字节是标准化的，而其余的是设备相关的。
厂商[2]  设备ID[2] 命令寄存器[2] 状态寄存器[2] 版本修订ID[1] 类代号[3] 高速缓存线[1] 延期寄存器[1] 头类型[1] BIST[1]
    基地址0[4]           基地址1[4]                  基地址2[4]                            基地址3[4]
    基地址4[4]           基地址5[4]              CardBus CIS指针[4]            子系统厂商ID[2]     子系统设备ID[2]
   扩展ROM基地址                保留[8]                                中断线[1]      中断引脚[1] Min_Gnt[1] Max_Lat[1]    	

   PCI寄存器始终是小头的。
尽管标准被设计为体系结构无关的，但PCI设计值仍然有点偏好PC环境。驱动程序编写者在访问多字节的配置寄存器时，要十分注意字节序。
因为能够在PC上工作的代码到其他平台上可能就无法工作。可以借助定义在asm/byteorder.h中的函数。

驱动程序如何查询设备，以及如何访问设备的配置空间。
1. 用3或者5个寄存器可标识一个设备：vendorID、deviceID和class是常用的3个寄存器。
2. 每个PCI制造商会将正确的值赋予这三个只读寄存器，驱动程序可利用它们查询设备。
3. 此外，有时厂商利用subsystem vendorID和subsystem deviceID两个字段进一步区分相似的设备。

vendorID:16位寄存器，用于表示硬件制造商。例如，每个Intel设备被表示为同一个厂商编号，即0x8086.
         PCI Special Interest Group维护有一个全球的厂商编号注册表，制造商必须申请一个唯一的编号并赋予它们的寄存器
deviceID:16位寄存器，由制造商选择。无需对设备ID进行官方注册。该ID通常和厂商ID配对成一个唯一的32位硬件设备标识符。
         我们使用签名一词来表示一对厂商和设备ID。设备驱动程序通常依靠该设备签名来识别设备。
class   : 每个外部设备属于某个类。class寄存器是一个16位的值，其中高8为表示了基类或者组，
          例如ethernet以太网和token ring令牌环是同属network组的两个类，而serial串行和parallel是同属communication通信组。
         某些驱动程序可依靠class寄存器来识别它们的外设。
subsystem vendorID:		 
subsystem deviceID：机一部标识设备。如果设备中的芯片是一个连接到本地板载总线上的通用接口芯片，则可能会用于完全不同的多种用途。

对应于 struct pci_device_id结构体；用于定义该驱动程序支持的不同类型的PCI设备列表
__u32 vendor;
__u32 device;
   它们指定了设备的PCI厂商和设备ID。如果驱动程序可以处理任何厂商或设备ID，这些字段应该使用值PCI_ANY_ID.
__u32 subvendor;
__u32 subdevice;
   它们指定设备的PCI子系统厂商和子系统设备ID，如果驱动程序可以处理任何类型的子系统ID，这些字段应该使用值PCI_ANY_ID.
__u32 class;
__u23 class_mask;
   这两个值使驱动程序可以指定它支持一种PCI类设备。PCI规范中描述了不同类的PCI设备。如果驱动程序可以处理任何类型的，使用值 PCI_ANY_ID.
kernel_ulong_t driver_data;
   该值不是用来和设备相匹配的，而是用来保存PCI驱动程序用于区分不同设备的信息，如果它需要的话。
应该使用两个宏来进行struct pci_device_id结构体的初始化：
PCI_DEVICE(vendor, device);
   它创建一个仅和特定厂商及设备ID相匹配的struct pci_device_id。这个宏把结构体的subvendor和subdevice字段设置为PCI_ANY_ID.
PCI_DEVICE_CLASS(device_class, device_class_mask)
   它创建一个和特定PCI类相匹配的struct pci_device_id.
例如: drivers/usb/host/ehci-hcd.c
      drivers/i2c/buses/i2c-i810.c
	  

-------------------------------------------------------------------------------------------------
MODULE_DEVICE_TABLE:
这个pci_device_id结构体需要被导出到用户空间，使热插拔和模块装在系统直到什么模块针对什么硬件设备。宏MODULE_DEVICE_TABLE完成这个工作。
例子：MODULE_DEVICE_TABLE(pci, i810_ids);

/lib/modules/KERNEL_VERSION/modules.pcimap

struct pci_driver结构体：
const char *name : 驱动程序的名称，在内核的所有PCI驱动程序中它必须是唯一的，通常被设置为和驱动程序的模块名相同的名字。当驱动程序运行在内核中时，
他会出现在sysfs的/sys/bus/pci/drivers下面。

const struct pci_device_id *id_table;
指向struct pci_device_id 表的指针。

int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);
指向PCI驱动程序中的探测函数的指针。当PCI核心有一个它认为驱动程序需要控制的struct pci_dev时，就会调用该函数。CPI核心用来做判断
的struct pci_device_id指针也被传递给该函数。如果PCI驱动程序确认传递给它的struct pci_dev，则应该恰当地初始化设备然后返回0，
如果驱动程序不确认该设备，或发生了错误，它应该返回一个负的错误值。

void (*remove)(struct pci_dev *dev);
指向一个移除函数的指针，当struct pci_dev被从系统中移除，或PCI驱动成正在从内核卸载时，PCI核心调用该函数。

int (*suspend)(struct pci_dev *dev, u32 state);
指向一个挂起函数的指针，当struct pci_dev被挂起时PCI核心调用该函数。挂起状态以state变量来传递。该函数是可选的，驱动程序不一定要提供。

int (*resume)(struct pci_dev *dev);
指向一个恢复函数的指针，当struct pci_dev被恢复时PCI核心调用该函数。它总是在挂起函数已经被调用之后被调用。该函数是可选的，驱动程序不一定要提供。

pci_driver 需要初始化四个字段：name, id_table probe remove.
pci_driver 注册函数：pci_register_driver(&pci_driver);   注销函数：pci_unregister_driver
    如果注册成功，返回0.否则，返回一个负的错误编号。
	
	
------------------------------------------------------------------------------------------------- 老式
如果真的需要查找特定PCI设备的能力的话，可以使用下面的函数：
struct pci_dev *pci_get_device(unsigned int vendor, unsigned int device, struct pci_dev *from);
pci_dev_put 该函数不能在中断上下文中被调用。如果这么干，会在系统日志中打印一条告警信息。

struct pci_dev * pci_get_subsys(unsigned int vendor, unsigned int device, unsigned int ss_vendor, unsigned int ss_device, struct pci_dev *from);
允许在查找设备时指定子系统厂商和子系统设备ID。
pci_dev_put 该函数不能在中断上下文中被调用。如果这么干，会在系统日志中打印一条告警信息。

struct pci_dev *pci_get_slot(struct pci_bus *bus, unsigned int devfn);
在指定struct pci_bus上的系统PCI设备列表中查找指定的设备和PCI设备的功能编号。
pci_dev_put 该函数不能在中断上下文中被调用。如果这么干，会在系统日志中打印一条告警信息。


int pci_enable_device(struct pci_dev *dev) 激活PCI设备。

------------------------------------------------------------------------------------------------- 访问配置空间
在驱动程序检测到设备之后，它通常需要读取或写入三个地址空间：内存、端口和配置。对驱动程序而言，对配置空间的访问至关重要，因为
这是它找到设备映射到内存和IO空间的什么位置的唯一途径。
Linux提供了访问配置空间的标准接口：前64字节为标准；总共有256字节空间。

int pci_read_config_byte(struct pci_dev *dev, int where, u8 *val)
int pci_read_config_word(struct pci_dev *dev, int where, u16 *val)
int pci_read_config_dword(struct pci_dev *dev, int where, u32 *val)
int pci_write_config_byte(struct pci_dev *dev, int where, u8 val)
int pci_write_config_word(struct pci_dev *dev, int where, u16 val)
int pci_write_config_dword(struct pci_dev *dev, int where, u32 val)

驱动程序不能访问pci_dev的任何时刻，都可以使用这些函数来代替上述函数。
int pci_bus_read_config_byte(struct pci_bus *bus, unsigned int devfn,
			     int where, u8 *val);
int pci_bus_read_config_word(struct pci_bus *bus, unsigned int devfn,
			     int where, u16 *val);
int pci_bus_read_config_dword(struct pci_bus *bus, unsigned int devfn,
			      int where, u32 *val);
int pci_bus_write_config_byte(struct pci_bus *bus, unsigned int devfn,
			      int where, u8 val);
int pci_bus_write_config_word(struct pci_bus *bus, unsigned int devfn,
			      int where, u16 val);
int pci_bus_write_config_dword(struct pci_bus *bus, unsigned int devfn,
			       int where, u32 val);


------------------------------------------------------------------------------------------------- 访问IO和内存空间
一个PCI设备可实现多达6个IO地址区域。每个区域可以是内存也可以是IO地址。
大多数设备在内存区域实现IO寄存器。因为这通常是一个更明智的方法。
但是，不想常规内存，IO寄存器不应该由CPU缓存，因为每次访问都可能有边际作用。
6个IO地址区域[PCI_BASE_ADDRESS_0 ~ PCI_BASE_ADDRESS_5]
[续]
--因为PCI定义的IO空间时32为地址总线，因此，内存和IO使用相同的配置接口是有道理的，
如果，设备使用64位的地址总线，他可以为每个区域使用两个连续的PCI_BASE_ADDRESS寄存器来声明64位内存空间的区域(低位优先)。
对一个设备来说，既提供32位区域也提供64位区域是可能的。


将IO寄存器实现为内存区域的PCI设备通过在其配置寄存器中设置"内存是可预取的"标志来标识这个不同。
如果内存区域被标记为可预取，则CPU可缓存其内容，并进行各种优化。
对非可预取的内存的访问不能被优化，因为这种访问可能有边际作用，就像IO端口。
把控制寄存器映射到内存地址范围的外设把该范围声明为非可预取的，不过想PCI板载视频内存这样的东西是可预取的。


在内核中，PCI设备的IO区域已经被集成到通用资源管理。因此，我们无需访问配置变量来了解设备被映射到内存或IO空间的何处。
获得区域的首选接口由如下函数组成：

#define pci_resource_start(dev, bar)	((dev)->resource[(bar)].start)
返回6个PCI IO区域之一的首地址，该区域由整数bar(base address register 基地址寄存器)指定，bar的取值为0到5.
#define pci_resource_end(dev, bar)	((dev)->resource[(bar)].end)
返回地bar个IO区域的位地址。注意这是最后一个可用的地址，而不是该区域之后的第一个地址。
#define pci_resource_flags(dev, bar)	((dev)->resource[(bar)].flags)
返回和该资源相关联的标志。
资源标志用来定义单个资源的某些特性。对与PCI IO区域关联的PCI资源，该信息从基地址寄存器中获得，但对于和PCI设备无关的资源，它可能来至其他地方。
所有资源的标志定义在linux/ioport.h中，下面列出其中最重要的几个：
IORESOURCE_IO
IORESOURCE_MEM
    如果相关的IO区域存在，将设置这些标志之一。
IORESOURCE_PREFETCH
IORESOURCE_READONLY
    这些标志标明内存区域是否为可预取和写保护的，对PCI资源来说，从来不会设置后的那个标志。

通过使用pci_resource_系列函数，设备驱动程序可完全忽略底层的PCI寄存器。因为系统已经使用这些寄存器构建了资源信息。


#define pci_resource_len(dev,bar) \ ....   .... 
------------------------------------------------------------------------------------------------- PCI中断	
在Linux的引导阶段，计算机固件已经为设备分配了一个唯一的中断号，驱动程序只需要使用该中断号。
中断号保存在配置寄存器60(PCI_INTERRUPT_LINE)中，该寄存器为一个字节宽，这允许多大256个中断线，但实际的限制取决于所使用的CPU。
驱动程序无需检测中断号，因为从PCI_INTERRUPT_LINE找到的值肯定是正确的。

如果设备不支持中断，寄存器61(PCI_INTERRUPT_PIN)是0；否则为非零。但是，因为驱动程序知道自己的设备是否是中断驱动的，因此，它通常不需要读取
PCI_INTERRUPT_LINE寄存器。





   