!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
DEBFLAGS	Makefile	/^  DEBFLAGS = -O -g -DSHORT_DEBUG # "-O" is needed to expand inlines$/;"	m
DEBFLAGS	Makefile	/^  DEBFLAGS = -O2$/;"	m
KERNELDIR	Makefile	/^KERNELDIR ?= \/lib\/modules\/$(shell uname -r)\/build$/;"	m
NR_TIMEVAL	short.c	356;"	d	file:
PWD	Makefile	/^PWD       := $(shell pwd)$/;"	m
SHORT_DEFAULT	short.c	/^enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};$/;"	e	enum:short_modes	file:
SHORT_MEMORY	short.c	/^enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};$/;"	e	enum:short_modes	file:
SHORT_NR_PORTS	short.c	44;"	d	file:
SHORT_PAUSE	short.c	/^enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};$/;"	e	enum:short_modes	file:
SHORT_STRING	short.c	/^enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};$/;"	e	enum:short_modes	file:
base	short.c	/^static unsigned long base = 0x378;$/;"	v	file:
do_short_read	short.c	/^ssize_t do_short_read (struct inode *inode, struct file *filp, char __user *buf,$/;"	f
do_short_write	short.c	/^ssize_t do_short_write (struct inode *inode, struct file *filp, const char __user *buf,$/;"	f
irq	short.c	/^static int irq = -1;$/;"	v	file:
major	short.c	/^static int major = 0;	\/* dynamic by default *\/$/;"	v	file:
obj-m	Makefile	/^obj-m	:= short.o$/;"	m
probe	short.c	/^static int probe = 0;	\/* select at load time how to probe irq line *\/$/;"	v	file:
share	short.c	/^static int share = 0;	\/* select at load time whether install a shared irq *\/$/;"	v	file:
short_base	short.c	/^unsigned long short_base = 0;$/;"	v
short_buffer	short.c	/^unsigned long short_buffer = 0;$/;"	v
short_cleanup	short.c	/^module_exit(short_cleanup);$/;"	v
short_cleanup	short.c	/^void short_cleanup(void)$/;"	f
short_do_tasklet	short.c	/^void short_do_tasklet (unsigned long unused)$/;"	f
short_fops	short.c	/^struct file_operations short_fops = {$/;"	v	typeref:struct:file_operations
short_head	short.c	/^unsigned long volatile short_head;$/;"	v
short_i_fops	short.c	/^struct file_operations short_i_fops = {$/;"	v	typeref:struct:file_operations
short_i_read	short.c	/^ssize_t short_i_read (struct file *filp, char __user *buf, size_t count, loff_t *f_pos)$/;"	f
short_i_write	short.c	/^ssize_t short_i_write (struct file *filp, const char __user *buf, size_t count,$/;"	f
short_incr_bp	short.c	/^static inline void short_incr_bp(volatile unsigned long *index, int delta)$/;"	f	file:
short_incr_tv	short.c	/^static inline void short_incr_tv(volatile struct timeval **tvp)$/;"	f	file:
short_init	short.c	/^int short_init(void)$/;"	f
short_init	short.c	/^module_init(short_init);$/;"	v
short_interrupt	short.c	/^irqreturn_t short_interrupt(int irq, void *dev_id, struct pt_regs *regs)$/;"	f
short_irq	short.c	/^volatile int short_irq = -1;$/;"	v
short_kernelprobe	short.c	/^void short_kernelprobe(void)$/;"	f
short_modes	short.c	/^enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};$/;"	g	file:
short_open	short.c	/^int short_open (struct inode *inode, struct file *filp)$/;"	f
short_poll	short.c	/^unsigned int short_poll(struct file *filp, poll_table *wait)$/;"	f
short_probing	short.c	/^irqreturn_t short_probing(int irq, void *dev_id, struct pt_regs *regs)$/;"	f
short_queue	short.c	/^DECLARE_WAIT_QUEUE_HEAD(short_queue);$/;"	v
short_read	short.c	/^ssize_t short_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)$/;"	f
short_release	short.c	/^int short_release (struct inode *inode, struct file *filp)$/;"	f
short_selfprobe	short.c	/^void short_selfprobe(void)$/;"	f
short_sh_interrupt	short.c	/^irqreturn_t short_sh_interrupt(int irq, void *dev_id, struct pt_regs *regs)$/;"	f
short_tail	short.c	/^volatile unsigned long short_tail;$/;"	v
short_tl_interrupt	short.c	/^irqreturn_t short_tl_interrupt(int irq, void *dev_id, struct pt_regs *regs)$/;"	f
short_wq	short.c	/^static struct work_struct short_wq;$/;"	v	typeref:struct:work_struct	file:
short_wq_count	short.c	/^int short_wq_count = 0;$/;"	v
short_wq_interrupt	short.c	/^irqreturn_t short_wq_interrupt(int irq, void *dev_id, struct pt_regs *regs)$/;"	f
short_write	short.c	/^ssize_t short_write(struct file *filp, const char __user *buf, size_t count,$/;"	f
tasklet	short.c	/^static int tasklet = 0;	\/* select whether a tasklet is used *\/$/;"	v	file:
tv_data	short.c	/^struct timeval tv_data[NR_TIMEVAL]; \/* too lazy to allocate it *\/$/;"	v	typeref:struct:timeval
tv_head	short.c	/^volatile struct timeval *tv_head=tv_data;$/;"	v	typeref:struct:timeval
tv_tail	short.c	/^volatile struct timeval *tv_tail=tv_data;$/;"	v	typeref:struct:timeval
use_mem	short.c	/^static int use_mem = 0;	\/* default is I\/O-mapped *\/$/;"	v	file:
wq	short.c	/^static int wq = 0;	\/* select at load time whether a workqueue is used *\/$/;"	v	file:
