linux驱动的入口函数module_init的加载和释放:

#define module_init(x)     __initcall(x);              //include/linux/init.h
#define __initcall(fn) device_initcall(fn)
#define device_initcall(fn)                 __define_initcall("6",fn,6)
#define __define_initcall(level,fn,id) /
         static initcall_t __initcall_##fn##id __used /
         __attribute__((__section__(".initcall" level ".init"))) = fn
		 
如果某驱动想以func作为该驱动的入口，则可以如下声明：module_init(func);被上面的宏处理过后，变成__initcall_func6 __used加入到内核映像的
".initcall"区。内核的加载的时候，会搜索".initcall"中的所有条目，并按优先级加载它们，普通驱动程序的优先级是6。其它模块优先级列出如下：
值越小，越先加载。	

#define pure_initcall(fn)           __define_initcall("0",fn,0)
#define core_initcall(fn)            __define_initcall("1",fn,1)
#define core_initcall_sync(fn)          __define_initcall("1s",fn,1s)
#define postcore_initcall(fn)             __define_initcall("2",fn,2)
#define postcore_initcall_sync(fn)  __define_initcall("2s",fn,2s)
#define arch_initcall(fn)            __define_initcall("3",fn,3)
#define arch_initcall_sync(fn)          __define_initcall("3s",fn,3s)
#define subsys_initcall(fn)                 __define_initcall("4",fn,4)
#define subsys_initcall_sync(fn)      __define_initcall("4s",fn,4s)
#define fs_initcall(fn)                          __define_initcall("5",fn,5)
#define fs_initcall_sync(fn)               __define_initcall("5s",fn,5s)
#define rootfs_initcall(fn)                  __define_initcall("rootfs",fn,rootfs)
#define device_initcall(fn)                 __define_initcall("6",fn,6)
#define device_initcall_sync(fn)       __define_initcall("6s",fn,6s)
#define late_initcall(fn)             __define_initcall("7",fn,7)
#define late_initcall_sync(fn)           __define_initcall("7s",fn,7s)

module_init除了初始化加载之外，还有后期释放内存的作用。linux kernel中有很大一部分代码是设备驱动代码，这些驱动代码都有初始化和反初始化函数，
这些代码一般都只执行一次，为了有更有效的利用内存，这些代码所占用的内存可以释放出来。

linux就是这样做的，对只需要初始化运行一次的函数都加上__init属性，__init 宏告诉编译器如果这个模块被编译到内核则把这个函数放到（.init.text）
段，module_exit的参数卸载时同__init类似，如果驱动被编译进内核，则__exit宏会忽略清理函数，因为编译进内核的模块不需要做清理工作，显然__init
和__exit对动态加载的模块是无效的，只支持完全编译进内核。

在kernel初始化后期，释放所有这些函数代码所占的内存空间。连接器把带__init属性的函数放在同一个section里，在用完以后，把整个section释放掉。
当函数初始化完成后这个区域可以被清除掉以节约系统内存。Kenrel启动时看到的消息"Freeing unused kernel memory: xxxk freed"同它有关。




	 
		 