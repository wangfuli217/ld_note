TDD三定律（官方版）：
    在编写不能通过的单元测试前,不可编写生产代码。
    只可编写刚好无法通过的单元测试,不能编译也算不通过。
    只可编写刚好足以通过当前失败测试的生产代码。

TDD三定律（白话解读版）：
    先把单元测试写好了，再去写生产代码。
    单元测试至少要能编译通过。
    单元测试写好之后，生产代码要使失败的测试用例刚好能通过。

F.I.R.S.T原则
    快    速（First）：能够快速运行。
    独    立（Independence）：可单独运行每个测试，也就是说可以任何顺序运行测试。
    可重复（Repeat）：在任何环境中测试均能通过。
    自动验证（Spontaneous Verification）：应有布尔值输出。
    及    时（Timely）：应在生产代码之前编写。

    测试应当具有可读性，以便其他程序员可以舒服地改变或者增加测试
使测试更好读
    对使用者隐去不重要的细节，以便有更重要的细节会更突出
       将测试项的输入参数和验证参数按照不同的函数或者不同的段落进行组织。
       通过注册或表驱动的方式构建测试输入和结果验证之间的桥梁。
    创建最小的测试声明
        对于这样的输入情形，期望有这样的行为/输出
        用自然语言描述，然后实现定制的“微语言”
        例如：CheckScoreSortFilterBeforeAfter("-5,1,4,3,-99","4,3,1")
    让错误消息具有可读性，更好版本的assert/手工打造错误消息
    选择好的测试输入
        应当选择一组最简单的输入，它能完整地使用被测代码
        简化输入值，又简单又能完成工作的测试值更好
    一个功能的多个测试，多种场景，各种临界情况
    为测试函数命名
        考虑被测试的类/函数/场景/Bug  Test_XXX
        测试函数并不会被工作代码调用，长度无关紧要
    对测试较好的开发方式
    利于测试的理想代码
        明确定义的接口
        没有过多状态和其他的设置
        没有很多需要审查的隐藏数据
    测试驱动开发
    
    可测性差的代码
      使用全局变量
         对于每个测试都要重置所有全局变量状态(否则，不同的测试之间会忽悠影响)
         很难理解那些函数有什么副作用。没办法独立考虑每个函数，要考虑整个程序才能理解是不是所有的代码都能工作
      对外部组件有大量依赖的代码
         很难给他写出任何测试，因为要先搭建太多脚手架。写测试会比较无趣，因此人们会避免写测试
         ...
      代码有不确定的行为
         测试会很古怪，而且不可靠。经常失败的测试最终会被忽略。
         
    优秀代码
       类中只有很少或者没有内部状态
           很容易写出测试，因为要测试一个方法只要很少的设置，并且有较少的隐藏状态需要检查
           有很少状态的类更简单，更容易理解
       类/函数只做一件事
           要测试它只要很少的测试用例
           较小|较简单的组件更加模块化，并且一般来讲系统有更少的耦合
       每个类对别的类依赖较少，低耦合
           每个类可以独立地测试(比多多个类一起测试容易很多)
           系统可以并行开发，可以很容易修改或者删除类，而不会影响系统的其他部分
       函数的接口简单，定义明确
           有很明确的行为可以测试。测试简单接口所需的工作量较少
           接口更容易让程序员学习，并且重用的可能性更大
       
    走得太远
        牺牲真实代码的可读性
        着迷于100%的代码覆盖率
        让测试成为产品开发的阻碍
        
1. 每个测试的最高一层应该越简明越好。最好每个测试的输入输出可以用一行代码来描述。
2. 如果测试失败了，它所发出的错误消息应该能可让你容易跟踪并修正这个bug
3. 使用最简单的并且能够完整运用代码的测试输入
4. 给测试函数取一个描述性的名字，以使每个测试所得到的东西很明确。
        