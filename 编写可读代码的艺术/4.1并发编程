并发会在性能和编写额外代码上增加一些开销；
    1. 正确的并发是复杂的，即便对于简单的问题也是如此；
    2. 并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待；
    3. 并发常常需要对设计策略的根本性修改。

并发防御原则：
    1. 单一权责原则
       a. 推论：限制数据作用域
       b. 推论：使用数据复本
       c. 推论：线程应尽可能地独立
       
在并发编程中用到的几种执行模型：
    a. 生产者-消费者模型： 一个或多个生产者线程创建某些工作，并置于缓存或队列中。
      一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。

    b. 读者-作者模型：当存在一个主要为读者线程提供信息源，但只是偶尔被作者线程更新的共享资源，
       吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。协调读者线程，
       不去读作者线程正在更新的信息（反之亦然），这是一种辛苦的平衡工作。作者线程倾向于
       长期锁定许多读者线程，从而导致吞吐量问题。

    c. 宴席哲学家模型：想象一下，一群哲学家环坐在圆桌旁。每个哲学家的左手边放了一把叉子。
       桌面中央摆着一大碗意大利面。哲学家们思索良久，直至肚子饿了。每个人都要拿起叉子吃饭。
       但除非手上有两把叉子，否则就没法进食。如果左边或右边的哲学家已经取用一把叉子，
       中间这位就得等到别人吃完、放回叉子。每位哲学家吃完后，就将把两把叉子放回桌面，
       直到肚子再饿。用线程代替哲学家，用资源代替叉子，就变成了许多企业级应用中进程
       竞争资源的情形，如果没有用心设计，这种竞争式系统就会遭遇死锁，活锁，吞吐量和效率低等问题。

    c. 警惕同步方法之间的依赖。同步方法之间的依赖会导致并发代码中的狡猾缺陷。避免使用
       一个共享对象的多个方法。

    d. 保持同步区域微小。尽可能少地设计临界区，尽可能减小同步区域。

    e. 很难编写正确的关闭代码。尽早考虑关闭问题，尽早令其工作正常。这会花费比你预期更多的时间。
        检视既有算法，因为这可能会比想象中难得多。

测试线程代码。下面是一些精炼的建议：
    1. 将伪失败看作可能的线程问题；
    2. 先使非线程代码可工作；
    3. 编写可插拔的线程代码；
    4. 编写可调整的线程代码；
    5. 运行多于处理器数量的线程；
    6. 在不同平台上运行；
    7. 调整代码并强迫错误发生。