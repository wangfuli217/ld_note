/*
 * =====================================================================================
 *
 *       Filename:  atom.c
 *
 *    Description:  #define ATOM_SIZE before #include <zy/atom.h>
 *
 *        Version:  1.0
 *        Created:  28.02.10
 *       Revision:  
 *       Compiler:  gcc
 *
 *         Author:  Yang Zhang (ZY), imyeyeslove@163.com
 *        Company:  
 *
 * =====================================================================================
 */

#include	<assert.h>
#include	<string.h>
#include	<stdlib.h>
#include	<stdio.h>
#include	<limits.h>

#define		ZY_ATOM_IMPLEMENTATION
#include	<zy/atom.h>


#define         search_part(at, str, len)                                                 \
do {                                                                                      \
        assert(at);                                                                       \
        assert(str);                                                                      \
        assert(len > 0);                                                                  \
	/*-----------------------------------------------------------------------------   \
         *  hash function                                                                 \
	 *-----------------------------------------------------------------------------*/ \
        for (i = 0; i < len; i++)                                                     \
                key = (key << 1) + scatter[(unsigned char)str[i]];                        \
	/*-----------------------------------------------------------------------------   \
         *  make key during 0 -- ATOM_SIZE                                                \
	 *-----------------------------------------------------------------------------*/ \
        key &= ATOM_SIZE - 1;                                                                 \
	/*-----------------------------------------------------------------------------   \
         *  search                                                                        \
	 *-----------------------------------------------------------------------------*/ \
        if (at[key].size) {                                                                    \
                for (atom_n *p = at[key].head; p; p = p->link) {                          \
                        if (p->len == len) {                                              \
				for (i = 0; i < len && p->str[i] == str[i]; i++)      \
                                        ;                                                 \
                                if (i == len) {                                           \
                                        return p->str;                                    \
                                }                                                         \
                        }                                                                 \
                }                                                                         \
        }                                                                                 \
} while (0)


/*-----------------------------------------------------------------------------
 *  core & auxiliary. no need to export
 *-----------------------------------------------------------------------------*/
static const char *search(atom_t *, const char *, long);
static const char *add(atom_t *, const char *, long);
static char *ltoa(long);

/*-----------------------------------------------------------------------------
 *  for hash function
 *-----------------------------------------------------------------------------*/
static unsigned long scatter[] = {
2078917053, 143302914, 1027100827, 1953210302, 755253631, 2002600785,
1405390230, 45248011, 1099951567, 433832350, 2018585307, 438263339,
813528929, 1703199216, 618906479, 573714703, 766270699, 275680090,
1510320440, 1583583926, 1723401032, 1965443329, 1098183682, 1636505764,
980071615, 1011597961, 643279273, 1315461275, 157584038, 1069844923,
471560540, 89017443, 1213147837, 1498661368, 2042227746, 1968401469,
1353778505, 1300134328, 2013649480, 306246424, 1733966678, 1884751139,
744509763, 400011959, 1440466707, 1363416242, 973726663, 59253759,
1639096332, 336563455, 1642837685, 1215013716, 154523136, 593537720,
704035832, 1134594751, 1605135681, 1347315106, 302572379, 1762719719,
269676381, 774132919, 1851737163, 1482824219, 125310639, 1746481261,
1303742040, 1479089144, 899131941, 1169907872, 1785335569, 485614972,
907175364, 382361684, 885626931, 200158423, 1745777927, 1859353594,
259412182, 1237390611, 48433401, 1902249868, 304920680, 202956538,
348303940, 1008956512, 1337551289, 1953439621, 208787970, 1640123668,
1568675693, 478464352, 266772940, 1272929208, 1961288571, 392083579,
871926821, 1117546963, 1871172724, 1771058762, 139971187, 1509024645,
109190086, 1047146551, 1891386329, 994817018, 1247304975, 1489680608,
706686964, 1506717157, 579587572, 755120366, 1261483377, 884508252,
958076904, 1609787317, 1893464764, 148144545, 1415743291, 2102252735,
1788268214, 836935336, 433233439, 2055041154, 2109864544, 247038362,
299641085, 834307717, 1364585325, 23330161, 457882831, 1504556512,
1532354806, 567072918, 404219416, 1276257488, 1561889936, 1651524391,
618454448, 121093252, 1010757900, 1198042020, 876213618, 124757630,
2082550272, 1834290522, 1734544947, 1828531389, 1982435068, 1002804590,
1783300476, 1623219634, 1839739926, 69050267, 1530777140, 1802120822,
316088629, 1830418225, 488944891, 1680673954, 1853748387, 946827723,
1037746818, 1238619545, 1513900641, 1441966234, 367393385, 928306929,
946006977, 985847834, 1049400181, 1956764878, 36406206, 1925613800,
2081522508, 2118956479, 1612420674, 1668583807, 1800004220, 1447372094,
523904750, 1435821048, 923108080, 216161028, 1504871315, 306401572,
2018281851, 1820959944, 2136819798, 359743094, 1354150250, 1843084537,
1306570817, 244413420, 934220434, 672987810, 1686379655, 1301613820,
1601294739, 484902984, 139978006, 503211273, 294184214, 176384212,
281341425, 228223074, 147857043, 1893762099, 1896806882, 1947861263,
1193650546, 273227984, 1236198663, 2116758626, 489389012, 593586330,
275676551, 360187215, 267062626, 265012701, 719930310, 1621212876,
2108097238, 2026501127, 1865626297, 894834024, 552005290, 1404522304,
48964196, 5816381, 1889425288, 188942202, 509027654, 36125855,
365326415, 790369079, 264348929, 513183458, 536647531, 13672163,
313561074, 1730298077, 286900147, 1549759737, 1699573055, 776289160,
2143346068, 1975249606, 1136476375, 262925046, 92778659, 1856406685,
1884137923, 53392249, 1735424165, 1602280572
};

/*-----------------------------------------------------------------------------
 *  
 *  				atom wrapper
 *
 *-----------------------------------------------------------------------------*/

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  atom_search_string
 *  Description:  just wrap search();
 * =====================================================================================
 */
const char *atom_search_string(atom_t *at, const char *str)
{
	assert(at);
	assert(str);
	return search(at, str, strlen(str));
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  atom_add_string
 *  Description:  just wrap add();
 * =====================================================================================
 */
const char *atom_add_string(atom_t *at, const char *str)
{
	assert(at);
	assert(str);
	return add(at, str, strlen(str));
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  atom_search_num
 *  Description:  also wrap, convert a num to a num-string
 * =====================================================================================
 */
const char *atom_search_num(atom_t *at, long n)
{
	assert(at);
	char *p = ltoa(n);
	return search(at, p, strlen(p));
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  atom_add_num
 *  Description:  also wrap, convert a num to a num-string
 * =====================================================================================
 */
const char *atom_add_num(atom_t *at, long n)
{
	assert(at);
	char *p = ltoa(n);
	return add(at, p, strlen(p));
}



/*-----------------------------------------------------------------------------
 *
 *  				atom core
 *
 *-----------------------------------------------------------------------------*/

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  search
 *  Description:  just search
 *  		  don't use it directly, so static
 * =====================================================================================
 */
static const char *search(atom_t *at, const char *str, long len)
{
	long i;
        unsigned key = 0;                                                           
	search_part(at, str, len);
	return NULL;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  add
 *  Description:  firstly search, if not exists, add
 *  		  don't use it directly, so static
 * =====================================================================================
 */
static const char *add(atom_t *at, const char *str, long len)
{
	long i;
        unsigned key = 0;                                                            
	search_part(at, str, len);

	/*-----------------------------------------------------------------------------
	 *  now, not found, so add it
	 *-----------------------------------------------------------------------------*/
	atom_n *p = (atom_n *) calloc(1, sizeof(atom_n) + len);
	p->len = len;                                           /* atom_n.len */
	memmove(p->str, str, len);                               /* atom_n.str */
	p->str[len] = '\0';
	p->link = at[key].head;                                 /* atom_n.link */
	at[key].head = p;                                       /* atom.head */
	at[key].size++;                                         /* atom.size */

	return p->str;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  atom_create
 *  Description:  create a atom table with ATOM_SIZE elements
 * =====================================================================================
 */
atom_t *atom_create()
{
	atom_t *at = (atom_t *) calloc(ATOM_SIZE, sizeof(atom_t));
	if (!at) {
		fprintf(stderr, "Calloc Atom Table Failure!\n");
		exit(EXIT_FAILURE);
	}
	return at;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  atom_free
 *  Description:  free every atom_n in every list
 * =====================================================================================
 */
void atom_free(atom_t *at)
{
	assert(at);
	
	atom_n *current;
	atom_n *next;

	for ( int i = 0; i < ATOM_SIZE; i += 1 ) {              /* every list */
		current = at[i].head;
		while (current) {                               /* every atom_n */
			next = current->link;
			free(current);
			current = next;
		}
	}
	
	free(at);
	at = NULL;
}


/*-----------------------------------------------------------------------------
 *
 *  				atom auxiliary
 *
 *-----------------------------------------------------------------------------*/
static char *ltoa(long n)
{
        char buf[64] = {0};                                                               
        char *p = buf + 63;                                     /* at buf[63] */
        long abso;                                                                      

        /*-----------------------------------------------------------------------------   
         *  i.e. -128 ~ +127, -128 == 127 + 1                                             
	 *
	 *  in <limits.h>:
	 *
	 *  #if __WORDSIZE == 64
	 *  # define LONG_MAX	9223372036854775807L
	 *  #else
	 *  # define LONG_MAX	2147483647L
	 *  #endif
	 *  #define LONG_MIN	(-LONG_MAX - 1L)
         *-----------------------------------------------------------------------------*/ 
        if (n == LONG_MIN) {                                                              
                abso = LONG_MAX + 1UL;                                                     
        } else if (n < 0) {                                                               
                abso = -n;                                                                  
        } else {                                                                          
                abso = n;                                                                  
        }                                                                                 

        /*-----------------------------------------------------------------------------   
         *  fill from buf[62], leave buf[63] to be '\0' 
         *-----------------------------------------------------------------------------*/ 
	do {
                *--p = abso % 10 + '0';                                                    
	} while (abso /= 10);

	/*-----------------------------------------------------------------------------
	 *  for signed num
	 *-----------------------------------------------------------------------------*/
	if (n < 0) {
		*--p = '-';
	}

	return p;
}
