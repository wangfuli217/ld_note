回顾：
1.明确：CPU访问外设都是以地址指针的形式访问
  务必：将来访问外设一定首先搞清楚外设对应的基地址
  切记要记得一个人：硬件工程师
2.明确：ARM裸板开发
  软件框架：
  //1.各种硬件初始化
  xxx_init();
  //2.死循环开始处理业务
  while(1) {
  	...
  }
3.项目实施过程
  1.了解用户需求
  2.默念嵌入式开发理念
  3.掌控硬件信息
    粗看
    细看
    	关键是：硬件操作时序图
  4.掌握某个外设将来跟CPU之间的通信方式
    GPIO：LED,按键
    UART：BT,GPRS,GPS等
    IO(多根)：多根数据线和地址线,Nand
    I2C:
    SPI：
    ...
  5.编写ARM裸板程序
  6.编译：
    首先配置交叉编译器的环境变量
  7.测试
  8.注意：
    研究对象转移：

**********************************************************
二.ARM体系结构及汇编编程
面试题：谈谈你对ARM处理器的认识
1.ARM定义
  可以认为是一种处理器架构：X86,ARM,POWERPC,MIPS,DSP,FPGA
  也可以认为是一家公司：ARM公司
  ARM公司只做ARM处理器的设计,靠卖IP盈利
2.常见制造ARM处理器的厂家
  华为海思
  联芯
  MTK:消费类
  三星：消费类 
  飞思卡尔：军品，工控，汽车
  TI：消费类,达芬奇系列(DSP+ARM视频监控) 
  Atmel：工业控制
  博通：网络
  MARVELL：网络
3.指令集的分类：复杂指令集,精简指令集
4.ARM核的发展历史和版本信息(ARM公司定义)
  大版本来分：ARMV4,ARMV5,ARMV6,ARMV7,ARMV8
  每一个大版本下面又分若干个小版本(ARM定义)：
  ARMV4:           芯片厂家某个处理器
        ARM7TDMI：S3C4510,S3C44B0
        ARM9TDMI: S3C2410,S3C2440 
  ARMV5:
  	ARM1020E: S3C6410
  	Xscale(intel):PX270   
  ARMV6:
  	ARM1136EJS:MSM7200(高通)
  ARMV7:
  	ARM CortexA8:S5PV210
  	ARM CortexM3:STM32 
  ARMV8:支持64位
  	ARM CortexA57:MTK6732(4核)
  	              MTK6752(8核)
5.计算机设计的两种架构
  冯诺伊曼：指令和数据共用一个总线
  哈弗：指令和数据分开
  
5.ARM7的ARM三级流水线
  冯诺伊曼
  "指令":给CPU下发的执行命令
  指令如果采用三级流水线处理：
  明确：三级流水线处理需要三个硬件逻辑单元：
  分别是：取指器,解码器,执行器
  也就代表一个执行的执行最终需要三步骤：
  1.先从存储器中取得指令(取指F)
  2.然后将指令进行翻译(解码D)
  3.最后CPU执行指令(执行E)
  
  明确：
  ARM指令的宽度：32位
  Thumb指令的宽度：16位
  PC:永远保存取指地址
  例如：
  取指      解码      执行
  push
  add       push
  ldr       add       push

  假设：
  正在执行指令的地址为：0x20008000
  正在取值指令的地址为：0x20008008
  PC=0x20008008   	              
  
  总结：
  1.对于ADD,SUB,ORR,AND,EOR指令的处理需要三级流水线即可
  2.特例：
    ldr指令(存储加载指令),从内存中加载数据到CPU
    需要五级流水线：取值F 解码D 执行E 访存M 写回W
    访存：访问某个内存地址
    写回：一旦找到这个内存地址,从地址中读取数据到CPU
    
    bl指令(跳转指令),让CPU跳转到某个地址去取指
    需要五级流水线：取值F 解码D 执行E 保存返回地址L 跳转A
    
    中断：
    明确：什么是中断
    答：
    	中断属于计算机世界中的一个非常非常重要的机制
    	明确：
    	硬件层面上：CPU一天到晚就是在跟外设进行数据通信
    	软件层面上：CPU一天到晚要不处理进程要不处理中断
    	中断产生的本质就是因为外设的数据处理速算远远慢于
    	CPU的处理数据！
    	以UART为例：CPU读取UART的方法
    	1.采用轮询方法
    	  CPU读取UART,如果发现UART没有准备好数据
    	  CPU原地死等,并且CPU不能干别的事情
    	  最后结果是大大减低的CPU的利用率
    	  
    	2.采用中断方法
    	  CPU读取UART，如果发现UART没有准备好数据
    	  CPU可以干别的事情(其他进程),一旦UART
    	  准备好数据，UART给CPU发送一个中断电信号(嗨,我准备好)
    	  ,CPU一旦接收到这个中断信号,CPU就开始处理UART
    	  一旦处理完毕，在接着执行原先被打断的事情
    	  大大提高了CPU的利用率(至少做2件事)
    	3.总结：
    	  轮询和中断永远是死对头！  
    	
    	中断的流水线处理：
    	1.中断发生时,保证正在执行的指令完成,不能打断正在
    	  执行的指令
    	2.接着就开始对中断进行处理
    	  解码中断  执行中断 保存返回地址  跳转
  	
6.ARM9TDMI 五级流水线
  明确：
  三级流水线仅仅取指 解码 执行,对于ldr指令采用访存和写回
  也就是访存和写回对于三级流水线并没有通用和合法！
  
  但是到五级流水线,任何指令让访存和写回通用和合法
  
  明确：
  ARM处理器寄存器分为两类：
  1.ARM核内部寄存器(暂存数据使用)
    R1,R2...
    不能以地址指针的形式访问,以名称直接访问
    并且只能用汇编来访问这些寄存器
    
  2.外设设计的控制器对应的特殊寄存器(SFR)
    这些寄存器在访问时必须以地址指针的形式访问

7.ARM的工作模式
  工作模式有7种：
  SVC管理模式：当系统复位上电或者软件调用swi软中断指令
               CPU就会切换到SVC管理模式
  FIQ快速中断模式：当外设产生的中断信号以FIQ形式发送给
               CPU,切换到FIQ模式
  IRQ中断模式：当外设产生的中断信号以IRQ形式发送给
               CPU,切换到IRQ模式
   	       注意：CPU有两根信号线：FIQ和IRQ
  终止模式：当CPU访问存储器异常(内存地址不存在,权限不够)
            CPU切换到终止模式
  未定义指令模式：当CPU执行未定义的指令时(LISI)
  Sytem系统模式：
  USER模式：
  	   以上两个模式都一样,仅仅却别在于权限所有不同
  	   普通UC的应用程序一般运行在USER模式
 
 <<ARM体系结构与编程>>杜春雷

7.ARM的工作状态
  ARM状态：
  	执行ARM指令集：32位
  THUMB状态：	                   	   		
  	执行thumb指令集：16位

  状态切换：利用BX指令
  BX R0; R0=地址 ->让CPU跳转到R0所指定的地址运行
  如果R0[0]=地址的bit0=1,切换到THUMB状态
  如果R0[0]=地址的bit0=0,切换到ARM状态 
  
8.ARM核内部寄存器的组织方式
  ARM核内部共37寄存器
  31个通用寄存器
  6个状态寄存器
     1个CPSR：程序状态寄存器
     5个SPSR：备份程序状态寄存器
  划分：
  R0~R15：通用寄存器
  FIQ模式有单独的：R8~R14
  其余模式有单独的R3,R14
  除了User和System其余模式都有单独的SPSR,用来保存CPSR
  CPSR只有一个,PC只有一个
  R13又称sp：用来保存栈指针(栈地址)
  R14又称lr：用来保存返回地址
  R15又称PC:用来保存取值指令的地址
  注意：不区分大小写

9.CPSR和SPSR说明
  CPSR:程序状态寄存器
  BIT[4:0]:模式为,体现当前CPU的工作模式
  BIT[5]:体现处理器的状态=0ARM =1THUMB
  BIT[6]:配置FIQ =1禁止 =0使能
  BIT[7]:配置IRQ ...
  BIT[28]:体现程序运算的结果是否溢出
          =1溢出
          =0没有
  	  adds r1, r2, r3 如果元算的结果溢出,CPSRbit28=1
  
  BIT[29]:体现程序运算的结果是否发生了进位或者借位
          发生1
          无0
  BIT[30]:体现程序运算的结果是否为0
          为0=1
          为1=0
  BIT[31]:体现程序的运算结果是负数或者小于
          如果是=1
          否则=0
  
  注意：如果指令后面添加后缀s,表示指令运算的结果会影响到
        条件标志位:NZCV	         
  SPSR用来保存CPSR

10.ARM异常
  ”异常“：随机,不是预期的事件发生
  ARM异常的种类：
  1.Reset复位异常
    特点：当按复位键产生复位异常,CPU硬件上自动到0x0地址
          去执行
  2.undef未定义指令异常
    特点：当CPU发现这个指令非法,产生未定义指令异常
    CPU硬件自动到0x04地址去执行
  3.软中断异常
    当软件调用swi指令时,产生软中断异常,CPU硬件自动到
    0x08地址去执行
  4.预取终止异常
    当CPU访问某个存储器地址时,发生访问异常(地址不合法,权限     不够),CPU硬件自动到0x0C地址去执行
  5.数据终止异常
    当CPU访问某个数据时,发生访问异常(数据不合法,权限           不够),CPU硬件自动到0x10地址去执行
  6.IRQ异常
    当外设给CPU发送IRQ中断信号时,发生IRQ异常
    CPU硬件自动到0x18地址去执行
  7.FIQ异常
    当外设给CPU发送FIQ中断信号时,发生FIQ异常
    CPU硬件自动到0x1C地址去执行
    
  总结：
  一旦发生异常,CPU跳转到对应的地址以后,后序的事情完全
  由程序员自己来实现
  
  
  
  
  
  
  
  
  
  
    







  