回顾：
1.ARM汇编和C的混合调用
  明确：函数之间传递参数的方法
  1.采用寄存器传递
    利用r0,r1,r2,r3
    结合栈来传递(参数大于4个)
    注意：参数个数尽量保持在4个以内(CPU的处理远远快于外设)
    参数的摆放：常用放在前面
  2.强制采用栈传递
    asmlinkage
  
  明确：函数的返回值以r0进行返回
  
  明确：C调用ARM汇编函数和变量,注意事项
  1.汇编要将函数和变量用.global进行修饰
  2.C调用时要进行外部引用声明,用extern
  
  明确：ARM汇编调用C的函数和变量,注意事项
  1.C的函数和变量定义时要进行全局化,不能用static修饰
  2.ARM调用时使用时要进行.extern修饰
  
  具体：参见add/main 要求：只要能看懂即可
  
2.ARM异常处理
  明确：ARM异常种类
  1.复位异常
  2.未定义指令异常
  3.软中断异常
  4.预取指令异常
  5.数据处理异常
    速度PK(大->小)
    ARM寄存器>Cache>内存>SSD>机械硬盘
    四大存储类型：register int a;
  6.IRQ中断
  7.FIQ中断
  
  明确：ARM7中异常处理的返回代码
  movs pc,lr:软中断/未定义指令
  subs pc,lr,#4：预取指令/irq/fiq
  subs pc,lr,#8:数据处理 
 
3.中断处理的流程
  面试题：谈谈对中断的理解
  明确：为什么有中断机制
  本质：外设的处理速度远远慢于CPU
  中断和轮询是死对头！
  轮询：应用在等待时间极短
        长时间的轮询,结果大大降低CPU的利用率
  中断：应用在随机场合,等待时间比较长(不固定)
        长时间等待场合,利用中断会提高CPU的利用率
  以CPU读取UART为例进行解释说明
  
  明确：中断的硬件连接
  关键要谈中断控制器
  "外设"产生的中断信号不会直接输送CPU
  要经过中断控制器的过滤,最终由中断
  控制器决定是否发送给CPU
  中断控制器的作用：
  1.使能或者禁止某个外设中断
  2.设置中断的优先级
  3.设置中断采用IRQ/FIQ
  4.如果是多核(CPU),设置中断到底给哪些CPU发送
  5.设置外设中断有效的触发方式
  画出一个简要的中断连接图
           
  明确：中断的触发流程和处理流程
  以按键为例：
  1.每当用户进行按键操作(按下或者松开)
  2.硬件上电信号由高电平向低电平跳变,产生下降沿
  3.下降沿电信号发送给中断控制器
  4.中断控制器要对这个电信号进行判断
    判断是否使能？
    判断优先级？
    判断中断信号采用IRQ/FIQ?
    判断下降沿是否是有效的电信号
  5.中断控制器将给CPU发送一个电信号(IRQ/FIQ)
  6.CPU一旦接收到了一个中断电信号
    发生中断异常(假设IRQ)
  7.ARM核硬件将做：
    备份CPSR
    配置CPSR：MODE T F I
    LR=PC-4
    PC=0x18(可以软件来修改)
  8.CPU跑到地址0x18地址开启(取值,解码,执行...)
    正式开启了软件的处理流程
  9.在开启软件处理流程之前,软件要建立好异常向量表
  10.跳转到异常向量表的0x18地址以后,将做
     1.保护被中断打断的任务(进程)现场
       压栈
     2.执行后序的中断处理函数
       判断外设中断
       根据不同的外设中断,执行不同的任务(萝卜和白菜)
     3.中断处理函数执行完毕以后,恢复现场
       原先被打断的任务继续执行
  11.画出整个处理的操作图
     int.bmp     

4.中断的软件编程步骤
  1.编写异常向量表的代码
  2.编写保护现场的代码
  3.编写外设对应的中断处理函数
    根据用户需求来实现不同的业务
  4.编写恢复现场的代码      
  
  实际开发模式：
  1.ARM裸板开发
    利用ARM公司的集成开发工具Keil
    Keil开发工具里面集成了大量的ARM公司的原始代码
    例如：1,2,4三步代码ARM公司已经帮你实现
    
  2.linux内核开发
    内核已经将1,2,4完美实现
       
案例：给shell程序添加按键中断支持
1.昨夜实现1,2,4
2.实现3,编写按键中断处理函数
  但是在编写之前要进行中断控制器的各种初始化(仅作了解)
3.了解中断控制器相关的内容
  研发对象转移：以KEY_UP按键为例
  1.CPU访问按键外设
  2.CPU访问按键对应的GPIO(XEINT0/GPH0_0):复用
    采用中断方式
  3.CPU访问中断管脚连接的中断控制器
    CPU访问中断控制器
  4.CPU访问中断控制器是通过中断控制器对应的
    一大堆的寄存器(特殊功能寄存器)访问
  5.最终
    CPU只要访问中断控制器对应的寄存器
  6.看S5PV210的中断控制器章节的芯片手册
    先看基本框架：跟你相关就看,不相关跳过
    找到寄存器的信息：先记录基地址
    		      然后看各个bit位
    		      可以采用默认值
  7.目的：
    只要将中断控制器初始化好,将来按键中断的电信号
    就可以顺利达到CPU     
  
4.中断控制器特性
  将S5PV210支持的所有中断进行分组：VIC0,VIC1,VIC2,VIC3
  每一组个数为32,范围0~31
  结论：KEY_UP对应的中断为VIC0组的第一个EINT0
        VICx中的每一个数字(0~31)代表着某个外设的中断
        
  "清中断"：一旦外设给CPU发送中断电信号,中断控制器会记录
            中断触发了,只要软件不清中断,中断控制器根据
            之前的记录继续给CPU发送中断信号
  结论：中断清除一般都是在中断处理函数中完成
  
  此案例将KEY_UP作为IRQ方式！
  
  VICINTSELECT中断类型配置寄存器：
  基地址：VIC0:0xF200000C
  对于EINT0:
  BIT[0]=0 //IRQ
  
  VICINTENABLE中断使能寄存器
  基地址：0xF2000010
  
  VICINTENCLEAR中断清除寄存器
  
  VICADDRESS：保存当前触发中断对应的中断处理函数
  "ISR":某个中断服务程序/某个中断处理函数       
  KEY1->isr_func1
  KEY2->isr_func2
  KEY3->isr_func3
  如果KEY2有操作,KEY2给CPU发中断信号
  VICADDRESS硬件自动保存isr_func2函数地址
  
  VICVECTADDR: 保存每一个中断对应的中断处理函数 
  例如VIC0(32个中断)
EINT0->VICVECTADDR0:也同样包含bit[0:31]
      VICVECTADDR1
      ...
      VICVECTADDR31
  
  KEY1->isr_func1
  KEY2->isr_func2
  KEY3->isr_func3
  
  结果是：
  VICVECTADDR0=isr_func1
  VICVECTADDR1=isr_func2
  VICVECTADDR2=isr_func3
  
  总结：将来某个中断触发,硬件自动将VICVECTADDR拷贝到
        VICADDRESS(真正反映哪个中断触发)
  
  GPH0CON配置寄存器
  GPH0PUD上下拉电阻配置寄存器
  
  EXTINTCON0中断配置寄存器P332
  设置有效的触发方式
  BIT[2:0]=010 //下降沿为有效
  
  EXTINTFILTERCON:
  =0:禁止滤波
  
  EXITINTMASK:使能屏蔽中断
  
  EXTINTPEND:中断状态配置寄存器
  中断发生以后,在中断处理函数记得要清中断
  如果要清中断,必须写1清为0
  
  
  
  
  
  
  
  
  
  
  
  
  
   