低级语言-指令；高级语言-statement/expression

汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令机器语言也有三条指令，汇编器就是做一个简单的替换工作

可移植的（Portable）或者称为平台无关的（PlatformIndependent） 指令集（Instruction Set）

Source Code->目标文件（Object File）或可执行文件（Executable）可执行文件只是目标文件的一种类型 可执行文件代码才是计算机可以执行的程序

解释（Interpret）语言与编译语言执行过程区别 p23

4GL以后的语言主要不是通过输入、输出、基本运算、测试分支和循环（5种）基本指令来编程的，是在描述要做什么（Declarative）而不是描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全交由编译器或解释器决定，例如SQL语言 显示出编程语句越来越智能越来越像自然语言

编程语言也是一种形式语言，是专门设计用来表达计算过程的形式语言 形式语言有严格的语法（Syntax）规则

语法规则是由关于符号（Token）和结构（Structure）的规则所组成的 。Token的概念相当于自然语言中的单词和标点、数学式中的数和运算符、化学分子式中的元素名和数字 语法规则的第二个范畴是结构，也就是Token的排列方式 Token的规则称为词法（Lexical）规则，而关于语句结构的规则称为语法（Grammar）规则

Syntax和Grammar通常都翻译成“语法”，这让初学者非常混乱，Syntax的含义其实包含了Lexical和Grammar，还包含一部分语义（Semantic）

区分编译时和运行时（Run-time）这两个概念，不仅是调试，在掌握C语言的很多特性时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做

当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。

缩进（Indent）

有些不重要的警告信息gcc默认是不提示的，但这些警告信息也有可能表明程序中有Bug。一个好的习惯是打开gcc的-Wall选项

斜线（Slash） 嵌套（Nest）字符串字面值（String Literal）界定符（Delimiter）转义序列（EscapeSequence）

换行符（Line Feed LF 老式打印机进纸，喂纸，有个喂的动作所以是feed）

\r Carriage Return CR 是回到本行开头（Carriage是卷着纸的轴，随着打字慢慢左移，打完一行就一下子移回最右边），用老式打字机打完一行之后需要这么两个动作，\r\n，所以现在Windows上的文本文件用\r\n 做行分隔符，许多应用层网络协议（如HTTP）也用\r\n做行分隔符

\a 响铃（Alert，或Bell）字符终端下显示这个字符的效果是PC喇叭发出嘀的一声，在图形界面终端下的效果取决于终端的实现

\f是分页符，主要用于控制打印机在打印源代码时提前分页，这样可以避免一个函数跨两页打印

include必须单独占一行

单引号只能括一个字符而不能像双引号那样括一串字符，字符常量也可以是一个转义序列，例如'\n' ，这时虽然单引号括了两个字符，但实际上只表示一个字符

字符常量中要表示双引号"和问号?，既可以使用转义序列\" 和\?，也可以直接用字符"和?，而要表示' 和\ 则必须使用转义序列

转义序列是编译器在处理字符串字面值时转义的，而占位符是由printf解释的，格式化字符串实际包含的字符是character 

"5" 、'5' 、5， 字符串 字符 整数

些特殊的终端上缺少某些字符，需要用Trigraph输入，例如??= 表示#

变量的类型也决定了它所占的存储空间的大小

函数名、宏定义、结构体成员名等等，在C语言中这些统称为标识符（Identifier ）

定义（Definition）和声明（Declaration）之间的关系是：如果一个声明同时也要求分配存储空间，则称为定义 
定义了变量之后，我们要把值存到它们的存储空间里，可以用赋值（Assignment）语句 
定义一个变量，就是分配一块存储空间并给它命名；给一个变量赋值，就是把一个值存到了这块存储空间中 
定义和赋值也可以一步完成，这称为变量的初始化（Initialization）
初始化是一种特殊的变量定义语句，而不是一种赋值语句

C语言的很多语法规则既适用于赋值也适用于初始化，但在以后的学习中你也会了解到它们之间的不同，请在学习过程中注意总结赋值和初始化的相同之处和不同之处

char 型变量的存储空间是一个字节
char 型本质上就是整数，只不过取值范围比int 型小，所以以后我们把char 型和int 型统称为整数类型（Integer Type ）或简称整型
'0' ~ '9'  的ASCII码是十六进制的30~39，这是字符型'0'~'9' 和整数0~9 的区别。

去掉return 0; 则编译时显示“在有返回值的函数中，控制流程到达函数尾”

expression=运算符(operator)+操作数（Operand）

一个表达式中出现多个等号，是从右到左计算
优先级的运算符是从左到右计算还是从右到左计算，这称为运算符的结合性（Associativity ）。+-*/是左结合的，等号是右结合的

等号的右边可以是任意组合的表达式，但要注意等号左边不能是任意组合的表达式，因为等号左边表示的不是一个值而是一个存储位置

C语言定义的取整运算既不是Floor 也不是Ceiling，无论操作数是正是负总是把小数部分截断(Truncate），所以当操作数为正的时候相当于Floor ，当操作符为负的时候相当于Ceiling

c定义了一系列隐式类型转换（Implicit Conversion）规则
本来编程语言作为一种形式语言要求有简单而严格的规则，自动类型转换规则不仅很复杂，而且使C语言的形式看起来也不那么严格了，C语言这么设计是为了书写程序简便而做的折衷，有些事情编译器可以自动做掉，程序员就不必每次都写一堆繁琐的代码

计算机之所以能处理符号，是因为符号在计算机内部也用数字来表示，每个字符在计算机内部都用一个整数来表示，称为字符编码（Character Encoding），目前大部分平台通用的是ASCII码 取值范围是0~127

字符也可以用ASCII码的转义序列表示  '\11' 或'\x9' 表示Tab字符，"\11"或"\x9"表示由Tab字符组成的字符串

数学中使用函数有时候书写可以省略括号，而C语言要求一定要加上括号，例如sin(pi/2)
pi/2 是参数（Argument ），sin 是函数(Function），sin(pi/2) 是函数调用（Function Call)  表达式的值就是sin(pi/2) 的计算结果，在C语言的术语中称为函数的返回值（Return Value）

像sin 这种函数，我们传进去一个参数会得到一个返回值 用sin 函数就是为了用它的返回值

printf也是一个函数  整个printf就是一个函数调用，也就是一个表达式， 我们并不关心返回值（事实上它也有返回值，表示实际打印的字符数），我们用printf不是为了用它的返回值，而是为了利用它所产生的副作用（Side Effect）－－打印。C语言的函数可以有Side Effect ，这一点是它和数学函数在概念上的根本区别（？？a<b<c）

Side Effect这个概念也适用于运算符组成的表达式。比如a + b这个表达式也可以看成一个函数调用，运算符+是一个函数，它的两个参数是a和b，返回值是两个参数的和，传入两个参数，得到一个返回值，并没有产生任何Side Effect。而赋值运算符是产生Side Effect的，如果把a = b这个表达式看成函数调用，传入两个参数a和b分别做左值和右值使用，返回值就是所赋的值，既是b的值也是a的值，但除此之外还产生了Side Effect，就是a的值被改变了，改变计算机存储单元里的数据或者做输入或输出操作，这些都算Side Effect。
不用函数返回值，就说明我们用的是副作用

开始我们说赋值是一种语句，后来学了表达式，我们说赋值语句是表达式语句的一种，一开始我们说printf是一种语句，现在学了函数，我们又说printf也是表达式语句的一种。随着我们一步步的学习，把原来看似不同类型的语句统一成一种语句了。学习的过程总是这样，初学者一开始接触的很多概念从严格意义上说是错的，但是很容易理解，随着一步步学习，在理解原有概念的基础上不断纠正，不断泛化（Generalize ）。比如上一年级老师说，小数不能减大数，其实这个概念是错的，后来引入了负数就可以减了，后来接触了分数，原来的正数和负数的概念就泛化为和分数相对的整数，上初中学了无理数，原来的整数和分数的概念就泛化为有理数，再上高中学了复数，有理数和无理数的概念就泛化为实数。

包含头文件2方法：
          #include <myinc.h>   #include "myinc.h"
gcc在               系统预设包含文件目录找        先在当前 再到指定目录
头文件类型      系统头文件                                  自定义头文件
自己编写的头文件，通常放在与源程序相同目录中，并以第2种方式包含；大型程序中，头文件单独放在1个目录，此时编译程序时需要用选项  －Ldirname告诉gcc到名为dirname的目录找－lname 让编译器装载名为libname.a/libname.so的函数库，该库位于系统默认或或由－L指定的目录中。

使用math.h中的函数还有一点特殊之处，gcc 命令行必须加-lm选项，因为数学函数位于libm.so库文件中（通常在/lib 目录下）大部分库函数（例如printf）位于libc.so库文件中，以后称为libc ，使用libc 中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc 默认的

程序的编译过程：
                                         预处理(pre-processing)      				    编译(compiling)		汇编(assembling)			链接(linking)
输入文件                        c源文件									    预处理文件				汇编文件					2进制机器码文件＋其他机器码文件和库文件
文件名                            *.c/*.C(带有*.h的头文件)					 *.i						*.s						*.o    			
处理任务 		 	#ifdef #include #define预处理命令	   生成汇编语言文件			转为2进制机器码			汇集成可执行的2进制码文件
生成文件			*.i											 *.s						*.o						*(a.out)									iso
命令				gcc -E *.c -o *.i						 gcc -S *.i -o *.s	gcc -c *.s -o *.o 	gcc *.o -o *    						ESc

main 函数的返回值是返回给操作系统看的，因为main 函数是被操作系统调用的，通常程序执行成功就返回0，在执行过程中出错就返回一个非零值

如果main中return 4; 则执行后再echo $? 显示4
$?是Shell 中的一个特殊变量，表示上一条命令的退出状态

main函数2中正确写法：
int main(int argc, char *argv[])  
int main(void)

void aaa()           表达不完整。因为OLD C标准存在，所以编译器不做语法检查但能通过，会引入bug
void aaa(void)       函数原型(Prototype)：声明了一个函数的名字、参数类型和个数、返回值类型
void aaa(void);   	函数声明  	编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，然后在碰到函数调用时才知道怎么生成相应的指令
void aaa(void){...}	函数定义

分配存储空间的变量声明才叫变量定义，编译器只有见到函数定义才会生成指令，而指令在程序运行时当然也要占存储空间

定义变量时可以把同样类型的变量列在一起，而定义函数参数却不可以
void a(int hour, minute) 错误

C语言的设计者也不希望自己设计的语法规则里到处都是例外，一个容易被用户接受的设计应该遵循最少例外原则（Rule of Least Surprise）

实参(Argument)	形参(Parameter)
形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化。 函数定义中有几个形参，在调用时就要传几个实参，不能多也不能少，每个参数的类型也必须对应上
C语言的这种传递参数的方式称为Call by Value

有时候我们把函数叫做接口（Interface ），调用函数就是使用这个接口，使用接口的前提是必须和接口保持一致

使用printf函数必须包含stdio.h

每次调用函数时局部变量都表示不同的存储空间。局部变量在每次函数调用时分配存储空间，在每次函数返回时释放存储空间

如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。所以，局部变量在使用之前一定要先赋值，如果基于一个不确定的值做后续计算肯定会引入Bug 。

不要把必要条件（Necessary Condition）当充分条件（SufficientCondition），这一点在Debug 时尤其重要

全局变量在任何函数中都可以访问，所以在程序运行过程中全局变量被读写的顺序从源代码中是看不出来的，源代码的书写顺序并不能反映函数的调用顺序。程序出现了Bug 往往就是因为在某个不起眼的地方对全局变量的读写顺序不正确

main函数外定义的变量是全局变量，用它们的函数不需设置参数

函数先在自己作用域找变量的值，若没有则在大环境找全局变量

局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式初始化  如double pi = acos(-1.0);在局部合法，在全局非法
程序开始运行时要用适当的值来初始化全局变量，所以初始值必须保存在编译生成的可执行文件中，因此初始值在编译时就要计算出来，然而上面第二种Initializer 的值必须在程序运行时调用acos 函数才能得到，所以不能用来初始化全局变量。请注意区分编译时和运行时这两个概念

语句块则不需要在{}后面再加; 号。如果} 后面加了; 号，则这个; 号本身又是一条新的语句了，在C语言中一个单独的; 号表示一条空语句

语句块中也可以定义局部变量,和函数的局部变量同样道理，每次进入语句块时为变量j分配存储空间，每次退出语句块时释放变量j的存储空间。语句块也构成一个作用域
单独使用语句块通常是为了定义一些比函数的局部变量更“ 局部” 的变量

奇数 odd  偶数 even  奇偶性（Parity）

取模（Modulo ） 余数（Remainder ）	商（Quotient ） 

单目运算符（Unary Operator ） +-正负号；逻辑非，只有1个运算数 （此3号比加减优先级都高），++ --
双目运算符（Binary Operator） +-加减号

代码不管写成哪种缩进格式，在编译器看起来都是一样的

Dangling-else 问题。C语言规定，else 总是和它上面最近的一个if配对

浮点型的精度有限，不适合用 == 运算符做精确比较。计算2者差，看是否小于某个很小的误差值。《编程卓越之道》p70

a < b < c（<为函数，a b为其参数，产生返回值是0或1）  	a < b && b < c 比较区别

switch中case 后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来

浮点型不适合做精确比较，所以C语言规定case 后面跟的常量表达式必须是整型的

有时候编译器会对switch语句进行整体优化，使它比等价的if/else语句所生成的指令效率更高

return语句的作用是提供整个函数的返回值，并结束当前函数返回到调用它的地方（有点像break作用）
有返回值的函数中也可以使用return语句，例如当检查到一个错误时提前结束当前函数的执行并返回

void a(double a)
{
	if (a < 0.0)    比较时类型需要一致
}

return 1; = return(1); 表达式外面套括号表示改变运算符优先级，在这里不起任何作用

返回布尔值的函数是一类非常有用的函数，在程序中通常充当控制表达式，函数名通常带有is或if等表示判断的词，这类函数也叫做谓词（Predicate）
如，判断奇偶数：
int is_parity(int x)
{
	return !(x % 2);   成功返回1；不成返回0
}
int main(void)
{
	int i ＝ 19;
	if (is_parity(i))
		...；
	else
		...；
}
函数的返回值：函数返回一个值相当于定义一个和返回值类型相同的临时变量并用return后面的表达式来初始化

当if语句对函数的返回值做判断时，函数已经退出，局部变量x已经释放，所以不可能在这时候才计算表达式!(x % 2)的值，表达式的值必然是事先计算好了存在一个临时变量里的，然后函数退出，局部变量释放，if语句对这个临时变量的值做判断。注意，虽然函数的返回值可以看作是一个临时变量，但我们只是读一下它的值，读完值就释放它，而不能往它里面存新的值，换句话说，函数的返回值不是左值，或者说函数调用表达式不能做左值

Call by Value，按值传递，现在我们知道返回值也是按值传递的，即便返回语句写成return x;，返回的也是变量x的值，而非变量x本身，因为变量x马上就要被释放了

printf("...\n"); 最后建议加\n，否则在terminal中显示有小问题

自己直接或间接调用自己的函数称为递归函数。函数A调用函数B，函数B又调用函数A，也就是函数A间接调用自己

每次调用函数时分配参数和局部变量的存储空间

递归调用（recursive）图！！！	p85

递归和循环是等价的，用循环能做的事用递归都能做，反之亦然

章1－5就可实现所有c问题，后面的例如循环只是使代码更简洁
计算机指令能做的所有事情就是数据存取、运算、测试和分支、循环（或递归），在计算机上运行高级语言写的程序最终也要翻译成指令，指令做不到的事情高级语言写的程序肯定也做不到，虽然高级语言有丰富的语法特性，但也只是比指令写起来更方便而已，能做的事情是一样多的

递归调用都是在重复做同样一件事，就是把n乘到(n-1)!上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n的值不一样），这种每次都有点区别的重复工作称为迭代（Iteration）。

我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人类最不擅长的

函数式编程（Functional Programming ）	递归	Declarative	数学式函数
命令式编程（Imperative Programming ）	循环	Imperative	c的主要方式

对全局变量多次赋值会影响代码的线程安全性

不要以为“ 变量可以多次赋值” 是天经地义的，很多编程语言都在避免Imperative的方式，例如Erlang 语言规定变量的值不允许改变

do/while 这种形式在while(控制表达式)后面一定要加; 号，否则编译器无法判断这是一个do/while 循环的结尾还是另一个while 循环的开头

for(控制表达式1;控制表达式2;控制表达式3)
      语句
＝
控制表达式1;	
while( 控制表达式2) {
        语句
        控制表达式3;
}
从这种等价形式来看，控制表达式1和3都可以为空，但控制表达式2是必不可少的，例
如，for(;1;){...} 等价于while(1){...} 死循环。C语言规定，如果控制表达式2为空，则当作
控制表达式2的值为真，因此，死循环也可以写成for(;;){...}

a+++++b ＝ a++ ++ +b
编译解析：词法解析－>语法解析－>基本的语义分析（这时报错）
词法解析阶段，编译器总是从前到后找最长的合法Token（贪婪），++运算符要求操作数能做左值，a能做左值所以a++ 没问题，但表达式a++ 的值只能做右值，不能再++了，所以最终编译器会报错

for(int i = 1; i <= n; i++)，c99引入，控制表达式1的位置可以有变量定义， gcc编译要加上选项-std=c99。在C++ 中这种写法很常见，但是在C语言中，考虑到兼容性，不建议使用这种写法

increment 和decrement这两个词很有意思，大多数字典都说它们是名词，但经常被当成动词用，在计算机术语中，它们当动词用时应该理解为increase by one和decrease by one。现代英语中很多名词都被当成动词用，字典都跟不上时代了，再比如transition也是如此

有一位数的有两位数的，这个表格很不整齐，如果把打印语句改为printf("%d\t", i*j); 就整齐了，所以才需要有Tab（制表符）这么个字符

goto 语句，实现无条件跳转，只要给那个地方起个标号就行，唯一的限制是goto 只能跳到同一个函数的某个标号处，而不能跳到别的函数里

嵌套循环中遇到某个错误条件需要立即跳到循环之外的某个地方做出错处理，就可以用goto 语句。除了差错外，不要用goto

[SICP] 指出，在学习一门编程语言时，要特别注意以下三方面：
1. 这门语言提供了哪些Primitive ，比如基本数据类型，比如基本的运算符、表达式和语句。
2. 这门语言提供了哪些组合规则，比如复合数据类型，比如表达式和语句的组合规则。
3. 这门语言提供了哪些抽象机制，例如数据抽象和过程抽象（Procedure Abstraction ）

结构体/数组 中元素的存储空间也是相邻

枚举类型的成员是常量(int型)，它们的值编译器自动分配

结构体的成员名和变量名不在同一命名空间，但枚举的成员名和变量名却在同一命名空间，所以会出现命名冲突

计算机术语中有Zeroth 这个词

比如count 数组中的每个元素占4个字节，则count[i]位于从数组开头跳过4*i个字节的存储位置。

这种数组下标的表达式不仅可以表示存储位置中的值，也可以表示存储位置本身，也就是说可以做左值

C编译器并不检查count[-1]或是count[100] 这样的访问越界错误，编译时能顺利通过，所以属于运行时错误
编译器对于这么明显的错误都视而不见？理由一，这种错误并不总是显而易见的，以后会讲到通过指针而不是数组名来访问数组的情况，指针指向数组的什么位置只有运行时才知道，编译时无法检查是否越界，而运行时检查数组访问越界会影响性能，所以干脆不检查了；理由二，[C99 Rationale] 指出，C语言的设计精神是：相信每个C程序员都是高手，不要阻止程序员去干他们需要干的事，高手们使用count[-1] 这种技巧其实并不少见，不能当作错误

遍历（Traversal）

数组和结构体虽然有很多相似之处，但也有一个显著的不同：数组不能互相赋值
int a[5], b[5] = { 4, 3, 2, 1 };
a = b;  (错误)
既然不能互相赋值，也就不能用数组类型作为函数的参数或返回值   (那返回多个值怎么办？？)

数组名做右值使用时，自动转换成指向数组首元素的指针

计算机执行每一条指令的结果都是确定的，没有一条指令产生的是随机数，调用C标准库得到的随机数其实是伪随机（Pseudorandom ）数，是用数学公式算出来的确定的数，只不过这些数看起来很随机，并且从统计意义上也很接近均匀分布（Uniform Distribution ）的随机数

C标准库中生成伪随机数的是rand 函数，使用这个函数需要包含头文件stdlib.h ，它没有参数，
返回值是一个介于0和RAND_MAX 之间的接近均匀分布的整数。RAND_MAX 是头文件中定义的一个常
量，在不同的平台上有不同的取值，但可以肯定它是一个非常大的整数。

若希望最大范围为n，用int x = rand() % n; 余数是从0到（n－1） 非常巧妙的方法

每次产生的随机数都是一样的，不仅如此，在别的计算机上运行该程序产生的随机数很可能也是这样的。这正说明了这些数是伪随机数，是用一套确定的公式基于某个初值算出来的，只要初值相同，随后的整个数列就都相同。实际应用中不可能使用每次都一样的随机数，例如开发一个麻将游戏，每次运行这个游戏摸到的牌不应该是一样的。因此，C标准库允许我们自己指定一个初值，然后在此基础上生成伪随机数，这个初值称为Seed ，可以用srand 函数指定Seed

通常我们通过别的途径得到一个不确定的数作为Seed ，例如调用time 函数得到当前系统时间距1970年1月1日00:00:00 （各种派生自UNIX 的系统都把这个时刻称为Epoch ，因为UNIX 系统最早发明于1969年）的秒钟数，然后传给srand ：
srand(time(NULL));
然后再调用rand ，得到的随机数就和刚才完全不同了。调用time 函数需要包含头文件time.h，这里的NULL表示空指针

预处理器做了两件事情，一是把头文件stdio.h和stdlib.h 在代码中展开，二是把#define定义的标识符N替换成它的定义20
以#号开头的语法元素称为预处理指示（Preprocessing Directive ）

用cpp main.c（= gcc -E main.c）命令也可以达到同样的效果，只做预处理而不编译，cpp表示C preprocessor

define定义是在预处理阶段处理的，而枚举是在编译阶段处理的

与宏定义相反的做法称为硬编码（Hard coding ）。应尽可能避免硬编码，这其实也是一个“ 提取公因式” 的过程，和抽象具有相同的作用，就是避免一个地方的改动波及到大的范围。也如同类，为达到灵活复用等目的而把会变化的地方提出来单独写

字符串可以看作一个数组，它的元素是字符型的

字符'\0' 表示字符串结束。这里的\0 是ASCII码的八进制表示，也就是ASCII码为0的那个字符

字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符：char c = "Hello, world.\n"[0];
但是通过下标修改其中的字符却是不允许的： "Hello, world.\n"[0] = 'A';会产生编译错误，说字符串字面值是只读的，不允许修改。字符串字面值还有一点和数组名类似，做右值使用时自动转换成指向首元素的指针，所以printf("hello world")其实是传一个指针参数给printf

char str[10] = { 'H', 'e', 'l', 'l', 'o', '\0' };str 的后四个元素没有指定，自动初始化为0，即'\0' 字符

char str[] = "Hello, world.\n";字符串字面值的长度包括'\0' 在内一共15个字符，编译器会确定数组str 的长度为15

printf会从数组str 的开头一直打印到'\0' 字符为止（'\0' 本身不打印）。这其实是一个危险的信号：如果数组str 中没有'\0' ，那么printf就会打印出界，后果和前面讲的数组访问越界一样诡异：有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃

概念模型，二维数组是三行两列的表格。
物理模型，六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C语言的这种存储方式称为Row-major 方式，而有些编程语言（例如FORTRAN ）是把概念模型的表格一列一列接起来拼起一串存储的，称为Column-major 方式

除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度

通过下标访问字符串组成的数组可以代替一堆case 分支判断，这样就可以把每个case 里重复的代码（printf调用）提取出来，从而又一次达到了“ 提取公因式” 的效果。这种方法称为数据驱动的编程（Data-driven Programming ），写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择得正确，其它代码自然而然就变得容易理解和维护

传给scanf 的第一个参数中：
1。用%d、%f或%c表示读入一个整数、浮点数或字符，则第二个参数的形式应该是&运算符加一个相应类型的变量名，表示读进来的数存到这个变量中；
2。用%s读入一个字符串，则第二个参数应该是数组名，数组名前面不加&，因为数组类型做右值时自动转换成指针类型，而scanf 后面这个参数要的就是指针类型

后缀运算符和操作数之间也不加空格，例如取结构体成员s.a 、函数调用foo(arg1) 、取数组成员a[i] 

有时为了突出优先级也可以写得更紧凑，例如for (i=1; i<10; i++) 、distance = sqrt(x*x + y*y) 等。但是省略的空格一定不要误导了读代码的人，例如a||b && c很容易让人理解成错误的优先级

标准的Linux 终端是24行80列。 折行后用空格和上面的表达式或参数对齐
foo(sqrt(x*x + y*y),
    a[i-1] + b[i-1] + c[i-1])

较长的字符串可以断成多个字符串然后分行书写，例如：
printf("This is such a long sentence that "
		 "it cannot be held within a line\n");
C编译器会自动把相邻的多个字符串接在一起

switch和语句块里的case 、default对齐写，也就是说语句块里的case 、default相对于switch不往里缩进

自己命名的标号（用于goto ）必须顶头写不缩进，而不管标号下的语句缩进到第几层

代码中每个逻辑段落之间应该用一个空行分隔开。例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行

有时候不正确的算法也是有用的，如果对于某个问题寻求正确的算法很困难，而某个不正确的算法可以在有限时间内终止，并且能把误差控制在一定范围内，那么这样的算法也是有实际意义的
例如有时候寻找最优解的开销很大，往往会选择能给出次优解的算法

数据的组织方式包含了存储方式和访问方式这两层意思

数组	各元素挨个存储，每个元素的大小相同，提供按下标访问的方式
结构体	各成员挨个存储，每个成员的大小不同，只能用. 运算符加成员名来访问，而不能按下标访问

堆栈的访问规则被限制为Push 和Pop 两种操作只能访问栈顶元素而不能访问栈中其它元素

top 用作数组stack 的索引，注意top 总是指向栈顶元素的下一个元素，可以把它称为指针（Pointer）

栈操作的top 指针在Push 时增大而在Pop 时减小，栈空间是可以重复利用的，而队列的head 、tail 指针都在一直增大，虽然前面的元素已经出队了，但它所占的存储空间却不能重复利用

任何复杂的加减乘除运算都可以分解成简单的逻辑运算

把与门、或门和反相器组合来实现NAND 和NOR运算，则电路过于复杂了，因此逻辑电路中通常有专用的与非门和或非门

10进制－2进制：  除二反序取余法

八进制和十六进制是程序员为了书写二进制方便而发明的简便写法，好比草书和正楷的关系一样
把(10110010)2 分成每3位一组，10、110、010，然后把每一组写成一个十进制，就是(262) 8
把(10110010)2 分成每4位一组，1011、0010，然后把每一组写成一个数字，(B2) 16 ，称为十六进制（Hexadecimal ）

溢出（Overflow ），通常把计算机中的一个标志位置1表示产生溢出

相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位
正整数溢出称为上溢（Overflow ），负整数溢出称为下溢（Underflow ）

一个地址所对应的存储单元不能存很多东西，只能存一个字节

int 、float 等多字节的数据类型保存在内存中要占用多个地址，这种情况下把起始地址当作这个数据的地址

内存地址是从0开始编号的整数，最大编到多少取决于CPU的地址空间（Address Space ）有多大

32位就是指地址是32位的，从0x0000 0000到0xffff ffff（每个16进制位代表4个2进制位，即8＊4＝32）

计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时根据最高位和次高位产生的进位的异或设置溢出标志。至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，就去检查溢出标志，如果程序把它理解成无符号数加法，就去检查进位标志。通常计算机在做算术运算之后还可能设置另外两个标志，如果结果为零则设置零标志，如果结果的最高位是1则设置负数标志（只有当理解成有符号数运算时才去检查这个标志）

偏移的指数（Biased Exponent）。规定一个偏移值，比如16，实际的指数要加上这个偏移值再填写到指数部分，这样，比16大的就表示正指数，比16小的就表示负指数。要表示0.25 ，指数部分应该填16-1=15 

尾数部分的最高位必须是1，也就是说尾数必须以0.1 开头，对指数做相应的调整，这称为正规化（Normalize ）。由于尾数部分的最高位必须是1，这个1就不必保存了，可以节省出一位来用于提高精度，我们说最高位的1是隐含的（Implied）

17的浮点数表示：17=(0.10001) ×2的5次方。计算机中：0符号位	10101偏移指数5	隐含最高位（1）00010000 （末4位用来提高精度）

浮点数内存中：sign bit + biased exponent + nomalized significand  首位貌似只能作符号位，遂浮点数无 unsigned

c语言规定了signed和unsigned 两个关键字，unsigned char 型表示无符号数，signed char 型表示有符号数

x86平台的gcc定义char 是有符号的。这也是C标准的Rationale之一：优先考虑效率，而可移植性尚在其次	＝> 	定义比不定义效率高 

写不可移植的代码有时候也是必要的，比如Linux 内核代码使用了很多gcc特性以得到最佳的执行效率，在写的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写，如果不是为了效率，一般来说就没有理由故意写不可移植的代码（移植性2层含义：platform;compiler）

ASCII码的取值范围是0~127，所以不管char 型是有符号的还是无符号的，存一个ASCII码都没有问题，一般来说，如果用char 型存ASCII码字符，就不必明确写signed还是unsigned ，如果把char 型当作8位的整数来用，为了可移植性就必须写明是signed还是unsigned(??为移植应该不写明是否有符号？)

c标准中无明确规定3类：
Implementation-defined：要求编译器必须对此做出明确规定，并写在编译器的文档中（char是否有符号）
Unspecified：有几种可选的处理方式，编译器可以自己决定，并且也不必写在编译器的文档中，这样即使用同一个编译器的不同版本来编译也可能得到不同的结果（一个函数调用的各个实参表达式按什么顺序求值）
Undefined：完全不确定的，编译器很可能也没规定，甚至也没做出错处理，有很多情况是编译器是检查不出来的，最终会导致运行时错误（数组访问越界）

转义序列，以\ 或\x 加八进制或十六进制数字表示，这种表示方式相当于把八进制和十六进制整数常量开头的0替换成\ 了

char 型以外的这些整数类型如果不明确写signed或unsigned 关键字都表示有符号数signed，这一点是C标准明确规定的（首位为1，优先考虑符号，而非作为数字处理）

char 型在C标准中明确规定占一个字节之外，其它整数类型占几个字节都是Implementation－Defined 
c编译器常遵守：
    类型    ILP32（位数） LP64 （位数）		I int;L long;P pointer(指针类型的长度总是和计算机的位数一致)
char      8         8
short     16        16
int       32        32
long      32        64
long long 64        64
指针        	   32        		     64

0x7fffffff和0xffff0000 这两个常量虽然看起来差不多，但前者是int 型（31位是0），而后者是unsigned int 型（31位是1，代表负数，而我们要得是正数，所以系统认为是unsigned int）

整型：有符号和无符号的char 、int 、long 、long long ，Bit-field ，枚举常量

浮点型有float 、double、long double，和整数类型一样，既没有规定每种类型占多少字节，也没有规定采用哪种表示形式

0x1234U ，98765ULL

浮点数也可以加一个后缀，例如3.14f、.01L ，没有后缀的浮点数常量是double型的，有后缀f 或F的浮点数常量是float 型的，有后缀l或L的浮点数常量是long double型的

C语法规则中最复杂的是哪一部分，我一定会说是类型转换

1.	+ - ~ 单目， <<  >> 移位：								      			Integer Promotion
2.	+ - * / % > < >= <= == != 双目 & |  ^ ，char, short, bit-field：	Integer Promotion 
3.	+ - * / % > < >= <= == != 双目，integer：							Usual Arithmetic Conversion
4.	函数的参数列表中有... 即参数数量不定，比如printf： 				Integer Promotion					调用printf("%c", ch)时，char型变量ch的值其实是被提升为int后才传给printf
5.	函数的参数列表中有...实参是float：								Default Argument Promotion

可以看出char, short, bit-field在任何时候都转换为integer。C中其实并不存在8位整数的位运算，操作数在做位运算之前都至少被提升为int型了

1。	Integer Promotion：
	char, short, Bit-field -> i -> ui

2。 Usual Arithmetic Conversion：
	对于ILP32：i->ui->ul, i->l->ul（l年龄小于ui但辈分大，2者比较转为ul）, 	  ul->ll->ull->f->d->ld; 
	对于LP64： i->ui->l, l->ul->ull（ll年龄小于ul但辈分大，2者比较转为ull）, l->ll->ull->f->d->ld; 

3。 Default Argument Promotion：
	float -> double（intel 80x86 FPU中，所有计算都使用扩展精度格式80位，将数存入内存时，FPU自动将操作数4舍5入到合适大小。非intel CPU只提供32/64位，精度会稍低）

赋值产生的类型转换：
函数调用传参 ＝  定义形参并且用实参对其做初始化							int foo(int, int); 调用foo(3.1, 4.2) 时会自动把两个double型的实参转成int 型赋给形参
函数返回 	   ＝  定义一个临时变量并且用return的表达式对其做初始化		函数定义中有返回语句return 1.2; ，则返回值1.2 会自动转成int 型再返回

char c = getchar(); ，看到这一句，往往想当然地认为getchar的返回值是char 型的，而事实上getchar的返回值是int 型的，这样赋值会引起1个类型转换

以上为隐式类型转换（Implicit Conversion，或者叫Coercion ）
显式类型转换（Explicit Conversion）或强制类型转换（Type Cast）。例如计算表达式(double)3 + i

移动的位数必须小于左操作数的总位数。如果大于等于位数，则结果是Undefined

移位运算符不同于+ - * / ==等运算符，两边操作数的类型不要求一致，但两边操作数都要做Integer Promotion，整个表达式的类型和左操作数提升后的类型相同

如果左移改变了最高位（符号位），那么结果肯定不是乘以2了，所以我加了个前提“ 在一定的取值范围内”

计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有i * 8，可以编译成移位指令而不是乘法指令

右移如果是负数，那么高位移入1还是0不一定，这是Implementation-defined 的。对于x86平台的gcc 编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“ 右移1位相当于除以2” 的性质

类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，建议只对无符号数做位运算，以减少出错的可能

一个数和自己做异或的结果是0（反物质）。如果需要一个常数0，x86平台的编译器可能会生成这样的指令：xorl %eax, %eax 。不管eax 寄存器里的值原来是多少，做异或运算都能得到0

从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转

如果a1 ^ a2 ^ a3 ^ ... ^ an 的结果是1，则表示a1 、a2 、a3 ...an之中1的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity Check ），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。

x ^ x ^ y == y，因为x ^ x == 0，0 ^ y == y。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用temp = a; a = b; b = temp; 的办法了。利用位运算可以这样做交换：
       a = a ^ b;
       b = b ^ a;
       a = a ^ b;
注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量temp 则可以交换。

RAID实现原理即为上2点

其他运算符 	p245

a && b的计算过程是：首先求表达式a的值，如果a的值是假则整个表达式的值是假，不会再去求b的值；如果a的值是真，则下一步求b的值作为整个表达式的值。所以，a &&b相当于“if a then b” ，而a || b相当于“if not a then b” 。这种特性称为Short-circuit，很多人喜欢利用Short-circuit特性简化代码

1。函数调用开始之前是Sequence Point
2。条件运算符?: 、逗号运算符、逻辑与&& 、逻辑或|| 的第一个操作数求值之后是Sequence Point
3。在一个完整的声明末尾是Sequence Point ，所谓完整的声明是指这个声明不是另外一个声明的一部分
4。在一个完整的表达式末尾是Sequence Point ，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分
5。在库函数即将返回时是Sequence Point 。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的，并不是真正的函数，所以才需要有这条规则

表达式应遵循的原则一：在两个Sequence Point之间，同一个变量的值只允许被改变一次
表达式应遵循的原则二：在两个Sequence Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写

如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序（也就是从左到右）
如果一个操作数后面有多个前缀，按照离操作数从近到远的顺序（也就是从右到左）

Dangling-else 问题：例如a ? b : c ? d : e是看成(a ? b : c) ? d : e还是a ? b : (c ? d : e)呢？C语言规定是后者

赋值= 和各种复合赋值（*= /= %= += -= <<= >>= &= ^= |=）。在双目运算符中只有赋值和复合赋值是右结合的

左结合和右结合这两个概念只对双目运算符有意义。结合性指若表达式含多个上述符号，按从右至左还是左到右的顺序结合运算

PC任何时间点都保存下个指令在内存中的地址，但新指令不必和旧的相邻

CPU和内存之间用地址总线、数据总线和控制线连接起来，每条线上有1和0两种状态：
1。CPU内部将寄存器对接到数据总线上，使寄存器的每一位对接到一条数据线，等待接收数据
2。CPU通过控制线发一个读请求，并且将内存地址通过地址线发给内存
3。内存收到地址和读请求之后，将相应的内存单元对接到数据总线的另一端，这样，内存单元每一位的1或0状态通过一条数据线到达CPU寄存器中相应的位，就完成了数据传送

32位计算机有32条地址线，地址空间（Address Space ）从0x00000000 到0xffffffff ，共4GB

低地址保存的是整数的低位，这称为小端（Little Endian）字节序（Byte Order）。x86平台是小端字节序的，而另外一些平台规定低地址保存整数的高位，称为大端（Big Endian）字节序

访问这种设备就像访问内存一样，按地址读写即可，但和访问内存不同的是，往一个地址写数据只是给设备发一个命令，数据不一定要保存，而从一个地址读数据也不一定是读先前保存在这个地址的数据，而是得到设备的当前状态

设备中可供读写访问的单元通常称为设备寄存器（注意和CPU寄存器不是一回事），操作设备的过程就是读写这些设备寄存器的过程，比如向串口发送寄存器里写数据，串口设备就会把数据发送出去，读串口接收寄存器的值，就可以读取串口设备接收到的数据

内存映射I/O （Memory-mapped I/O ）：	ARM	像内存1样访问
端口I/O （Port I/O ）：					x86	用专门in/out指令访问

设备总线并不直接和CPU相连，CPU通过内存映射I/O 或端口I/O 访问相应的总线控制器，通过总线控制器再去访问挂在总线上的设备

x86平台上，硬盘是挂在IDE、SATA或SCSI总线上的设备，保存在硬盘上的程序是不能被CPU直接取指令执行的，操作系统在执行程序时会把它从硬盘拷贝到内存，这样CPU才能取指令执行，这个过程称为加（Load）

程序加载到内存之后，成为操作系统调度执行的一个任务，就称为进程（Process）。进程和程序不是一一对应的。一个程序可以多次加载到内存，成为同时运行的多个进程，例如可以同时开多个终端窗口，每个窗口都运行一个Shell进程，而它们对应的程序都是磁盘上的/bin/bash 文件

操作系统（Operating System ）本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的启动代码（称为Bootloader ）首先把操作系统从磁盘加载到内存，然后执行操作系统中的代码把用户需要的其它程序加载到内存

操作系统和其它用户程序的不同之处在于：操作系统是常驻内存的，而其它用户程序则不一定

操作系统最核心的功能是管理进程调度、管理内存的分配使用和管理各种设备，做这些工作的程序称为内核（Kernel ）

内存只是保存数据而不会产生新的数据，如果CPU不去读它，它也不需要主动提供数据给CPU，所以内存总是被动地等待被读或者被写
设备往往会自己产生数据，并且需要主动通知CPU来读这些数据，例如敲键盘产生一个输入字符，用户希望计算机马上响应自己的输入，这就要求键盘设备主动通知CPU来读这个字符并做相应处理，给用户响应

Linux 内核源代码中绝大部分是设备驱动程序
设备驱动程序通常是内核里的一组函数，通过读写设备寄存器实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用

设备 p258

说明虚拟地址空间和物理地址空间独立
内bus（地址、数据线，32 bit，寻址空间4gb）－> MMU（VA，检查页表决定映射，地址转换，内存保护机制）+总线接口 －>  外bus（bit与寻址空间gb不定）－> 芯片引脚（PA，物理页面/页帧，保存页表）	  
MMU 将VA 映射到PA 是以页（Page ）为单位的，32位处理器的页尺寸通常是4KB 

程序中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址，指令中的地址被CPU解释执行，就成了CPU执行单元发出的内存地址

MMU 的情况下，程序中使用的地址都是虚拟地址，都会引发MMU做查表和地址转换操作

All problems in computer science can be solved by another level of indirection. 多了一层间接必然是为了解决什么问题的

异常（Exception）：CPU内部产生，CPU当前执行的指令出了问题；		访问内存的指令被MMU检查出权限错误，除法指令的除数为0等
中断（Interrupt）：外部设备产生，和CPU当前执行的指令无关；		人按键盘操作

内核就是由各种中断和异常处理程序组成

操作系统－>虚拟地址空间＝用户空间（前3GB （0x00000000~0xbfffffff ））＋内核空间（后1GB （0xc0000000~0xffffffff））

正常情况：处理器在用户模式执行用户程序
中断或异常情况：处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序

register flip-flop		程序指令直接控制
cache 	SRAM(static)	硬件自动完成（l1用VA寻址，l2用PA寻址）
memory	DRAM(dynamic)	程序指令间接控制（指令中地址是VA，访问内存时用映射为PA），电路简单，存储量大，访问速度慢
hd								操作系统配合硬件完成，机械式访问，每次缓存几个page到memory

CPU－>发出VA（寻址l1）查找相应数据是否被l1缓存－>发出PA（寻址l2）查找相应数据是否被l1缓存－>到物理内存取数据，cache line(32-256字节，作为下次缓存)

访问Cache 比访问内存、硬盘快几个数量级，由于局部性原理，CPU大部分时间是在和Cache 打交道，有Cache 的计算机明显会快很多。高速存储器的容量只能做得很小，却能显著提升计算机的性能，这就是Memory Hierarchy 的意义所在

大多数程序的行为都具有局部性（Locality ）的特点：它们会花费大量的时间反复执行一小段代码（例如循环），或者反复访问一个很小的地址范围中的数据（例如访问一个数组）。所以预读缓存的办法很有效

在Shell中可以用特殊变量$?得到上一条命令的退出状态

通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的

_start是一个符号（Symbol ），符号在汇编程序中代表一个地址        接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明

访问内存时在指令中可以用多种方式表示内存地址，比如可以用数组基地址、元素长度和下标三个量来表示

说main 函数是程序的入口点其实不准确，_start才是真正的入口点，而main 函数是被_start调用的

操作系统为程序的运行预留了一块栈空间，函数调用时就在这个栈空间里分配栈帧，函数返回时就释放栈帧

多传了参数而不用是没有问题的，少传了参数却用了则会出问题

退出状态为0表示程序执行成功，退出状态非0表示出错。注意，退出状态只有8位，而且被Shell解释成无符号数，如果改为exit(-1); 或return -1，则echo $?显示255

编译之后用readelf命令看它的符号表，了解各变量的地址分布

变量A用const 修饰，表示A是只读的，不可修改。定义时必须初始化。因为只有初始化时才有机会给它一个值，一旦定义之后就不能再改写了，也就是不能再赋值了

字符串字面值是只读的，相当于在全局作用域定义了一个const 数组

全局变量如果不初始化则初值为0，同理可以推断，static变量（不管是函数里的还是函数外的）如果不初始化则初值也是0

 函数的参数和局部变量是分配在栈上的，b是数组也一样，也是分配在栈上的

栈是从高地址向低地址增长的，但数组总是从低地址向高地址排列的，按从低地址到高地址的顺序依次是b[0] 、b[1] 、b[2] ……这样

变量c并没有在栈上分配存储空间，而是直接存在eax 寄存器出c的值当参数压栈，这就是register 关键字的作用，指示编译器尽可能分配一个寄存器来存储这个变量

编译器叫Translator ，变量叫Object ，编译单元（Translation Unit ）

变量名、函数名、宏定义、typedef的类型名、enum 成员等等都属于同一个命名空间。如果有重名的话，宏定义覆盖所有其它标识符，因为它在预处理阶段而不是编译阶段处理，除了宏定义之外其它几类标识符按上面所说的规则处理，内层作用域覆盖外层作用域

标识符的链接属性（Linkage ）有三种：
1。   外部链接（External Linkage ），如果最终的可执行文件由多个程序文件链接而成，一个标识符在任意程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有ExternalLinkage 。具有External Linkage 的标识符编译后在符号表中是GLOBAL的符号。例如上例
   中main 函数外面的a和c，main 和printf也算。
2。   内部链接（Internal Linkage ），如果一个标识符在某个程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有Internal Linkage 。例如上例中main 函数外面的b（属性static）。如果有另一个foo.c 程序和main.c链接在一起，在foo.c 中也声明一个static int b;，则那个b和这个b不代表同一个变量。具有Internal Linkage 的标识符编译后在符号表中是LOCAL 的符号，但main 函数里面那个a不能算Internal Linkage 的，因为即使在同一个程序文件中，在不同的函数中声明多次，也不代表同一个变量。
3。   无链接（No Linkage ）。除以上情况之外的标识符都属于No Linkage 的，例如函数的局部变量，以及不表示变量和函数的其它标识符

const 和以后要介绍的restrict 和volatile 关键字属于同一类语法元素，称为类型限定符（Type Qualifier）

CPU内部产生的数称为立即数（Immediate）,所以有立即数寻址

call指令两个作用：
1. foo函数调用完之后要返回call的下一条指令继续执行，所以把call的下一条指令的地址0x80483e9压栈，同时把esp的值减4，esp的值现在是0xbf822d18。
2. 修改程序计数器eip，跳转到foo函数的开头执行。

首先将ebp寄存器的值压栈，同时把esp的值再减4.换句话说就是把原来ebp的值保存在栈上，然后又给ebp赋了新值

每个函数的栈帧中，ebp指向栈底，而esp指向栈顶，在函数执行过程中esp随着压栈和出栈操作随时变化，而ebp是不动的，函数的参数和局部变量都是通过ebp的值加上一个偏移量来访问

ret指令是call指令的逆操作

1. 参数压栈传递，并且是从右向左依次压栈。
2. ebp总是指向栈帧的栈底。
3. 返回值通过eax寄存器传递。

aaaa
