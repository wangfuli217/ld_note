O_APPEND
      The  file  is  opened in append mode.  Before each write(2), the file offset is positioned at the end of
      the file, as if with lseek(2).  O_APPEND may lead to corrupted files on NFS file systems  if  more  than
      one  process  appends data to a file at once.  This is because NFS does not support appending to a file,
      so the client kernel has to simulate it, which can¡¯t be done without a race condition.

O_ASYNC
      Enable signal-driven I/O: generate a signal (SIGIO by default, but this can  be  changed  via  fcntl(2))
      when  input or output becomes possible on this file descriptor.  This feature is only available for ter-
      minals, pseudo-terminals, sockets, and (since Linux 2.6) pipes and  FIFOs.   See  fcntl(2)  for  further
      details.

O_CLOEXEC (Since Linux 2.6.23)
      Enable  the  close-on-exec  flag for the new file descriptor.  Specifying this flag permits a program to
      avoid additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.  Additionally, use of this flag
      is essential in some multithreaded programs since using a separate fcntl(2) F_SETFD operation to set the
      FD_CLOEXEC flag does not suffice to avoid race conditions where one thread opens a  file  descriptor  at
      the same time as another thread does a fork(2) plus execve(2).

O_CREAT
      If  the file does not exist it will be created.  The owner (user ID) of the file is set to the effective
      user ID of the process.  The group ownership (group ID) is set either to the effective group ID  of  the
      process or to the group ID of the parent directory (depending on file system type and mount options, and
      the mode of the parent directory, see the mount options bsdgroups and sysvgroups described in mount(8)).

      mode  specifies  the  permissions  to use in case a new file is created.  This argument must be supplied
      when O_CREAT is specified in flags; if O_CREAT is not specified, then mode is  ignored.   The  effective
      permissions  are  modified  by the process¡¯s umask in the usual way: The permissions of the created file
      are (mode & ~umask).  Note that this mode only applies to future accesses of the newly created file; the
      open() call that creates a read-only file may well return a read/write file descriptor.

      The following symbolic constants are provided for mode:
S_IRWXU  00700 user (file owner) has read, write and execute permission

      S_IRUSR  00400 user has read permission

      S_IWUSR  00200 user has write permission

      S_IXUSR  00100 user has execute permission

      S_IRWXG  00070 group has read, write and execute permission

      S_IRGRP  00040 group has read permission

      S_IWGRP  00020 group has write permission

      S_IXGRP  00010 group has execute permission

      S_IRWXO  00007 others have read, write and execute permission

      S_IROTH  00004 others have read permission

      S_IWOTH  00002 others have write permission

      S_IXOTH  00001 others have execute permission

O_DIRECT (Since Linux 2.4.10)
      Try  to  minimize  cache effects of the I/O to and from this file.  In general this will degrade perfor-
      mance, but it is useful in special situations, such as when applications do their own caching.  File I/O
      is  done  directly  to/from user space buffers.  The I/O is synchronous, that is, at the completion of a
      read(2) or write(2), data is guaranteed to have been transferred.  See NOTES below for  further  discus-
      sion.

      A semantically similar (but deprecated) interface for block devices is described in raw(8).

O_DIRECTORY
      If  pathname  is not a directory, cause the open to fail.  This flag is Linux-specific, and was added in
      kernel version 2.1.126, to avoid denial-of-service problems if opendir(3) is called on a  FIFO  or  tape
      device, but should not be used outside of the implementation of opendir(3).

O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and path-
      name already exists, then open() will fail.  The behavior of O_EXCL is undefined if O_CREAT is not spec-
      ified.

      When  these  two  flags  are specified, symbolic links are not followed: if pathname is a symbolic link,
      then open() fails regardless of where the symbolic link points to.

      O_EXCL is only supported on NFS when using NFSv3 or later on kernel 2.6 or later.  In environments where
      NFS O_EXCL support is not provided, programs that rely on it for performing locking tasks will contain a
      race condition.  Portable programs that want to perform atomic file locking using a lockfile,  and  need
      to  avoid  reliance  on  NFS support for O_EXCL, can create a unique file on the same file system (e.g.,
      incorporating hostname and PID), and use link(2) to make a link to the lockfile.  If link(2) returns  0,
      the  lock  is  successful.   Otherwise,  use  stat(2)  on the unique file to check if its link count has
      increased to 2, in which case the lock is also successful.

O_LARGEFILE
      (LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in  an  off64_t)
      to  be  opened.  The _LARGEFILE64_SOURCE macro must be defined in order to obtain this definition.  Set-
      ting the _FILE_OFFSET_BITS feature test macro to 64 (rather than using  O_LARGEFILE)  is  the  preferred
      method of obtaining method of accessing large files on 32-bit systems (see feature_test_macros(7)).

O_NOATIME (Since Linux 2.6.8)
      Do  not update the file last access time (st_atime in the inode) when the file is read(2).  This flag is
      intended for use by indexing or backup programs, where its use can significantly reduce  the  amount  of
      disk  activity.   This  flag  may  not  be effective on all file systems.  One example is NFS, where the
      server maintains the access time.

O_NOCTTY
      If pathname refers to a terminal device ¡ª see tty(4) ¡ª it will not become the process¡¯s controlling ter-
      minal even if the process does not have one.

O_NOFOLLOW
      If  pathname  is  a symbolic link, then the open fails.  This is a FreeBSD extension, which was added to
      Linux in version 2.1.126.  Symbolic links in earlier components of the pathname will still be  followed.

O_NONBLOCK or O_NDELAY
      When  possible,  the  file is opened in non-blocking mode.  Neither the open() nor any subsequent opera-
      tions on the file descriptor which is returned will cause the calling process to wait.  For the handling
      of  FIFOs  (named pipes), see also fifo(7).  For a discussion of the effect of O_NONBLOCK in conjunction
      with mandatory file locks and with file leases, see fcntl(2).

O_SYNC The file is opened for synchronous I/O.  Any write(2)s on the resulting file descriptor will  block  the
      calling  process  until  the data has been physically written to the underlying hardware.  But see NOTES
      below.

O_TRUNC
      If the file already exists and is a regular file and the open mode allows writing (i.e.,  is  O_RDWR  or
      O_WRONLY)  it will be truncated to length 0.  If the file is a FIFO or terminal device file, the O_TRUNC
      flag is ignored.  Otherwise the effect of O_TRUNC is unspecified.
