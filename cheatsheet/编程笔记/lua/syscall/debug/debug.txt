    Lua的debug库并不是提供一个调试器，而是提供一些供你写调试器的一些操作。
Lua实现这些功能是以C API来实现的，因此这个库相当于提供使用Lua代码访问C API，这是从性能上考虑的。

1. 调试功能需要使用debug模块.它仅仅提供了一些基本功能,而没有实现常见的完整调试器.另外官方不建议滥用这个库,
2. 调用debug.debug函数可以启动一个交互式的调试环境.这个交互式环境类似于Lua的默认的交互式编程环境,可以查看,
   修改一些变量并且计算一些表达式.但是它主要用于在程序出现异常的时候启动,用于查看变量以分析异常出现的原因.

3. 修改元表
  debug库中也有setmetatable和getmetatable函数.和不加debug前缀的这两个函数并不是同一个函数.但是不知道为什么
要单独设置这一组函数.
4. 栈等级
  debug.getinfo函数调用的时候可以传入一个整数作为参数.这个整数就表示调用等级.然后就会返回一个包含对应栈等级
(对应函数)的信息的表.0表示debug.getinfo这个函数本身,1表示调用debug.getinfo的函数等级.
5. 获取局部变量
  debug.getlocal用于获取局部变量.它接收两个参数,第一个是栈等级,第二个是局部变量的编号(用整数表示,-1表示
最后一个局部变量).
6. 获取函数上值
  所谓的上值就是函数外部的函数可以访问的变量.例如闭包中被外层函数闭包起来的变量.debug.getupvalue可以用于
获取函数上值.与getlocal不同的是,getupvalue的第一个参数是一个函数而不是一个整数.
7. 改变上值
  与debug.getupvalue对应的还有一个debug.setupvalue,用于改变上值.
  也可以用debug.upvaluejoin函数.它可以改变闭包变量之间的关系.把一个闭包函数中的闭包变量给另一个闭包函数.
8. 查看注册表值
  使用这条命令可以查看注册表值:
  debug.getregistry()
  所谓的注册表中包含标准io输入输出流对应的地址等信息.
9. 其他函数简介
  debug.traceback会返回一条栈追踪信息(返回的字符串格式有点像代码异常时候的提示,但是这就是它的正常返回值).例如:
  s=debug.traceback()type(s)print(s)
  debug.getuservalue和debug.setuservalue用于对userdata类型的处理.


stack level。指的是一个代表当前阶段一个特定函数的活跃值：访问debug库的函数其level为1，调用该函数的函数其level为2。

反射是程序用来检查和修改其自身某些部分的能力。像Lua语言这样的动态语言支持击中反射机制：
1. 环境允许运行时观察全局变量
2. 诸如type和pairs这样的函数允许运行时检查和遍历未知数据结构；
3. 诸如load和require这样的函数允许程序在自身中追加代码或更新代码
还有很多方面是缺失的；程序 不能检查局部变量，开发人员不能跟踪代码的执行，函数也不知道是被谁调用了

--> 调试库{自省函数 - introspective function和钩子 - hook}

1. 自省机制 : 允许我们检查一下正在运行的程序的几个方面：例如：活动函数的栈、当前正在执行的代码行
              局部变量的名称和值。
1) 主要的自省函数时debug.getinfo; 第一个参数是一个函数或一个栈层
2) 当为某函数foo调用debug.getinfo(foo), 会得到一个table; table字段如下:
    source ->          函数定义的位置
    short_src ->       source的短版本(最多60个字符), 可用于错误信息中
    linedefined ->     该函数定义在源代码中的第一行的行号
    lastlinedefined -> 该函数定义在源代码中的最后一行的行号
    what ->            函数类型("lua"->Lua函数, "C"->C函数, "main"->lua主程序块)
    name ->            该函数的一个适当名称
    namewhat ->        上一个字段的含义(可能是"global", "local", "method", "field"和""), 空字符串表示Lua没有找到该函数的名称
    nups ->            该函数的upvalue的数量
    activelines ->     一个table, 包含了该函数的所有活动行的集合
    func ->            函数本身
3) 当foo是一个C函数时, 只有字段what, name和namewhat有意义
4) 用一个数字<n>调用debug.getinfo(n), 可以得到相应栈层上函数的数据; 
   <n>是1, 可以得到调用debug.getinfo的那个函数的数据;
   <n>大于栈中函数的总数, debug.getinfo返回nil;
   当用数字来调用debug.getinfo时, table中还会包含currrentline字段, 表示
   此时这个函数正在执行的那行;
5) getinfo的第二个参数(可选), 用于指定希望获取那些信息
    'n'       选择name和namewhat
    'f'       选择func
    'S'       选择source, short_src, what, linedefined, lastlinedefined
    'l'       选择currrentline
    'L'       选择activelines
    'u'       选择nups
    
1.1 访问局部变量
1) 可用debug.getlocal来检查任意活动函数的局部变量
2) 该函数有两个参数: 一个时希望查询的函数栈层, 另一个是变量的索引
3) 该函数返回变量的名字和它当前的值
4) 如果变量索引大雨活动变量的总数, 返回nil
5) 如果栈层无效, 会引发一个错误
6) debug.setlocal改变局部变量的值, 前两个参数与getlocal相同, 第3个参数是
   该变量的新值; 返回变量名, 如果变量索引超出返回, 返回nil
   
1.2 访问非局部的变量
1) getupvalue, 可以访问为一个lua函数所使用的"非局部的变量";
   第一个参数是一个函数(是一个closure);
   第二个参数是变量索引
2) debug.setupvalue, 修改"非局部的变量";
   第一个参数是closure;
   第二个参数是一个变量索引;
   第三个参数是一个新值
   
1.2 访问其他协同程序
1) 调试库所有自省函数都接受一个可选的协同程序参数作为第一个参数, 这样就
   可以从外部来检查这个协同程序
   
2. 钩子 : 允许我们回溯程序的运行过程。
1) 允许用户注册一个钩子函数, 这个函数会在程序运行中的某个特定时间发生时
   被调用
2) 触发钩子的事件:
    每当lua调用一个函数时产生的call事件;
    每当函数返回时产生的return事件;
    每当lua开始执行一行新代码时产生的line事件;
    当执行完指定数量的指令后产生的count事件;
3) 用一个字符串参数来调用钩子函数, 该字符串描述了导致调用钩子的事件
    "call", "return", "line"或"count"
4) 对line事件, 还可以传入第二个参数, 表示代码的行号
5) debug.sethook
    第一个参数是钩子函数;
    第二个参数是一个字符串, 描述了需要监控的事件;
    第三个参数是个可选数字, 说明多久获得一次count事件