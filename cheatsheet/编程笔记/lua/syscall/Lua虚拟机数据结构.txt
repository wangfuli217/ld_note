在开始下面的分析之前,首先来介绍一下两个重要的数据结构:lua_State以及global_State.
lua_State可以认为是每一个Lua"线程"所独有的一份数据,后面介绍到Lua协程时会明白这里所谓的"线程"是什么意思.

将其中各个成员变量分类介绍以含义如下:
Lua栈相关
    StkId top:当前Lua栈顶,见Lua栈部分讲解
    StkId base:当前Lua栈底,见Lua栈部分讲解
    StkId stack_last:指向Lua栈最后位置
    StkId stack:指向Lua栈起始位置
    int stacksize:Lua栈大小

Lua CallInfo数组相关
前面提过,每次函数调用都对应一个CallInfo结构体,
    CallInfo *ci:指向当前函数的CallInfo数据指针
    CallInfo *end_ci:指向CallInfo数组的结束位置
    CallInfo *base_ci:指向CallInfo数组的起始位置
    int size_ci:CallInfo数组的大小

hook相关
    lu_byte hookmask:hook mask位,分别有以下几种值:LUA_MASKCALL
    lu_byte allowhook;
    int basehookcount;
    int hookcount;
    lua_Hook hook;

GC相关
    TValue l_gt
    GCObject openupval; / list of open upvalues in this stack */
    GCObject *gclist;

其他
    CommonHeader:Lua通用数据相关,见第二章
    lu_byte status:当前状态
    global_State l_G:指向全局状态指针,见下面关于global_State的讲解
    const Instruction *savedpc:当前函数的pc指针
    unsigned short nCcalls:记录C调用层数
    unsigned short baseCcalls:恢复一个协程时的C调用层数
    struct lua_longjmp errorJmp; / current error recover point */
    ptrdiff_t errfunc; /* current error handling function (stack index) */

global_State是一个进程独有的数据结构,它其中的很多数据会被该进程中所有的lua_State
所共享.换言之,一个进程只会有一个global_State,但是却可能有多份lua_State,它们之间是一对多的关系.