CommonHeader:Lua通用数据相关的成员,前面已经做过讲解.
TValue *k: 存放常量的数组.
Instruction *code:存放指令的数组.
struct Proto **p:如果本函数中还有内部定义的函数,那么这些内部函数相关的Proto指针就放在这个数组里.
int *lineinfo:存放对应指令的行号信息,与前面的code数组内的元素一一对应.
struct LocVar *locvars:存放函数内局部变量的数组.
TString **upvalues:存放UpValue的数组,至于UpValue的含义,后面会做分析.
TString *source:Lua脚本文件名.
int sizeupvalues:前面upvalues数组的大小.
int sizek:k数组的大小.
int sizecode:code数组的大小.
int sizelineinfo:lineinfo数组的大小.
int sizep:p数组的大小.
int sizelocvars:localvars数组的大小.
int linedefined:函数body的第一行行号.
int lastlinedefined:函数body的最后一行.
GCObject *gclist:gc链表.
lu_byte nups:upvalue的数量.
lu_byte numparams:函数参数数量.
lu_byte is_vararg:有以下几种取值
    #define VARARG_HASARG 1
    #define VARARG_ISVARARG 2
    #define VARARG_NEEDSAR 4
lu_byte maxstacksize:函数最大stack大小,由类型是lu_byte可知,最大是255.

/*       T  A    B       C     mode		   opcode	*/
  opmode(0, 1, OpArgR, OpArgN, iABC) 		/* OP_MOVE */
T:表示这是不是一条逻辑测试相关的指令，这种指令可能会将PC指针自增1。
A:表示这个指令会不会赋值给R(A)。
B/C:B/C参数的格式。
mode:这个OpCode的格式。

B/C参数的格式如下：
	(lopcodes.h)
	245 enum OpArgMask {
	246   OpArgN,  /* argument is not used */
	247   OpArgU,  /* argument is used */
	248   OpArgR,  /* argument is a register or a jump offset */
	249   OpArgK   /* argument is a constant or register/constant */
	250 };

OpArgN表示这个参数没有被使用，但是这里的意思并不是真的没有被使用，只是没有作为R()或者RK()宏的参数使用。
从图中可以看出,Lua共有三种指令格式:iABC,iABx,iAsBx。

Lua代码中提供了根据指令中的值得到相应数据的几个宏,
	(lvm.c)
	343 #define RA(i)   (base+GETARG_A(i))
	344 /* to be used after possible stack reallocation */
	345 #define RB(i)   check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
	346 #define RC(i)   check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
	347 #define RKB(i)  check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
	348     ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
	349 #define RKC(i)  check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
	350     ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
	351 #define KBx(i)  check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))

RA/RB/RC自不必多做解释，前面讲解Lua指令执行的时候已经说过，其含义就是以参数为偏移量在函数栈中取数据。
RKB/RKC的意思有两层，第一是这个指令格式只可能作用在opcode的B/C参数上，不会作用在参数A上；
第二层意思是这个数据除了从函数栈中获取之外，还有可能从常量数组(也就是K数组)中获取,关键在于宏ISK的判断：
	(lopcodes.h)
 	38  #define SIZE_B      9
	118 /* this bit 1 means constant (0 means register) */
	119 #define BITRK       (1 << (SIZE_B - 1))
	120
	121 /* test whether value is a constant */
	122 #define ISK(x)      ((x) & BITRK)

结合起来看，这个宏的含义就很简单了：判断这个数据的第八位是不是1，如果是则认为应该从K数组中获取数据，
否则就是从函数栈寄存器中获取数据。后面会结合具体的指令来解释这个格式。

宏KBx也是自解释的，它不会从函数栈中取数据了，直接从K数组中获取数据。