--[[
  io.open()##
  原型：io.open (filename [, mode])
  解释：这个函数会以参数mode所描述的方式代开文件filename并返回一个文件描述符，
        如果出错将会返回nil并且附带一个错误信息。
        错误代码表示的意思依系统而定。
  不同的mode含义解释如下：
  "r": 只读模式(默认)；所有之前的数据都保留；
  "w": 只写模式；所有之前的数据都删除；
  "a": 只追加模式；所有之前的数据都保留；
  "r+": 读写更新模式，所有之前的数据都保留；
  "w+": 读写更新模式，所有之前的数据都删除；
  "a+": 读写追加更新模式，所有之前的数据都保留，只允许在文件尾部做写入。

  "r":以只读方式打开文件，该文件必须存在，否则返回nil。(默认的打开方式)
  "w":以只写方式打开文件，若文件存在则清空文件内容，若文件不存在则建立该文件，从头开始写入。
  "a":以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。
  "r+":以读写方式打开文件，该文件必须存在，读取时从文件头开始读，写入时从文件头开始写，保留原文件中没有被覆盖的内容；
  "w+":以读写方式打开文件，若文件存在则清空文件内容。若文件不存在则建立该文件，从头开始写入，读取文件时从头读取。
  "a+":以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。

  注意：mode 字符串可以在最后加一个 'b' ， 这会在某些系统上以二进制方式打开文件。
        默认模式是只读模式.写入和追加的区别在于写入会覆盖原有内容,追加不会.
        如果要写入的文件不存在,一般会自动创建.

--]]

-- 打开存在的文件
local file, msg = io.open("iotest.txt",'r')
if file == nil then
    print(msg)
else
    print("open exist file success :")
    print(file)
end

-- 打开不存在的文件
local ret, errormsg = io.open("iotest2.txt", "r")
print("\nopen don't exist file ret :")
print(ret)
if ret == nil then
    print(errormsg)
end

--[[
print(io.open("non-existent-file","r")) -- nil no-existent-file:No such file or directory 2
print(io.open("/etc/passwd","w"))       -- nil  /etc/passwd:Permission denied 13
local f = assert(io.open(filename, mode)) 
--]]


--[[
1. 代码中我们使用了mode="r"的方式打开文件是由于这种模式要求文件必须存在，如果使用其他模式可能会创建新的文件，而不会返回失败。
2. 我们可以使用mode="r"的特性来自己实现一个检测文件是否存在的函数。
3. 注意取得函数错误信息的方法，便于查找错误原因。
--]]
