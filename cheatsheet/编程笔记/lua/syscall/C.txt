https://github.com/yszheda/wiki/wiki/Lua

http://www.lua.org/manual/5.1/manual.html
http://cloudwu.github.io/lua53doc/manual.html#lua_call

http://luaforge.net/projects/

http://lua-users.org/wiki/CommonFunctions # 常用函数

http://lua-users.org/wiki/SampleCode 

http://www.shouce.ren/api/lua/5/_3.htm  # 教程
http://www.shouce.ren/api/view/a/5552   # 
https://github.com/mpeterv/luacheck

https://luarocks.org/
https://wiki.openwrt.org/doc/techref/uci

https://github.com/tylerneylon

---- lua 官网推荐 ----
http://www.lua.org/download.html
http://lua-users.org/wiki/
http://lua-users.org/wiki/LuaAddons
http://luaforge.net/projects/
https://luarocks.org/
http://www.lua.org/faq.html#1.1
http://www.lua.org/demo.html

lua 论坛(lua 中国开发者 luaer中国官司方网站)        http://www.luaer.cn
Lua参考手册(最正式、权威的Lua文档)                  http://www.lua.org/manual/5.1/
Lua编程(在线版,同样具权威性的Lua教科书)             http://www.lua.org/pil/
Lua正式网站的文档页面(包含很多有价值的文档资料链接) http://www.lua.org/docs.html
Lua维基(最全面的Lua维基百科)                        http://lua-users.org/wiki/
LuaForge(最丰富的Lua开源代码基地)                   http://luaforge.net/projects/
官网:         http://www.lua.org/
API文档:      http://www.lua.org/docs.html
教程:         http://www.w3cschool.cn/lua/lua-tutorial.html
下载:         http://www.lua.org/download.html
Web开发框架   http://www.keplerproject.org/

http://lua-users.org/wiki/LearningLua        很好的开始学习Lua的开始点。
http://www.lua.org/pil                       绝佳参考书
http://luafaq.org/gotchas.html               FAQ
http://www.lua.org/manual/5.1                阅读手册
http://lua-users.org/wiki/LuaComparison      语言比较
http://lua-users.org/wiki/TutorialDirectory  语言深入学习
http://lua-users.org/wiki/LuaEditorSupport   编辑调试器
http://luaforge.net/frs/?group_id=377        scite编辑器调试器
http://code.google.com/p/lua-checker/        lua lint
http://lua-users.org/wiki/StoringNilsInTables 
dump
http://www.lua.org/pil/12.1.1.html 
http://lua-users.org/wiki/TableSerialization
http://lua-users.org/lists/lua-l/2009-11/msg00491.html
http://mysite.mweb.co.za/residents/sdonovan/lua/lua.png

http://lua-users.org/wiki/StringInterpolation 字符串处理
http://ztact.com/software/Luashell            luashell
http://lua-users.org/wiki/SandBoxes           sandboxes
http://lua-users.org/wiki/LuaUses             builtin lua
http://lua-users.org/wiki/SimpleLuaApiExample C API
http://lua-users.org/wiki/BindingCodeToLua    C API
http://lua-users.org/wiki/LuaTypeChecking     类型检查

gcc test.c -llua -lm

http://lua-users.org/wiki/DetectingUndefinedVariables Lua中访问未定义变量能被捕捉到么？

https://github.com/LuaDist/Repository


http://lua-users.org/wiki/LuaDevelopmentModel

http://lua-users.org/wiki/UnitTesting # test

太玄的Lua编程语言课: 虫部落-> 搜狗微信


Lua 提供了高级抽象，却又没失去与硬件的关联 https://wuzhiwei.net/lua_make_class/

        栈顶
      5  |  -1
      4  |  -2
      3  |  -3
      2  |  -4
      1  |  -5
        栈底
1. 正数索引, 不需要知道栈的大小, 就知道栈底在哪, 永远为1
2. 负数索引, 不需要知道栈的大小, 就知道栈顶在哪, 永远为-1


调试类型
    命令行调试
    图形界面调试
命令行调试器有：RemDebug、clidebugger、ctrace、xdbLua、LuaInterface - Debugger、Rldb、ModDebug。
图形界调试器有：SciTE、Decoda、ZeroBrane Studio、akdebugger、luaedit。

lua 编程难理解难点
1. 函数的默认(缺省)输入参数 和 函数参数多类型输入
2. 函数的抛异常退出方式 和 函数的失败退出方式
3. 函数的迭代器方式 和 递归调用


C API的基本概念
  栈管理 ; 
  lua调用C函数时，C函数需要遵循的协议 ; 
  C调用lua函数时，C函数需要遵循的协议 ; 
  lua调用C函数时，C函数异常处理流程  
  C调用lua函数时，C函数异常处理流程
  
  字符串和数值之间相互转换
  函数入参值多类型
  函数多值返回值
  错误提示

1. lua_CFunction 理解lua调用C函数时，C函数需要遵循的协议
typedef int (*lua_CFunction) (lua_State *L);
为了正确的和 Lua 通讯， C 函数必须使用下列协议。 这个协议定义了参数以及返回值传递方法： 
1.1  C 函数通过 Lua 中的栈来接受参数， 参数以正序入栈（第一个参数首先入栈）。 因此，当函数开
     始的时候， lua_gettop(L) 可以返回函数收到的参数个数。第一个参数（如果有的话）在索引 1
     的地方， 而最后一个参数在索引 lua_gettop(L) 处。
1.2  当需要向 Lua 返回值的时候， C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入）， 
     然后返回这些返回值的个数。在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。 
     和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。
     
下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和：
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 参数的个数 */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i <= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 第一个返回值 */
       lua_pushnumber(L, sum);         /* 第二个返回值 */
       return 2;                   /* 返回值的个数 */
     }
     
2. lua_call 理解C调用lua函数时，C函数需要遵循的协议
void lua_call (lua_State *L, int nargs, int nresults);
要调用一个函数请遵循以下协议：
  2.1 首先，要调用的函数应该被压入栈；
  2.2 接着，把需要传递给这个函数的参数按正序压栈； 这是指第一个参数首先压栈。
  2.3 最后调用一下 lua_call；
nargs 是你压入栈的参数个数。 当函数调用完毕后，所有的参数以及函数本身都会出栈。 
而函数的返回值这时则被压栈。 返回值的个数将被调整为 nresults 个，
除非 nresults 被设置成 LUA_MULTRET。在这种情况下，所有的返回值都被压入堆栈中。
Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈），
因此在调用结束后，最后一个返回值将被放在栈顶。
被调用函数内发生的错误将（通过 longjmp ）一直上抛。

下面的例子中，这行 Lua 代码等价于在宿主程序中用 C 代码做一些工作：
     a = f("how", t.x, 14)
这里是 C 里的代码：
     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
     
3. 字符串和数值之间相互转换
  3.1 必须是数值或者字符串判断
  lua_type(L, i) == LUA_TSTRING      i必须为字符串 不抛出异常
  lua_type(L, i) == LUA_TNUMBER      i必须为数值   不抛出异常
  
  luaL_checktype(L, i, LUA_TSTRING); i必须为字符串 抛出异常
  luaL_checktype(L, i, LUA_TNUMBER); i必须为数值   抛出异常
  
  3.2 不区分字符串或数值判断
  lua_isstring(L, i)            是LUA_TSTRING或者LUA_TNUMBER类型都可以
  lua_isnumber(L, i)            是LUA_TNUMBER类型或者是LUA_TSTRING类型且该字符串可以转换为数字

  3.3 数值和字符串的优先级
  先判断lua_isnumber在判断lua_isstring，最后判断是否其他类型。
  这是由于数值可以无条件转换为字符串，而字符串合法情况下才可以转换为数值。
  
  例如：
  对于函数nixio_getpw()即函数nixio.getpw()而言；
  struct passwd *getpwuid(uid_t uid); 要求输入数值参数
  相对struct passwd *getpwnam(const char *name); 要求输入字符串参数
     
4. 函数入参值多类型
  nixio_getpw (入参多类型 和 入参存在默认值)
    lua_isnumber     数值参数
    lua_isstring     字符串参数
    lua_isnoneornil  默认参数
    other            错误参数   luaL_argerror(L, 1, "supported values: <groupname>, <gid>");
                                luaL_argerror(L, 1, "supported values: <username>");
  nixio_getpw (入参多类型 和 入参存在默认值)
  nixio_open
    lua_isnoneornil(L, 2)  默认参数
    lua_isnumber(L, 2)     数值参数
    lua_isstring(L, 2)     字符串参数
      other  luaL_argerror(L, 2, "supported values: r, r+, w, w+, a, a+");  字符串枚举类型出错
    other    luaL_argerror(L, 2, "open flags or string expected");          入参类型出错
    
  nixio__check_mode
    lua_isnoneornil(L, idx)                          默认参数
    lua_isstring(L, idx) && lua_objlen(L, idx) == 9  字符串参数
    lua_isnumber(L, idx)                             数值参数
    luaL_argerror(L, idx, "supported values: [0-7]?[0-7][0-7][0-7], " 入参类型出错
                           "[-r][-w][-xsS][-r][-w][-xsS][-r][-w][-xtT]");
                           
5. 函数多值返回值
  5.1 状态返回
  信号中断或者请求资源不足              系统调用失败                        系统调用成功
  lua_pushboolean(L, 0);                lua_pushnil(L);                     lua_pushboolean(L, 1);
  lua_pushinteger(L, errno);            lua_pushinteger(L, errno);
  lua_pushstring(L, strerror(errno));   lua_pushstring(L, strerror(errno));
  
  5.2 字符串返回
    nixio只有以下函数仅仅返回一个字符串。其他很多函数都返回多值(包含字符串)，或者一个表
  nixio_getcwd
  nixio_basename
  nixio_dirname
  nixio_realpath
  nixio_strerror
  
  5.3 表返回
    POSIX系统调用接口返回数据结构。Lua通过表对应的内容
  nixio_getpw
  nixio_getgr
  nixio_getsp
  
  nixio_times
  nixio_uname
  nixio_sysinfo
  
  nixio_statvfs
  nixio_stat
  nixio_lstat
  
  5.4 数值返回
    POSIX系统调用接口返回数值，数值有位置、长度或者状态意义的
  nixio_file_seek
  nixio_file_tell

  nixio_fork
  nixio_getppid
  nixio_getuid
  nixio_getgid
  nixio_nice
  nixio_setsid
  nixio_getpid
  nixio_umask
  
  nixio_sock__sendto
  nixio_sock__recvfrom
  
  5.5 boolean 返回
  nixio_nanosleep 表示执行成功
  
  5.6 userdata 返回
  像类一样，存在成员函数
  nixio_open，nixio_dup，nixio_pipe，stdin，stdout，stderr
  nixio_dir，nixio_glob
  nixio_socket
  nixio__bind_connect，nixio_sock_accept
  
6. 错误提示
  luaL_argerror(L, 3, "supported values: any, inet, inet6"); # 位置错误
  luaL_error(L, "out of memory");                            # 系统错误
  
  luaL_argcheck(L, *fdp != -1, 1, "invalid file object");    # 位置类型错误
  luaL_checkany(L, 2)                                        # none错误
  luaL_checktype(L, 2, LUA_TTABLE);                          # 位置类型错误
  
  
7. lua和luaX 呵呵
我们会发现每个C文件的导出函数都会使用lua开头，如果没有lua开头的函数都是static函数。并且我们会发现lua后的大写前缀可以标识这个函数所属的文件：
luaL_loadfile luaL_loadfilex L应该是library的意思，属于lauxlib
luaD_protectedparser luaD_pcall D是do的意思，属于ldo
luaU_undump U 是undump的意思，属于lundump
luaY_parser Y 是代表yacc的意思，lua的parser最早是用过yacc生成的，后来改成手写，名字也保留下来，属于lparser
其它的lua函数也都有这个规律。

lua对与每一个文件(chunk)建立一个LexState来做词法分析的context数据，此结构定义在llex.h中。

8. lua标准库的返回值
   8.1: nil, message
   
   
   8.2: exception
   
   

版权归作者所有，任何形式转载请联系作者。
作者：阿毛（来自豆瓣）
来源：https://book.douban.com/review/9347578/

中文：https://wenku.baidu.com/view/8412a17c5a8102d276a22fc6.html
英文：http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf

云风，Lua GC的源码剖析系列文章
https://blog.codingnow.com/2011/03/lua_gc_1.html

Coroutines Tutorial
http://lua-users.org/wiki/CoroutinesTutorial

Lua的function、closure和upvalue
https://blog.csdn.net/soloist/article/details/319214

Lua的多任务机制
https://blog.csdn.net/soloist/article/details/329381

New Garbage Collector
http://wiki.luajit.org/create/New-Garage-Collector
