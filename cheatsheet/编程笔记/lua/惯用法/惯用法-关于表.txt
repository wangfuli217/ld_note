    Lua的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从1到n
的整数键，其他的所有键都储存在哈希部分中。

    哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组
下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，
将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。

    当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。
再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部
哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的2的乘方。

当创建一个空表时，数组和哈希部分的长度都将初始化为0，即不会为它们初始化任何数组。
让我们来看下执行下面这段代码时在Lua中发生了什么：
  local a = {}
  for i=1,3 do
      a[i] = true
  end
最开始，Lua创建了一个空表a，在第一次迭代中，a[1] = true触发了一次rehash，Lua将数组
部分的长度设置为2^0，即1，哈希部分仍为空。在第二次迭代中，a[2] = true再次触发了rehash，
将数组部分长度设为2^1，即2。最后一次迭代，又触发了一次rehash，将数组部分长度设为2^2，即4。

下面这段代码：
  a = {}
  a.x = 1; a.y = 2; a.z = 3
与上一段代码类似，只是其触发了三次表中哈希部分的rehash而已。
只有三个元素的表，会执行三次rehash；然而有一百万个元素的表仅仅只会执行20次rehash而已，
因为2^20 = 1048576 > 1000000。但是，如果你创建了非常多的长度很小的表（比如坐标点：
point = {x=0,y=0}），这可能会造成巨大的影响。

如果你有很多非常多的很小的表需要创建时，你可以将其预先填充以避免rehash。比如：{true,true,true}，
Lua知道这个表有三个元素，所以Lua直接创建了三个元素长度的数组。类似的，{x=1, y=2, z=3}，
Lua会在其哈希部分中创建长度为4的数组。

以下代码执行时间为1.53秒：
a = os.clock()
for i = 1,2000000 do
    local a = {}
    a[1] = 1; a[2] = 2; a[3] = 3
end
b = os.clock()
print(b-a)  --1.528293
如果我们在创建表的时候就填充好它的大小，则只需要0.75秒，一倍的效率提升！
a = os.clock()
for i = 1,2000000 do
    local a = {1,1,1}
    a[1] = 1; a[2] = 2; a[3] = 3
end
b = os.clock()
print(b-a)  --0.746453
所以，当需要创建非常多的小size的表时，应预先填充好表的大小。




