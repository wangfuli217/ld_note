3R原则（the rules of 3R）是：减量化（reducing），再利用（reusing）和再循环（recycling）三种原则的简称。

3R原则本是循环经济和环保的原则，但是其同样适用于Lua。

1. Reducing
有许多办法能够避免创建新对象和节约内存。例如：如果你的程序中使用了太多的表，你可以
考虑换一种数据结构来表示。

举个栗子。 假设你的程序中有多边形这个类型，你用一个表来储存多边形的顶点：
polyline = {
    { x = 1.1, y = 2.9 },
    { x = 1.1, y = 3.7 },
    { x = 4.6, y = 5.2 },
    ...
}

以上的数据结构十分自然，便于理解。但是每一个顶点都需要一个哈希部分来储存。如果放置
在数组部分中，则会减少内存的占用:
polyline = {
    { 1.1, 2.9 },
    { 1.1, 3.7 },
    { 4.6, 5.2 },
    ...
}
一百万个顶点时，内存将会由153.3MB减少到107.6MB，但是代价是代码的可读性降低了。

最变态的方法是：
polyline = {
    x = {1.1, 1.1, 4.6, ...},
    y = {2.9, 3.7, 5.2, ...}
}
一百万个顶点，内存将只占用32MB，相当于原来的1/5。你需要在性能和代码可读性之间做出取舍。

在循环中，我们更需要注意实例的创建。
for i=1,n do
    local t = {1,2,3,'hi'}
    --执行逻辑，但t不更改
    ...
end
我们应该把在循环中不变的东西放到循环外来创建：
local t = {1,2,3,'hi'}
for i=1,n do
    --执行逻辑，但t不更改
    ...
end

2. Reusing
如果无法避免创建新对象，我们需要考虑重用旧对象。
考虑下面这段代码：
local t = {}
for i = 1970, 2000 do
    t[i] = os.time({year = i, month = 6, day = 14})
end
在每次循环迭代中，都会创建一个新表{year = i, month = 6, day = 14}，但是只有year是变量。

下面这段代码重用了表：
local t = {}
local aux = {year = nil, month = 6, day = 14}
for i = 1970, 2000 do
    aux.year = i;
    t[i] = os.time(aux)
end
另一种方式的重用，则是在于缓存之前计算的内容，以避免后续的重复计算。后续遇到相同的
情况时，则可以直接查表取出。这种方式实际就是动态规划效率高的原因所在，其本质是用空
间换时间。


3. Recycling
Lua自带垃圾回收器，所以我们一般不需要考虑垃圾回收的问题。
了解Lua的垃圾回收能使得我们编程的自由度更大。
Lua的垃圾回收器是一个增量运行的机制。即回收分成许多小步骤（增量的）来进行。
频繁的垃圾回收可能会降低程序的运行效率。
我们可以通过Lua的collectgarbage函数来控制垃圾回收器。

collectgarbage函数提供了多项功能：停止垃圾回收，重启垃圾回收，强制执行一次回收循环，
强制执行一步垃圾回收，获取Lua占用的内存，以及两个影响垃圾回收频率和步幅的参数。

对于批处理的Lua程序来说，停止垃圾回收collectgarbage("stop")会提高效率，因为批处理
程序在结束时，内存将全部被释放。

对于垃圾回收器的步幅来说，实际上很难一概而论。更快幅度的垃圾回收会消耗更多CPU，
但会释放更多内存，从而也降低了CPU的分页时间。只有小心的试验，我们才知道哪种方式更适合。




