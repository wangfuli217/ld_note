与其他主流脚本语言不同的是，Lua在实现字符串类型有两方面不同。

第一，所有的字符串在Lua中都只储存一份拷贝。当新字符串出现时，Lua检查是否有其相同的
拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的
快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因
为Lua需要去查找比较一遍。

第二，所有的字符串变量，只保存字符串引用，而不保存它的buffer。这使得字符串的赋值变
得十分高效。例如在Perl中，$x = $y，会将$y的buffer整个的复制到$x的buffer中，当字符串
很长时，这个操作的代价将十分昂贵。而在Lua，同样的赋值，只复制引用，十分的高效。

但是只保存引用会降低在字符串连接时的速度。在Perl中，$s = $s . 'x'和$s .= 'x'的效
率差距惊人。前者，将会获取整个$s的拷贝，并将’x’添加到它的末尾；而后者，将直接将’x’插
入到$x的buffer末尾。

由于后者不需要进行拷贝，所以其效率和$s的长度无关，因为十分高效。


在Lua中，并不支持第二种更快的操作。以下代码将花费6.65秒：

a = os.clock()
local s = ''
for i = 1,300000 do
    s = s .. 'a'
end
b = os.clock()
print(b-a)  --6.649481

我们可以用table来模拟buffer，下面的代码只需花费0.72秒，9倍多的效率提升：

a = os.clock()
local s = ''
local t = {}
for i = 1,300000 do
    t[#t + 1] = 'a'
end
s = table.concat( t, '')
b = os.clock()
print(b-a)  --0.07178

所以：在大字符串连接中，我们应避免..。应用table来模拟buffer，然后concat得到最终字符串。