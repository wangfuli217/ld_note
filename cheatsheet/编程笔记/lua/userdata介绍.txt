1. 如何使用C中新创建的类型来扩展Lua
  typedef struct NumArray {
    int size;
    double values[1];  /* variable part */
  } NumArray;
  我们使用大小1声明数组的values，由于C语言不允许大小为0的数组，
  这个1只是一个占位符；我们在后面定义数组分配空间的实际大小。对于一个有n个元素的数组来说，我们需要
  sizeof(NumArray) + (n-1)*sizeof(double) bytes

2. Lua API提供了下面的函数用来创建一个userdatum：
  void *lua_newuserdata (lua_State *L, size_t size);
  lua_newuserdata函数按照指定的大小分配一块内存，将对应的userdatum放到栈内，并返回内存块的地址。
  如果出于某些原因你需要通过其他的方法分配内存的话，很容易创建一个指针大小的userdatum，然后将指向实际内存块的指针保存到userdatum里。
  
  使用lua_newuserdata函数，创建新数组的函数实现如下：
  static int newarray (lua_State *L) {
      int n = luaL_checkint(L, 1);
      size_t nbytes = sizeof(NumArray) + (n - 1)*sizeof(double);
      NumArray *a = (NumArray *)lua_newuserdata(L, nbytes);
      a->size = n;
      return 1;  /* new userdatum is already on the stack */
  }
  函数luaL_checkint是用来检查整数的luaL_checknumber的变体.
  一旦newarray在Lua中被注册之后，你就可以使用类似a = array.new(1000)的语句创建一个新的数组了。
  
  array.set(array, index, value)
  static int setarray (lua_State *L) {
    NumArray *a = (NumArray *)lua_touserdata(L, 1);
    int index = luaL_checkint(L, 2);
    double value = luaL_checknumber(L, 3);

    luaL_argcheck(L, a != NULL, 1, "'array' expected");
    luaL_argcheck(L, 1 <= index && index <= a->size, 2,
              "index out of range");
    a->values[index-1] = value;
    return 0;
  }
  luaL_argcheck函数检查给定的条件，如果有必要的话抛出错误。因此，如果我们使用错误的参数调用setarray，我们将得到一个错误信息：
  array.set(a, 11, 0)
  --> stdin:1: bad argument #1 to 'set' ('array' expected)

  下面的函数获取一个数组元素：
  static int getarray (lua_State *L) {
      NumArray *a = (NumArray *)lua_touserdata(L, 1);
      int index = luaL_checkint(L, 2);
  
      luaL_argcheck(L, a != NULL, 1, "'array' expected");
      luaL_argcheck(L, 1 <= index && index <= a->size, 2, "index out of range");
      lua_pushnumber(L, a->values[index-1]);
      return 1;
  }

  我们定义另一个函数来获取数组的大小：
  static int getsize (lua_State *L) {
      NumArray *a = (NumArray *)lua_touserdata(L, 1);
      luaL_argcheck(L, a != NULL, 1, "`array' expected");
      lua_pushnumber(L, a->size);
      return 1;
  }

  最后，我们需要一些额外的代码来初始化我们的库：
  static const struct luaL_reg arraylib [] = {
      {"new", newarray},
      {"set", setarray},
      {"get", getarray},
      {"size", getsize},
      {NULL, NULL}
  };
  

  int luaopen_array (lua_State *L) {
      luaL_openlib(L, "array", arraylib, 0);
      return 1;
  }


  打开上面定义的库之后，我们就可以在Lua中使用我们新定义的类型了：
  a = array.new(1000)
  print(a)                 --> userdata: 0x8064d48
  print(array.size(a))     --> 1000
  for i=1,1000 do
      array.set(a, i, 1/i)
  end
  print(array.get(a, 10))  --> 0.1




