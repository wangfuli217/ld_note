1. 编译
    Lua中提供了dofile函数，它是一种内置的操作，用于运行Lua代码块。
    但实际上dofile只是一个辅助函数，loadfile才是真正的核心函数。
    相比于dofile，loadfile只是从指定的文件中加载Lua代码块，然后编译这段代码块，如果有编译错误，就返回nil，同时给出错误信息，但是在编译成功后并不真正的执行这段代码块。
    因此，我们可以将dofile实现为：
        function dofile(filename)
            local f = assert(loadfile(filename)) -- 如果loadfile执行失败，assert函数将直接引发一个错误。
            return f()
        end
    1. dofile VS loadfile
            通过dofile的代码，我们还可以看出，如果打算多次运行一个文件中的Lua代码块，我们可以只执行loadfile一次，
        之后多次运行它返回的结果即可，这样就可以节省多次编译所带来的开销。这一点也是loadfile和dofile在性能上的区别。
        Lua中还提供了另外一种动态执行Lua代码的方式，即loadstring函数。顾名思义，相比于loadfile，loadstring的代码源
    来自于其参数中的字符串，如：
        f = loadstring("i = i + 1")
    此时f就变成了一个函数，每次调用时就执行"i = i + 1"，如：
    2. dofile VS loadstring
        loadstring 从字符串读取代码。（在全局环境编译）
        loadfile  从文件读取代码。
    3. load VS loadstring VS function
        f = load("i = i + 1")
        i=0
        f(); print(i) --> 1 
        f(); print(i) --> 2
        do
            i = 32
            local i = 0
            f = loadstring("i = i + 1; print(i)")                -- 不涉及词法域
            g = function () i = i + 1; print(i) end              -- 涉及词法域
            f() --> 33
            g() --> 1
         end
    Lua 将所有独立的程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变常实参。
    
    4. loadstring
    对于loadstring返回的函数，如果需要对一个表达式求值，则必须在其之前添加return，这样才能构成一条语句，返回表达式的值，如：
        i = 32
        f = loadstring("i = i + 1; return i * 2")
        print(f()) --输出66
        print(f()) --输出68。由于loadstring返回的就是正规的函数，因此可以被反复调用。

    5. Lua将所有独立的程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变长实参，
       因此在调用loadstring时，可以为其传递参数，如：
    local i = 30
    --下面的...表示变长实参，将值赋给局部变量x。
    local f = assert(loadstring("local x = ...; return (x + 10)    * 2")) 
    for i = 1, 20 do
        print(string.rep("*",f(i)))
    end

2. C 代码
    动态加载Lua代码，而事实上，Lua本身也支持动态加载C动态库中的代码，要完成该操作，我们需要借助于Lua内置的系统函数package.loadlib。
        package.loadlib("库的完整路径","函数名称")
    该函数有两个字符串参数，分别是动态库的全文件名和该库包含的函数名称，典型的调用代码如下：
        local path = "/usr/local/lib/lua/5.1/socket.so"
        local f = package.loadlib(path, "luaopen_socket")
    由于loadlib是非常底层的函数，因为在调用时必须提供完整的路径名和函数名称。

3.  错误 -- error 和 assert
    assert (v [, message])    -- 根据判断，输出错误信息
        功能：相当于C的断言，
        参数：
        v：如果其参数 v 的值为假(nil 或 false)，它就调用 error；否则，返回所有的参数。
        message：错误对象；如果不提供这个参数，参数默认为 "assertion failed!" 。
    error(message [, level]) -- 中止上一次保护函数调用， 将错误对象 message 返回。
        功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)
        通常情况下，error会附加一些错误位置的信息到message头部.
        level 参数指明了怎样获得出错位置。
        level参数指示获得错误的位置,
        level=1[默认]：为调用error位置(文件+行号)
        level=2：指出哪个调用error的函数的函数
        level=0: 不添加错误位置信息

        Lua作为一种嵌入式脚本语言，在发生错误时，不应该只是简单的退出或崩溃。
    相反，一旦有错误发生，Lua就应该结束当前程序块并返回到应用程序。
    在Lua中我们可以通过error()函数获取错误消息，如：
        print "enter a number:"
        n = io.read("*number")
        if not n then error("invalid input") end
    上面代码中的最后一行我们可以通过Lua提供的另外一个内置函数assert类辅助完成，如：
        print "enter a number:"
        n = assert(io.read("*number"),"invalid input")
    assert函数将检查其第一个参数是否为true，如果是，则简单的返回该参数，否则就引发一个错误。第二个参数是可选字符串。
        对于所有的编程语言而言，错误处理都是一个非常重要的环节。在实际的开发中，没有统一的指导原则，只能是在遇到问题后，
    经过缜密的分析在结合当时的应用场景，最后结合自己的经验再给出错误的具体处理方式。
    在有些情况下，我们可以直接返回错误码，而在另外一些情况下，则需要直接抛出错误，让开发者能够快速定位导致错误的代码源。
  返回错误代码 -- return方式       功能实现上的逻辑判断，通过重试或其他策略可以保证后续功能正常
  抛出错误     -- assert和error    功能实现上的逻辑错误，包括程序自身代码错误、实现功能的必要条件
  
4 错误处理与异常
    pcall (f, arg1, ···) -- assert和error,以及逻辑错误抛出异常，相当于try部分，而pcall则相当于catch部分。
        功能：在保护模式下调用函数(即发生的错误将不会反射给调用者)
        当调用函数成功能返回true,失败时将返回false加错误信息
    
        Lua提供了错误处理函数pcall，该函数的第一个参数为需要“保护执行”的函数，
    如果该函数执行失败，pcall将返回false及错误信息，否则返回true和函数调用的返回值。
    
    status, err = pcall(function () error({code=121}) end)  -- false err.code <-> 121
    status, err = pcall(function () error("error ok?") end) -- false err      <-> error ok?
    status, err = pcall(function () return nil end)         -- true  err      <-> nil
    status, err = pcall(function () ({code=121}) end)       -- true  err.code <-> 121
    status, err = pcall(function () return 121 end)         -- true  err      <-> 121
    
    status, err = pcall(function () return assert(1>2, "1>2 ok?") end) -- false err <-> stdin:1: 1>2 ok?
    status, err = pcall(function () return assert(1<2, "1<2 ok?") end) -- true err <-> true
    
    虽然你可以使用任何类型的值作为错误信息，通常情况下，我们使用字符串来描述遇到的错误。如果遇到内部错误
 （比如对一个非table的值使用索引下标访问）Lua将自己产生错误信息，否则Lua使用传递给error函数的参数作为错误信息。
 不管在什么情况下，Lua都尽可能清楚的描述问题发生的缘由。
    local status, err = pcall(function () a = 'a'+1 end)   -- stdin:1: attempt to perform arithmetic on a string value
    status, err = pcall(function () error("my error") end) -- stdin:1: my error

    见如下代码：   
实例1： -- 函数调用
    function foo()
        local a = 10
        print(a[2])
    end
    
    r, msg = pcall(foo)
    if r then
        print("This is ok.")
    else
        print("This is error.")
        print(msg)
    end
    --输出结果为：
    --This is error.
    --d:/test.lua:3: attempt to index local 'a' (a number value)
实例1： -- 匿名函数
    我们也可以给pcall函数直接传递匿名函数，如：
    r, msg = pcall(function() error({code = 121}) end)
    if r then
        print("This is ok.")
    else
        print("This is error.")
        print(msg.code)
    end
    --输出结果为：
    --This is error.
    --121
    
    if pcall(require, "luci.model.uci")  then
    if not pcall(tpl.Template, "themes/%s/header" % fs.basename(media)) then
    
    local ok, nfct pcall(io.lines, "/proc/net/nf_conntrack") 
    local ok, lines = pcall(io.lines, "/proc/net/ip6_tables_names")
    local ok, res = pcall(a.format, a, unpack(b))
    
    local res, co = oldpcall(coroutine.create, f)  
    
5. 错误消息与追溯：
        通常在错误发生时，希望得到更多的调试信息，而不是只有发生错误的位置。至少能追溯到发生错误时和函数调用情况，
    显示一个完整的函数调用栈轨迹。要完成这一功能，我们需要使用Lua提供的另外一个内置函数xpcall。
    该函数除了接受一个需要被调用的函数之外，还接受第二个参数，即错误处理函数。
    当发生错误时，Lua会在调用栈展开前调用错误处理函数。这样，我们就可以在这个函数中使用
    debug库的debug.traceback函数，它会根据调用栈来构建一个扩展的错误消息。如：

    function errorFunc()
        local a = 20
        print(a[10])
    end
    
    function errorHandle()
        print(debug.traceback())
    end
    
    if xpcall(errorFunc,errorHandle) then
        print("This is OK.")
    else
        print("This is error.")
    end
    
    --输出结果为：
    --[[stack traceback:
            d:/test.lua:7: in function <d:/test.lua:6>
            d:/test.lua:3: in function <d:/test.lua:1>
            [C]: in function 'xpcall'
            d:/test.lua:10: in main chunk
            [C]: ?
    This is error.
    --]]

xpcall (f, err)
    功能：与pcall类似，在保护模式下调用函数(即发生的错误将不会反射给调用者)
    但可指定一个新的错误处理函数句柄
    当调用函数成功能返回true,失败时将返回false加err返回的结果
