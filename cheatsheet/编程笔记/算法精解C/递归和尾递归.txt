递归
递归是一种强大的方法，它允许一个对象以其自身更小的形式来定义自己。
递归函数是一种可以调用自身的函数。每次成功的调用都使得输入变得更加精细，使我们越来越接近问题的答案。
1. 树的遍历；广度优先和深度优先查找；排序
例子：n! = (n)*(n-1)*(n-2)...*(1)
      F(n)= 1         如果n=0,n=1
      F(n)= nF(n-1)   如果n>1

递推和回归。
F(4)=4*F(3)                      递归阶段
       F(3)=3*F(2)
              F(2)=2*F(1)
                     F(1)=1      终止条件
---------------------------------------------
                 F(2)=(2)*1      回归阶段
        F(3)=(3)*(2)           
F(4)=(4)(6)
24                               递归完成

在递推阶段，每一个递归调用通过进一步调用自己来记住这次递归过程。当其中有调用满足终止条件时，递推结束。
每一个递归函数都必须拥有至少一个终止条件；否则，递推阶段就永远不会结束了。
一旦递推阶段结束，处理过程就进入回归阶段，在这之前的函数调用以逆序的方式回归，直到最初调用的函数返回为止，此时递归过程结束。

尾递归
如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。
当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。
注意: 当编译器检测到一个函数调用是尾递归的时候，编译器就覆盖当前的活跃记录而不是在栈中去创建一个新的。
例子：n! = (n)*(n-1)*(n-2)...*(1)
      F(n,a)= a            如果n=0,n=1
      F(n,a)= F(n-1,N*a)   如果n>1
注意在回归的过程中不需要做任何操作，这是所有尾递归函数的标志。
递推和回归。
F(4,1)=F(3,4)                      递归阶段
       F(3,4)=F(2,12)
              F(2,12)=F(1,24)
                      F(1,24)=24  终止条件
---------------------------------------------
                              24  回归阶段
                                  递归完成

// 普通递归方式求阶乘
int fact(int n){
    if (n < 0) {
        return 0;
    } else if (n == 0 || n == 1) {
        return 1;
    } else {
        return n * fact(n - 1);
    }
}

// 尾递归的方式求阶乘
int facttail(int n, int a){
    if (n < 0) {
        return 0;
    } else if (n == 0 || n == 1) {
        return a;
    } else {
        return facttail(n - 1, n * a);
    }
}

int main(int argc, char const *argv[]){
    printf("result = %d\n", fact(5));
    return 0;
}

例子：计算分治算法的运行时间
      T(n)= 1            如果n=1
      T(n)= 2*T(n/2)+n   如果n>1