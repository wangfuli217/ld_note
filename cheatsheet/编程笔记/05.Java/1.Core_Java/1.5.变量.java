
实例变量和局部变量

实例变量:
    1、在一个类中，任何方法之外定义的变量；
    2、从面向对象的思想来说我们又把实例变量看成一个类的属性。
    3、实例变量在没有符初值时系统会自动帮我们做初始化:
          整型数据初始化为 0，布尔型数据初始化为 false，对象类型初始化为 null 。
    实例变量的作用域在本类中完全有效，当被其它的类调用的时候也可能有效。

局部变量:
    1、在方法内定义的变量叫局部变量。
    2、局部变量使用前必须初始化，系统不会自动给局部变量做初始化。
    3、局部变量的生命范围在他所在的代码块，在重合的作用域范围内不允许两个局部变量命名冲突。

注: 局部变量与实例变量允许同名，在局部变量的作用域内，其优先级高于实例变量。
     我们可以用  this.实例变量名  以区分局部变量。


静态变量 static
    一个类只有一个静态变量，跟对象没有关系。被类的所有实例共享；如果子类没有覆盖，也共享父类的静态成员。
    一般直接使用类名来访问 “类名.静态变量名”。可以在没有任何实例时调用。
    在某种意义上类似于全局变量(Java里没有全局变量，这只是C和C++的说法)
    不能在 static 方法或代码块里访问非 static 成员(变量或方法)
    能继承和覆盖，但覆盖 static 方法必须也是 static 的方法。

    1. 可以修饰属性、方法、初始代码块，成为类变量、静态方法、静态初始化代码块。
       注: 初始代码块是在类中而不是在任何方法之内的代码块。
    2. 类变量、静态方法、静态初始化代码块与具体的某个对象无关，只与类相关，是全类公有的。 在类加载时初始化。
    3. 类加载: JVM通过CLASSPATH找到字节码文件，并将字节码文件中的内容通过I/O流读到JVM并保存的过程
       在虚拟机的生命周期中一个类只被加载一次。
       注: Java命令的作用是启动JVM (Java Virtual Mechine)。
    4. static 定义的是一块为整个类共有的一块存储区域，其发生变化时访问到的数据都是经过变化的。
    5. 为什么主方法必须是静态的？
       主方法是整个应用程序的入口，JVM只能通过类名去调用主方法。
    6. 类变量和静态方法可以在没有对象的情况下用: 类名.方法名(或属性名)来访问。
    7. 静态方法不可被覆盖(允许在子类中定义同名的静态方法,但是没有多态)
       父类如果是静态方法,子类不能覆盖为非静态方法。父类如果是非静态方法，子类不能覆盖为静态方法。
       争论: 静态方法可以覆盖但是没有多态。
       思考: 没有多态的覆盖叫覆盖吗？
       在静态方法中不允许调用本类中的非静态成员。
    8. 静态初始化代码块只在类加载的时候运行一次，以再也不执行了。所以静态代码块一般被用来初始化静态成员。
    9. 不加 static 为动态初始化代码块，在创建对象时被调用(在构造函数之前)。
    10. 最后要注意的一点就是 static 不能修饰局部变量。

