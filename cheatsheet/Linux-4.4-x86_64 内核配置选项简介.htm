<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<!--[if lt IE 9]><style type="text/css">@font-face { font-family: "JinBuGuoWebMono"; src: url("/d/mono.eot"); }</style><![endif]-->
<style media="all" type="text/css">
@font-face { font-family: "JinBuGuoWebMono"; src: url("/d/mono.ttf") format("truetype"); }
* { font-family: "JinBuGuoWebMono", "Ubuntu Mono", "Consolas", "Menlo", monospace; }
body { margin:10px; }
h1,h2 { text-align:center; background:#ddd; }
h2 { margin: 10px 5%; }
h2#auth_name {  background:#fff; }
dt { margin-top: 0.5em; }
/*缩进*/
dt, dd { margin-left: 0; }
dd dt, dd dd { margin-left: 1em; }
/*颜色*/
dt { color:#d11; }
dd dt { color:#28c; }
dd dd dt { color:#c2c; }
dd dd dd dt { color:#360; }
dd dd dd dd dt { color:#a50; }
dd dd dd dd dd dt { color:#11e; }
dt.omit { color:#555; }
</style>
<title>Linux-4.4-x86_64 内核配置选项简介 [金步国]</title>
<script>var _hmt=_hmt||[]; (function(){ var hm=document.createElement("script"); hm.src="//hm.baidu.com/hm.js?d286c55b63a3c54a1e43d10d4c203e75"; var s=document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm,s); })();</script>
</head>

<body>
<h1>Linux-4.4-x86_64 内核配置选项简介</h1><h2 id="auth_name">作者：<strong><a href="http://www.jinbuguo.com/">金步国</a></strong></h2>
<hr />
<h3>版权声明</h3>
<p>本文作者是一位开源理念的坚定支持者，所以本文虽然不是软件，但是遵照开源的精神发布。</p>
<ul>
<li>无担保：本文作者不保证作品内容准确无误，亦不承担任何由于使用此文档所导致的损失。</li>
<li>自由使用：任何人都可以自由的<u>阅读/链接/打印</u>此文档，无需任何附加条件。</li>
<li>名誉权：任何人都可以自由的<u>转载/引用/再创作</u>此文档，但必须保留作者署名并注明出处。</li>
</ul>
<h3>其他作品</h3>
<p>本文作者十分愿意与他人分享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有的作品集：</p>
<ul>
<li><a href="http://www.jinbuguo.com/">金步国作品集</a> [ <a href="http://www.jinbuguo.com/">http://www.jinbuguo.com/</a> ]</li>
</ul>
<h3>联系方式</h3>
<p>由于作者水平有限，因此不能保证作品内容准确无误。如果你发现了作品中的错误(哪怕是错别字也好)，请来信指出，任何提高作品质量的建议我都将虚心接纳。</p>
<ul>
<li>Email(QQ)：70171448在QQ邮箱</li>
</ul>
<hr />
<center>Last Update: 2016-10-24</center>
<hr />





<h2>Gentoo Linux<br />Gentoo内核(<a href="http://packages.gentoo.org/package/sys-kernel/gentoo-sources">gentoo-sources</a>)特有的选项</h2>
<dl>
<dt>Gentoo Linux support<br>CONFIG_GENTOO_LINUX</dt><dd>选"Y"后,将会自动选中那些在Gentoo环境中必须开启的内核选项,以避免用户遗漏某些必要的选项,减轻一些用户配置内核的难度.建议选"Y".</dd>
<dd><dl>
	<dt>Linux dynamic and persistent device naming (userspace devfs) support<br>CONFIG_GENTOO_LINUX_UDEV</dt><dd>目前此项的作用仅是开启CONFIG_TMPFS和CONFIG_DEVTMPFS及其所依赖的选项.CONFIG_TMPFS是为了在"/dev/shm","/run","/sys/fs/cgroup"三个目录中挂载tmpfs文件系统,CONFIG_DEVTMPFS是为了在"/dev"目录挂载devtmpfs文件系统.建议选"Y".</dd>
	<dt>Select options required by Portage features<br>CONFIG_GENTOO_LINUX_PORTAGE</dt><dd>自动选中各种Portage特性(FEATURES="cgroup ipc-sandbox network-sandbox")所依赖的内核选项.由于这些FEATURES即将变为默认开启,所以建议选"Y".</dd>
</dl></dd>
<dt>Support for init systems, system and service managers</dt><dd>"init"系统(系统与服务管理器)."init"是内核启动的第一个用户空间程序(PID=1),也是所有用户态进程的"大总管"([提示]所有内核态进程的大总管是PID=2的[kthreadd]).</dd>
<dd><dl>
	<dt>OpenRC, runit and other script based systems and managers<br>CONFIG_GENTOO_LINUX_INIT_SCRIPT</dt><dd><a href="http://www.gentoo.org/doc/en/openrc-migration.xml">OpenRC</a>是Gentoo传统的"init"系统,使用基于<a href="https://wiki.archlinux.org/index.php/SysVinit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">SysVinit</a>的传统启动脚本技术.选"Y"后,所有OpenRC所必需的内核选项(目前仅有CONFIG_BINFMT_SCRIPT)都会被自动选中.不确定的选"Y".</dd>
	<dt>systemd<br>CONFIG_GENTOO_LINUX_INIT_SYSTEMD</dt><dd>尽管倍受争议,但是<a href="http://linuxtoy.org/archives/more-than-upstart-systemd.html">systemd</a>确实是目前风头最劲的"init"系统,大有在Linux世界一统江湖的霸气和潜力.仅在你打算<a href="http://rca.is-programmer.com/2013/7/17/from-openrc-to-systemd.40004.html">从OpenRC迁移到systemd</a>时选"Y".选"Y"后,内核中所有被<a href="http://fedoraproject.org/wiki/Systemd/zh-cn">systemd</a>依赖的选项都将被自动选中,包括<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>建议的(而非必须的)选项,总计约20项.<a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">systemd</a>官方的<a href="https://github.com/systemd/systemd/blob/master/README">README</a>文件也列出了必须/推荐/可选的内核选项.</dd>
</dl></dd>
</dl>


<hr /><hr />


<dl>
<dt>64-bit kernel<br>CONFIG_64BIT</dt><dd>编译64位内核.本文仅讲述x86_64(AMD64)平台的内核编译,所以这个是必选项.</dd>
</dl>




<h2>General setup<br />常规设置</h2>
<dl>
<dt>Cross-compiler tool prefix<br>CONFIG_CROSS_COMPILE</dt><dd>交叉编译工具前缀(比如"arm-linux-"相当于使用"make CROSS_COMPILE=arm-linux-"进行编译).除非你想配置后默认自动进行交叉编译,否则不要使用此选项.</dd>
<dt>Compile also drivers which will not load<br>CONFIG_COMPILE_TEST</dt><dd>显示专属于其他平台(非x86平台)的驱动选项(需要交叉编译),仅供驱动开发者使用,普通的发行版制作者应该选"N".</dd>
<dt>Local version - append to kernel release<br>CONFIG_LOCALVERSION</dt><dd>在内核版本后面加上自定义的版本字符串(最大64字符),可以用"uname -a"命令看到</dd>
<dt>Automatically append version information to the version string<br>CONFIG_LOCALVERSION_AUTO</dt><dd>自动在版本字符串(CONFIG_LOCALVERSION)后面添加版本信息(类似"-gxxxxxxxx"格式),需要有perl以及git仓库支持</dd>
<dt>Kernel compression mode</dt><dd>内核镜像的压缩格式,可选Gzip/Bzip2/LZMA/XZ/LZO格式之一,推荐使用XZ格式.你的系统中需要有相应的压缩工具.</dd>
<dt>Default hostname<br>CONFIG_DEFAULT_HOSTNAME</dt><dd>设置默认主机名,默认值是"(none)".用户可以随后使用系统调用sethostname()来修改主机名.</dd>
<dt>Support for paging of anonymous memory (swap)<br>CONFIG_SWAP</dt><dd>使用交换分区或者交换文件来做为虚拟内存</dd>
<dt>System V IPC<br>CONFIG_SYSVIPC</dt><dd>System V <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/">进程间通信(IPC)</a>支持,用于进程间同步和交换数据,许多程序需要这个功能.选"Y",除非你确实知道自己在做什么</dd>
<dt>POSIX Message Queues<br>CONFIG_POSIX_MQUEUE</dt><dd><a href="http://www.cppblog.com/marv/archive/2012/03/21/168541.aspx">POSIX消息队列</a>是POSIX IPC的一部分,如果你想编译和运行那些使用"mq_*"系统调用的程序(比如为Solaris开发的程序),或者需要使用Docker容器,就必须开启此选项.POSIX消息队列可以作为"mqueue"文件系统挂载以方便用户对队列进行操作.不确定的选"Y".</dd>
<dt>open by fhandle syscalls<br>CONFIG_FHANDLE</dt><dd>用户程序可以使用句柄(而非文件名)来追踪文件(使用open_by_handle_at(2)/name_to_handle_at(2)系统调用),即使某文件被重命名,用户程序依然可定位那个文件.此特性有助于实现用户空间文件服务器(userspace file server).建议选"Y",因为systemd和udev依赖于它.</dd>
<dt>uselib syscall<br>CONFIG_USELIB</dt><dd>启用老旧的uselib()系统接口支持,仅在你需要使用基于libc5的古董级程序时才需要,不确定的选"N".</dd>
<dt>Auditing support<br>CONFIG_AUDIT</dt><dd>内核审计(跟踪每个进程的活动情况)支持,某些安全相关的内核子系统(例如SELinux)需要它.但是它会与systemd冲突,所以在使用systemd的系统上必须关闭.</dd>
<dd><dl>
	<dt>Enable system-call auditing support<br>CONFIG_AUDITSYSCALL</dt><dd>对系统调用进行审计.既可独立使用,也可被其他内核子系统(例如SELinux)使用.</dd>
	<dt>Make audit loginuid immutable<br>CONFIG_AUDIT_LOGINUID_IMMUTABLE</dt><dd>审计时使用固定的loginuid.在使用<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>之类的系统上应该开启(login服务由init进程负责重启),在使用<a href="https://wiki.archlinux.org/index.php/SysVinit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">SysVinit</a>或<a href="http://wangxu.me/blog/p/tag/init">Upstart</a>之类的系统上应该关闭(login服务由系统管理员手动重启).<a href="http://en.wikipedia.org/wiki/OpenRC">OpenRC</a>就是一个基于SysVinit的系统.</dd>
</dl></dd>
<dt>IRQ subsystem</dt><dd>IRQ(中断请求)子系统</dd>
<dd><dl>
	<dt>Expose hardware/virtual IRQ mapping via debugfs<br>CONFIG_IRQ_DOMAIN_DEBUG</dt><dd>通过debugfs中的irq_domain_mapping文件向用户显示硬件IRQ号/Linux IRQ号之间的对应关系.仅用于开发调试.</dd>
	<dt>Support sparse irq numbering<br>CONFIG_SPARSE_IRQ</dt><dd>稀疏IRQ号支持.它允许在小型设备上(例如嵌入式设备)定义一个很高的CONFIG_NR_CPUS值,但仍然不希望占用太多内核"<a href="http://en.wikipedia.org/wiki/Memory_footprint">memory footprint</a>"(一段可以被操作或被管理的内存区域)的场合.稀疏IRQ也更适合NUMA平台,因为它以一种对NUMA更友好的方式分发中断描述符.不确定的选"N".</dd>
</dl></dd>
<dt>Timers subsystem</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-timerm/">Linux内核时钟子系统</a></dd>
<dd><dl>
	<dt>Timer tick handling</dt><dd>内核时钟滴答处理程序,更多信息可以参考内核源码树下的"<a href="https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt">Documentation/timers/NO_HZ.txt</a>"文件</dd>
	<dd><dl>
		<dt>Periodic timer ticks (constant rate, no dynticks)<br>CONFIG_HZ_PERIODIC</dt><dd>无论CPU是否需要,都强制按照固定频率不断触发时钟中断.这是最耗电的方式,不推荐使用</dd>
		<dt>Idle dynticks system (tickless idle)<br>CONFIG_NO_HZ_IDLE</dt><dd>CPU在空闲状态时不产生不必要的时钟中断,以使处理器能够在较低能耗状态下运行以节约电力,适合于大多数场合</dd>
		<dt>Full dynticks system (tickless)<br>CONFIG_NO_HZ_FULL</dt><dd><a href="http://www.cnbeta.com/articles/238600.htm">完全无滴嗒</a>:即使CPU在忙碌状态也尽可能关闭所有时钟中断,适用于CPU在同一时间仅运行一个任务,或者用户空间程序极少与内核交互的场合.即使开启此选项,也需要额外设置"nohz_full=?"内核命令行参数才能真正生效.</dd>
	</dl></dd>
	<dt>Full dynticks system on all CPUs by default<br>CONFIG_NO_HZ_FULL_ALL</dt><dd>即使没有设置"nohz_full"引导参数,也默认对所有CPU(boot CPU 除外)开启完全无滴答特性.</dd>
	<dt>Old Idle dynticks config<br>CONFIG_NO_HZ</dt><dd>等价于CONFIG_NO_HZ_IDLE,临时用来兼容老版本内核选项,未来会被删除.</dd>
	<dt>High Resolution Timer Support<br>CONFIG_HIGH_RES_TIMERS</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime4/index.html">高精度定时器</a>(hrtimer)是从2.6.16开始引入,用于取代传统timer wheel(<a href="http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime3/index.html">基于jiffies定时器</a>)的时钟子系统.可以降低与内核其他模块的耦合性,还可以提供比1毫秒更高的精度(因为它可以读取HPET/TSC等新型硬件时钟源),可以更好的支持音视频等对时间精度要求较高的应用.建议选"Y".[提示]这里说的"定时器"是指"软件定时器",而不是主板或CPU上集成的<a href="http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime2/index.html">硬件时钟发生器</a>(ACPI PM Timer/HPET Timer/TSC Timer).</dd>
</dl></dd>
<dt>CPU/Task time and stats accounting</dt><dd>CPU/进程的时间及状态统计</dd>
<dd><dl>
	<dt>Cputime accounting</dt><dd>CPU时间统计方式</dd>
	<dd><dl>
		<dt>Simple tick based cputime accounting<br>CONFIG_TICK_CPU_ACCOUNTING</dt><dd>简单的基于滴答的统计,适用于大多数场合</dd>
		<dt>Deterministic task and CPU time accounting<br>CONFIG_VIRT_CPU_ACCOUNTING_NATIVE</dt><dd>通过读取CPU计数器进行统计,可以提供更精确的统计,但是对性能有一些不利影响.</dd>
		<dt>Full dynticks CPU time accounting<br>CONFIG_VIRT_CPU_ACCOUNTING_GEN</dt><dd>利用上下文跟踪子系统,通过观察每一个内核与用户空间的边界进行统计.该选项对性能有显著的不良影响,目前仅用于完全无滴答子系统(CONFIG_NO_HZ_FULL)的调试</dd>
		<dt>Fine granularity task level IRQ time accounting<br>CONFIG_IRQ_TIME_ACCOUNTING</dt><dd>通过读取TSC时间戳进行统计,这是统计进程IRQ时间的更细粒度的统计方式,但对性能有些不良影响(特别是在RDTSC指令速度较慢的CPU上).</dd>
	</dl></dd>
	<dt>BSD Process Accounting<br>CONFIG_BSD_PROCESS_ACCT</dt><dd>BSD进程记账支持.用户空间程序可以要求内核将进程的统计信息写入一个指定的文件,主要包括进程的创建时间/创建者/内存占用等信息.不确定的选"N".</dd>
	<dd><dl>
		<dt>BSD Process Accounting version 3 file format<br>CONFIG_BSD_PROCESS_ACCT_V3</dt><dd>使用新的v3版文件格式,可以包含每个进程的PID和其父进程的PID,但是不兼容老版本的文件格式.比如 <a href="http://www.gnu.org/software/acct/">GNU Accounting Utilities</a> 这样的工具可以识别v3格式</dd>
	</dl></dd>
	<dt>Export task/process statistics through netlink<br>CONFIG_TASKSTATS</dt><dd>通过<a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a>接口向用户空间导出进程的统计信息,与 BSD Process Accounting 的不同之处在于这些统计信息在整个进程生存期都是可用的.</dd>
	<dd><dl>
		<dt>Enable per-task delay accounting<br>CONFIG_TASK_DELAY_ACCT</dt><dd>在统计信息中包含进程等候系统资源(cpu,IO同步,内存交换等)所花费的时间</dd>
		<dt>Enable extended accounting over taskstats<br>CONFIG_TASK_XACCT</dt><dd>在统计信息中包含进程的更多扩展信息.不确定的选"N".</dd>
		<dd><dl>
			<dt>Enable per-task storage I/O accounting<br>CONFIG_TASK_IO_ACCOUNTING</dt><dd>在统计信息中包含进程在存储设备上的I/O字节数.</dd>
		</dl></dd>
	</dl></dd>
</dl></dd>
<dt>RCU Subsystem</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-rcu/">RCU(Read-Copy Update)子系统</a>.它允许程序查看到正在被修改/更新的文件.在读多写少的情况下,这是一个高性能的锁机制,对于被RCU保护的共享数据结构,读者不需要获得任何锁就可以访问它(速度非常快),但写者在访问它时首先拷贝一个副本,然后对副本进行修改,最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据,速度非常慢.RCU只适用于读多写少的情况:如网络路由表的查询更新,设备状态表的维护,数据结构的延迟释放以及多径I/O设备的维护等.</dd>
<dd><dl>
	<dt>RCU Implementation</dt><dd>RCU的实现方式</dd>
	<dd><dl>
		<dt>Tree-based hierarchical RCU<br>CONFIG_TREE_RCU</dt><dd>基于树型分层结构的实现.最适用于多CPU的非实时系统.</dd>
		<dt>Preemptible tree-based hierarchical RCU<br>CONFIG_TREE_PREEMPT_RCU</dt><dd>抢占式基于树型分层结构的实现.最适用于那些要求快速响应的多CPU实时系统.</dd>
		<dt>UP-only small-memory-footprint RCU<br>CONFIG_TINY_RCU</dt><dd>最简单的实现,能够大幅降低RCU系统的内存占用.最适用于单CPU的非实时系统.</dd>
		<dt>Preemptible UP-only small-memory-footprint RCU<br>CONFIG_TINY_PREEMPT_RCU</dt><dd>抢占式简单实现,能够大幅降低RCU系统的内存占用.最适用于那些要求快速响应的单CPU实时系统.</dd>
	</dl></dd>
	<dt>Consider userspace as in RCU extended quiescent state<br>CONFIG_RCU_USER_QS</dt><dd>在内核和用户边界设置钩子函数,将运行在用户态的CPU从全局RCU状态机制中移除,这样就不会在RCU系统中维护此CPU的时钟滴答.除非你想要帮助开发CONFIG_NO_HZ_FULL模块,否则不要打开此选项,而且它还会对性能有不利影响.</dd>
	<dt>Force context tracking<br>CONFIG_CONTEXT_TRACKING_FORCE</dt><dd>默认在内核和用户边界进行探测(上下文跟踪),以便测试依赖于此特性的各种功能(比如用户空间的 RCU extended quiescent state),这个特性目前仅用于调试目的,未来也许会用于为CONFIG_NO_HZ_FULL模块提供支持</dd>
	<dt>Tree-based hierarchical RCU fanout value<br>CONFIG_RCU_FANOUT</dt><dd>这个选项控制着树形RCU层次结构的端点数(fanout),以允许RCU子系统在拥有海量CPU的系统上高效工作.这个值必须至少等于CONFIG_NR_CPUS的1/4次方(4次根号).生产系统上应该使用默认值(64).仅在你想调试RCU子系统时才需要减小此值.</dd>
	<dt>Tree-based hierarchical RCU leaf-level fanout value<br>CONFIG_RCU_FANOUT_LEAF</dt><dd>这个选项控制着树形RCU层次结构的叶子层的端点数(leaf-level fanout).对于期望拥有更高能耗比(更节能)的系统,请保持其默认值(16).对于拥有成千上万个CPU的系统来说,应该考虑将其设为最大值(CONFIG_RCU_FANOUT).</dd>
	<dt>Disable tree-based hierarchical RCU auto-balancing<br>CONFIG_RCU_FANOUT_EXACT</dt><dd>强制按照CONFIG_RCU_FANOUT_LEAF的值,而不是使用自动平衡树结构来实现RCU子系统.目前仅用于调试目的.未来也许会用于增强NUMA系统的性能.</dd>
	<dt>Accelerate last non-dyntick-idle CPU's grace periods<br>CONFIG_RCU_FAST_NO_HZ</dt><dd>即使CPU还在忙碌,也允许进入dynticks-idle状态,并且阻止RCU每4个滴答就唤醒一次该CPU,这样能够更有效的使用电力,同时也拉长了RCU grace period的时间,造成性能降低.如果能耗比对你而言非常重要(你想节省每一分电力),并且你不在乎系统性能的降低(CPU唤醒时间增加),可以开启此选项.台式机和服务器建议关闭此选项.</dd>
	<dt>Enable RCU priority boosting<br>CONFIG_RCU_BOOST</dt><dd>允许提升RCU子系统的实时优先级(包括读操作与写操作),以避免RCU操作被阻塞太长时间.如果系统的CPU负载经常很重,或者你需要快速的实时响应系统,那么就选"Y",否则应该选"N".</dd>
	<dd><dl>
		<dt>Real-time priority to boost RCU readers to<br>CONFIG_RCU_BOOST_PRIO</dt><dd>允许提升被长时间抢占(阻塞)的RCU读操作的实时优先级到什么程度.取值范围是[1,99].默认值"1"适用于实时应用程序中不包含CPU密集型(CPU-bound)线程的常规场合(例如大多数桌面系统).但是如果你的实时应用程序拥有一个或多个CPU密集型线程,那么可能需要增加这个值,具体可以参考内核帮助的说明.仅在你确实理解了的情况下再改变默认值.</dd>
		<dt>Milliseconds to delay boosting after RCU grace-period start<br>CONFIG_RCU_BOOST_DELAY</dt><dd>在提升RCU读操作的优先级之前,允许有多长时间潜伏期(阻塞),取值范围是[0,3000],单位是毫秒,默认值是"500".不确定的请使用默认值.</dd>
	</dl></dd>
	<dt>Offload RCU callback processing from boot-selected CPUs<br>CONFIG_RCU_NOCB_CPU</dt><dd>如果你想帮助调试内核可以开启,否则请关闭.</dd>
	<dt>Build-forced no-CBs CPUs</dt><dd>在开启CONFIG_RCU_NOCB_CPU选项的情况下,指定哪些CPU是No-CB CPU,相当于预先设置"rcu_nocbs="内核引导参数.</dd>
</dl></dd>
<dt>Kernel .config support<br>CONFIG_IKCONFIG</dt><dd>把内核的配置信息编译进内核中,以后可以通过scripts/extract-ikconfig脚本从内核镜像中提取这些信息</dd>
<dd><dl>
	<dt>Enable access to .config through /proc/config.gz<br>CONFIG_IKCONFIG_PROC</dt><dd>允许通过 /proc/config.gz 文件访问内核的配置信息</dd>
</dl></dd>
<dt>Kernel log buffer size<br>CONFIG_LOG_BUF_SHIFT</dt><dd>设置内核日志缓冲区的最小尺寸(合理的设置应该等于CONFIG_LOG_CPU_MAX_BUF_SHIFT*最大CPU数量): 12(最小值)=4KB,...,16=64KB,17=128KB,18=256KB,...,25(最大值)</dd>
<dt>CPU kernel log buffer size contribution<br>CONFIG_LOG_CPU_MAX_BUF_SHIFT</dt><dd>每个CPU的内核日志缓存大小(通常只有几行文字,但在报告故障时可能会产生大量文字).例如在最大CPU数量(包含热插拔CPU)为64的系统上,如果CONFIG_LOG_BUF_SHIFT=18,那么该值应该设为12</dd>
<dt>Memory placement aware NUMA scheduler<br>CONFIG_NUMA_BALANCING</dt><dd>允许自动根据NUMA系统的节点分布状况进行进程/内存均衡(方法很原始,就是简单的内存移动).这个选项对UMA系统无效.[提示]UMA系统的例子:(1)只有一颗物理CPU(即使是多核)的电脑,(2)不支持"虚拟NUMA",或"虚拟NUMA"被禁用的虚拟机(即使所在的物理机是NUMA系统)</dd>
<dd><dl>
	<dt>Automatically enable NUMA aware memory/task placement<br>CONFIG_NUMA_BALANCING_DEFAULT_ENABLED</dt><dd>在<a href="http://www.ibm.com/developerworks/cn/linux/l-numa/">NUMA(Non-Uniform Memory Access Architecture)</a>系统上自动启用进程/内存均衡,也就是自动开启CONFIG_NUMA_BALANCING特性.</dd>
</dl></dd>
<dt>Control Group support<br>CONFIG_CGROUPS</dt><dd><a href="http://www.cnblogs.com/lisperl/archive/2012/04/17/2453838.html">Cgroup(Control Group)</a>是一种进程管理机制,可以针对一组进程进行系统资源的分配和管理,可用于Cpusets,CFS(完全公平调度器),内存管理等子系统.此外,systemd与Docker/LXC等容器也依赖于它.更多细节可以参考内核的"<a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">Documentation/cgroups/cgroups.txt</a>"文件</dd>
<dd><dl>
	<dt>Example debug cgroup subsystem<br>CONFIG_CGROUP_DEBUG</dt><dd>导出cgroups框架的调试信息,仅用于调试目的.</dd>
	<dt>Freezer cgroup subsystem<br>CONFIG_CGROUP_FREEZER</dt><dd>允许冻结/解冻cgroup内所有进程.Docker依赖于它.</dd>
	<dt>PIDs cgroup subsystem<br>CONFIG_CGROUP_PIDS</dt><dd>允许限制同一cgroup内所有进程的数量,超出限制后将无法fork()出新进程.</dd>
	<dt>Device controller for cgroups<br>CONFIG_CGROUP_DEVICE</dt><dd>允许为cgroup建立设备白名单,这样cgroup内的进程将仅允许对白名单中的设备进行mknod/open操作.Docker依赖于它.</dd>
	<dt>Cpuset support<br>CONFIG_CPUSETS</dt><dd><a href="http://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm">CPUSET</a>支持:允许将CPU和内存进行分组,并指定某些进程只能运行于特定的分组.Docker依赖于它.这里有一篇<a href="http://book.2cto.com/201302/16297.html">CPUSET的用法</a></dd>
	<dd><dl>
		<dt>Include legacy /proc/&lt;pid&gt;/cpuset file<br>CONFIG_PROC_PID_CPUSET</dt><dd>提供过时的 /proc/&lt;pid&gt;/cpuset 文件接口</dd>
	</dl></dd>
	<dt>Simple CPU accounting cgroup subsystem<br>CONFIG_CGROUP_CPUACCT</dt><dd>提供一个简单的资源控制器(Resource Controller,用于实现一组任务间的资源共享),以监控cgroup内所有进程的总CPU使用量.Docker依赖于它.</dd>
	<dt>Resource counters<br>CONFIG_RESOURCE_COUNTERS</dt><dd>为cgroup提供独立于controller资源计数器</dd>
	<dd><dl>
		<dt>Memory Resource Controller for Control Groups<br>CONFIG_MEMCG</dt><dd>为cgroup添加内存资源控制器,包含匿名内存和页面缓存(<a href="https://www.kernel.org/doc/Documentation/cgroups/memory.txt">Documentation/cgroups/memory.txt</a>).开启此选项后,将会增加关联到每个内存页fixed memory大小,具体在64位系统上是40bytes/PAGE_SIZE.仅在你确实明白什么是 <a href="https://www.kernel.org/doc/Documentation/cgroups/memory.txt">memory resource controller</a> 并且确实需要的情况下才开启此选项.此功能可以通过命令行选项"cgroup_disable=memory"进行关闭.Docker依赖于它.</dd>
		<dd><dl>
			<dt>Memory Resource Controller Swap Extension<br>CONFIG_MEMCG_SWAP</dt><dd>给 <a href="https://www.kernel.org/doc/Documentation/cgroups/memory.txt">Memory Resource Controller</a> 添加对swap的管理功能.这样就可以针对每个cgroup限定其使用的mem+swap总量.如果关闭此选项, memory resource controller 将仅能限制mem的使用量,而无法对swap进行控制(进程有可能耗尽swap).开启此功能会对性能有不利影响,并且为了追踪swap的使用也会消耗更多的内存(如果swap的页面大小是4KB,那么每1GB的swap需要额外消耗512KB内存),所以在内存较小的系统上不建议开启.</dd>
			<dd><dl>
				<dt>Memory Resource Controller Swap Extension enabled by default<br>CONFIG_MEMCG_SWAP_ENABLED</dt><dd>如果开启此选项,那么将默认开启CONFIG_MEMCG_SWAP特性,否则将默认关闭.即使默认开启也可以通过内核引导参数"swapaccount=0"禁止此特性.</dd>
			</dl></dd>
			<dt>Memory Resource Controller Kernel Memory accounting<br>CONFIG_MEMCG_KMEM</dt><dd>为 Memory Resource Controller 添加对内核对象所占用内存的管理功能.和标准的 Memory Resource Controller 对内存的控制不一样之处在于:这些内核对象所占用的内存是基于每个内存页的,并且可以被swap到硬盘.使用这个功能可以确保cgroup中的进程不会单独耗尽所有内核资源.</dd>
		</dl></dd>
		<dt>HugeTLB Resource Controller for Control Groups<br>CONFIG_CGROUP_HUGETLB</dt><dd>为cgroup添加对<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/">HugeTLB</a>页的资源控制功能.开启此选项之后,你就可以针对每个cgroup限定其对<a href="http://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/index.html">HugeTLB</a>的使用.Docker依赖于它.</dd>
	</dl></dd>
	<dt>Enable perf_event per-cpu per-container group (cgroup) monitoring<br>CONFIG_CGROUP_PERF</dt><dd>将per-cpu模式进行扩展,使其可以监控属于特定cgroup并运行于特定CPU上的线程.</dd>
	<dt>Group CPU scheduler<br>CONFIG_CGROUP_SCHED</dt><dd>让CPU调度程序可以在不同的cgroup之间分配CPU的带宽.Docker依赖于它.systemd资源控制单元(resource control unit)的CPUShares功能依赖于它.</dd>
	<dd><dl>
		<dt>Group scheduling for SCHED_OTHER<br>CONFIG_FAIR_GROUP_SCHED</dt><dd>公平CPU调度策略,也就是在多个cgroup之间平均分配CPU带宽."<a href="http://linuxtoy.org/archives/small-patch-but-huge-improvement.html">鸡血补丁</a>"CONFIG_SCHED_AUTOGROUP(自动分组调度功能)依赖于它.Docker依赖于它.systemd资源控制单元(resource control unit)的CPUShares功能也依赖于它.</dd>
		<dd><dl>
			<dt>CPU bandwidth provisioning for FAIR_GROUP_SCHED<br>CONFIG_CFS_BANDWIDTH</dt><dd>允许用户为运行在CONFIG_FAIR_GROUP_SCHED中的进程定义CPU带宽限制.对于没有定义CPU带宽限制的cgroup而言,可以无限制的使用CPU带宽.详情参见 <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt">Documentation/scheduler/sched-bwc.txt</a> 文件.systemd资源控制单元(resource control unit)的CPUQuota功能也依赖于它.</dd>
		</dl></dd>
		<dt>Group scheduling for SCHED_RR/FIFO<br>CONFIG_RT_GROUP_SCHED</dt><dd>允许用户为cgroup分配实时CPU带宽,还可以对非特权用户的实时进程组进行调度.详情参见 <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-rt-group.txt">Documentation/scheduler/sched-rt-group.txt</a> 文档.使用systemd的系统应该选"N".</dd>
	</dl></dd>
	<dt>Block IO controller<br>CONFIG_BLK_CGROUP</dt><dd>通用的块IO控制器接口,可以用于实现各种不同的控制策略.目前,IOSCHED_CFQ用它来在不同的cgroup之间分配磁盘IO带宽(需要额外开启CONFIG_CFQ_GROUP_IOSCHED),<a href="http://blog.tao.ma/?p=43">block io throttle</a>也会用它来针对特定块设备限制IO速率上限(需要额外开启CONFIG_BLK_DEV_THROTTLING).更多信息可以参考"<a href="https://www.kernel.org/doc/Documentation/cgroups/blkio-controller.txt">Documentation/cgroups/blkio-controller.txt</a>"文件.</dd>
	<dd><dl>
		<dt>Enable Block IO controller debugging<br>CONFIG_DEBUG_BLK_CGROUP</dt><dd>仅用于调试 Block IO controller 目的.</dd>
	</dl></dd>
</dl></dd>
<dt>Checkpoint/restore support<br>CONFIG_CHECKPOINT_RESTORE</dt><dd>在内核中添加"检查点/恢复"支持.也就是添加一些辅助的代码用于设置进程的 text, data, heap 段,并且在 /proc 文件系统中添加一些额外的条目.用于检测两个进程是否共享同一个内核资源的<a href="http://www.man7.org/linux/man-pages/man2/kcmp.2.html">kcmp()</a>系统调用依赖于它.使用systemd的建议开启此项.</dd>
<dt>Namespaces support<br>CONFIG_NAMESPACES</dt><dd><a href="http://www.cnblogs.com/lisperl/archive/2012/05/03/2480316.html">命名空间</a>支持.主要用于支持基于容器的轻量级虚拟化技术(比如<a href="http://www.cnblogs.com/lisperl/archive/2012/04/15/2450183.html">LXC</a>和<a href="http://en.wikipedia.org/wiki/Linux-VServer">Linux-VServer</a>以及<a href="http://www.docker.org.cn/book/docker.html">Docker</a>).</dd>
<dd><dl>
	<dt>UTS namespace<br>CONFIG_UTS_NS</dt><dd> uname()系统调用的命名空间支持</dd>
	<dt>IPC namespace<br>CONFIG_IPC_NS</dt><dd>进程间通信对象ID的命名空间支持</dd>
	<dt>User namespace<br>CONFIG_USER_NS</dt><dd>允许容器使用user命名空间.如果开启此项,建议同时开启CONFIG_MEMCG和CONFIG_MEMCG_KMEM选项,以允许用户空间使用"memory cgroup"限制非特权用户的内存使用量.不确定的选"N",如果你打算构建一个<a href="http://baike.baidu.com/view/698769.htm">VPS服务器</a>就必须选"Y".</dd>
	<dt>PID Namespaces<br>CONFIG_PID_NS</dt><dd>进程PID命名空间支持</dd>
	<dt>Network namespace<br>CONFIG_NET_NS</dt><dd>网络协议栈的命名空间支持.systemd服务单元(service unit)中的"PrivateNetwork/PrivateDevices"依赖于它.</dd>
</dl></dd>
<dt>Require conversions between uid/gids and their internal representation<br>CONFIG_UIDGID_STRICT_TYPE_CHECKS</dt><dd>强制将uid/gid转换为内部表示形式,以让那些未对uid/gid进行转换的内核子系统代码也能正常编译.不确定的选"N".</dd>
<dt>Automatic process group scheduling<br>CONFIG_SCHED_AUTOGROUP</dt><dd>每个TTY动态地创建任务分组(cgroup),这样就可以降低高负载情况下的桌面延迟.也就是传说中的桌面"<a href="http://wowubuntu.com/kernel-patch.html">鸡血补丁</a>",桌面用户建议开启.但服务器建议关闭.</dd>
<dt>Enable deprecated sysfs features to support old userspace tools<br>CONFIG_SYSFS_DEPRECATED</dt><dd>为了兼容旧版本的应用程序而保留过时的sysfs特性.仅当在使用2008年以前的发行版时才需要开启,2009年之后的发行版中必须关闭.此外,使用udev或systemd的系统也必须关闭.</dd>
<dd><dl>
	<dt>Enable deprecated sysfs features by default<br>CONFIG_SYSFS_DEPRECATED_V2</dt><dd>默认开启上述特性</dd>
</dl></dd>
<dt>Kernel->user space relay support (formerly relayfs)<br>CONFIG_RELAY</dt><dd>在某些文件系统(比如debugfs)中提供<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-relay/">中继(relay)</a>支持(从内核空间向用户空间传递大批量数据).主要用于调试内核.</dd>
<dt>Initial RAM filesystem and RAM disk (initramfs/initrd) support<br>CONFIG_BLK_DEV_INITRD</dt><dd>初始内存文件系统(<a href="http://linux.chinaunix.net/techdoc/net/2009/06/24/1120335.shtml">initramfs</a>,2.6以上内核的新机制,使用cpio格式,占据的内存随数据的增减自动增减)与初始内存盘(<a href="http://zh.wikipedia.org/wiki/Initrd">initrd</a>,2.4以前内核遗留的老机制,使用loop设备,占据一块固定的内存,需要额外开启CONFIG_BLK_DEV_RAM选项才生效)支持,一般通过lilo/grub的initrd指令加载.更多细节可以参考"<a href="https://www.kernel.org/doc/Documentation/initrd.txt">Documentation/initrd.txt</a>"文件,关于<a href="http://blog.linux.org.tw/~jserv/archives/001954.html">initrd到initramfs的进化</a>(<a href="http://hi.baidu.com/toniya/item/da1a25453b6da135fa8960a6">墙内镜像</a>),可以参考IBM上的两篇文章:<a href="http://www.ibm.com/developerworks/cn/linux/l-k26initrd/">Linux2.6 内核的 Initrd 机制解析</a>和<a href="http://www.ibm.com/developerworks/cn/linux/l-initrd.html">Linux 初始 RAM 磁盘（initrd）概述</a>.</dd>
<dd><dl>
	<dt>Initramfs source file(s)<br>CONFIG_INITRAMFS_SOURCE</dt><dd>如果你想<a href="http://www.arm9home.net/read.php?tid=5645">将initramfs镜像直接嵌入内核</a>(比如嵌入式环境或者想使用 EFI stub kernel),而不是通过lilo/grub这样的引导管理器加载,可以使用此选项,否则请保持空白.这个选项指明用来制作initramfs镜像的原料,可以是一个.cpio文件,或一个Initramfs虚根目录(其下包含"bin,dev,etc,lib,proc,sys"等子目录),或一个描述文件.细节可以参考"<a href="https://www.kernel.org/doc/Documentation/early-userspace/README">Documentation/early-userspace/README</a>"文档.[注意]内核帮助文档说可以指定多个目录或文件是错误的,实际只能接受单一的目录或文件</dd>
	<dd><dl>
		<dt>User ID to map to 0 (user root)<br>INITRAMFS_ROOT_UID</dt><dd>此选项仅在CONFIG_INITRAMFS_SOURCE中包含目录时才有效,将此值设为非零(例如"37"),那么所有UID=37的文件在打包到initramfs镜像内时,其UID都将被设为"0".</dd>
		<dt>Group ID to map to 0 (group root)<br>INITRAMFS_ROOT_GID</dt><dd>此选项仅在CONFIG_INITRAMFS_SOURCE中包含目录时才有效,将此值设为非零(例如"37"),那么所有GID=37的文件在打包到initramfs镜像内时,其GID都将被设为"0".</dd>
	</dl></dd>
	<dt>Support initial ramdisks compressed using gzip<br>CONFIG_RD_GZIP</dt><dd>支持经过gzip压缩的ramdisk或cpio镜像</dd>
	<dt>Support initial ramdisks compressed using bzip2<br>CONFIG_RD_BZIP2</dt><dd>支持经过bzip2压缩的ramdisk或cpio镜像</dd>
	<dt>Support initial ramdisks compressed using LZMA<br>CONFIG_RD_LZMA</dt><dd>支持经过LZMA压缩的ramdisk或cpio镜像</dd>
	<dt>Support initial ramdisks compressed using XZ<br>CONFIG_RD_XZ</dt><dd>支持经过XZ压缩的ramdisk或cpio镜像</dd>
	<dt>Support initial ramdisks compressed using LZO<br>CONFIG_RD_LZO</dt><dd>支持经过LZO压缩的ramdisk或cpio镜像</dd>
	<dt>Built-in initramfs compression mode</dt><dd>选择initramfs镜像的压缩格式."gzip"是兼容性最好的格式,但是压缩率却最低."XZ"是目前渐渐流行的格式,压缩率高,解压速度也不慢.</dd>
</dl></dd>
<dt>Optimize for size<br>CONFIG_CC_OPTIMIZE_FOR_SIZE</dt><dd>编译时优化内核尺寸(使用GCC的"-Os"而不是"-O2"参数编译),这会得到更小的内核,但是运行速度可能会更慢.主要用于嵌入式环境.</dd>
<dt>Configure standard kernel features (expert users)<br>CONFIG_EXPERT</dt><dd>配置标准的内核特性(仅供专家使用).这个选项允许你改变内核的"标准"特性(比如用于需要"非标准"内核的特定环境中),仅在你确实明白自己在干什么的时候才开启.</dd>
<dd><dl>
	<dt>Enable 16-bit UID system calls<br>CONFIG_UID16</dt><dd>允许对UID系统调用进行过时的16-bit包装,建议关闭</dd>
	<dt>Multiple users, groups and capabilities support<br>CONFIG_MULTIUSER</dt><dd>多用户(组)支持.若选"N",则所有进程都将以"UID=0,GID=0"运行(也就是禁止存在非root用户).选"Y",除非你确实知道自己在干什么.</dd>
	<dt>sgetmask/ssetmask syscalls support<br>CONFIG_SGETMASK_SYSCALL</dt><dd>是否开启已被反对使用的sys_sgetmask/sys_ssetmask系统调用(已不再被libc支持).建议选"N".</dd>
	<dt>Sysfs syscall support<br>CONFIG_SYSFS_SYSCALL</dt><dd>是否开启已被反对使用的sys_sysfs系统调用(已不再被libc支持).建议选"N".</dd>
	<dt>Sysctl syscall support<br>CONFIG_SYSCTL_SYSCALL</dt><dd>二进制sysctl接口支持.由于现在流行直接通过/proc/sys以ASCII明码方式修改内核参数(需要开启CONFIG_PROC_SYSCTL选项),所以已经不需要再通过二进制接口去控制内核参数,建议关闭它以减小内核尺寸.</dd>
	<dt>Load all symbols for debugging/ksymoops<br>CONFIG_KALLSYMS</dt><dd>装载所有的调试符号表信息,会增大内核体积,仅供调试时选择</dd>
	<dd><dl>
		<dt>Include all symbols in kallsyms<br>CONFIG_KALLSYMS_ALL</dt><dd>在<a href="http://blog.csdn.net/diy534/article/details/6941001">/proc/kallsyms</a>中包含内核知道的所有符号,内核将会增大300K,仅在你确实需要的时候再开启</dd>
	</dl></dd>
	<dt>Enable support for printk<br>CONFIG_PRINTK</dt><dd>允许内核向终端打印字符信息.任何由printk显示的字符串通常记录在/var/log/messages文件里.如果关闭,内核在初始化过程中将不会输出字符信息,这会导致很难诊断系统故障,并且"dmesg"命令也会失效.仅在你确实不想看到任何内核信息时选"N".否则请选"Y".</dd>
	<dt>BUG() support<br>CONFIG_BUG</dt><dd>显示故障和失败条件(BUG和WARN),禁用它将可能导致隐含的错误被忽略.建议仅在嵌入式设备或者无法显示故障信息的系统上关闭</dd>
	<dt>Enable ELF core dumps<br>CONFIG_ELF_CORE</dt><dd>内存转储支持,可以帮助调试ELF格式的程序,用于调试和开发用户态程序</dd>
	<dt>Enable PC-Speaker support<br>CONFIG_PCSPKR_PLATFORM</dt><dd>主板上的<a href="http://blog.csdn.net/raptor/article/details/7636997">蜂鸣器</a>支持.<a href="http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html">主板上的蜂鸣器</a>只能发出或长或短的"滴"或"嘟嘟"声,一般用于系统报警.不要和能够播放音乐的扬声器混淆.如果你的主板上没有就关闭,有的话(开机自检完成后一般能听到"滴"的一声)还是建议开启.</dd>
	<dt>Enable full-sized data structures for core<br>CONFIG_BASE_FULL</dt><dd>在内核中使用全尺寸的数据结构.禁用它将使得某些内核的数据结构减小以节约内存,但是将会降低性能</dd>
	<dt>Enable futex support<br>CONFIG_FUTEX</dt><dd><a href="http://hi.baidu.com/pbskasefcqcfjxr/item/8f0271c5a07d7c52ac00ef12">快速用户空间互斥(fast userspace mutexes)</a>可以使线程串行化以避免竞态条件,也提高了响应速度.禁用它将导致内核不能正确的运行基于glibc的程序</dd>
	<dt>Enable eventpoll support<br>CONFIG_EPOLL</dt><dd><a href="http://blog.csdn.net/sparkliang/article/details/4770655">Epoll</a>系列系统调用(epoll_*)支持,这是当前在Linux下开发大规模并发网络程序(比如Nginx)的热门人选,设计目的是取代既有POSIX select(2)与poll(2)系统接口,systemd依赖于它.建议开启.</dd>
	<dt>Enable signalfd() system call<br>CONFIG_SIGNALFD</dt><dd><a href="http://cpp.ezbty.org/import_doc/linux_manpage/signalfd4.2.html">signalfd()</a>系统调用支持,建议开启.传统的处理信号的方式是注册信号处理函数,由于信号是异步发生的,要解决数据的并发访问和可重入问题.signalfd可以将信号抽象为一个文件描述符,当有信号发生时可以对其read,这样可以将信号的监听放到select/poll/epoll监听队列中.systemd依赖于它.</dd>
	<dt>Enable timerfd() system call<br>CONFIG_TIMERFD</dt><dd><a href="http://blog.csdn.net/walkingman321/article/details/6162055">timerfd()</a>系统调用支持,建议开启.timerfd可以实现定时器功能,将定时器抽象为文件描述符,当定时器到期时可以对其read,这样也可以放到select/poll/epoll监听队列中.更多信息可以参考<a href="http://blog.csdn.net/gdutliuyun827/article/details/8460417">linux新的API signalfd、timerfd、eventfd使用说明</a>.systemd依赖于它.</dd>
	<dt>Enable eventfd() system call<br>CONFIG_EVENTFD</dt><dd><a href="http://www.cppblog.com/peija/archive/2010/10/07/128941.html">eventfd()</a>系统调用支持,建议开启.eventfd实现了线程之间事件通知的方式,eventfd的缓冲区大小是sizeof(uint64_t),向其write可以递增这个计数器,read操作可以读取,并进行清零.eventfd也可以放到select/poll/epoll监听队列中.当计数器不是0时,有可读事件发生,可以进行读取.</dd>
</dl></dd>
<dt>Enable bpf() system call<br>CONFIG_BPF_SYSCALL</dt><dd>开启内核的<a href="http://www.man7.org/linux/man-pages/man2/bpf.2.html">bpf()</a>系统调用支持(从3.15版本开始引入),以支持<a href="http://blog.csdn.net/ljy1988123/article/details/50444693">eBPF</a>功能.可用于内核调试与网络包过滤(tcpdump,libpcap,iptables).不确定的选"N".</dd>
<dt>Use full shmem filesystem<br>CONFIG_SHMEM</dt><dd>完全使用shmem来代替ramfs.shmem是基于共享内存的文件系统(可以使用swap),在启用CONFIG_TMPFS后可以挂载为tmpfs供用户空间使用,它比简单的ramfs先进许多.仅在微型嵌入式环境中且没有swap的情况下才可能会需要使用原始的ramfs.</dd>
<dt>Enable AIO support<br>CONFIG_AIO</dt><dd>开启POSIX异步IO支持.它常常被高性能的多线程程序使用,建议开启</dd>
<dt>Enable madvise/fadvise syscalls<br>CONFIG_ADVISE_SYSCALLS</dt><dd>开启内核的<a href="http://docs.oracle.com/cd/E19253-01/819-7052/lgroups-23/">madvise()</a>/<a href="http://blog.csdn.net/vah101/article/details/7317557">fadvise()</a>系统调用支持(2.6.16版本开始引入).以允许应用程序预先提示内核,它将如何使用特定的内存与文件.这种措施有助于提升应用程序的性能.建议选"Y".</dd>
<dt>Enable userfaultfd() system call<br>CONFIG_USERFAULTFD</dt><dd>开启内核的<a href="http://xiaogr.com/?p=96">userfaultfd()</a>系统调用支持(从4.3版本开始引入).该特性可以被诸如QEMU/KVM之类的虚拟化技术用来提高GuestOS热迁移性能.</dd>
<dt>Enable PCI quirk workarounds<br>CONFIG_PCI_QUIRKS</dt><dd>开启针对多种PCI芯片组的错误规避功能,仅在确定你的PCI芯片组确实没有没有任何bug时才关闭此功能.至于究竟哪些芯片组有bug,你可以直接打开"<a href="http://lxr.linux.no/linux/drivers/pci/quirks.c">drivers/pci/quirks.c</a>"文件查看.不确定的选"Y".</dd>
<dt>Enable membarrier() system call<br>CONFIG_MEMBARRIER</dt><dd>开启内核的<a href="http://man7.org/linux/man-pages/man2/membarrier.2.html">membarrier()</a>系统调用支持(与<a href="http://blog.jobbole.com/53697/">Memory Barrier</a>相关).有助于提升多CPU场景下的并行计算性能.建议选"Y".</dd>
<dt>Embedded system<br>CONFIG_EMBEDDED</dt><dd>如果你是为嵌入式系统编译内核,可以开启此选项,这样一些高级选项就会显示出来.单独选中此项本身对内核并无任何改变.</dd>
<dt>Kernel Performance Events And Counters<br>CONFIG_PERF_EVENTS</dt><dd>性能相关的事件和计数器支持(既有硬件的支持也有软件的支持).大多数现代CPU都会通过性能计数寄存器对特定类型的硬件事件(指令执行,缓存未命中,分支预测失败)进行计数,同时又丝毫不会减慢内核和应用程序的运行速度.这些寄存器还会在某些事件计数到达特定的阈值时触发中断,从而可以对代码进行性能分析. Linux Performance Event 子系统对上述特性进行了抽象,提供了针对每个进程和每个CPU的计数器,并可以被 tools/perf/ 目录中的"perf"工具使用.</dd>
<dd><dl>
	<dt>Debug: use vmalloc to back perf mmap() buffers<br>CONFIG_DEBUG_PERF_USE_VMALLOC</dt><dd>主要用于调试vmalloc代码.</dd>
</dl></dd>
<dt>Enable VM event counters for /proc/vmstat<br>CONFIG_VM_EVENT_COUNTERS</dt><dd>"<a href="http://blog.csdn.net/plusboy/article/details/1528252">/proc/vmstat</a>"中包含了从内核导出的虚拟内存的各种统计信息.开启此项后可以显示较详细的信息(包含各种事件计数器),关闭此项则仅仅显示内存页计数.主要用于调试和统计.</dd>
<dt>Enable SLUB debugging support<br>CONFIG_SLUB_DEBUG</dt><dd>SLUB调试支持,禁用后可显著降低内核大小,同时/sys/kernel/slab也将不复存在.</dd>
<dt>Disable heap randomization<br>CONFIG_COMPAT_BRK</dt><dd>禁用堆随机化(heap randomization)功能.堆随机化可以让针对堆溢出的攻击变得困难,但是不兼容那些古董级的二进制程序(2000年以前).如果你不需要使用这些古董程序,那么选"N".</dd>
<dt>Choose SLAB allocator</dt><dd>选择内存分配管理器</dd>
<dd><dl>
	<dt>SLAB<br>CONFIG_SLAB</dt><dd>久经考验的slab内存分配器,在大多数情况下都具有良好的适应性.</dd>
	<dt>SLUB (Unqueued Allocator)<br>CONFIG_SLUB</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/">SLUB</a>与SLAB兼容,但通过取消大量的队列和相关开销,简化了slab的结构.特别是在多核时拥有比slab更好的性能和更好的系统可伸缩性.</dd>
	<dt>SLOB (Simple Allocator)<br>CONFIG_SLOB</dt><dd>SLOB针对小型系统设计,做了非常激进的简化,以适用于内存非常有限(小于64M)的嵌入式环境.</dd>
</dl></dd>
<dt>SLUB per cpu partial cache<br>CONFIG_SLUB_CPU_PARTIAL</dt><dd>让SLUB内存分配器使用基于每个CPU的局部缓存,这样可以加速分配和释放属于此CPU范围内的对象,但这样做的代价是增加对象释放延迟的不确定性.因为当这些局部缓存因为溢出而要被清除时,需要使用锁,从而导致延迟尖峰.对于需要快速响应的实时系统,应该选"N",服务器则可以选"Y".</dd>
<dt>Provide system-wide ring of trusted keys<br>CONFIG_SYSTEM_TRUSTED_KEYRING</dt><dd>在内核中创建一个密钥环,从而允许向密钥环上添加受信任的密钥,主要用于内核模块的签名.如果你开启了CONFIG_MODULE_SIG,此项将被自动选中.不需要使用内核模块签名检查功能的应该选"N"</dd>
<dt>Profiling support<br>CONFIG_PROFILING</dt><dd>添加扩展的性能分析支持,可以被<a href="http://baike.baidu.com/view/2973608.htm">OProfile</a>之类的工具使用.仅用于调试目的.</dd>
<dt>OProfile system profiling<br>CONFIG_OPROFILE</dt><dd><a href="http://blog.csdn.net/yili_xie/article/details/4925648">OProfile性能分析工具</a>支持,仅用于调试目的.</dd>
<dd><dl>
	<dt>OProfile multiplexing support<br>CONFIG_OPROFILE_EVENT_MULTIPLEX</dt><dd><a href="http://lwn.net/Articles/343812/">OProfile multiplexing技术</a>支持</dd>
</dl></dd>
<dt>Kprobes<br>CONFIG_KPROBES</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-kprobes.html">Kprobes</a>是一个轻量级的内核调试工具,能在内核运行的几乎任意时间点进行暂停/读取/修改等操作的调试工具.仅供调试使用.</dd>
<dt>Optimize very unlikely/likely branches<br>CONFIG_JUMP_LABEL</dt><dd>针对内核中某些"几乎总是为真"或者"几乎总是为假"的条件分支判断使用<a href="http://blog.csdn.net/dog250/article/details/6123517">"asm goto"</a>进行优化(在分支预测失败时会浪费很多时间在回退上,但是这种情况极少发生).很多内核子系统都支持进行这种优化.建议开启.</dd>
<dd><dl>
	<dt>Static key selftest<br>CONFIG_STATIC_KEYS_SELFTEST</dt><dd>在内核启动时对上述分支优化补丁进行一次自我检查.</dd>
</dl></dd>
<dt>Transparent user-space probes<br>CONFIG_UPROBES</dt><dd><a href="http://blog.csdn.net/badu_123/article/details/8302642">Uprobes</a>与Kprobes类似,但主要用于用户空间的调试.</dd>
<dt>Stack Protector buffer overflow detection</dt><dd>GCC的"stack-protector"功能可以在函数开始执行时,在函数的返回地址末端设置一个敏感值,当函数执行完成要返回时,检查这个敏感值,看看是否存在溢出.如果有溢出则表明可能受到了堆栈溢出攻击,内核将通过panic来阻止可能的攻击.选项中的"None"表示关闭此功能,"Regular"表示启用此功能但是仅提供较弱的保护(需要GCC-4.2及以上版本),"Strong"则表示提供较强的保护(需要GCC-4.9及以上版本)</dd>
<dt>Enable GCOV-based kernel profiling<br>CONFIG_GCOV_KERNEL</dt><dd>基于<a href="http://gcc.gnu.org/onlinedocs/gcc/Gcov.html">GCC的gcov</a>(<a href="http://blog.linezing.com/2011/03/%E4%BD%BF%E7%94%A8gcov%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E6%B5%8B%E8%AF%95">代码覆盖率测试</a>工具)的<a href="http://blog.csdn.net/livelylittlefish/article/details/6382489">代码分析</a>支持,仅用于调试</dd>
<dd><dl>
	<dt>Profile entire Kernel<br>CONFIG_GCOV_PROFILE_ALL</dt><dd>支持对整个内核进行分析.内核体积将会显著增大,并且运行速度显著减慢.</dd>
</dl></dd>
</dl>





<h2>Enable loadable module support<br />可加载模块支持</h2>
<dl>
<dt>Enable loadable module support<br>CONFIG_MODULES</dt><dd>打开可加载模块支持,可以通过"make modules_install"把内核模块安装在/lib/modules/中.然后可以使用 modprobe, lsmod, modinfo, insmod, rmmod 等工具进行各种模块操作.</dd>
<dd><dl>
	<dt>Forced module loading<br>CONFIG_MODULE_FORCE_LOAD</dt><dd>允许使用"modprobe --force"在不校验版本信息的情况下强制加载模块,这绝对是个坏主意!建议关闭.</dd>
	<dt>Module unloading<br>CONFIG_MODULE_UNLOAD</dt><dd>允许卸载已经加载的模块.如果将模块静态编译进内核中,那么内核的执行效率会更好.如果代码作为动态模块加载,那么不使用时可以减少内核的内存使用并减少启动的时间,然而内核和模块在内存上相互独立又会影响内核的执行性能.</dd>
	<dd><dl>
		<dt>Forced module unloading<br>CONFIG_MODULE_FORCE_UNLOAD</dt><dd>允许强制卸载正在使用中的模块(rmmod -f),即使可能会造成系统崩溃.这又是一个坏主意!建议关闭.</dd>
	</dl></dd>
	<dt>Module versioning support<br>CONFIG_MODVERSIONS</dt><dd>允许使用为其他内核版本编译的模块,可会造成系统崩溃.这同样是个坏主意!建议关闭.</dd>
	<dt>Source checksum for all modules<br>CONFIG_MODULE_SRCVERSION_ALL</dt><dd>为模块添加"srcversion"字段,以帮助模块维护者准确的知道编译此模块所需要的源文件,从而可以校验源文件的变动.仅内核模块开发者需要它.</dd>
	<dt>Module signature verification<br>CONFIG_MODULE_SIG</dt><dd>在<a href="http://lwn.net/Articles/470906/">加载模块</a>时检查<a href="http://lwn.net/Articles/511720/">模块签名</a>,详情参见"<a href="https://www.kernel.org/doc/Documentation/module-signing.txt">Documentation/module-signing.txt</a>"文件.[!!警告!!]开启此选项后,必须确保模块签名后没有被strip(包括rpmbuild之类的打包工具).</dd>
	<dd><dl>
		<dt>Require modules to be validly signed<br>CONFIG_MODULE_SIG_FORCE</dt><dd>仅加载已签名并且密钥正确的模块,拒绝加载未签名或者签名密钥不正确的模块</dd>
		<dt>Automatically sign all modules<br>CONFIG_MODULE_SIG_ALL</dt><dd>在执行"make modules_install"安装模块的时候,自动进行签名.否则你必须手动使用 scripts/sign-file 工具进行签名.</dd>
	</dl></dd>
	<dt>Which hash algorithm should modules be signed with?</dt><dd>选择对模块签名时使用的散列函数.建议使用强度最高的"SHA-512"算法.注意:所依赖的散列算法必须被静态编译进内核.对于"SHA-512"来说,就是CONFIG_CRYPTO_SHA512和CONFIG_CRYPTO_SHA512_SSSE3(如果你的CPU支持SSSE3指令集的话).</dd>
	<dt>Compress modules on installation<br>CONFIG_MODULE_COMPRESS</dt><dd>在'make modules_install'时对内核模块进行压缩.传统的module-init-tools工具可能支持gzip压缩,而新式的kmod可能支持gzip与xz压缩.使用Kbuild在内核树之外编译的模块也会同样在安装时被压缩.不确定的选"N".</dd>
</dl></dd>
</dl>





<h2>Enable the block layer<br />块设备支持</h2>
<dl>
<dt>Enable the block layer<br>CONFIG_BLOCK</dt><dd>块设备支持,使用SSD/硬盘/U盘/SCSI/SAS设备者必选.除非你是某些特殊的嵌入式系统,否则没有理由不使用块设备.</dd>
<dd><dl>
	<dt>Block layer SG support v4<br>CONFIG_BLK_DEV_BSG</dt><dd>为块设备启用第四版<a href="http://sg.danny.cz/sg/">SG(SCSI generic</a>)支持.v4相比v3能够支持更复杂的SCSI指令(可变长度的命令描述块,双向数据传输,通用请求/应答协议),而且UDEV也要用它来获取设备的序列号.对于使用systemd的系统来说,必须选"Y".对于不使用systemd的系统,如果你需要通过/dev/bsg/*访问块设备,建议开启此选项,否则(通过/dev/{sd*,st*,sr*})可以关闭.</dd>
	<dt>Block layer SG support v4 helper lib<br>CONFIG_BLK_DEV_BSGLIB</dt><dd>你不需要手动开启此选项,如果有其他模块需要使用,会被自动开启.</dd>
	<dt>Block layer data integrity support<br>CONFIG_BLK_DEV_INTEGRITY</dt><dd>某些块设备可以通过存储/读取额外的信息来保障<a href="http://alanwu.blog.51cto.com/3652632/1093600">端到端的数据完整性</a>,这个选项为文件系统提供了相应的钩子函数来使用这个特性.如果你的设备支持 <a href="http://www.ibm.com/developerworks/cn/aix/library/au-T10E2E/">T10/SCSI Data Integrity Field</a> 或者 T13/ATA External Path Protection 特性,那么可以开启此选项,否则建议关闭.</dd>
	<dt>Block layer bio throttling support<br>CONFIG_BLK_DEV_THROTTLING</dt><dd><a href="http://lwn.net/Articles/403200/">Bio Throttling</a> 支持,也就是允许限制每个cgroup对特定设备的IO速率.细节可以参考"<a href="https://www.kernel.org/doc/Documentation/cgroups/blkio-controller.txt">Documentation/cgroups/blkio-controller.txt</a>".</dd>
	<dt>Block device command line partition parser<br>CONFIG_BLK_CMDLINE_PARSER</dt><dd>允许通过内核引导参数设定块设备的分区信息(<a href="https://www.kernel.org/doc/Documentation/block/cmdline-partition.txt">Documentation/block/cmdline-partition.txt</a>).仅对某些嵌入式设备有意义.</dd>
	<dt>Advanced partition selection<br>CONFIG_PARTITION_ADVANCED</dt><dd>如果你想支持各种不同的磁盘分区格式(特别是与UEFI配合使用的<a href="http://www.ibm.com/developerworks/cn/linux/l-gpt/index.html">GPT</a>格式),务必选中此项.</dd>
	<dd><dl>
		<dt>Acorn partition support<br>CONFIG_ACORN_PARTITION</dt><dd>Acorn 操作系统使用的分区格式,请根据实际情况选择子项,这里省略</dd>
		<dt>Alpha OSF partition support<br>CONFIG_OSF_PARTITION</dt><dd>Alpha 平台上使用的分区格式</dd>
		<dt>Amiga partition table support<br>CONFIG_AMIGA_PARTITION</dt><dd>AmigaOS 使用的分区格式</dd>
		<dt>Atari partition table support<br>CONFIG_ATARI_PARTITION</dt><dd>Atari OS 使用的分区格式</dd>
		<dt>Macintosh partition map support<br>CONFIG_MAC_PARTITION</dt><dd>苹果的Macintosh平台使用的分区格式</dd>
		<dt>PC BIOS (MSDOS partition tables) support<br>CONFIG_MSDOS_PARTITION</dt><dd>渐成历史垃圾,但目前依然最常见的DOS分区格式.除非你确信不使用此格式,否则必选.其下的子项根据实际情况选择.</dd>
		<dt>Windows Logical Disk Manager (Dynamic Disk) support<br>CONFIG_LDM_PARTITION</dt><dd>使用 Windows Logical Disk Manager 创建的分区格式.参见"<a href="https://www.kernel.org/doc/Documentation/ldm.txt">Documentation/ldm.txt</a>"</dd>
		<dt>SGI partition support<br>CONFIG_SGI_PARTITION</dt><dd>SGI 平台上使用的分区格式</dd>
		<dt>Ultrix partition table support<br>CONFIG_ULTRIX_PARTITION</dt><dd>DEC/Compaq Ultrix 平台上使用的分区格式</dd>
		<dt>Sun partition tables support<br>CONFIG_SUN_PARTITION</dt><dd>SunOS 平台上使用的分区格式</dd>
		<dt>Karma Partition support<br>CONFIG_KARMA_PARTITION</dt><dd>Rio Karma MP3 player 使用的分区格式</dd>
		<dt>EFI GUID Partition support<br>CONFIG_EFI_PARTITION</dt><dd>代表未来趋势,眼下正大红大紫的EFI <a href="http://www.ibm.com/developerworks/cn/linux/l-gpt/index.html">GPT</a>(<a href="http://zh.wikipedia.org/zh-cn/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8">GUID Partition Table</a>)分区格式.建议开启.如果你在UEFI平台上安装则必须开启.</dd>
		<dt>SYSV68 partition table support<br>CONFIG_SYSV68_PARTITION</dt><dd>Motorola Delta 机器上使用的分区格式</dd>
	</dl></dd>
	<dt>IO Schedulers</dt><dd><a href="http://liwei.life/2016/03/14/linux_io_scheduler/">IO调度器</a>(<a href="http://blog.hesey.net/2012/02/linux-io-scheduler.html">另一篇文章</a>)</dd>
	<dd><dl>
		<dt>Deadline I/O scheduler<br>CONFIG_IOSCHED_DEADLINE</dt><dd><a href="http://blog.csdn.net/vanbreaker/article/details/8287002">deadline</a>调度器.简洁小巧(只有400+行代码),提供了最小的读取延迟,非常适合同一时间只有少数个别进程进行IO请求的情况.如果你希望尽快读取磁盘,而不介意写入延迟,那它是最佳选择.通常对于数据库工作负载有最佳的表现.</dd>
		<dt>CFQ I/O scheduler<br>CONFIG_IOSCHED_CFQ</dt><dd><a href="http://blog.csdn.net/vanbreaker/article/details/8299491">cfq</a>(<a href="http://blog.csdn.net/vanbreaker/article/details/8308766">Complete Fair Queuing</a>)调度器.努力在各内核线程间公平分配IO资源,适用于系统中存在着大量内核线程同时进行IO请求的情况.但对于只有少数内核线程进行密集IO请求的情况,则会出现明显的性能下降.</dd>
		<dd><dl>
			<dt>CFQ Group Scheduling support<br>CONFIG_CFQ_GROUP_IOSCHED</dt><dd>允许将CFQ和cgroup组合使用,也就是将每个cgroup看成一个整体,在各cgroup之间进行IO资源的分配.参见"<a href="https://www.kernel.org/doc/Documentation/cgroups/blkio-controller.txt">Documentation/cgroups/blkio-controller.txt</a>"文件.还可以参考一下《Linux内核精髓》中的"<a href="http://book.51cto.com/art/201302/381375.htm">使用Block I/O控制器</a>"一章.</dd>
		</dl></dd>
		<dt>BFQ I/O scheduler<br>CONFIG_IOSCHED_BFQ</dt><dd><a href="http://algo.ing.unimo.it/people/paolo/disk_sched/">bfq(Budget Fair Queueing)</a>调度器.这是一个基于CFQ调度器的改进版本,更适合于对交互性要求比较高的场合,比如桌面系统和实时系统.如果静态编译进内核,还支持和cgroup配合,实现分层调度(hierarchical scheduling).</dd>
		<dd><dl>
			<dt>BFQ hierarchical scheduling support<br>CONFIG_CGROUP_BFQIO</dt><dd>通过cgroup文件系统接口,允许将BFQ分层使用(类似CONFIG_CFQ_GROUP_IOSCHED),这个子系统的名字是"bfqio".</dd>
		</dl></dd>
		<dt>Default I/O scheduler</dt><dd><a href="http://www.php-oa.com/2010/01/03/linux-io-elevator.html">默认IO调度器</a>.如果上述调度器都是模块,那么将使用最简单的内置NOOP调度器.<a href="http://blog.csdn.net/vanbreaker/article/details/8278358">NOOP(No Operation)</a>调度器只是一个简单的FIFO队列,不对IO请求做任何重新排序处理(但还是会做一定程度的归并),适合于SSD/U盘/内存/虚拟机硬盘/SAN(Storage Area Networks)等<em>无需寻道</em>的存储设备,重点是可以节约CPU资源,但不适用于普通硬盘这样的需要依靠磁头来定位的设备.另外,有人说拥有<a href="http://hi.baidu.com/51raid/item/96e688b9217b85d285dd7918">TCQ</a>/<a href="http://blog.sina.com.cn/s/blog_50aa6d5b0100o4hc.html">NCQ</a>技术(能够自动重新排序)的硬盘也适合用NOOP调度器,这个说法其实并不那么合理,但笔者在此不敢断言,希望读者在严谨的测试之后再做定夺.</dd>
	</dl></dd>
</dl></dd>
</dl>





<h2>Processor type and features<br />中央处理器(CPU)类型及特性</h2>
<dl>
<dt>DMA memory allocation support<br>CONFIG_ZONE_DMA</dt><dd>允许为寻址宽度不足32位的设备(也就是ISA和<a href="http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC</a>总线设备)在<a href="http://www.ibm.com/developerworks/cn/linux/l-memmod/">物理内存</a>的前16MB范围内(也就是传统上x86_32架构的<a href="http://hfli0.blogspot.com/2010/04/why-cannt-we-remove-zonedma-from-linux.html">ZONE_DMA</a>区域)分配内存.不确定的选"N",内核中若有其它驱动(主要是某些老旧的声卡)需要它会自动选中此项.[提示]LPC总线通常和主板上的南桥物理相连,通常连接了一系列的传统设备:BIOS,PS/2键盘,PS/2鼠标,软盘,并口设备,串口设备,某些集成声卡,TPM(可信平台模块),等等.[题外话]<a href="http://blog.nlogn.cn/why-does-x86_64-not-have-zone_highmem/">x86_64已经没有ZONE_HIGHMEM了</a></dd>
<dt>Symmetric multi-processing support<br>CONFIG_SMP</dt><dd><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-smp/">SMP(对称多处理器)</a>支持,如果你有多个CPU或者使用的是多核CPU就选上.</dd>
<dt>Processor feature human-readable names<br>CONFIG_X86_FEATURE_NAMES</dt><dd>让 /proc/cpuinfo 中的CPU特性标记更具可读性.选"Y".</dd>
<dt>Support x2apic<br>CONFIG_X86_X2APIC</dt><dd><a href="http://blog.csdn.net/defeattroy/article/details/8988570">x2apic</a>支持.具有这个特性的CPU可以使用32位的APIC ID(可以支持海量的CPU),并且可以使用MSR而不是mmio去访问 local APIC (更加高效).可以通过"grep x2apic /proc/cpuinfo"命令检查你的CPU是否支持这个特性.注意:有时候还需要在BIOS中也开启此特性才真正生效.[提示]在虚拟机中,还需要VMM的支持(例如qemu-kvm).</dd>
<dt>Enable MPS table<br>CONFIG_X86_MPPARSE</dt><dd>如果是不支持acpi特性的古董级SMP系统就选上.但现今的64位系统早都已经支持acpi了,所以可以安全的关闭.</dd>
<dt>Support for extended (non-PC) x86 platforms<br>CONFIG_X86_EXTENDED_PLATFORM</dt><dd>支持非标准的PC平台: Numascale NumaChip, ScaleMP vSMP, SGI Ultraviolet. 绝大多数人都遇不见这些平台.</dd>
<dt>Numascale NumaChip<br>CONFIG_X86_NUMACHIP</dt><dd><a href="http://www.numascale.com/numa_products.html">Numascale NumaChip</a> 平台支持</dd>
<dt>ScaleMP vSMP<br>CONFIG_X86_VSMP</dt><dd><a href="http://blog.csdn.net/china_world/article/details/6574690">ScaleMP vSMP</a> 平台支持</dd>
<dt>SGI Ultraviolet<br>CONFIG_X86_UV</dt><dd><a href="http://www.visinfo.com.cn/vis4.html">SGI Ultraviolet</a> 平台支持</dd>
<dt>Intel Low Power Subsystem Support<br>CONFIG_X86_INTEL_LPSS</dt><dd>为 Intel <a href="http://ark.intel.com/zh-cn/products/codename/37530/Lynx-Point">Lynx Point</a> <a href="http://zh.wikipedia.org/wiki/PCH">PCH</a> 或更高级别芯片组中的 Intel Low Power Subsystem 技术提供支持.Lynx Point PCH 芯片组主要是为采用LGA1150的<a href="http://zh.wikipedia.org/wiki/Intel_Haswell">Haswell</a>处理器提供支持.</dd>
<dt>AMD ACPI2Platform devices support<br>CONFIG_X86_AMD_PLATFORM_DEVICE</dt><dd>为<a href="http://digi.tech.qq.com/a/20150603/009450.htm">AMD Carrizo</a>以及后继架构的I2C,UART,GPIO提供支持.</dd>
<dt>Intel SoC IOSF Sideband support for SoC platforms<br>CONFIG_IOSF_MBI</dt><dd>为主打低功耗的Intel SoC平台CPU开启"sideband"寄存器访问支持.这些CPU包括:<a href="http://diy.pconline.com.cn/608/6083956_all.html">BayTrail</a>,<a href="http://www.techbang.com/posts/23775-intel-braswell-soc-comprehensive-evolution-as-low-price-low-temperatures-but-more-powerful">Braswell</a>,<a href="http://ark.intel.com/zh-CN/products/family/79047/Intel-Quark-SoC">Quark</a></dd>
<dt>Single-depth WCHAN output<br>CONFIG_SCHED_OMIT_FRAME_POINTER</dt><dd>使用简化的 /proc/&lt;PID&gt;/wchan 值,禁用此选项会使用更加精确的wchan值(可以在"ps -l"结果的WCHAN域看到),但会轻微增加调度器消耗.</dd>
<dt>Linux guest support<br>CONFIG_HYPERVISOR_GUEST</dt><dd>如果这个内核将在<a href="http://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>里面运行就开启,否则就关闭.</dd>
<dd><dl>
	<dt>Enable paravirtualization code<br>CONFIG_PARAVIRT</dt><dd>半虚拟化(paravirtualization)支持.</dd>
	<dd><dl>
		<dt>paravirt-ops debugging<br>CONFIG_PARAVIRT_DEBUG</dt><dd>仅供调试.<a href="http://www.chenjunlu.com/2013/05/a-common-paravirtualization-interface-paravirt_ops/">paravirt-ops</a>是内核通用的半虚拟化接口.</dd>
		<dt>Paravirtualization layer for spinlocks<br>CONFIG_PARAVIRT_SPINLOCKS</dt><dd>半虚拟化的自旋锁支持.开启之后运行在虚拟机里的内核速度会加快,但是运行在物理CPU上的宿主内核运行效率会降低(最多可能会降低5%).请根据实际情况选择.</dd>
		<dt>Xen guest support<br>CONFIG_XEN</dt><dd><a href="http://zh.wikipedia.org/wiki/Xen">Xen</a>半虚拟化技术支持</dd>
	</dl></dd>
	<dt>Enable Xen debug and tuning parameters in debugfs<br>CONFIG_XEN_DEBUG_FS</dt><dd>为Xen在debugfs中输出各种统计信息和调整选项.对性能有严重影响.仅供调试.</dd>
	<dt>KVM Guest support (including kvmclock)<br>CONFIG_KVM_GUEST</dt><dd><a href="http://wiki.ubuntu.com.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>客户机支持(包括<a href="http://blog.csdn.net/defeattroy/article/details/8849701">kvmclock</a>).</dd>
	<dt>Paravirtual steal time accounting<br>CONFIG_PARAVIRT_TIME_ACCOUNTING</dt><dd>允许进行更细粒度的 task steal time 统计.会造成性能的略微降低.仅在你确实需要的时候才开启.</dd>
</dl></dd>
<dt>Memtest<br>CONFIG_MEMTEST</dt><dd>为内核添加<a href="http://www.memtest86.com/">内存测试</a>功能,也就是添加"memtest"内核引导参数以支持对内存进行"体检".仅在你确实知道这是什么东西并且确实需要的时候再开启.否则请关闭.</dd>
<dt>Processor family</dt><dd>处理器系列,请按照你实际使用的CPU选择."Generic-x86-64"表示通用于所有x86-64平台,而不是针对特定类型的CPU进行优化.</dd>
<dt>Supported processor vendors<br>CONFIG_PROCESSOR_SELECT</dt><dd>支持的CPU厂商,按实际情况选择.</dd>
<dt>Enable DMI scanning<br>CONFIG_DMI</dt><dd>允许扫描<a href="http://www.symantec.com/zh/cn/security_response/glossary/define.jsp?letter=d&word=dmi-desktop-management-interface">DMI</a>(<a href="http://www.biosrepair.com/pic/pic46.htm">Desktop Management Interface</a>)/<a href="http://blog.csdn.net/zhoudaxia/article/details/5919699">SMBIOS</a>(<a href="https://sites.google.com/site/thebackofdaniel/computer/bios/smbios-introduction">System Management BIOS</a>)以<a href="http://linux-wiki.cn/wiki/Dmidecode">获得机器的硬件配置</a>,从而对已知的bug bios进行规避.具体涉及到哪些机器可参见"drivers/acpi/blacklist.c"文件.除非确定你的机器没有bug,否则请开启此项.</dd>
<dt>GART IOMMU support<br>CONFIG_GART_IOMMU</dt><dd>为较旧的AMD Athlon64/Opteron/Turion/Sempron CPU提供<a href="http://en.wikipedia.org/wiki/Graphics_address_remapping_table">GART</a> <a href="http://server.zdnet.com.cn/files/all-1836536.htm">IOMMU</a>支持.图形地址重映射表(<a href="http://dri.freedesktop.org/wiki/GART/">Graphics Address Remapping Table</a>)可以将物理地址不连续的系统内存映射成看上去连续的图形内存交给GPU使用,是一种挖CPU内存补GPU内存机制,这种机制也可以被认为是一种"伪IOMMU"(缺乏地址空间隔离和访问控制).开启此选项以后,在内存大于3G的系统上,传统的32位总线(PCI/AGP)的设备将可以使用完全<a href="http://blog.csdn.net/peasant_lee/article/details/5594753">DMA</a>的方式直接访问原本超出32位寻址范围之外的系统内存区域.具体方法是:通过编程让设备在受GART控制的显存区域工作,然后使用GART将这个地址映射为真实的物理地址(4GB以上)来实现的.USB/声卡/IDE/SATA之类的设备常常需要它.开启此选项之后,除非同时开启了CONFIG_IOMMU_DEBUG选项或者使用了"iommu=force"内核引导参数,否则此特性仅在条件满足的情况下(内存足够大且确有支持GART的设备)激活.由于较新的AMD CPU都已配备了AMD IOMMU(应该使用CONFIG_AMD_IOMMU),故而仅建议在内存大于3G的老式AMD系统上选"Y".</dd>
<dt>IBM Calgary IOMMU support<br>CONFIG_CALGARY_IOMMU</dt><dd>IBM xSeries/pSeries 系列服务器的 <a href="http://bitsup.blogspot.com/2008/03/calgary-iommu-at-what-price.html">Calgary IOMMU</a> 支持.</dd>
<dd><dl>
	<dt>Should Calgary be enabled by default?<br>CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT</dt><dd>开启此选项表示默认启用Calgary特性,关闭此选项表示默认禁用Calgary特性(可以使用"iommu=calgary"内核引导参数开启).</dd>
</dl></dd>
<dt>Enable Maximum number of SMP Processors and NUMA Nodes<br>CONFIG_MAXSMP</dt><dd>让内核支持x86_64平台所能支持的最大SMP处理器数量和最大NUMA节点数量.主要用于调试目的.</dd>
<dt>Maximum number of CPUs<br>CONFIG_NR_CPUS</dt><dd>支持的最大CPU数量,每个CPU要占8KB的内核镜像,最小有效值是"2",最大有效值是"512".注意:这里的"CPU数量"是指"逻辑CPU数量".例如,对于一颗带有超线程技术的4核8线程CPU来说,相当于拥有8个CPU.</dd>
<dt>SMT (Hyperthreading) scheduler support<br>CONFIG_SCHED_SMT</dt><dd>Intel超线程技术(<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E5%9F%B7%E8%A1%8C%E7%B7%92">HyperThreading</a>)支持.</dd>
<dt>Multi-core scheduler support<br>CONFIG_SCHED_MC</dt><dd>针对多核CPU进行调度策略优化</dd>
<dt>Preemption Model</dt><dd>内核抢占模式</dd>
<dd><dl>
	<dt>No Forced Preemption (Server)<br>CONFIG_PREEMPT_NONE</dt><dd>禁止内核抢占,这是Linux的传统模式,可以得到最大的吞吐量,适合服务器和科学计算环境</dd>
	<dt>Voluntary Kernel Preemption (Desktop)<br>CONFIG_PREEMPT_VOLUNTARY</dt><dd>自愿内核抢占,通过在内核中设置明确的抢占点以允许明确的内核抢占,可以提高响应速度,但是对吞吐量有不利影响.适合普通桌面环境的</dd>
	<dt>Preemptible Kernel (Low-Latency Desktop)<br>CONFIG_PREEMPT</dt><dd>主动内核抢占,允许抢占所有内核代码,对吞吐量有更大影响,适合需要运行实时程序的场合或者追求最快响应速度的桌面环境.</dd>
</dl></dd>
<dt>Reroute for broken boot IRQs<br>CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS</dt><dd>这是一个对某些<a href="http://article.gmane.org/gmane.linux.acpi.devel/36842">芯片组bug</a>(在某些情况下会发送多余的"<a href="http://lwn.net/Articles/284826/">boot IRQ</a>")的修复功能.开启此选项之后,仅对有此bug的芯片组生效.要检查哪些芯片组有此bug可以查看"<a href="http://lxr.linux.no/linux/drivers/pci/quirks.c">drivers/pci/quirks.c</a>"文件中的"quirk_reroute_to_boot_interrupts_intel"函数.</dd>
<dt>Machine Check / overheating reporting<br>CONFIG_X86_MCE</dt><dd><a href="http://ilinuxkernel.com/?p=303">MCE</a>(<a href="http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&docname=c02691010">Machine Check Exception</a>)支持.让CPU检测到硬件故障(过热/数据错误)时通知内核,以便内核采取相应的措施(如显示一条提示信息或关机等).更多信息可以"man <a href="http://www.mcelog.org/">mcelog</a>"看看.可以通过"grep mce /proc/cpuinfo"检查CPU是否支持此特性,若支持建议选中,否则请关闭.当然,如果你对自己的硬件质量很放心,又是桌面系统的话,不选也无所谓.</dd>
<dd><dl>
	<dt>Intel MCE features<br>CONFIG_X86_MCE_INTEL</dt><dd>Intel CPU 支持</dd>
	<dt>AMD MCE features<br>CONFIG_X86_MCE_AMD</dt><dd>AMD CPU 支持</dd>
</dl></dd>
<dt>Machine check injector support<br>CONFIG_X86_MCE_INJECT</dt><dd>MCE注入支持,仅用于调试</dd>
<dt>Enable vsyscall emulation<br>CONFIG_X86_VSYSCALL_EMULATION</dt><dd>对过时的<a href="http://blog.tizgrape.com/lkd%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9Avsyscall%E5%92%8Cvdso/">vsyscall</a>页提供仿真支持.禁用此项大致相当于使用"vsyscall=none"内核引导参数(差别在于当应用程序使用vsyscall时将直接崩溃(segfault)而不会产生警告消息).许多2013年之前编译的程序(也可能包括某些新近编译的程序)需要使用此特性.</dd>
<dt>Enable support for 16-bit segments<br>CONFIG_X86_16BIT</dt><dd>如果你需要使用Wine运行那些古董级的16位保护模式程序,就选"Y",否则选"N"</dd>
<dt>Dell laptop support<br>CONFIG_I8K</dt><dd>Dell Inspiron 8000 笔记本的 <a href="http://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> 驱动(<a href="http://my.oschina.net/MinGKai/blog/138554">i8k</a>).该驱动可以读取CPU温度和风扇转速,进而帮助<a href="http://people.debian.org/~dz/i8k/">上层工具</a>控制风扇转速.该驱动仅针对 Dell Inspiron 8000 笔记本进行过测试,所以不保证一定能适用于其他型号的Dell笔记本.</dd>
<dt>CPU microcode loading support<br>CONFIG_MICROCODE</dt><dd>CPU的<a href="http://www.whitecell.org/list.php?id=42">微代码更新</a>支持,建议选中.CPU的微代码更新就像是给CPU打补丁,用于纠正CPU的行为.更新微代码的常规方法是升级BIOS,但是也可以在Linux启动后更新.比如在Gentoo下,可以使用"emerge microcode-ctl"安装<a href="http://wiki.gentoo.org/wiki/Intel_microcode">microcode-ctl</a>服务,再把这个服务加入boot运行级即可在每次开机时自动更新CPU微代码.其他Linux系统可以参考<a href="http://bbs.chinaunix.net/thread-2178586-1-1.html">这个帖子</a>.</dd>
<dd><dl>
	<dt>Intel microcode loading support<br>CONFIG_MICROCODE_INTEL</dt><dd><a href="http://www.intel.com/content/www/cn/zh/search.html?context=1047413&tab=767193&keyword=%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">Intel CPU 微代码</a>支持</dd>
	<dt>AMD microcode loading support<br>CONFIG_MICROCODE_AMD</dt><dd>AMD CPU 微代码支持</dd>
</dl></dd>
<dt>Early load microcode<br>CONFIG_MICROCODE_INTEL_EARLY</dt><dd>支持从initrd镜像首部加载微代码,以便尽可能早的更新CPU微代码.即使在initrd首部并未嵌入微代码也不会造成问题,所以"Y"是安全的.不过你真的需要吗?笔者认为你一般并不需要:)</dd>
<dt>/dev/cpu/*/msr - Model-specific register support<br>CONFIG_X86_MSR</dt><dd>允许用户空间的特权进程(使用rdmsr与wrmsr指令)访问x86的<a href="http://blog.csdn.net/edonlii/article/details/8685713">MSR寄存器</a>(<a href="http://en.wikipedia.org/wiki/Model-specific_register">Model-Specific Register</a>)以访问CPU的很多重要的参数.MSR是非标准寄存器,主要用于读取CPU的工作状态(频率/电压/功耗/温度/性能等),以及设置CPU的工作参数(触发特定的CPU特性,依CPU的不同而不同).<a href="http://www.coreboot.org/Msrtool">msrtool</a>工具可以转储出MSR的内容.不确定的可以选"M".</dd>
<dt>/dev/cpu/*/cpuid - CPU information support<br>CONFIG_X86_CPUID</dt><dd>允许用户空间的特权进程使用<a href="http://www.cnblogs.com/fence/archive/2010/05/27/1745742.html">CPUID</a>指令获得详细的<a href="http://wenku.baidu.com/view/4105c609bb68a98271fefaf8.html">CPU信息</a>(<a href="http://www.mouseos.com/arch/CPUID.html">CPUID</a>):CPU类型,型号,制造商信息,商标信息,序列号,缓存等.不确定的可以选"M".</dd>
<dt>Enable 1GB pages for kernel pagetables<br>CONFIG_DIRECT_GBPAGES</dt><dd>允许<a href="http://www.sigma.me/2011/01/22/mem-page-tlb.html">内核页表</a>使用大小为1GB的<a href="http://wiki.debian.org/Hugepages">Hugepages</a>并进行直线映射(linear mapping),需要高端CPU的支持(可以用"grep pdpe1gb /proc/cpuinfo"命令检查).这可以减小<a href="http://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80">页表缓存</a>(<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">Translation Lookaside Buffer</a>)的压力,从而提升系统的性能,这对于拥有海量内存并且运行某些特定应用(PosgreSQL,MySQL,Java,Memcached,KVM,Xen...)的系统来说比较有意义.如果你的CPU支持,可以选"Y".</dd>
<dt>Numa Memory Allocation and Scheduler Support<br>CONFIG_NUMA</dt><dd>开启 <a href="http://www.ibm.com/developerworks/cn/linux/l-numa/index.html">NUMA(Non Uniform Memory Access)</a> 支持.虽然说集成了内存控制器的CPU都属于NUMA架构.但事实上,对于大多数只有一颗物理CPU的个人电脑而言,即使支持NUMA架构,也没必要开启此特性.可以参考<a href="http://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html">SMP/NUMA/MPP体系结构对比</a>.此外,对于不支持"虚拟NUMA",或"虚拟NUMA"被禁用的虚拟机(即使所在的物理机是NUMA系统),也应该关闭此项.</dd>
<dt>Old style AMD Opteron NUMA detection<br>CONFIG_AMD_NUMA</dt><dd>因为AMD使用一种旧式的方法读取NUMA配置信息(新式方法是CONFIG_X86_64_ACPI_NUMA),所以如果你使用的是AMD多核CPU,建议开启.不过,即使开启此选项,内核也会优先尝试CONFIG_X86_64_ACPI_NUMA方法,仅在失败后才会使用此方法,所以即使你不能确定CPU的类型也可以安全的选中此项.</dd>
<dt>ACPI NUMA detection<br>CONFIG_X86_64_ACPI_NUMA</dt><dd>使用基于 ACPI SRAT(System Resource Affinity Table) 技术的NUMA节点探测方法.这也是检测NUMA节点信息的首选方法,建议选中.</dd>
<dt>NUMA emulation<br>CONFIG_NUMA_EMU</dt><dd>仅供开发调试使用</dd>
<dt>Maximum NUMA Nodes (as a power of 2)<br>CONFIG_NODES_SHIFT</dt><dd>允许的最大NUMA节点数.需要注意其计算方法:最大允许节点数=2<sup>CONFIG_NODES_SHIFT</sup>.也就是说这里设置的值会被当做2的指数使用.取值范围是[1,10],也就最多允许1024个节点.</dd>
<dt>Memory model</dt><dd><a href="http://wangcong.org/blog/archives/2043">内存模式</a>."Sparse Memory"主要用来支持内存热插拔,相比其他两个旧有的内存模式,代码复杂性也比较低,而且还拥有一些性能上的优势,对某些架构而言是唯一的可选项.其他两个旧有的内存模式是:"<a href="http://www.technovelty.org/linux/discontiguous-memory.html">Discontiguous Memory</a>"和"<a href="http://zh.wikipedia.org/wiki/%E5%B9%B3%E9%9D%A2%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%BC%8F">Flat Memory</a>".</dd>
<dt>Sparse Memory virtual memmap<br>CONFIG_SPARSEMEM_VMEMMAP</dt><dd>对于64位CPU而言,开启此选项可以简化pfn_to_page/page_to_pfn的操作,从而提高内核的运行效率.但是在32位平台则建议关闭.更多细节可以参考<a href="http://markmail.org/message/x3hpe4sapu4iegga">这个帖子</a>.</dd>
<dt>Enable to assign a node which has only movable memory<br>CONFIG_MOVABLE_NODE</dt><dd>允许对一个完整的NUMA节点(CPU和对应的内存)进行热插拔.一般的服务器和个人电脑不需要这么高级的特性.</dd>
<dt>Allow for memory hot-add<br>CONFIG_MEMORY_HOTPLUG</dt><dd>支持向运行中的系统添加内存.也就是内存热插支持.</dd>
<dd><dl>
	<dt>Allow for memory hot remove<br>CONFIG_MEMORY_HOTREMOVE</dt><dd>支持从运行中的系统移除内存.也就是内存热拔支持.</dd>
</dl></dd>
<dt>Allow for balloon memory compaction/migration<br>CONFIG_BALLOON_COMPACTION</dt><dd>允许规整/合并泡状内存(<a href="http://smilejay.com/2012/11/kvm-ballooning-overview/">balloon memory</a>).内存的<a href="http://delxu.blog.51cto.com/975660/288682">Ballooning技术</a>是指虚拟机在运行时动态地调整它所占用的宿主机内存资源,该技术在节约内存和灵活分配内存方面有明显的优势,目前所有主流虚拟化方案都支持这项技术(前提是客户机操作系统中必须安装有相应的balloon驱动).由于内存的动态增加和减少会导致内存过度碎片化,特别是对于2M尺寸的连续大内存页来说更加严重,从而严重降低内存性能.允许balloon内存压缩和迁移可以很好的解决在客户机中使用大内存页时内存过度碎片化问题.如果你打算在虚拟机中使用大内存页(huge page),那么建议开启,否则建议关闭.</dd>
<dt>Allow for memory compaction<br>CONFIG_COMPACTION</dt><dd>允许对<a href="http://www.dbafan.com/blog/?p=435">大内存页(huge pages)</a>进行<a href="http://lwn.net/Articles/368869/">规整</a>.主要是为了解决大内存页的碎片问题.建议在使用大内存页的情况下开启此项,否则建议关闭.</dd>
<dt>Page migration<br>CONFIG_MIGRATION</dt><dd>允许在保持虚拟内存页地址不变的情况下移动其所对应的物理内存页的位置.这主要是为了解决两个问题:(1)在NUMA系统上,将物理内存转移到相应的节点上,以加快CPU与内存之间的访问速度.(2)在分配大内存页的时候,可以避免碎片问题.</dd>
<dt>Enable bounce buffers<br>CONFIG_BOUNCE</dt><dd>为那些不能直接访问所有内存范围的驱动程序开启<a href="http://blog.csdn.net/force_eagle/article/details/7723772">bounce buffer</a>支持.当CONFIG_ZONE_DMA被开启后,这个选项会被默认开启(当然,你也可以在这里手动关闭).这主要是为了那些不具备<a href="http://blog.csdn.net/force_eagle/article/details/7744896">IOMMU</a>功能的PCI/ISA设备而设,但它对性能有些不利影响.在支持IOMMU的设备上,应该关闭它而是用IOMMU来代替.</dd>
<dt>Enable KSM for page merging<br>CONFIG_KSM</dt><dd><a href="http://buycloud.com.cn/wordpress/?p=348">KSM</a>(<a href="http://blog.chinaunix.net/uid-20794164-id-3601786.html">Kernel Samepage Merging</a>)支持:周期性的扫描那些被应用程序标记为"可合并"的地址空间,一旦发现有内容完全相同的页面,就将它们合并为同一个页面,这样就可以节约内存的使用,但对性能有不利影响.推荐和内核虚拟机KVM(<a href="https://www.kernel.org/doc/Documentation/vm/ksm.txt">Documentation/vm/ksm.txt</a>)或者其他支持"MADV_MERGEABLE"特性的应用程序一起使用.KSM并不默认开启,仅在应用程序设置了"MADV_MERGEABLE"标记,并且 /sys/kernel/mm/ksm/run 被设为"1"的情况下才会生效.</dd>
<dt>Low address space to protect from user allocation<br>CONFIG_DEFAULT_MMAP_MIN_ADDR</dt><dd>2009年,内核曾经爆过一个严重的<a href="http://baoz.net/linux-sockops-wrap-proto-ops-local-root-exploit/">NULL指针漏洞</a>,由于其根源是将NULL指针映射到地址"0"所致,所以从2.6.32版本以后,为了防止此类漏洞再次造成严重后果,特别设置了此选项,用于指定受保护的内存低端地址范围(可以在系统运行时通过 <a href="http://wiki.debian.org/mmap_min_addr">/proc/sys/vm/mmap_min_addr</a> 进行调整),这个范围内的地址禁止任何用户态程序的写入,以从根本上堵死此类漏洞可能对系统造成的损害.但内核这种强加的限制,对于需要使用vm86系统调用(用于在保护模式的进程中模拟8086的实模式)或者需要映射此低端地址空间的程序(bitbake,dosemu,qemu,wine,...)来说,则会造成不兼容,不过目前这些程序的新版本都进行了改进,以适应内核的这种保护.一般情况下,"4096"是个明智的选择,或者你也可以保持默认值.</dd>
<dt>Enable recovery from hardware memory errors<br>CONFIG_MEMORY_FAILURE</dt><dd>在具备<a href="http://en.wikipedia.org/wiki/Machine_check_architecture">MCA(Machine Check Architecture)</a>恢复机制的系统上,允许内核在物理内存中的发生数据错误的情况下,依然坚强的纠正错误并恢复正常运行.这需要有相应的硬件(通常是ECC内存)支持.有<a href="http://www.zzec.cn/help/html/?138.html">ECC内存</a>的选,没有的就别选了.</dd>
<dd><dl>
	<dt>HWPoison pages injector<br>CONFIG_HWPOISON_INJECT</dt><dd>仅用于调试.</dd>
</dl></dd>
<dt>Transparent Hugepage Support<br>CONFIG_TRANSPARENT_HUGEPAGE</dt><dd>大多数现代计算机体系结构都支持多种不同的<a href="http://en.wikipedia.org/wiki/Page_%28computer_memory%29">内存页面</a>大小(比如x86_64支持4K和2M以及1G[需要cpu-flags中含有"pdpe1gb"]).大于4K的内存页被称为"<a href="http://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/">大页</a>"(<a href="https://wiki.debian.org/Hugepages">Hugepage</a>).<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>(<a href="http://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80">页表缓存</a>)是位于CPU内部的<a href="http://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81%E8%A1%A8">分页表</a>(虚拟地址到物理地址的映射表)缓冲区,既高速又很宝贵(尺寸很小).如果系统内存很大(大于4G)又使用4K的内存页,那么分页表将会变得很大而难以在CPU内缓存,从而导致较高的TLB不命中概率,进而降低系统的运行效率.开启大内存页支持之后,就可以使用大页(2M或1G),从而大大缩小分页表的尺寸以大幅提高TLB的命中率,进而<a href="http://kenwublog.com/tune-large-page-for-jvm-optimization">优化系统性能</a>.传统上使用大内存页的方法是通过Hugetlbfs虚拟文件系统(CONFIG_HUGETLBFS),但是hugetlbfs需要专门进行配置以及应用程序的特别支持.所以从2.6.38版本开始引入了<a href="http://lp007819.wordpress.com/2011/03/23/kernel-2-6-38-%E7%89%B9%E6%80%A7-transparent-huge-pages/">THP</a>(<a href="http://blog.chinaunix.net/uid-26489617-id-3205109.html">Transparent Hugepages</a>),目标是替代先前的Hugetlbfs虚拟文件系统(CONFIG_HUGETLBFS).THP允许内核在可能的条件下,透明的(对应用程序来说)<a href="http://lenky.info/2012/03/03/linux%E4%B8%8Bhugetlbpage%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">使用大页</a>(<a href="http://www.dbaleet.org/tag/hugepages/">huge pages</a>)与<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/">HugeTLB</a>,THP不像hugetlbfs那样需要专门进行配置以及应用程序的特别支持.THP将这一切都交给操作系统来完成,也不再需要额外的配置,对于应用程序完全透明,因而可用于更广泛的应用程序.这对于数据库/KVM等需要使用大量内存的应用来说,可以提升其效能,但对于内存较小(4G或更少)的个人PC来说就没啥必要了.详见"<a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">Documentation/vm/transhuge.txt</a>"文档.</dd>
<dd><dl>
	<dt>Transparent Hugepage Support sysfs defaults</dt><dd>设置 /sys/kernel/mm/transparent_hugepage/enabled 文件的默认值."always"表示总是对所有应用程序启用透明大内存页支持,"madvise"表示仅对明确要求该特性的程序启用.建议选"always".</dd>
</dl></dd>
<dt>Cross Memory Support[Enable process_vm_readv/writev syscalls]<br>CONFIG_CROSS_MEMORY_ATTACH</dt><dd><a href="http://lwn.net/Articles/405284/">交叉内存</a>支持,也就是<a href="http://bookjovi.iteye.com/blog/1229689">process_vm_readv()和process_vm_writev()系统调用</a>支持.从而允许有权限的进程直接读取/写入另外一个进程的地址空间.现在它们只用于<a href="http://www.cnblogs.com/jpcflyer/archive/2012/03/04/2379048.html">openMPI</a>快速进程通信,也可以用于调试程序.未来也许还会有其他用途.</dd>
<dt>Enable cleancache driver to cache clean pages if tmem is present<br>CONFIG_CLEANCACHE</dt><dd><a href="http://lwn.net/Articles/386090/">Cleancache</a>是内核VFS层新增的特性,可以被看作是内存页的"<a href="http://memcache.drivehq.com/memparam/Bench/Other/VictimCache.htm">Victim Cache</a>"(<a href="http://sse.tongji.edu.cn/arch/arch_course/architecture/chapter4/lecture4/htm/lecture4_6.htm">受害者缓存</a>),当回收内存页时,先不把它清空,而是把其加入到内核不能直接访问的"<a href="http://sohulinux.blog.sohu.com/183867412.html">transcendent memory</a>"中,这样支持Cleancache的文件系统再次访问这个页时可以直接从"transcendent memory"加载它,从而减少磁盘IO的损耗.目前只有<a href="http://lwn.net/Articles/397574/">zcache</a>和<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>支持"transcendent memory",不过将来会有越来越多的应用支持.开启此项后即使此特性不能得到利用,也仅对性能有微小的影响,所以建议开启.更多细节请参考"<a href="https://www.kernel.org/doc/Documentation/vm/cleancache.txt">Documentation/vm/cleancache.txt</a>"文件.</dd>
<dt>Enable frontswap to cache swap pages if tmem is present<br>CONFIG_FRONTSWAP</dt><dd><a href="http://lwn.net/Articles/386090/">Frontswap</a>是和Cleancache非常类似的东西,在传统的swap前加一道内存缓冲(同样位于"transcendent memory"中).目的也是减少swap时的磁盘读写.CONFIG_ZSWAP依赖于它,建议开启.</dd>
<dt>Contiguous Memory Allocator<br>CONFIG_CMA</dt><dd>这是一个分配连续物理内存页面的分配器.一些比较低端的DMA设备只能访问连续的物理内存,同时透明大内存页也需要连续的物理内存.传统的解决办法是在系统启动时,在内存还很充足的时候,先预留一部分连续物理内存页面,留作后用,但这部分内存就无法被挪作他用了,为了可能的分配需求,预留这么一大块内存,并不是一个明智的方法.而<a href="http://blog.csdn.net/21cnbao/article/details/7309757">连续内存分配器</a>(<a href="http://lwn.net/Articles/447405/">Contiguous Memory Allocator</a>)可以做到允许这部分预留的内存被正常使用,仅在确实需要的时候才将大块的连续物理内存分配给相应的驱动程序.这个机制对于那些不支持I/O map和scatter-gather的设备很有作用.详情参见"include/linux/dma-contiguous.h"文件.此选项仅对嵌入式系统有意义,不确定的选"N".</dd>
<dt>Track memory changes<br>CONFIG_MEM_SOFT_DIRTY</dt><dd>在内核页表的PTE(Page Table Entry)数据结构上添加一个"soft-dirty"位以追踪内存页内容的变化.此特性基本上专用于<a href="http://criu.org">CRIU(Checkpoint/Restore In Userspace)</a>项目(可以帮助容器进行热迁移).不确定的选"N".</dd>
<dt>Compressed cache for swap pages<br>CONFIG_ZSWAP</dt><dd><a href="http://blog.druggo.org/post/2014/05/02/ZSWAP-ZRAM">ZSWAP</a>是一个放置在swap前面的压缩缓存,它可以将需要换出的页压缩存放在内存中的压缩池里,这样在压缩池没有满的时候,可以避免使用真正的swap设备.当压缩池满的时候,则把最老的页解压后写入swap设备.压缩池默认是内存总量的20%(/sys/module/zswap/parameters/max_pool_percent).<a href="https://zh.wikipedia.org/wiki/Zswap">ZSWAP</a>不仅提升了swap的整体性能,也变相的增加了swap空间.选中此项后,可以通过"zswap.enabled=1"内核引导参数开启此功能.</dd>
<dt>Common API for compressed memory storage<br>CONFIG_ZPOOL</dt><dd>通用的<a href="http://kernel.taobao.org/index.php?title=%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A52013-04#In-kernel_memory_compression">内存压缩API</a>,主要用于给zbud(zswap)或zsmalloc提供支持.不确定的选"N",如果内核有其他选项依赖于它会自动选中.</dd>
<dt>Low density storage for compressed pages<br>CONFIG_ZBUD</dt><dd>专用于zswap内部的低密度内存压缩API,最多允许将两个物理内存页压缩为一个压缩内存页,这既有优势(简单的空间收集及空闲空间复用)也有劣势(潜在的低内存利用率).此种算法还能确保压缩后的内存页不会比最初未压缩页数多.不确定的选"N".</dd>
<dt>Memory allocator for compressed pages<br>CONFIG_ZSMALLOC</dt><dd><a href="http://lwn.net/Articles/477067/">zsmalloc</a>压缩内存分配器主要用于给<a href="http://zh.wikipedia.org/zh-cn/Zram">zram</a>提供支持,建议与CONFIG_ZRAM同开关.参考:<a href="http://kernel.taobao.org/index.php/%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A52013-04#In-kernel_memory_compression">3种内存压缩方案对比</a>.</dd>
<dd><dl>
	<dt>Use page table mapping to access object in zsmalloc<br>CONFIG_PGTABLE_MAPPING</dt><dd>zsmalloc默认使用基于内存复制的对象映射方法来访问跨越不同页面的区域,但如果某些架构(例如ARM)执行虚拟内存映射的速度快于内存复制,那么应该将此项选"Y",这将导致zsmalloc使用页表映射而不是内存复制来进行对象的映射.你可以在你的系统上使用"https://github.com/spartacus06/zsmapbench"脚本来测试这两种方法的速度差异.在x86_64平台上,Debian8与Fedora22与openSUSE13此项默认为"N",而Ubuntu15此项默认为"Y",作者本人未测试过哪个更合理.</dd>
</dl></dd>
<dt>Enable idle page tracking<br>CONFIG_IDLE_PAGE_TRACKING</dt><dd>此特性跟踪哪些用户页面需要被工作负载使用,哪些用户页面处于闲置状态.此信息(/sys/kernel/mm/page_idle)可用于确定工作负载需要的用户内存大小.从而帮助调优内存cgroup限制以及决定将此任务放置到集群中的那台机器上.参见<a href="https://www.kernel.org/doc/Documentation/vm/idle_page_tracking.txt">Documentation/vm/idle_page_tracking.txt</a>文档.不确定的选"N".</dd>
<dt>Support non-standard NVDIMMs and ADR protected memory<br>CONFIG_X86_PMEM_LEGACY</dt><dd>支持 Intel Sandy Bridge-EP 处理器使用的不符合<a href="http://servers.pconline.com.cn/522/5222919.html">NVDIMM</a>规范的<a href="http://alanwu.blog.51cto.com/3652632/1618303">非易失内存</a>(以电容做后备电力且掉电后不会丢失数据的内存).仅有某些高端服务器才会使用这种外带电容供电的内存.</dd>
<dt>Check for low memory corruption<br>CONFIG_X86_CHECK_BIOS_CORRUPTION</dt><dd>低位内存脏数据检查,即使开启此选项,默认也不会开启此功能(需要明确使用"memory_corruption_check=1"内核引导选项).这些脏数据通常被认为是有bug的BIOS引起的,默认每60秒(可以通过memory_corruption_check_period内核参数进行调整)扫描一次0-64k(可以通过memory_corruption_check_size内核参数进行调整)之间的区域.这种检查所占用的开销非常小,基本可以忽略不计.如果始终检查到错误,则可以通过"memmap="内核引导参数来避免使用这段内存.一般没必要选中,如果你对BIOS不放心,带着它试运行一段时间,确认没问题之后再去掉.</dd>
<dd><dl>
	<dt>Set the default setting of memory_corruption_check<br>CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK</dt><dd>设置memory_corruption_check的默认值,选中表示默认开启(相当于使用"memory_corruption_check=1"内核引导选项),不选中表示默认关闭.</dd>
</dl></dd>
<dt>Amount of low memory, in kilobytes, to reserve for the BIOS<br>CONFIG_X86_RESERVE_LOW</dt><dd>为BIOS设置保留的低端地址(默认是64K).内存的第一页(4K)存放的必定是BIOS数据,内核不能使用,所以必须要保留.但是有许多BIOS还会在suspend/resume/热插拔等事件发生的时候使用更多的页(一般在0-64K范围),所以默认保留0-64K范围.如果你确定自己的BIOS不会越界使用内存的话,可以设为"4",否则请保持默认值.但是也有一些很奇葩的BIOS会使用更多的低位内存,这种情况下可以考虑设为"640"以保留所有640K的低位内存区域.</dd>
<dt>MTRR (Memory Type Range Register) support<br>CONFIG_MTRR</dt><dd><a href="http://blog.csdn.net/arethe/article/details/6248448">MTRR</a>(<a href="http://blog.chinaunix.net/uid-25871104-id-3140904.html">Memory type range registers</a>)是CPU内的一组MSR(Model-specific registers),其作用是告诉CPU以哪种模式(write-back/uncachable)存取各内存区段效率最高.这对于AGP/PCI显卡意义重大,因为write-combining技术可以将若干个总线写传输捆绑成一次较大的写传输操作,可以将图像写操作的性能提高2.5倍或者更多.这段代码有着通用的接口,其他CPU的寄存器同样能够使用该功能.简而言之,开启此选项是个明智的选择.</dd>
<dd><dl>
	<dt>MTRR cleanup support<br>CONFIG_MTRR_SANITIZER</dt><dd><a href="http://en.wikipedia.org/wiki/Memory_type_range_register">MTRR cleanup</a>的意思是将MTRR的连续输出转为离散的输出,这样X驱动就可以在其中添加writeback项,算是一种优化措施.建议开启.可以使用"mtrr_chunk_size"来限制最大的连续块尺寸.</dd>
	<dd><dl>
		<dt>MTRR cleanup enable value (0-1)<br>CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT</dt><dd>"1"表示默认开启CONFIG_MTRR_SANITIZER特性,相当于使用"enable_mtrr_cleanup","0"表示默认关闭CONFIG_MTRR_SANITIZER特性,相当于使用"disable_mtrr_cleanup".建议设为"1".</dd>
		<dt>MTRR cleanup spare reg num (0-7)<br>CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT</dt><dd>这里设定的值等价于使用内核引导参数"mtrr_spare_reg_nr=N"中的"N".也就是告诉内核reg0N可以被清理或改写(参见"/proc/mtrr"文件).在多数情况下默认值是"1",其含义是 /proc/mtrr 中的 reg01 将会被映射.一般保持其默认值即可.修改此项的值通常是为了解决某些<a href="http://my-fuzzy-logic.de/blog/index.php?/archives/41-Solving-linux-MTRR-problems.html">MTRR故障</a>.</dd>
	</dl></dd>
	<dt>x86 PAT support<br>CONFIG_X86_PAT</dt><dd><a href="http://blog.csdn.net/arethe/article/details/6238335">PAT(Page Attribute Table)</a>是对MTRR的补充,且比MTRR更灵活.如果你的CPU支持PAT(grep pat /proc/cpuinfo),那么建议开启.仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭.</dd>
</dl></dd>
<dt>x86 architectural random number generator<br>CONFIG_ARCH_RANDOM</dt><dd>Intel 从 <a href="http://zh.wikipedia.org/wiki/Intel_Ivy_Bridge">Ivy Bridge</a> 微架构开始(对于Atom来说是从Silvermont开始),在CPU中集成了一个高效的硬件随机数生成器(称为"Bull Mountain"技术),并引入了一个新的x86指令"<a href="http://en.wikipedia.org/wiki/RdRand">RDRAND</a>",可以非常高效的产生随机数.此选项就是对此特性的支持.</dd>
<dt>Supervisor Mode Access Prevention<br>CONFIG_X86_SMAP</dt><dd><a href="http://lwn.net/Articles/517475/">SMAP(Supervisor Mode Access Prevention)</a>是Intel从<a href="http://zh.wikipedia.org/wiki/Intel_Haswell">Haswell</a>微架构开始引入的一种新特征,它在CR4寄存器上引入一个新标志位SMAP,如果这个标志为1,内核访问用户进程的地址空间时就会触发一个页错误,目的是为了防止内核因为自身错误意外访问用户空间,这样就可以避免一些内核漏洞所导致的安全问题.但是由于内核在有些时候仍然需要访问用户空间,因此intel提供了两条指令STAC和CLAC用于临时打开/关闭这个功能,反复使用STAC和CLAC会带来一些轻微的性能损失,但考虑到增加的安全性,还是建议开启.</dd>
<dt>Intel MPX (Memory Protection Extensions)<br>CONFIG_X86_INTEL_MPX</dt><dd><a href="https://software.intel.com/en-us/taxonomy/term/43113">Intel MPX</a>(内存保护扩展)是一种用于检测缓冲区溢出bug的硬件特性.此选项并非用于保护内核自身,而是用于允许应用程序利用MPX特性.可以通过"grep mpx /proc/cpuinfo"检查你的CPU是否支持MPX特性.详见<a href="https://www.kernel.org/doc/Documentation/x86/intel_mpx.txt">Documentation/x86/intel_mpx.txt</a>文档.不确定的选"N".</dd>
<dt>EFI runtime service support<br>CONFIG_EFI</dt><dd><a href="http://baike.baidu.com/view/196503.htm">EFI/UEFI</a>支持.如果你打算<a href="http://wiki.gentoo.org/wiki/UEFI_Gentoo_Quick_Install_Guide">在UEFI/EFI平台上安装Linux</a>(2010年之后的机器基本都已经是UEFI规格了),那么就必须开启此项(开启后也依然可以在传统的BIOS机器上启动).<a href="http://blog.woodelf.org/2014/05/28/how-uefi-works-translated/">UEFI启动流程</a>与传统的BIOS相差很大.虽然Linux受到了所谓"<a href="http://blogs.msdn.com/b/b8_cn/archive/2011/09/27/uefi.aspx">安全启动</a>"问题的阻挠(已经<a href="http://news.mydrivers.com/1/254/254690.htm">解决</a>),但是UEFI依然将迅速一统江湖.[提示]在UEFI平台上安装Linux的关键之一是首先要用一个支持UEFI启动的LiveCD以UEFI模式启动机器.</dd>
<dd><dl>
	<dt>EFI stub support<br>CONFIG_EFI_STUB</dt><dd><a href="http://wiki.gentoo.org/wiki/EFI_stub_kernel">EFI stub</a> 支持.如果开启此项,就可以不通过GRUB2之类的引导程序来加载内核,而直接由EFI固件进行加载,这样就可以不必安装引导程序了.不过这是一个看上去很美的特性,由于EFI固件灵活性比GRUB2差许多,所以缺点有三:(1)不能在传统的BIOS机器上启动.(2)给内核传递引导参数很麻烦(需要使用"efibootmgr -u").(3)不能使用intrd.不过,针对后两点的解决办法是:使用CONFIG_CMDLINE和CONFIG_INITRAMFS_SOURCE.更多细节可参考"<a href="https://www.kernel.org/doc/Documentation/x86/efi-stub.txt">Documentation/x86/efi-stub.txt</a>"文档.</dd>
	<dd><dl>
		<dt>EFI mixed-mode support<br>CONFIG_EFI_MIXED</dt><dd>允许在32位固件上启动64位内核.选"N".</dd>
	</dl></dd>
</dl></dd>
<dt>Enable seccomp to safely compute untrusted bytecode<br>CONFIG_SECCOMP</dt><dd>允许使用<a href="http://plaintext.blog.edu.cn/2010/553458.html">SECCOMP</a>技术安全地运算非信任代码.通过使用管道或其他进程可用的通信方式作为文件描述符(支持读/写调用),就可以利用SECCOMP把这些应用程序隔离在它们自己的地址空间.这是一种有效的安全沙盒技术.systemd也强烈建议开启它.除非你是嵌入式系统,否则不要关闭.</dd>
<dt>Enable -fstack-protector buffer overflow detection<br>CONFIG_CC_STACKPROTECTOR</dt><dd>开启GCC的"-fstack-protector"命令行选项,以使用<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/">GCC中的编译器堆栈保护技术</a>.这样可以有效的防御以堆栈溢出为代表的缓冲区溢出攻击,不过系统的运行速度也会受到一些影响.服务器之类强调安全的场合建议开启,个人PC之类的就不是很有必要了.</dd>
<dt>Timer frequency</dt><dd>内核时钟频率.对于要求快速响应的场合,比如桌面环境,建议使用1000Hz,而对于不需要快速响应的SMP/NUMA服务器,建议使用250Hz或100Hz或300Hz(主要处理多媒体数据).</dd>
<dt>kexec system call<br>CONFIG_KEXEC</dt><dd>提供<a href="http://www.ibm.com/developerworks/cn/linux/l-kexec/">kexec</a>系统调用,可以<a href="http://www.linuxsir.org/bbs/thread335331.html">不必重启而切换到另一个内核</a>(不一定必须是Linux内核),不过这个特性并不总是那么可靠.如果你不确定是否需要它,那么就是不需要.</dd>
<dt>kernel crash dumps<br>CONFIG_CRASH_DUMP</dt><dd>当内核崩溃时自动导出运行时信息的功能,主要用于调试目的.更多信息请参考"<a href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt">Documentation/kdump/kdump.txt</a>"文件.</dd>
<dt>kexec jump<br>CONFIG_KEXEC_JUMP</dt><dd><a href="http://lwn.net/Articles/263286/">kexec jump</a> 支持.这是对CONFIG_KEXEC的增强功能,仅在你确实明白这是干啥的情况下再开启,否则请关闭.</dd>
<dt>Physical address where the kernel is loaded<br>CONFIG_PHYSICAL_START</dt><dd>加载内核的物理地址.如果内核不是可重定位的(CONFIG_RELOCATABLE=n),那么bzImage会将自己解压到该物理地址并从此地址开始运行,否则,bzImage将忽略此处设置的值,而从引导装载程序将其装入的物理地址开始运行.仅在你确实知道自己是在干什么的情况下才可以改变该值,否则请保持默认.</dd>
<dt>Build a relocatable kernel<br>CONFIG_RELOCATABLE</dt><dd>使内核可以<a href="http://tsecer.blog.163.com/blog/static/1501817201199871326/">在浮动的物理内存位置加载</a>,主要用于调试目的.仅在你确实知道为什么需要的时候再开启,否则请关闭.</dd>
<dt>Support for hot-pluggable CPUs<br>CONFIG_HOTPLUG_CPU</dt><dd>热插拔CPU支持(通过 /sys/devices/system/cpu 进行控制).</dd>
<dd><dl>
	<dt>Set default setting of cpu0_hotpluggable<br>CONFIG_BOOTPARAM_HOTPLUG_CPU0</dt><dd>开启/关闭此项的意思是设置"cpu0_hotpluggable"的默认值为"on/off".开启此项表示默认将CPU0设置为允许热插拔.</dd>
	<dt>Debug CPU0 hotplug<br>CONFIG_DEBUG_HOTPLUG_CPU0</dt><dd>仅用于调试目的.</dd>
</dl></dd>
<dt>Compat VDSO support<br>CONFIG_COMPAT_VDSO</dt><dd>是否将<a href="http://blog.csdn.net/juana1/article/details/6904932">VDSO</a>(Virtual Dynamic Shared Object)映射到旧式的确定性地址.如果Glibc版本大于等于2.3.3选"N",否则就选"Y".</dd>
<dt>vsyscall table for legacy applications</dt><dd>设置内核引导参数"vsyscall=[native|emulate|none]"的值.对于使用Glibc-2.14以上版本的系统来说,如果不需要使用特别老旧的静态二进制程序,应该将此项设为"None"以提升性能与安全性.</dd>
<dt>Built-in kernel command line<br>CONFIG_CMDLINE_BOOL</dt><dd>将内核引导参数直接编进来.在无法向内核传递引导参数的情况下(比如在嵌入式系统上,或者想使用 EFI stub kernel),这就是唯一的救命稻草了.如果你使用grub之类的引导管理器,那么就可以不需要此特性.</dd>
<dd><dl>
	<dt>Built-in kernel command string<br>CONFIG_CMDLINE</dt><dd>将要编译进内核的引导参数字符串.</dd>
	<dt>Built-in command line overrides boot loader arguments<br>CONFIG_CMDLINE_OVERRIDE</dt><dd>开启此项表示完全忽略引导加载器传递过来的参数,并仅仅只使用CONFIG_CMDLINE所指定的参数.通常情况下建议关闭此项,除非你确定引导加载器在传递内核引导参数的时候不能正常工作.</dd>
</dl></dd>
<dt>Enable the LDT (local descriptor table)<br>CONFIG_MODIFY_LDT_SYSCALL</dt><dd>Linux允许用户空间的应用程序使用<a href="http://man7.org/linux/man-pages/man2/modify_ldt.2.html">modify_ldt(2)</a>系统调用针对每个CPU安装<a href="http://www.csie.ntu.edu.tw/~wcchen/asm98/asm/proj/b85506061/chap2/segment.html">Local Descriptor Table (LDT)</a>.某些老旧的程序或者运行在DOSEMU/Wine中的程序需要使用此接口.不确定的选"N"(尤其是嵌入式系统与服务器).</dd>
</dl>





<h2>Power management and ACPI options<br />电源管理和ACPI选项</h2>
<dl>
<dt>Suspend to RAM and standby<br>CONFIG_SUSPEND</dt><dd>"休眠到内存"(ACPI S3)支持.也就是系统休眠后,除了内存之外,其他所有部件都停止工作,重开机之后可以直接从内存中恢复运行状态.要使用此功能,你需要执行"echo mem > /sys/power/state"命令,还需要在BIOS中开启S3支持,否则可能会有问题.</dd>
<dd><dl>
	<dt>Enable freezer for suspend to RAM/standby<br>CONFIG_SUSPEND_FREEZER</dt><dd>选"Y".除非你知道自己在做什么</dd>
</dl></dd>
<dt>Hibernation (aka 'suspend to disk')<br>CONFIG_HIBERNATION</dt><dd>"休眠到硬盘"(ACPI S4)支持.也就是将内存的内容保存到硬盘(hibernation),所有部件全都停止工作.要使用此功能,你首先需要使用内核引导参数"resume=/dev/swappartition",然后执行"echo disk > /sys/power/state"命令.如果你不想从先前的休眠状态中恢复,那么可以使用"noresume"内核引导参数.更多信息,可以参考"<a href="https://www.kernel.org/doc/Documentation/power/swsusp.txt">Documentation/power/swsusp.txt</a>"文件.</dd>
<dt>Default resume partition<br>CONFIG_PM_STD_PARTITION</dt><dd>默认的休眠分区.这个分区必须是swap分区.不过这里设置的值会被明确的内核引导参数中的值覆盖.</dd>
<dt>Opportunistic sleep<br>CONFIG_PM_AUTOSLEEP</dt><dd>这是一种从<a href="https://lwn.net/Articles/479841/">安卓借鉴过来的休眠方式</a>.这个特性在安卓系统上被称为"suspend blockers"或"wakelocks".这是一种更激进的电源管理模式,以尽可能节约电力为目的.系统默认就处于休眠状态,仅为内存和少数唤醒系统所必须的设备供电,当有任务(唤醒源)需要运行的时候才唤醒相关组件工作,工作完成后又立即进入休眠状态.不过这些特性需要相应的设备驱动程序的支持.目前除了安卓设备,在PC和服务器领域,能够利用此特性的驱动还比较少,不过这是一项非常有前途的电源技术,喜欢尝鲜的可以考虑开启.</dd>
<dt>User space wakeup sources interface<br>CONFIG_PM_WAKELOCKS</dt><dd>允许用户空间的程序通过sys文件系统接口,创建/激活/撤销系统的"唤醒源".需要与CONFIG_PM_AUTOSLEEP配合使用.</dd>
<dd><dl>
	<dt>Maximum number of user space wakeup sources (0 = no limit)<br>CONFIG_PM_WAKELOCKS_LIMIT</dt><dd>用户空间程序允许使用的"唤醒源"数量,"0"表示无限,最大值是"100000".</dd>
	<dt>Garbage collector for user space wakeup sources<br>CONFIG_PM_WAKELOCKS_GC</dt><dd>对"唤醒源"对象使用垃圾回收.主要用于调试目的和Android环境.</dd>
</dl></dd>
<dt>Run-time PM core functionality[Device power management core functionality]<br>CONFIG_PM_RUNTIME<br>CONFIG_PM</dt><dd>允许IO设备(比如硬盘/网卡/声卡)在系统运行时进入省电模式,并可在收到(硬件或驱动产生的)唤醒信号后恢复正常.此功能通常需要硬件的支持.建议在笔记本/嵌入式等需要节约电力的设备上选"Y".</dd>
<dt>Power Management Debug Support<br>CONFIG_PM_DEBUG</dt><dd>仅供调试使用</dd>
<dt>Enable workqueue power-efficient mode by default<br>CONFIG_WQ_POWER_EFFICIENT_DEFAULT</dt><dd>因为"per-cpu workqueue"的缓存更靠近对应的CPU,所以它比"unbound workqueue"拥有更好的性能,但另一方面"per-cpu workqueue"通常又比"unbound workqueue"需要消耗更多的电能.选中此项表示默认开启"workqueue.power_efficient"内核引导参数,以使用"unbound workqueue"而不是"per-cpu workqueue"以降低功耗,但是性能会有微小的损失.</dd>
<dt>ACPI (Advanced Configuration and Power Interface) Support<br>CONFIG_ACPI</dt><dd><a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%94%B5%E6%BA%90%E6%8E%A5%E5%8F%A3">高级配置与电源接口</a>(<a href="http://www.xiaofeng.org/Article/20090422220.htm">Advanced Configuration and Power Interface</a>)包括了软件和硬件方面的规范,目前已被软硬件厂商广泛支持,并且取代了许多过去的配置与电源管理接口,包括 PnP BIOS (Plug-and-Play BIOS), MPS(CONFIG_X86_MPPARSE), APM(Advanced Power Management) 等.总之,ACPI已经成为x86平台必不可少的组件,如果你没有特别的理由,务必选中此项.</dd>
<dd><dl>
	<dt>AML debugger interface (EXPERIMENTAL)<br>CONFIG_ACPI_DEBUGGER</dt><dd>仅供调试使用.</dd>
	<dt>Deprecated /proc/acpi files<br>CONFIG_ACPI_PROCFS</dt><dd>过时的 /proc/acpi 接口支持,建议关闭.</dd>
	<dt>Deprecated power /proc/acpi directories<br>CONFIG_ACPI_PROCFS_POWER</dt><dd>过时的 /proc/acpi 接口支持,建议关闭.</dd>
	<dt>Allow supported ACPI revision to be overriden<br>CONFIG_ACPI_REV_OVERRIDE_POSSIBLE</dt><dd>某些笔记本固件会根据操作系统支持的ACPI版本决定硬件的工作模式.例如 Dell XPS 13 (2015) 期望操作系统支持"ACPI v5"规范,但Linux实际上只支持"ACPI v4"规范,此时固件会将声卡的工作模式从HDA模式(Linux支持此模式,且为首选模式)转换成I2S模式(次选模式).选中此项后,将强制Linux内核哄骗固件说它支持"ACPI v5"规范,相当于使用了"acpi_rev_override"内核引导参数.</dd>
	<dt>EC read/write access through /sys/kernel/debug/ec<br>CONFIG_ACPI_EC_DEBUGFS</dt><dd>仅供调试使用.</dd>
	<dt>Deprecated /proc/acpi/event support<br>CONFIG_ACPI_PROC_EVENT</dt><dd>过时的 /proc/acpi/event 接口支持,建议关闭.</dd>
	<dt>AC Adapter<br>CONFIG_ACPI_AC</dt><dd>允许在外接交流电源和内置电池之间进行切换.</dd>
	<dt>Battery<br>CONFIG_ACPI_BATTERY</dt><dd>允许通过 /proc/acpi/battery 接口查看电池信息.</dd>
	<dt>Button<br>CONFIG_ACPI_BUTTON</dt><dd>允许守护进程通过 /proc/acpi/event 接口捕获power/sleep/lid(合上笔记本)按钮事件,并执行相应的动作,软关机(poweroff)也需要它的支持.</dd>
	<dt>Video<br>CONFIG_ACPI_VIDEO</dt><dd>对主板上的集成显卡提供ACPI支持.注意:仅支持集成显卡.</dd>
	<dt>Fan<br>CONFIG_ACPI_FAN</dt><dd>允许用户层的程序对风扇进行控制(开/关/查询状态)</dd>
	<dt>Dock<br>CONFIG_ACPI_DOCK</dt><dd>支持兼容ACPI规范的扩展坞(比如 IBM Ultrabay 和 Dell Module Bay)支持.</dd>
	<dt>Processor<br>CONFIG_ACPI_PROCESSOR</dt><dd>在支持 ACPI C2/C3 的CPU上,将ACPI安装为idle处理程序.有几种CPU频率调节驱动依赖于它.而且目前的CPU都已经支持ACPI规范,建议开启此项.</dd>
	<dt>IPMI<br>CONFIG_ACPI_IPMI</dt><dd>允许ACPI使用<a href="http://zh.wikipedia.org/wiki/IPMI">IPMI</a>(智能平台管理接口)的请求/应答消息访问BMC(主板管理控制器).IPMI通常出现在服务器中,以允许通过诸如<a href="http://www.ibm.com/developerworks/cn/linux/l-ipmi/">ipmitool</a>这样的工具监视服务器的物理健康特征(温度/电压/风扇状态/电源状态).</dd>
	<dt>Processor Aggregator<br>CONFIG_ACPI_PROCESSOR_AGGREGATOR</dt><dd>支持 ACPI 4.0 加入的处理器聚合器(<a href="http://lwn.net/Articles/355934/">processor Aggregator</a>)功能,以允许操作系统对系统中所有的CPU进行统一的配置和控制.目前只支持逻辑处理器(也就是利用Intel超线程技术虚拟出来的CPU)idling功能,其目标是降低耗电量.不确定的应该选"N".在某些服务器上此驱动(acpi_pad)可能<a href="http://zh.community.dell.com/techcenter/b/weblog/archive/2012/10/23/ubuntu-on-dell-12g-poweredge-servers">与BIOS中的节能功能冲突</a></dd>
	<dt>Thermal Zone<br>CONFIG_ACPI_THERMAL</dt><dd>ACPI thermal zone 支持.系统温度过高时可以及时调整风扇的工作状态以避免你的CPU被烧毁.目前所有CPU都支持此特性.务必开启.参见CONFIG_THERMAL选项.</dd>
	<dt>NUMA support<br>CONFIG_ACPI_NUMA</dt><dd>通过读取系统固件中的ACPI表,获得NUMA系统的CPU及物理内存分布信息.NUMA系统必选.</dd>
	<dt>Custom DSDT Table file to include<br>CONFIG_ACPI_CUSTOM_DSDT_FILE</dt><dd>允许将一个定制过的DSDT编译进内核.详情参见"<a href="https://www.kernel.org/doc/Documentation/acpi/dsdt-override.txt">Documentation/acpi/dsdt-override.txt</a>"文档.看不懂的请保持空白.</dd>
	<dt>ACPI tables override via initrd<br>CONFIG_ACPI_INITRD_TABLE_OVERRIDE</dt><dd>允许initrd更改 <a href="http://www.cnblogs.com/junzhkevin/archive/2013/02/25/2932801.html">ACPI tables</a> 中的任意内容. ACPI tables 是BIOS提供给OS的硬件配置数据,包括系统硬件的电源管理和配置管理.详情参见"<a href="https://www.kernel.org/doc/Documentation/acpi/initrd_table_override.txt">Documentation/acpi/initrd_table_override.txt</a>"文件.</dd>
	<dt>Debug Statements<br>CONFIG_ACPI_DEBUG</dt><dd>详细的ACPI调试信息,不搞开发就别选.</dd>
	<dt>PCI slot detection driver<br>CONFIG_ACPI_PCI_SLOT</dt><dd>将每个PCI插槽都作为一个单独的条目列在 /sys/bus/pci/slots/ 目录中,有助于将设备的物理插槽位置与逻辑的PCI总线地址进行对应.不确定的选"No".</dd>
	<dt>Power Management Timer Support<br>CONFIG_X86_PM_TIMER</dt><dd><a href="http://www.biosren.com/viewthread.php?tid=2895">ACPI PM Timer</a>,简称"ACPI Timer",是一种集成在主板上的硬件时钟发生器,提供3.579545MHz固定频率.这是比较传统的硬件时钟发生器(HPET则是比较新型的硬件时钟发生器),目前所有的主板都支持,而且是ACPI规范不可分割的部分.除非你确定不需要,否则必选.</dd>
	<dt>Container and Module Devices<br>CONFIG_ACPI_CONTAINER</dt><dd>支持 NUMA节点/CPU/内存 的热插拔. Device ID: ACPI0004, PNP0A05, PNP0A06 (find /sys/devices/ -name "PNP0A0[56]*" -or -name "ACPI0004*")</dd>
	<dt>Memory Hotplug<br>CONFIG_ACPI_HOTPLUG_MEMORY</dt><dd>内存热插拔支持. Device ID: PNP0C80 (find /sys/devices/ -name "PNP0C80*")</dd>
	<dt>Smart Battery System<br>CONFIG_ACPI_SBS</dt><dd><a href="http://baike.baidu.com/view/1938623.htm">智能电池系统</a>(<a href="http://wenku.baidu.com/view/9388cf93daef5ef7ba0d3c7e.html">Smart Battery System</a>)可以让笔记型电脑显示及管理详细精确的电池状态信息.<a href="http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&dlc=zh-hans&docname=c00718292">使用锂电池</a>的笔记本电脑必备利器.但遗憾的是并不是所有笔记本都支持这项特性.</dd>
	<dt>Hardware Error Device<br>CONFIG_ACPI_HED</dt><dd>Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误(通常是已经被纠正的错误).如果你的系统中有设备ID为"PNP0C33"的设备(find /sys/devices/ -name "PNP0C33*"),那么就选上.</dd>
	<dt>Allow ACPI methods to be inserted/replaced at run time<br>CONFIG_ACPI_CUSTOM_METHOD</dt><dd>允许在不断电的情况下直接对ACPI的功能进行删改,包含一定危险性,它允许root任意修改内存中内核空间的内容.仅用于调试.</dd>
	<dt>Boottime Graphics Resource Table support<br>CONFIG_ACPI_BGRT</dt><dd>在 /sys/firmware/acpi/bgrt/ 中显示 ACPI Boottime Graphics Resource Table ,以允许操作系统获取固件中的启动画面(splash).</dd>
	<dt>Hardware-reduced ACPI support only<br>CONFIG_ACPI_REDUCED_HARDWARE_ONLY</dt><dd>以"reduced hardware"模式编译内核的ACPI代码,从而获得体积更小的内核但仅能运行在ACPI "reduced hardware"模式的硬件上.不确定的选"N".</dd>
	<dt>ACPI NVDIMM Firmware Interface Table (NFIT)<br>CONFIG_ACPI_NFIT</dt><dd><a href="http://baike.baidu.com/item/NVDIMM">非易失性内存</a>(<a href="http://baike.baidu.com/pic/NVDIMM/7475977/0/908fa0ec08fa513d43b893993f6d55fbb2fbd963">NVDIMM</a>)支持.此种内存使用超级电容作为后备电力,并且使用非挥发性的flash存储介质来保存数据,以使数据能够在掉电之后依然保存.这是一种很有前途的技术,但是目前笔记本与普通服务器并不使用这种内存.</dd>
	<dt>ACPI Platform Error Interface (APEI)<br>CONFIG_ACPI_APEI</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-apei/">高级平台错误接口(ACPI Platform Error Interface)</a>是<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-ras/">RAS(Reliability, Availability and Serviceability)</a>的一部分,是定义在 ACPI 4.0 规范中的一个面向硬件错误管理的接口,主要是为了统一 firmware/BIOS 和 OS 之间的错误交互机制,使用标准的错误接口进行管理,同时也扩展了错误接口的内容以便实现更加灵活丰富的功能.</dd>
	<dd><dl>
		<dt>APEI Generic Hardware Error Source<br>CONFIG_ACPI_APEI_GHES</dt><dd>"Firmware First Mode"支持.由于BIOS/FIRMWARE是平台相关的,因此BIOS/FIRMWARE比OS更清楚硬件平台的配置情况,甚至包含各种必须的修正/定制/优化.这样,在"Firmware First"模式下,BIOS/FIRMWARE利用这一优势,可以有针对性的对发生的硬件错误进行分析/处理/分发,也可以更准确的记录错误的现场信息.这样,不但对硬件错误可以做出更准确,更复杂的处理,而且可以降低OS的复杂性和冗余度.建议开启.</dd>
		<dt>APEI PCIe AER logging/recovering support<br>CONFIG_ACPI_APEI_PCIEAER</dt><dd>让 PCIe AER errors 首先通过 APEI firmware 进行报告.</dd>
		<dt>APEI memory error recovering support<br>CONFIG_ACPI_APEI_MEMORY_FAILURE</dt><dd>让 Memory errors 首先通过 APEI firmware 进行报告.</dd>
		<dt>APEI Error INJection (EINJ)<br>CONFIG_ACPI_APEI_EINJ</dt><dd>仅供调试使用.</dd>
		<dt>APEI Error Record Serialization Table (ERST) Debug Support<br>CONFIG_ACPI_APEI_ERST_DEBUG</dt><dd>仅供调试使用</dd>
	</dl></dd>
	<dt>Extended Error Log support<br>CONFIG_ACPI_EXTLOG</dt><dd>服务器CPU一般都会在非核心寄存器中记录比CONFIG_X86_MCE故障更详细的额外信息,诸如<a href="https://en.wikipedia.org/wiki/Predictive_failure_analysis">PFA(Predictive Failure Analysis)</a>之类的故障预警系统需要收集这些信息.但由于这些非核心寄存器的位置差别很大没有统一标准,系统软件难以直接读取这些扩展的错误信息.此驱动可以在MCE或CMCI机制之外,将系统固件提供的这些额外扩展错误信息导出到用户空间.不确定的选"N".</dd>
	<dt>PMIC (Power Management Integrated Circuit) operation region support<br>CONFIG_PMIC_OPREGION</dt><dd><a href="http://baike.baidu.com/view/7765458.htm">电源管理芯片</a>(<a href="https://zh.wikipedia.org/zh-cn/%E9%9B%BB%E6%BA%90%E7%AE%A1%E7%90%86IC">PMIC</a>)支持.此种芯片常用于以电池作为电源的嵌入式装置.</dd>
</dl></dd>
<dt>SFI (Simple Firmware Interface) Support<br>CONFIG_SFI</dt><dd>简单固件接口规范(<a href="http://en.wikipedia.org/wiki/Simple_Firmware_Interface">Simple Firmware Interface</a>)使用一种轻量级的简单方法(通过内存中的一张静态表格)从firmware向操作系统传递信息.目前这个规范仅用于第二代 Intel Atom 平台,其核心名称是"<a href="http://news.mydrivers.com/1/163/163402.htm">Moorestown</a>".</dd>
<dt>CPU Frequency scaling<br>CONFIG_CPU_FREQ</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cpufreq-1/">CPUfreq</a>子系统允许动态改变CPU主频,达到省电和降温的目的.现如今的CPU都已经支持动态频率调整,建议开启.不过,如果你是为虚拟机编译内核,就没有必要开启了,由宿主机内核去控制就OK了.</dd>
<dd><dl>
	<dt>CPU frequency translation statistics<br>CONFIG_CPU_FREQ_STAT</dt><dd>通过sysfs文件系统输出CPU频率变化的统计信息</dd>
	<dd><dl>
		<dt>CPU frequency translation statistics details<br>CONFIG_CPU_FREQ_STAT_DETAILS</dt><dd>输出更详细的CPU频率变化统计信息</dd>
	</dl></dd>
	<dt>Default CPUFreq governor</dt><dd>默认的CPU频率<a href="http://www.ibm.com/developerworks/cn/linux/l-cpufreq-2/">调节策略</a>.不同策略拥有不同的<a href="http://www.ibm.com/developerworks/cn/linux/l-cpufreq-3/">调节效果</a>.</dd>
	<dt>'performance' governor<br>CONFIG_CPU_FREQ_GOV_PERFORMANCE</dt><dd>'性能'优先,静态的将频率设置为cpu支持的最高频率.最耗电,发热量最大,性能/效率比最低.不建议使用.</dd>
	<dt>'powersave' governor<br>CONFIG_CPU_FREQ_GOV_POWERSAVE</dt><dd>'节能'优先,静态的将频率设置为cpu支持的最低频率,严重影响性能.[注意]此调节器实际上并不能真正节省电能,因为系统需要花更长的时间才能进入空闲状态(C1E,C3,C6).但对于CONFIG_X86_INTEL_PSTATE驱动来说,这是效果最佳的调节器.</dd>
	<dt>'userspace' governor for userspace frequency scaling<br>CONFIG_CPU_FREQ_GOV_USERSPACE</dt><dd>既允许手动调整cpu频率,也允许用户空间程序动态调整cpu频率(需要额外的调频软件).比较麻烦,不建议使用.</dd>
	<dt>'ondemand' cpufreq policy governor<br>CONFIG_CPU_FREQ_GOV_ONDEMAND</dt><dd>'随需应变',内核周期性的考察CPU负载,当CPU负载超过/低于设定的百分比阈值(/sys/devices/system/cpu/cpufreq/ondemand/up_threshold)时,就自动将cpu频率设为最高/最低值(也就是仅在最高和最低频率间切换),比较适合台式机.[优化建议]将"up_threshold"设为95左右,可以获得更高的"性能/瓦特"比.</dd>
	<dt>'conservative' cpufreq governor<br>CONFIG_CPU_FREQ_GOV_CONSERVATIVE</dt><dd>'保守',和'ondemand'相似,内核同样周期性的考察CPU负载,但是频率的升降是渐变式的(通常只在相邻的两档频率间切换,但具体取决于"/sys/devices/system/cpu/cpufreq/conservative/freq_step"的百分比设置,设为"100"则等价于仅允许在最高和最低频率间切换):当CPU负载超过百分比上限(/sys/devices/system/cpu/cpufreq/conservative/up_threshold)时,就自动提升一档CPU频率;当CPU负载低于百分比下限(/sys/devices/system/cpu/cpufreq/conservative/down_threshold)时,就自动降低一档CPU频率.更适合用于笔记本/PDA/x86_64环境.[优化建议]'conservative'在默认设置下的"性能/瓦特"比通常不如'ondemand'优秀,但是优化设置之后情况则可能反转.例如,在"down_threshold=93,up_threshold=97"的情况下,可以比"up_threshold=95"的'ondemand'略有优势.</dd>
	<dt>x86 CPU frequency scaling drivers</dt><dd>CPU频率调节器驱动</dd>
	<dd><dl>
		<dt>Intel P state control<br>CONFIG_X86_INTEL_PSTATE</dt><dd>此驱动是专用于Intel的"<a href="http://zh.wikipedia.org/wiki/Sandy_Bridge%E5%BE%AE%E6%9E%B6%E6%A7%8B">Sandy Bridge</a>"/"<a href="http://zh.wikipedia.org/wiki/Intel_Ivy_Bridge">Ivy Bridge</a>"/"<a href="http://zh.wikipedia.org/wiki/Intel_Haswell">Haswell</a>"/"<a href="http://baike.baidu.com/view/5565083.htm">Broadwell</a>"/"<a href="http://baike.baidu.com/view/9294118.htm">SkyLake</a>"或更新CPU微架构的首选驱动,可以更好的支持"<a href="http://www.expreview.com/13254-all.html">Turbo Boost 2.0</a>"技术.[注意]此驱动仅支持"performance"与"powersave"(首选)两种频率调节策略(但两者都支持动态频率调整),且"性能/瓦特"比都优于传统的'ondemand'.[提示]可以通过"echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo"关闭睿频加速,进一步降低CPU温度与性能.</dd>
		<dt>Processor Clocking Control interface driver<br>CONFIG_X86_PCC_CPUFREQ</dt><dd>PCC(Processor Clocking Control)接口支持.此种接口仅对某些HP Proliant系列服务器有意义.更多细节可以参考"<a href="https://www.kernel.org/doc/Documentation/cpu-freq/pcc-cpufreq.txt">Documentation/cpu-freq/pcc-cpufreq.txt</a>"文件.</dd>
		<dt>ACPI Processor P-States driver<br>CONFIG_X86_ACPI_CPUFREQ</dt><dd>此驱动同时支持Intel和AMD的CPU,这是较老的intel cpu与非intel cpu首选的驱动(除非你的CPU是古董级别).[注意]对于可以使用P-state驱动的Intel CPU来说,应该选"N".</dd>
		<dd><dl>
			<dt>Legacy cpb sysfs knob support for AMD CPUs<br>CONFIG_X86_ACPI_CPUFREQ_CPB</dt><dd>为了兼容旧的用户空间程序而设置,建议关闭.</dd>
		</dl></dd>
		<dt>AMD Opteron/Athlon64 PowerNow!<br>CONFIG_X86_POWERNOW_K8</dt><dd>过时的驱动,仅为老旧的<a href="http://zh.wikipedia.org/wiki/AMD_K8">K8</a>核心的AMD处理器提供支持.<a href="http://zh.wikipedia.org/wiki/AMD_K10">K10</a>以及更新的CPU应该使用CONFIG_X86_ACPI_CPUFREQ驱动.</dd>
		<dt>AMD frequency sensitivity feedback powersave bias<br>CONFIG_X86_AMD_FREQ_SENSITIVITY</dt><dd>如果你使用 AMD Family 16h 或者更高级别的处理器,同时又使用"ondemand"频率调节器,开启此项可以更有效的进行频率调节(在保证性能的前提下更节能).</dd>
		<dt>Intel Enhanced SpeedStep (deprecated)<br>CONFIG_X86_SPEEDSTEP_CENTRINO</dt><dd>已被时代抛弃的驱动,仅对老旧的迅驰平台 Intel Pentium M / XEON 处理器有意义.</dd>
		<dt>Intel Pentium 4 clock modulation<br>CONFIG_X86_P4_CLOCKMOD</dt><dd>已被时代抛弃的驱动,仅对支持老旧的Speedstep技术的 Intel Pentium 4 / XEON 处理器有意义.而且即便是在这样的CPU上,因为种种兼容性问题可能导致的不稳定,也不建议开启.</dd>
	</dl></dd>
</dl></dd>
<dt>CPU idle PM support<br>CONFIG_CPU_IDLE</dt><dd><a href="http://en.wikipedia.org/wiki/Idle_%28CPU%29">CPU idle</a> 指令支持,该指令可以让CPU在空闲时"打盹"以节约电力和减少发热.只要是支持ACPI的CPU就应该开启.由于所有64位CPU都已支持ACPI,所以不必犹豫,开启![提示]为虚拟机编译的内核就没有必要开启了,由宿主机内核去控制就OK了.</dd>
<dd><dl>
	<dt>Support multiple cpuidle drivers<br>CONFIG_CPU_IDLE_MULTIPLE_DRIVERS</dt><dd>允许CONFIG_CPU_IDLE为每个不同的CPU使用不同的驱动.仅在你的系统由多个不同型号的CPU组成,并且具有不同的唤醒潜伏时间和状态的时候才需要开启.</dd>
</dl></dd>
<dt>Cpuidle Driver for Intel Processors<br>CONFIG_INTEL_IDLE</dt><dd>专用于Intel CPU的cpuidle驱动.而CONFIG_CPU_IDLE则可用于非Intel的CPU.</dd>
<dt>Memory power savings</dt><dd>内存节能</dd>
<dd><dl>
	<dt>Intel chipset idle memory power saving driver<br>CONFIG_I7300_IDLE</dt><dd>在某些具备内存节能特性的intel服务器芯片组上,让内存也可以在空闲时通过idle指令"打盹".这些<a href="http://blog.chinaunix.net/uid-15089195-id-3561594.html">芯片组</a>必须具备 <a href="http://tech.sina.com.cn/h/2007-04-18/1957292094.shtml">I/O AT</a> 支持(例如 Intel 7300).同时内存也需要支持此特性.</dd>
</dl></dd>
</dl>





<h2>Bus options (PCI etc.)<br />总线选项</h2>
<dl>
<dt>PCI support<br>CONFIG_PCI</dt><dd><a href="http://blog.csdn.net/fudan_abc/article/category/345294">PCI</a>是最重要的内部总线,不但PCI与PCI Express设备依赖于它,而且USB/IDE/SATA/SCSI/火线(IEEE 1394)/PCMCIA/CardBus等各种内部和外部总线也都依赖于它.所以必须选"Y",除非你知道自己在干什么.</dd>
<dd><dl>
	<dt>Support mmconfig PCI config space access<br>CONFIG_PCI_MMCONFIG</dt><dd>允许通过mmconfig方式访问<a href="http://en.wikipedia.org/wiki/PCI_configuration_space">PCI config space</a>,这种访问方式比传统的IO方式速度更快.建议开启.MMCONFIG的意思是"Memory-Mapped config",它是PCI Express引入的新<a href="http://blog.csdn.net/fudan_abc/article/details/1888773">总线枚举</a>方式.背景知识:PCI设备都有一组叫做'Configuration Space'的寄存器,PCI-E设备在PCI的基础上又增加了一组叫做'Extended Configuration Space'的寄存器.这些寄存器都被映射到了内存中(Memory-Mapped),操作系统理应提供相应的API供设备驱动和诊断程序访问这些'Configuration Space'.但如果操作系统没有提供Memory-Mapped方式的API的话,这些驱动程序和诊断程序就必须自己根据操作系统的底层规则(IO方式)去访问,这显然就增加了开发难度.这个选项的目的就是提供Memory-Mapped方式的API.</dd>
	<dt>Read CNB20LE Host Bridge Windows<br>CONFIG_PCI_CNB20LE_QUIRK</dt><dd>CNB20LE芯片组PCI热插拔支持.除非你非常明确的知道你需要它,否则请关闭此项.</dd>
	<dt>PCI Express support<br>CONFIG_PCIEPORTBUS</dt><dd><a href="http://zh.wikipedia.org/wiki/PCI_Express">PCI Express</a>是PCI的升级版并在软件层与PCI兼容,其目标是统一电脑内部总线.基本上只要不是古董机,都早已支持PCI-E了.选"Y".</dd>
	<dd><dl>
		<dt>PCI Express Hotplug driver<br>CONFIG_HOTPLUG_PCI_PCIE</dt><dd>如果你的主板和设备都支持PCI Express热插拔就可以选上.</dd>
		<dt>Root Port Advanced Error Reporting support<br>CONFIG_PCIEAER</dt><dd><a href="http://stuff.mit.edu/afs/sipb/contrib/linux/Documentation/PCI/pcieaer-howto.txt">PCI Express Root Port Advanced Error Reporting (AER)</a> 驱动支持.这样,发送到 Root Port 的 Error reporting messages 就会由 PCI Express AER 处理.建议开启.背景知识:PCI Express 定义了两种错误报告范例:(1)baseline,所有PCI-E组件都必须要支持,功能也比较基础.(2)AER(Advanced Error Reporting),功能比较高级,也更可靠,但并不要求所有组件都支持.</dd>
		<dd><dl>
			<dt>PCI Express ECRC settings control<br>CONFIG_PCIE_ECRC</dt><dd>允许覆写firmware/bios设置的 PCI Express ECRC(端对端循环冗余校验).建议关闭,除非你确实知道为什么要开启.</dd>
			<dt>PCIe AER error injector support<br>CONFIG_PCIEAER_INJECT</dt><dd>允许 PCI-E AER 注入,仅用于测试目的.</dd>
		</dl></dd>
		<dt>PCI Express ASPM control<br>CONFIG_PCIEASPM</dt><dd>PCI Express <a href="http://baike.baidu.cn/view/2803778.html">ASPM(Active State Power Management)</a> 和 Clock Power Management 支持.这是PCI-E规范制定的一种电源管理方案,可以在设备空闲时采用节电模式.建议开启.<a href="https://wireless.wiki.kernel.org/en/users/Documentation/ASPM">ASPM</a>可以在运行时通过 /sys/module/pcie_aspm/parameters/policy 进行开启或关闭.</dd>
		<dd><dl>
			<dt>Debug PCI Express ASPM<br>CONFIG_PCIEASPM_DEBUG</dt><dd>仅供调试.</dd>
			<dt>Default ASPM policy</dt><dd>默认的ASPM电源管理策略.下面的三个选项:"BIOS default"表示使用BIOS中的设置作为默认."Powersave"表示在可能的情况下,默认使用"L0s"和"L1",以尽可能节约电力."Performance"表示禁止使用"L0s"和"L1"(即使BIOS开启也同样禁止),以保证最高性能.</dd>
		</dl></dd>
	</dl></dd>
	<dt>Message Signaled Interrupts (MSI and MSI-X)<br>CONFIG_PCI_MSI</dt><dd>PCI/PCI-E支持三类中断:(1)INTx使用传统的IRQ中断,可以与现行的驱动程序和操作系统兼容.(2)MSI是PCI2.2规范中新增的,通过写入特殊的内存地址来触发和发送中断,该种方式脱离了中断引脚带来的数目限制,并且延迟小/效率高.不过MSI方式将中断全部落在单个CPU上,对多核CPU利用不佳.(3)MSI-X是在PCI3.0规范中新增的,在MSI的基础上,支持更多的消息数量以及独立的消息地址,可以自动在多个CPU上分担中断,更适合多CPU系统.建议开启.开启后,也可以使用"pci=nomsi"内核引导参数关闭MSI特性.</dd>
	<dt>PCI Debugging<br>CONFIG_PCI_DEBUG</dt><dd>将PCI调试信息输出到系统日志里.如果你想诊断PCI设备的故障,可以开启,否则应该关闭.</dd>
	<dt>Enable PCI resource re-allocation detection<br>CONFIG_PCI_REALLOC_ENABLE_AUTO</dt><dd>让内核自动检测"是否需要重新分配PCI资源".即使此项已开启,你依然可以用"pci=realloc=[on|off]"来覆盖它.此项仅在已开启CONFIG_PCI_IOV的情况下才有意义.此时,如果BIOS没有为<a href="http://docs.oracle.com/cd/E38902_01/html/E38873/glbzi.html">SR-IOV(Single-Root I/O Virtualization)</a> BAR(基地址寄存器)分配资源,那么内核将会自动对PCI资源进行重新分配.不确定的选"N".</dd>
	<dt>PCI Stub driver<br>CONFIG_PCI_STUB</dt><dd><a href="http://www.chenyudong.com/archives/add-pci-pass-through-device-to-guest-vm-with-libvirt-and-qemu.html">PCI设备穿透</a>(<a href="http://www.powerpcdev.net/blog/index.php/archives/52.html">PCI Stub</a>)的作用是将属主机的PCI设备跟目前绑定的驱动分离,暂时由其接管,最后再交给虚拟机内的客户操作系统自己去驱动这个PCI设备(例如网卡穿透/<a href="http://docs.eayun.cn/zh-CN/EayunOS/4.1/html/EayunOS-features/hostdev_passthrough/vga_passthrough_notice.html">显卡穿透</a>),以获得高性能.由于USB等所有外围设备实际上也都是连接在PCI总线上的,所以此功能同样适合各种外围设备,例如U盘加密狗之类.</dd>
	<dt>Xen PCI Frontend<br>CONFIG_XEN_PCIDEV_FRONTEND</dt><dd>如果你使用XEN的半虚拟化技术,并且你的硬件支持IOMMU,那么可以开启此项,否则应该关闭.</dd>
	<dt>Interrupts on hypertransport devices<br>CONFIG_HT_IRQ</dt><dd>允许本地的<a href="http://zh.wikipedia.org/wiki/HyperTransport">HyperTransport</a>设备使用中断.这个只可用于AMD平台,Intel平台不支持这个.</dd>
</dl></dd>
<dt>PCI IOV support<br>CONFIG_PCI_IOV</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-pci-passthrough/">PCI I/O Virtualization</a>支持.这需要硬件支持IOMMU技术(AMD-Vi,Intel VT-d).</dd>
<dt>PCI PRI support<br>CONFIG_PCI_PRI</dt><dd>PCI Page Request Interface 支持.它允许IOMMU之后的设备能够从页错误中恢复过来.这需要硬件支持IOMMU技术(AMD-Vi,Intel VT-d).</dd>
<dt>PCI PASID support<br>CONFIG_PCI_PASID</dt><dd>PASID(Process Address Space Identifiers)可以被PCI设备用来同时访问多个IO地址空间.这需要硬件IOMMU技术(AMD-Vi,Intel VT-d)支持PASID特性.不确定的选"N".</dd>
<dt>PCI IO-APIC hotplug support<br>CONFIG_PCI_IOAPIC</dt><dd>PCI <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/">IO-APIC</a> 热插拔支持.</dd>
<dt>ISA-style DMA support<br>CONFIG_ISA_DMA_API</dt><dd><a href="https://lkml.org/lkml/2011/1/27/326">ISA-style DMA</a>控制器支持.目前基本只有<a href="http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC总线</a>设备需要使用,最常见的是串口,并口,PS/2键盘,<a href="http://zh.wikipedia.org/wiki/Super_I/O">Super I/O</a>芯片(可以使用<a href="http://www.coreboot.org/Superiotool">Superiotool</a>和<a href="http://www.lm-sensors.org/wiki/man/sensors-detect">sensors-detect</a>工具检测).不确定的选"Y".[说明]这是一个历史遗留问题,对于ISA架构,DMA操作是由一个专用的"DMA控制器"(最常见的是<a href="http://en.wikipedia.org/wiki/Intel_8237">Intel 8237</a>)来执行的,但是到了PCI架构,由于每一个PCI设备都可以控制PCI总线(成为"<a href="http://en.wikipedia.org/wiki/Bus_mastering">bus master</a>")并直接读写系统内存,所以"DMA控制器"又消失了.此选项只是为那些需要"ISA-DMA控制器"的设备提供了兼容性接口(API)而已.</dd>
<dt>PCCard (PCMCIA/CardBus) support<br>CONFIG_PCCARD</dt><dd><a href="http://zh.wikipedia.org/wiki/PC%E5%8D%A1">PCCard(PCMCIA/CardBus/ExpressCard)</a>接口通常出现在笔记本电脑上,这些接口卡通常大小与信用卡差不多,厚度大约3-5毫米.注意:必须要配合<a href="https://www.kernel.org/pub/linux/utils/kernel/pcmcia/">pcmciautils</a>工具才能正常使用PCMCIA设备.</dd>
<dd><dl>
	<dt>16-bit PCMCIA support<br>CONFIG_PCMCIA</dt><dd>老旧的 16-bit PCMCIA 卡支持</dd>
	<dd><dl>
		<dt>Load CIS updates from userspace<br>CONFIG_PCMCIA_LOAD_CIS</dt><dd>有些PCMCIA卡需要从用户空间更新CIS(Card Information Structure)之后才能正常工作.开启此项后,内核将可以使用内置的固件加载器和热插拔子系统自动加载CIS,而不再需要用户空间工具的辅助.建议选"Yes".</dd>
	</dl></dd>
	<dt>32-bit CardBus support<br>CONFIG_CARDBUS</dt><dd>常见的PCMCIA卡基本上都是32位的<a href="http://zh.wikipedia.org/wiki/CardBus">CardBus</a>与<a href="http://zh.wikipedia.org/wiki/ExpressCard">ExpressCard</a>设备.如果你有这样的卡,就选"Yes".由于绝大多数的卡都是"yenta-compatible"的,所以一般你还需要选中CONFIG_YENTA项.</dd>
	<dt>CardBus yenta-compatible bridge support<br>CONFIG_YENTA</dt><dd>使用PCMCIA卡的基本上都需要选择这一项,子项是一些拥有自己特定扩展的硬件,请按实际情况选择.</dd>
	<dt class="omit">{省略的部分请按照自己实际使用的PCMCIA卡选择}</dt>
</dl></dd>
<dt>Support for PCI Hotplug<br>CONFIG_HOTPLUG_PCI</dt><dd>PCI热插拔不仅仅针对PCI和PCI-E设备,也包括<a href="http://zh.wikipedia.org/wiki/CardBus">CardBus</a>与<a href="http://zh.wikipedia.org/wiki/ExpressCard">ExpressCard</a>设备.请按需选择.</dd>
<dt class="omit">{省略的部分请按照自己实际使用PCI控制器进行选择}</dt>
<dt>RapidIO support<br>CONFIG_RAPIDIO</dt><dd><a href="http://baike.baidu.com/view/1237941.htm">RapidIO</a>总线支持.这种总线主要用于嵌入式系统.</dd>
<dd><dl>
	<dt>Discovery timeout duration (seconds)<br>CONFIG_RAPIDIO_DISC_TIMEOUT</dt><dd>等待主机完成枚举(也就是初始化)的超时秒数.</dd>
	<dt>Enable RapidIO Input/Output Ports<br>CONFIG_RAPIDIO_ENABLE_RX_TX_PORTS</dt><dd>开启所有 RapidIO Input/Output 端口.</dd>
	<dt>DMA Engine support for RapidIO<br>CONFIG_RAPIDIO_DMA_ENGINE</dt><dd>使用<a href="http://zhidao.baidu.com/question/467321157.html">DMA引擎</a>(CONFIG_DMADEVICES)进行RapidIO数据传输</dd>
	<dt>RapidIO subsystem debug messages<br>CONFIG_RAPIDIO_DEBUG</dt><dd>将RapidIO调试信息输出到系统日志里.如果你想诊断RapidIO设备的故障,可以开启,否则应该关闭.</dd>
	<dt class="omit">{省略的部分请按照自己实际使用的控制器进行选择}</dt>
</dl></dd>
<dt>Mark VGA/VBE/EFI FB as generic system framebuffer<br>CONFIG_X86_SYSFB</dt><dd>此选项的主要是为simplefb(可作为VGA/VBE/EFI FB的单一替代品通用于BIOS和UEFI平台)提供支持,仅在你确实需要开启CONFIG_FB_SIMPLE选项时才需要选"Y",否则请选"N".</dd>
</dl>





<h2>Executable file formats / Emulations<br />可执行文件格式/仿真</h2>
<dl>
<dt>Kernel support for ELF binaries<br>CONFIG_BINFMT_ELF</dt><dd>ELF是最常用的跨平台二进制文件格式,支持动态连接,支持不同的硬件平台,支持不同的操作系统.必选,除非你知道自己在做什么.</dd>
<dt>Write ELF core dumps with partial segments<br>CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS</dt><dd>如果你打算在此Linux上开发应用程序或者帮助别人调试bug,那么就选"Y",否则选"N".注意这里的调试和开发不是指内核调试和开发,是应用程序的调试和开发.</dd>
<dt>Kernel support for scripts starting with #!<br>CONFIG_BINFMT_SCRIPT</dt><dd>支持以"#!/path/to/interpreter"行开头的脚本.务必"Y",不要"M"或"N",除非你知道自己在做什么.</dd>
<dt>Kernel support for MISC binaries<br>CONFIG_BINFMT_MISC</dt><dd>允许插入二进制封装层到内核中,<b>直接运行</b>Java,.NET(Mono-based),Python,Emacs-Lisp等语言编译的二进制程序时需要它,DOSEMU也需要它.想要更方便的使用此特性(<a href="http://blog.csdn.net/roland_sun/article/details/50062295">指定特定类型的文件用特定的程序打开</a>),你还需要使用"mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc"挂载<a href="http://guaneryu.com/blog/?tag=binfmt_misc">binfmt_misc</a>伪文件系统.具体详情可以参考"<a href="https://www.kernel.org/doc/Documentation/binfmt_misc.txt">Documentation/binfmt_misc.txt</a>"文档.</dd>
<dt>Enable core dump support<br>CONFIG_COREDUMP</dt><dd><a href="http://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6">核心转储(core dump)</a>支持.如果你打算在此Linux上开发应用程序或者帮助别人调试bug,那么就选"Y",否则选"N".注意这里的调试和开发不是指内核调试和开发,是应用程序的调试和开发.</dd>
<dt>IA32 Emulation<br>CONFIG_IA32_EMULATION</dt><dd>允许在64位内核中运行32位代码.除非你打算使用纯64位环境,否则请开启此项.提示:GRUB2支持引导纯64位内核,但是GRUB不支持.</dd>
<dd><dl>
	<dt>IA32 a.out support<br>CONFIG_IA32_AOUT</dt><dd>早期UNIX系统的可执行文件格式(32位),目前已经被ELF格式取代.除非你需要使用古董级的二进制程序.否则请关闭.</dd>
	<dt>x32 ABI for 64-bit mode<br>CONFIG_X86_X32</dt><dd>允许32位程序使用完整的64位寄存器,以减小内存占用(<a href="http://en.wikipedia.org/wiki/Memory_footprint">memory footprint</a>).这可以提高32位程序的运行性能.如果你使用binutils-2.22以上的版本(支持elf32_x86_64),就选"Y",否则选"N".</dd>
</dl></dd>
</dl>





<h2>Networking support<br />网络支持</h2>
<dl>
<dt>Networking options<br>CONFIG_NET</dt><dd>网络选项.systemd依赖于它</dd>
<dd><dl>
	<dt>Packet socket<br>CONFIG_PACKET</dt><dd>链路层<a href="http://blog.csdn.net/tqyou85/article/details/3115664">PF_PACKET</a>套接字支持.可以让应用程序(比如:抓包工具<a href="http://zh.wikipedia.org/zh-cn/Tcpdump">tcpdump</a>,DHCP客户端<a href="http://linux.die.net/man/8/dhclient">dhclient</a>,WiFi设置工具<a href="http://w1.fi/wpa_supplicant/">wpa_supplicant</a>)直接与网络设备通讯,而无需使用内核中的其它中介协议.不确定的选"Y"或"M".</dd>
	<dd><dl>
		<dt>Packet: sockets monitoring interface<br>CONFIG_PACKET_DIAG</dt><dd>PF_PACKET套接字监控接口,<a href="http://xikder.blog.51cto.com/1423200/869467">ss</a>这样的诊断工具需要它.</dd>
	</dl></dd>
	<dt>Unix domain sockets<br>CONFIG_UNIX</dt><dd><a href="http://learn.akae.cn/media/ch37s04.html">Unix domain sockets</a> 支持.许多程序都使用它在操作系统内部进行进程间通信(IPC),比如: X Window, syslog, udev 等等.选"Y",除非你确实知道自己在做什么.</dd>
	<dd><dl>
		<dt>UNIX: socket monitoring interface<br>CONFIG_UNIX_DIAG</dt><dd>UNIX套接字监控接口,<a href="http://xikder.blog.51cto.com/1423200/869467">ss</a>这样的工具需要它.</dd>
	</dl></dd>
	<dt>Transformation user configuration interface<br>CONFIG_XFRM_USER</dt><dd>为<a href="http://zh.wikipedia.org/zh-cn/IPsec">IPsec</a>相关的工具提供<a href="http://manpages.ubuntu.com/manpages/raring/man8/ip-xfrm.8.html">Transformation(XFRM)</a>用户配置接口</dd>
	<dt>Transformation sub policy support<br>CONFIG_XFRM_SUB_POLICY</dt><dd>XFRM子策略支持,不确定的选"N".</dd>
	<dt>Transformation migrate database<br>CONFIG_XFRM_MIGRATE</dt><dd>用于动态的更新 <a href="http://en.wikipedia.org/wiki/IPsec">IPsec</a> <a href="http://en.wikipedia.org/wiki/Security_association">SA(security association)</a> 的定位器(locator).这个特性对于手机这类移动设备来讲至关重要,因为它需要在不同的基站之间迁移.不确定的选"N".</dd>
	<dt>Transformation statistics<br>CONFIG_XFRM_STATISTICS</dt><dd>转换统计,这不是<a href="http://network.51cto.com/art/201007/209214.htm">SNMP/MIB</a>规范的内容.用于调试目的.不确定的选"N".</dd>
	<dt>PF_KEY sockets<br>CONFIG_NET_KEY</dt><dd><a href="http://cxw06023273.iteye.com/blog/867303">PF_KEYv2 套接字</a>支持(与KAME兼容).PF_KEY协议族主要用来处理SA(安全关联),对SADB(SA数据库)进行管理,主要用在IPsec协议中.<a href="http://wenku.baidu.com/view/e6cc6608763231126edb1107.html">PF_KEY_v2的编程API</a>在<a href="http://tools.ietf.org/html/rfc2367">RFC2367</a>中定义.</dd>
	<dd><dl>
		<dt>PF_KEY MIGRATE<br>CONFIG_NET_KEY_MIGRATE</dt><dd>向PF_KEYv2套接字中添加一个 PF_KEY MIGRATE 消息. PF_KEY MIGRATE 消息可用于动态的更新 IPsec SA(security association) 的定位器(locator).这个特性对于手机这类移动设备来讲至关重要,因为它需要在不同的基站之间迁移.不确定的选"N".</dd>
	</dl></dd>
	<dt>TCP/IP networking<br>CONFIG_INET</dt><dd>TCP/IP协议,必选!</dd>
	<dd><dl>
		<dt>IP: multicasting<br>CONFIG_IP_MULTICAST</dt><dd><a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD">IP多播(IP multicasting)</a>支持.指的是一个发送者向一组特定的接收者发送数据,但只需发送一份数据副本.实际应用的场合很少,<a href="http://www.baike.com/wiki/Mbone">MBONE</a>算是其中之一,与RTP等音视频协议相结合也算一种.不确定的选"N".</dd>
		<dt>IP: advanced router<br>CONFIG_IP_ADVANCED_ROUTER</dt><dd>高级路由支持,需要开启内核的IP转发功能(echo 1 > /proc/sys/net/ipv4/ip_forward)才能正常工作.如果这个Linux系统用作专业的路由器就选上,选上之后还需要按需选择其下的子项.一般的主机不需要这个.</dd>
		<dd><dl>
			<dt>FIB TRIE statistics<br>CONFIG_IP_FIB_TRIE_STATS</dt><dd>主要用于测试TRIE性能</dd>
			<dt>IP: policy routing<br>CONFIG_IP_MULTIPLE_TABLES</dt><dd>策略路由</dd>
			<dt>IP: equal cost multipath<br>CONFIG_IP_ROUTE_MULTIPATH</dt><dd>用于基于目的地址的负载均衡</dd>
			<dt>IP: verbose route monitoring<br>CONFIG_IP_ROUTE_VERBOSE</dt><dd>显示冗余的路由监控信息</dd>
		</dl></dd>
		<dt>IP: kernel level autoconfiguration<br>CONFIG_IP_PNP</dt><dd>在内核启动时自动配置网卡的ip地址/路由表,配置信息来自于以下途径:内核引导参数,<a href="http://baike.baidu.com/view/32782.htm">自举协议(BOOTP)</a>,<a href="http://baike.baidu.com/view/876146.htm">反向地址转换协议(RARP)</a>,<a href="http://zh.wikipedia.org/wiki/DHCP">动态主机配置协议(DHCP)</a>.通常,需要从网络启动的无盘工作站才需要这个东西(此时还需要开启CONFIG_ROOT_NFS),一般的发行版都通过启动脚本(<a href="http://roy.marples.name/projects/dhcpcd/">dhcpcd</a>/<a href="http://www.isc.org/products/DHCP">dhclient</a>/<a href="http://zh.wikipedia.org/zh-cn/Ifconfig">ifconfig</a>)配置网络.不确定的选"N".</dd>
		<dd><dl>
			<dt>IP: DHCP support<br>CONFIG_IP_PNP_DHCP</dt><dd>DHCP协议支持</dd>
			<dt>IP: BOOTP support<br>CONFIG_IP_PNP_BOOTP</dt><dd>BOOTP协议支持</dd>
			<dt>IP: RARP support<br>CONFIG_IP_PNP_RARP</dt><dd>RARP协议支持</dd>
		</dl></dd>
		<dt>IP: tunneling<br>CONFIG_NET_IPIP</dt><dd><a href="https://sites.google.com/site/emmoblin/linux-network-1/linux-zhongip-sui-dao">IP隧道</a>,主要目的是为了在TCP/IP网络中传输其他协议的数据包,当然也包括IP数据包(例如用于实现VPN).</dd>
		<dt>IP: GRE demultiplexer<br>CONFIG_NET_IPGRE_DEMUX</dt><dd>GRE demultiplexer 支持.被CONFIG_NET_IPGRE和CONFIG_PPTP所依赖.</dd>
		<dt>IP: GRE tunnels over IP<br>CONFIG_NET_IPGRE</dt><dd>基于IP的<a href="http://zkhylt.blog.51cto.com/3638719/771968">通用路由封装</a>(<a href="http://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">Generic Routing Encapsulation</a>)隧道支持.该驱动主要用于对端是Cisco路由器的场合,因为Cisco的路由器特别偏好GRE隧道(而不是CONFIG_NET_IPIP),并且GRE还允许通过隧道对组播进行再分发.</dd>
		<dd><dl>
			<dt>IP: broadcast GRE over IP<br>CONFIG_NET_IPGRE_BROADCAST</dt><dd>GRE/IP的一种应用是构建一个广播WAN(<a href="http://baike.baidu.com/view/21956.htm">Wide Area Network</a>),而其看上去却很像一个跑在互联网上的LAN(<a href="http://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">Local Area Network</a>).如果你想要创建这样的网络,那么就选"Y"(还要加上CONFIG_IP_MROUTE).</dd>
		</dl></dd>
		<dt>IP: multicast routing<br>CONFIG_IP_MROUTE</dt><dd><a href="http://www.mvn.cn/multicast-details.htm">组播路由</a>支持.实际应用的场合很少,<a href="http://www.baike.com/wiki/Mbone">MBONE</a>算是其中之一,不确定的选"N".</dd>
		<dd><dl>
			<dt>IP: multicast policy routing<br>CONFIG_IP_MROUTE_MULTIPLE_TABLES</dt><dd>通常,组播路由器上会运行一个单独的用户态守护进程,根据源地址和目的地址来处理数据包.开启此项后,将能同时考虑数据包所带的标记(mark)和所通过的网络接口,并可在用户空间同时运行多个守护进程,每一个进程处理一张路由表.</dd>
			<dt>IP: PIM-SM version 1 support<br>CONFIG_IP_PIMSM_V1</dt><dd>Sparse Mode PIM (Protocol Independent Multicast) version 1 支持. 该协议被Cisco路由器广泛支持,你需要特定的软件(pimd-v1)才能使用它.</dd>
			<dt>IP: PIM-SM version 2 support<br>CONFIG_IP_PIMSM_V2</dt><dd>Sparse Mode PIM (Protocol Independent Multicast) version 2 支持. 该协议的使用并不广泛,你需要特定的软件(pimd 或 gated-5)才能使用它.</dd>
		</dl></dd>
		<dt>IP: ARP daemon support<br>CONFIG_ARPD</dt><dd>通常情况下,内核自身会使用ARP协议解析本地网络中的IP地址与MAC地址的对应关系,并进行缓存.开启此项后,内核将使用用户空间的守护进程进行ARP解析.这主要是为了使用其他的替代解析协议(比如mGRE隧道中的NHRP),或调试目的.不确定的选"N".</dd>
		<dt>IP: TCP syncookie support<br>CONFIG_SYN_COOKIES</dt><dd><a href="http://baike.baidu.com/view/6625802.htm">TCP syncookie</a> 支持,这是抵抗<a href="http://www.xfocus.net/articles/200106/208.html">SYN flood</a>攻击的好东西.此特性的开关可以通过"/proc/sys/net/ipv4/tcp_syncookies"文件控制,写入"1"表示开启,写入"0"表示关闭.建议服务器环境开启此项.</dd>
		<dt>Virtual (secure) IP: tunneling<br>CONFIG_NET_IPVTI</dt><dd>虚拟IP隧道.可以和xfrm隧道一起使用,以实现IPSEC安全隧道,并在其上使用路由协议.不确定的选"N".</dd>
		<dt>IP: Foo (IP protocols) over UDP<br>CONFIG_NET_FOU</dt><dd>允许将任意IP层协议封装到UDP隧道中.不确定的选"N".</dd>
		<dt>IP: AH transformation<br>CONFIG_INET_AH</dt><dd><a href="http://wenku.baidu.com/view/dd0d200f6c85ec3a87c2c53a.html">IPsec AH</a> 支持.IPsec验证头(AH)可对整个数据包(IP报头与数据)提供身份验证/完整性/抗重播保护.但是它不提供保密性,即它不对数据进行加密.由于这个原因,AH头正在慢慢被ESP头取代.</dd>
		<dt>IP: ESP transformation<br>CONFIG_INET_ESP</dt><dd><a href="http://wenku.baidu.com/view/dd0d200f6c85ec3a87c2c53a.html">IPsec ESP</a> 支持.IPsec封装安全负载(ESP)不仅为IP负载提供身份验证/完整性/抗重播保护,还提供保密性,也就是还对数据进行加密.ESP有两种使用模式:传输模式(ESP不对整个数据包进行签名,只对IP负载(不含IP报头)进行保护)和隧道模式(将原始IP包封装进新的带有ESP头的IP包内,可提供完整的保护).ESP可以独立使用,也可与AH组合使用(越来越少).</dd>
		<dt>IP: IPComp transformation<br>CONFIG_INET_IPCOMP</dt><dd>IP静荷载压缩协议(<a href="http://wenku.baidu.com/view/082419c00c22590102029d2d.html">IP Payload Compression Protocol</a>)(RFC3173)支持.用于支持IPsec</dd>
		<dt>IP: IPsec transport mode<br>CONFIG_INET_XFRM_MODE_TRANSPORT</dt><dd>IPsec传输模式.常用于对等通信,用以提供内网安全.数据包经过了加密但IP头没有加密,因此任何标准设备或软件都可查看和使用IP头</dd>
		<dt>IP: IPsec tunnel mode<br>CONFIG_INET_XFRM_MODE_TUNNEL</dt><dd>IPsec隧道模式.用于提供外网安全(包括虚拟专用网络).整个数据包(数据头和负载)都已经过加密处理且分配有新的ESP头/IP头/验证尾,从而能够隐藏受保护站点的拓扑结构</dd>
		<dt>IP: IPsec BEET mode<br>CONFIG_INET_XFRM_MODE_BEET</dt><dd>IPsec BEET模式.</dd>
		<dt>Large Receive Offload (ipv4/tcp)<br>CONFIG_INET_LRO</dt><dd><a href="http://blog.chinaunix.net/uid-317451-id-92639.html">LRO(Large Receive Offload)</a> (ipv4/tcp) 支持.它通过将多个TCP数据整合在一个skb结构中,并在稍后的某个时刻作为一个大的数据包交付给上层的网络协议栈,以减少上层协议栈处理skb的开销,提高Linux系统接收TCP数据包的能力.目前,主流网卡驱动都已支持此特性.建议开启.不过,<a href="http://en.wikipedia.org/wiki/Large_receive_offload">LRO</a>不应该在路由器上开启,因为它破坏了end-to-end原则,并会对路由性能造成显著的不利影响.</dd>
		<dt>INET: socket monitoring interface<br>CONFIG_INET_DIAG</dt><dd>INET(TCP,DCCP,...) socket 监视接口,一些Linux本地工具(如:包含ss的<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2">iproute2</a>)需要使用它</dd>
		<dd><dl>
			<dt>UDP: socket monitoring interface<br>CONFIG_INET_UDP_DIAG</dt><dd>UDP socket 监视接口,一些Linux本地工具(如:包含ss的<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2">iproute2</a>)需要使用它</dd>
		</dl></dd>
		<dt>TCP: advanced congestion control<br>CONFIG_TCP_CONG_ADVANCED</dt><dd>高级<a href="http://baike.baidu.com/view/1453183.htm">拥塞控制</a>,子项提供多种<a href="http://blog.csdn.net/zhangskd/article/details/6715751">拥塞控制算法</a>供选用.如果没有特殊需求就别选了,内核会自动将默认的拥塞控制设为"CUBIC"并将"new Reno"作为候补.仅在你确实知道自己需要的情况下选"Y".不确定的选"N".</dd>
		<dt>TCP: MD5 Signature Option support (RFC2385)<br>CONFIG_TCP_MD5SIG</dt><dd><a href="ftp://ftp.isi.edu/in-notes/rfc2385.txt">RFC2385</a>中描述了一种对TCP会话进行MD5签名的保护机制.目前仅用于保护互联网运营商骨干路由器间的<a href="http://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">BGP</a>会话.一般的路由器/服务器等设备根本不需要这个.</dd>
		<dt>The IPv6 protocol<br>CONFIG_IPV6</dt><dd>引领未来的<a href="http://zh.wikipedia.org/wiki/IPv6">IPv6</a>支持.</dd>
		<dd><dl>
			<dt>IPv6: Privacy Extensions (RFC 3041) support<br>CONFIG_IPV6_PRIVACY</dt><dd>IPv6利用"<a href="http://tools.ietf.org/html/rfc4862">Stateless Address Autoconfiguration</a>"在无DHCP服务器的情况下,产生可用的"临时IPv6地址".而本选项则为这个机制增加"隐私扩展"(<a href="http://tools.ietf.org/html/rfc4941">RFC4941</a>)保护.默认状态下,内核并不生产"临时地址",需要"echo 2 >/proc/sys/net/ipv6/conf/all/use_tempaddr"才能开启</dd>
			<dt>IPv6: Router Preference (RFC 4191) support<br>CONFIG_IPV6_ROUTER_PREF</dt><dd>主机连上IPv6网络后,会发出路由器邀请包(Router Solicitation),路由器则应答路由器公告包(Router Advertisement),其中包含网关地址/IPv6前缀/DNS地址,这样主机就能取得IPv6地址,并连接到互联网上,这就是无状态地址自动分配(StateLess Address AutoConfiguration)."<a href="http://www.ietf.org/rfc/rfc4191.txt">Router Preference</a>"是"Router Advertisement"包的可选扩展.它可以改进主机选中路由器的能力,特别是在多归属(<a href="http://blog.chinaunix.net/uid-16459552-id-3761490.html">multi-homed</a>)网络中.不确定的选"N".</dd>
			<dd><dl>
				<dt>IPv6: Route Information (RFC 4191) support<br>CONFIG_IPV6_ROUTE_INFO</dt><dd>对"<a href="http://www.ietf.org/rfc/rfc4191.txt">Route Information</a>"的实验性支持.</dd>
			</dl></dd>
			<dt>IPv6: Enable RFC 4429 Optimistic DAD<br>CONFIG_IPV6_OPTIMISTIC_DAD</dt><dd>乐观<a href="http://kapok.blog.51cto.com/517862/130464">重复地址检测</a>(<a href="http://tools.ietf.org/html/rfc4429">Optimistic Duplicate Address Detection</a>)的实验性支持.可以更快的进行自动地址配置.不确定的选"N".</dd>
			<dt>IPv6: AH transformation<br>CONFIG_INET6_AH</dt><dd>IPsec AH 支持.不确定的选"Y"或"M".AH头正在慢慢被ESP头取代.</dd>
			<dt>IPv6: ESP transformation<br>CONFIG_INET6_ESP</dt><dd>IPsec ESP 支持.不确定的选"Y"或"M".</dd>
			<dt>IPv6: IPComp transformation<br>CONFIG_INET6_IPCOMP</dt><dd>IPv6静荷载压缩协议(<a href="http://wenku.baidu.com/view/082419c00c22590102029d2d.html">IP Payload Compression Protocol</a>)(RFC3173)支持.用于支持IPsec.不确定的选"Y"或"M".</dd>
			<dt>IPv6: Mobility<br>CONFIG_IPV6_MIP6</dt><dd><a href="http://wenku.baidu.com/view/13c8a2dc26fff705cc170af2.html">移动IPv6(RFC3775)</a>支持.主要用于移动设备.不确定的选"N".</dd>
			<dt>IPv6: IPsec transport mode<br>CONFIG_INET6_XFRM_MODE_TRANSPORT</dt><dd>IPsec传输模式.常用于对等通信,用以提供内网安全.数据包经过了加密但IP头没有加密,因此任何标准设备或软件都可查看和使用IP头.不确定的选"Y"或"M".</dd>
			<dt>IPv6: IPsec tunnel mode<br>CONFIG_INET6_XFRM_MODE_TUNNEL</dt><dd>IPsec隧道模式.用于提供外网安全(包括虚拟专用网络).整个数据包(数据头和负载)都已经过加密处理且分配有新的ESP头/IP头/验证尾,从而能够隐藏受保护站点的拓扑结构.不确定的选"Y"或"M".</dd>
			<dt>IPv6: IPsec BEET mode<br>CONFIG_INET6_XFRM_MODE_BEET</dt><dd>IPsec BEET模式.不确定的选"Y"或"M".</dd>
			<dt>IPv6: MIPv6 route optimization mode<br>CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION</dt><dd><a href="http://man.chinaunix.net/network/Linux_Mobile_IPv6_HowTo/index.htm">移动IPv6(Mobile IPv6)</a>路由优化模式.主要用于移动设备.不确定的选"N".</dd>
			<dt>IPv6: IPv6-in-IPv4 tunnel (SIT driver)<br>CONFIG_IPV6_SIT</dt><dd>在IPv4网络上建立IPv6隧道.如果你希望可以通过IPv4网络接入一个IPv6网络,可以选"Y"或"M",否则选"N".</dd>
			<dd><dl>
				<dt>IPv6: IPv6 Rapid Deployment (6RD)<br>CONFIG_IPV6_SIT_6RD</dt><dd><a href="http://www.a10networks.com.cn/products/axseries-IPv6_rapid_deployment_6rd.php">IPv6快速部署(6RD)</a>支持.不确定的选"N".</dd>
			</dl></dd>
			<dt>IPv6: IP-in-IPv6 tunnel (RFC2473)<br>CONFIG_IPV6_TUNNEL</dt><dd>IPv6-in-IPv6/IPv4-in-IPv6 隧道(<a href="http://wenku.baidu.com/view/8f221d6b1eb91a37f1115c62.html">RFC2473</a>)支持.不确定的选"N".</dd>
			<dt>IPv6: GRE tunnel<br>CONFIG_IPV6_GRE</dt><dd>基于IPv6的<a href="http://zkhylt.blog.51cto.com/3638719/771968">通用路由封装</a>(<a href="http://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">Generic Routing Encapsulation</a>)隧道支持.该驱动主要用于对端是Cisco路由器的场合,因为Cisco的路由器特别偏好GRE隧道(而不是CONFIG_IPV6_TUNNEL),并且GRE还允许通过隧道对组播进行再分发.</dd>
			<dt>IPv6: Multiple Routing Tables<br>CONFIG_IPV6_MULTIPLE_TABLES</dt><dd><a href="http://blog.csdn.net/oohaha_123/article/details/8597761">多重路由表</a>(<a href="http://www.study-area.org/tips/m_routing.htm">Multiple Routing Tables</a>)支持.不确定的选"N".</dd>
			<dd><dl>
				<dt>IIPv6: source address based routing<br>CONFIG_IPV6_SUBTREES</dt><dd>允许根据源地址或前缀进行路由.不确定的选"N".</dd>
			</dl></dd>
			<dt>IPv6: multicast routing<br>CONFIG_IPV6_MROUTE</dt><dd>测试性的IPv6<a href="http://www.mvn.cn/multicast-details.htm">组播路由</a>支持.实际应用的场合很少,不确定的选"N".</dd>
			<dd><dl>
				<dt>IPv6: multicast policy routing<br>CONFIG_IPV6_MROUTE_MULTIPLE_TABLES</dt><dd>通常,组播路由器上会运行一个单独的用户态守护进程,根据源地址和目的地址来处理数据包.开启此项后,将能同时考虑数据包所带的标记(mark)和所通过的网络接口,并可在用户空间同时运行多个守护进程,每一个进程处理一张路由表.</dd>
				<dt>IPv6: PIM-SM version 2 support<br>CONFIG_IPV6_PIMSM_V2</dt><dd>IPv6 PIM multicast routing protocol PIM-SMv2 支持.</dd>
			</dl></dd>
		</dl></dd>
		<dt>NetLabel subsystem support<br>CONFIG_NETLABEL</dt><dd><a href="http://lwn.net/Articles/204905/">NetLabel</a>子系统支持.NetLabel子系统为诸如CIPSO与RIPSO之类能够在分组信息上添加标签的协议提供支持,看不懂就别选了.</dd>
	</dl></dd>
	<dt>Security Marking<br>CONFIG_NETWORK_SECMARK</dt><dd>对网络包进行安全标记,类似于nfmark,但主要是为安全目的而设计.看不懂的就别选了</dd>
	<dt>Timestamping in PHY devices<br>CONFIG_NETWORK_PHY_TIMESTAMPING</dt><dd>允许在硬件支持的前提下,为物理层(<a href="http://zh.wikipedia.org/wiki/PHY">PHY</a>)数据包打上时间戳.这会略微增加发送与接收的开销.不确定的选"N".</dd>
	<dt>Network packet filtering framework (Netfilter)<br>CONFIG_NETFILTER</dt><dd><a href="http://www.ha97.com/4082.html">Netfilter</a>可以对数据包进行过滤和修改,可以作为防火墙("packet filter"或"proxy-based")或网关(NAT)或代理(proxy)或网桥使用.</dd>
	<dd><dl>
		<dt>Network packet filtering debugging<br>CONFIG_NETFILTER_DEBUG</dt><dd>仅供开发者调试Netfilter使用</dd>
		<dt>Advanced netfilter configuration<br>CONFIG_NETFILTER_ADVANCED</dt><dd>选"Y"将会显示所有模块供用户选择,选"N"则会隐藏一些不常用的模块,并自动将常用模块设为"M".</dd>
		<dd><dl>
			<dt>Bridged IP/ARP packets filtering<br>CONFIG_BRIDGE_NETFILTER</dt><dd>如果你希望使用桥接防火墙就打开它.Docker依赖于它.不确定的选"N".</dd>
		</dl></dd>
		<dt>Core Netfilter Configuration</dt><dd>核心Netfilter配置(当包流过Chain时如果match某个规则那么将由该规则的target来处理,否则将由同一个Chain中的下一个规则进行匹配,若不match所有规则那么最终将由该Chain的policy进行处理)</dd>
		<dd><dl>
			<dt>Netfilter ingress support<br>CONFIG_NETFILTER_INGRESS</dt><dd>允许将入站包进行分类.</dd>
			<dt>Netfilter NFACCT over NFNETLINK interface<br>CONFIG_NETFILTER_NETLINK_ACCT</dt><dd>允许通过<a href="http://www.netfilter.org/projects/libnfnetlink/">NFNETLINK</a>接口支持<a href="http://netfilter.org/projects/libnetfilter_acct/index.html">NFACCT</a>(记账).</dd>
			<dt>Netfilter NFQUEUE over NFNETLINK interface<br>CONFIG_NETFILTER_NETLINK_QUEUE</dt><dd>允许通过<a href="http://www.netfilter.org/projects/libnfnetlink/">NFNETLINK</a>接口支持<a href="https://home.regit.org/netfilter-en/using-nfqueue-and-libnetfilter_queue/">NFQUEUE</a>(排队).</dd>
			<dt>Netfilter LOG over NFNETLINK interface<br>CONFIG_NETFILTER_NETLINK_LOG</dt><dd>允许通过<a href="http://www.netfilter.org/projects/libnfnetlink/">NFNETLINK</a>接口支持"LOG"(日志).该选项废弃了ipt_ULOG和ebg_ulog机制,并打算在将来废弃基于syslog的ipt_LOG和ip6t_LOG模块.</dd>
			<dt>Netfilter connection tracking support<br>CONFIG_NF_CONNTRACK</dt><dd>连接追踪(connection tracking)支持,连接跟踪把所有连接都保存在一个表格内,并将每个包关联到其所属的连接.可用于报文伪装或地址转换,也可用于增强包过滤能力.</dd>
			<dd><dl>
				<dt>Connection mark tracking support<br>CONFIG_NF_CONNTRACK_MARK</dt><dd>允许对连接进行标记,与针对单独的包进行标记的不同之处在于它是针对连接流的. CONNMARK target 和 connmark match 需要它的支持.</dd>
				<dt>Connection tracking security mark support<br>CONFIG_NF_CONNTRACK_SECMARK</dt><dd>允许对连接进行安全标记,通常这些标记包(SECMARK)复制到其所属连接(CONNSECMARK),再从连接复制到其关联的包(SECMARK).</dd>
				<dt>Connection tracking zones<br>CONFIG_NF_CONNTRACK_ZONES</dt><dd>"<a href="http://lwn.net/Articles/370152/">conntrack zones</a>"支持.通常,每个连接需要一个全局唯一标示符,而"conntrack zones"允许在不同zone内的连接使用相同的标识符.</dd>
				<dt>Supply CT list in procfs (OBSOLETE)<br>CONFIG_NF_CONNTRACK_PROCFS</dt><dd>已被废弃,选"N".</dd>
				<dt>Connection tracking events<br>CONFIG_NF_CONNTRACK_EVENTS</dt><dd>连接跟踪事件支持.如果启用这个选项,连接跟踪代码将提供一个"notifier"链,它可以被其它内核代码用来获知连接跟踪状态的改变</dd>
				<dt>Connection tracking timeout<br>CONFIG_NF_CONNTRACK_TIMEOUT</dt><dd>连接跟踪"timeout"扩展.这样你就可以在网络流上通过 CT target 附加超时策略.</dd>
				<dt>Connection tracking timestamping<br>CONFIG_NF_CONNTRACK_TIMESTAMP</dt><dd>时间戳支持.这样你就能在连接建立和断开时打上时间戳.</dd>
				<dt>DCCP protocol connection tracking support<br>CONFIG_NF_CT_PROTO_DCCP</dt><dd><a href="http://zh.wikipedia.org/zh-cn/DCCP">DCCP协议</a>支持.</dd>
				<dt>SCTP protocol connection tracking support<br>CONFIG_NF_CT_PROTO_SCTP</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-sctp/">SCTP协议</a>支持.</dd>
				<dt>UDP-Lite protocol connection tracking support<br>CONFIG_NF_CT_PROTO_UDPLITE</dt><dd><a href="http://net.chinaunix.net/5/2006/12/15/1142339.shtml">UDP-Lite</a>支持.</dd>
				<dt>Amanda backup protocol support<br>CONFIG_NF_CONNTRACK_AMANDA</dt><dd><a href="http://www.amanda.org/">Amanda</a>备份协议支持.</dd>
				<dt>FTP protocol support<br>CONFIG_NF_CONNTRACK_FTP</dt><dd><a href="http://www.cnbeta.com/articles/171754.htm">文件传输协议(FTP)</a>支持.跟踪FTP连接需要额外的帮助程序.</dd>
				<dt>H.323 protocol support<br>CONFIG_NF_CONNTRACK_H323</dt><dd><a href="http://networking.ctocio.com.cn/tips/192/6490692.shtml">H.323协议</a>支持.</dd>
				<dt>IRC protocol support<br>CONFIG_NF_CONNTRACK_IRC</dt><dd><a href="http://zh.wikipedia.org/zh-cn/IRC">IRC</a>扩展协议<a href="http://en.wikipedia.org/wiki/Direct_Client-to-Client">DCC(Direct Client-to-Client Protocol)</a>支持.该协议允许用户之间绕开服务器直接聊天和传输文件.</dd>
				<dt>NetBIOS name service protocol support<br>CONFIG_NF_CONNTRACK_NETBIOS_NS</dt><dd><a href="http://baike.baidu.com/view/491843.htm">NetBIOS</a>协议支持.</dd>
				<dt>SNMP service protocol support<br>CONFIG_NF_CONNTRACK_SNMP</dt><dd><a href="http://baike.baidu.com/view/2899.htm">SNMP</a>协议支持.</dd>
				<dt>PPtP protocol support<br>CONFIG_NF_CONNTRACK_PPTP</dt><dd><a href="http://tools.ietf.org/html/rfc2637">RFC2637</a> <a href="http://baike.baidu.com/view/32771.htm">点对点隧道协议(Point to Point Tunnelling Protocol)</a> 协议支持.</dd>
				<dt>SANE protocol support<br>CONFIG_NF_CONNTRACK_SANE</dt><dd><a href="http://www.sane-project.org/">SANE</a>协议支持.</dd>
				<dt>SIP protocol support<br>CONFIG_NF_CONNTRACK_SIP</dt><dd><a href="http://baike.baidu.com/view/51013.htm">SIP</a>协议支持.</dd>
				<dt>TFTP protocol support<br>CONFIG_NF_CONNTRACK_TFTP</dt><dd><a href="http://baike.baidu.com/view/23881.htm">TFTP</a>协议支持.</dd>
				<dt>Connection tracking netlink interface<br>CONFIG_NF_CT_NETLINK</dt><dd>基于<a href="http://blog.csdn.net/dog250/article/details/6425664">netlink</a>的用户接口支持.</dd>
				<dt>Connection tracking timeout tuning via Netlink<br>CONFIG_NF_CT_NETLINK_TIMEOUT</dt><dd>通过<a href="http://www.ibm.com/developerworks/cn/linux/l-kerns-usrs/">Netlink</a>机制支持对连接追踪超时进行细粒度的调节:允许为特定的网络流指定超时策略,而不是使用统一的全局超时策略.</dd>
				<dt>Connection tracking helpers in user-space via Netlink<br>CONFIG_NF_CT_NETLINK_HELPER</dt><dd>通过<a href="http://www.ibm.com/developerworks/cn/linux/l-kerns-usrs/">Netlink</a>机制为用户空间的连接追踪帮助程序提供基础框架.</dd>
				<dt>NFQUEUE integration with Connection Tracking<br>CONFIG_NETFILTER_NETLINK_QUEUE_CT</dt><dd>开启此项后,即使网络包已经在队列(NFQUEUE)中,它依然可以包含连接追踪信息.</dd>
			</dl></dd>
			<dt>Transparent proxying support<br>CONFIG_NETFILTER_TPROXY</dt><dd>透明代理支持,也就是可以处理非本地的 IPv4 TCP/UDP 套接字.此功能需要配合一些iptables规则和策略路由才能工作.详见"<a href="https://www.kernel.org/doc/Documentation/networking/tproxy.txt">Documentation/networking/tproxy.txt</a>"文档.</dd>
			<dt>Netfilter Xtables support (required for ip_tables)<br>CONFIG_NETFILTER_XTABLES</dt><dd>如果你打算使用 ip_tables, ip6_tables, arp_tables 之一就必须选上</dd>
			<dd><dl>
				<dt>nfmark target and match support<br>CONFIG_NETFILTER_XT_MARK</dt><dd>"nfmark"是用户给包打上的一个自定义标记.用于match时,允许基于"nfmark"值对包进行匹配.用于target时,允许在"mangle"表中创建规则以改变包的"nfmark"值.</dd>
				<dt>ctmark target and match support<br>CONFIG_NETFILTER_XT_CONNMARK</dt><dd>"ctmark"是用户以连接为组,给同一连接中的所有包打上的自定义标记.用法与"nfmark"相似.</dd>
				<dt>set target and match support<br>CONFIG_NETFILTER_XT_SET</dt><dd>"set"是<a href="http://blog.sina.com.cn/s/blog_6bdc95ab0100m58b.html">ipset</a>工具创建的<a href="http://blog.chinaunix.net/uid-21706718-id-3561951.html">IP地址集合</a>.使用match可以对IP地址集合进行匹配,使用target可以对集合中的项进行增加和删除.</dd>
				<dt>AUDIT target support<br>CONFIG_NETFILTER_XT_TARGET_AUDIT</dt><dd>为被drop/accept的包创建审计记录.</dd>
				<dt>CHECKSUM target support<br>CONFIG_NETFILTER_XT_TARGET_CHECKSUM</dt><dd>用于"mangle"表,为缺少校验和的包添加checksum字段的值.主要是为了兼容一些老旧的网络程序(例如某些dhcp客户端).</dd>
				<dt>"CLASSIFY" target support<br>CONFIG_NETFILTER_XT_TARGET_CLASSIFY</dt><dd>允许为包设置优先级,一些<a href="http://edseek.com/~jasonb/articles/traffic_shaping/qdiscs.html">qdiscs</a>排队规则(atm,cbq,dsmark,pfifo_fast,htb,prio)需要使用它</dd>
				<dt>"CONNMARK" target support<br>CONFIG_NETFILTER_XT_TARGET_CONNMARK</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_CONNMARK</dd>
				<dt>"CONNSECMARK" target support<br>CONFIG_NETFILTER_XT_TARGET_CONNSECMARK</dt><dd>针对链接进行安全标记,同时还会将连接上的标记还原到包上(如果链接中的包尚未进行安全标记),通常与 SECMARK target 联合使用</dd>
				<dt>"CT" target support<br>CONFIG_NETFILTER_XT_TARGET_CT</dt><dd>允许为包加上连接追踪相关的参数,比如"event"和"helper".</dd>
				<dt>"DSCP" and "TOS" target support<br>CONFIG_NETFILTER_XT_TARGET_DSCP</dt><dd>DSCP target 允许对IPv4/IPv6包头部的DSCP(Differentiated Services Codepoint)字段(常用于Qos)进行修改. TOS target 允许在"mangle"表创建规则以修改IPv4包头的TOS(Type Of Service)字段或IPv6包头的Priority字段.</dd>
				<dt>"HL" hoplimit target support<br>CONFIG_NETFILTER_XT_TARGET_HL</dt><dd>HL(IPv6)/TTL(IPv4) target 允许更改包头的 hoplimit/time-to-live 值.</dd>
				<dt>"HMARK" target support<br>CONFIG_NETFILTER_XT_TARGET_HMARK</dt><dd>允许在"raw"和"mangle"表中创建规则,以根据特定范围的哈希计算结果设置"<a href="http://wenku.baidu.com/view/b5162f3543323968011c92e0">skbuff</a>"标记.</dd>
				<dt>IDLETIMER target support<br>CONFIG_NETFILTER_XT_TARGET_IDLETIMER</dt><dd>每个被匹配的包的定时器都会被强制指定为规则指定的值,当超时发生时会触发一个sysfs文件系统的通知.剩余时间可以通过sysfs读取.</dd>
				<dt>"LED" target support<br>CONFIG_NETFILTER_XT_TARGET_LED</dt><dd>允许在满足特定条件的包通过的时候,触发LED灯闪烁.比如可以用于控制网卡的状态指示灯仅在有SSH活动的时候才闪烁.</dd>
				<dt>LOG target support<br>CONFIG_NETFILTER_XT_TARGET_LOG</dt><dd>允许向syslog中记录包头信息.</dd>
				<dt>"MARK" target support<br>CONFIG_NETFILTER_XT_TARGET_MARK</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MARK</dd>
				<dt>"NETMAP" target support<br>CONFIG_NETFILTER_XT_TARGET_NETMAP</dt><dd>NETMAP用于实现一对一的静态NAT(地址转换).</dd>
				<dt>"NFLOG" target support<br>CONFIG_NETFILTER_XT_TARGET_NFLOG</dt><dd>通过nfnetlink_log记录日志.</dd>
				<dt>"NFQUEUE" target Support<br>CONFIG_NETFILTER_XT_TARGET_NFQUEUE</dt><dd>用于替代老旧的 QUEUE target. 因为NFQUEUE能支持最多65535个队列,而QUEUE只能支持一个.</dd>
				<dt>"NOTRACK" target support (DEPRECATED)<br>CONFIG_NETFILTER_XT_TARGET_NOTRACK</dt><dd>已被废弃,勿选.</dd>
				<dt>"RATEEST" target support<br>CONFIG_NETFILTER_XT_TARGET_RATEEST</dt><dd>RATEEST target 允许测量网络流的传输速率.[注: rateest match 允许根据速率进行匹配.]</dd>
				<dt>REDIRECT target support<br>CONFIG_NETFILTER_XT_TARGET_REDIRECT</dt><dd><a href="http://www.linuxtopia.org/Linux_Firewall_iptables/x4508.html">REDIRECT</a>是一种特别的NAT:所有进入的连接都被映射到其入口网卡的地址,这样这些包就会"流入"本机而不是"流过"本机.这主要用于实现透明代理.</dd>
				<dt>"TEE" - packet cloning to alternate destination<br>CONFIG_NETFILTER_XT_TARGET_TEE</dt><dd>对包进行克隆,并将克隆的副本路由到另一个临近的路由器(<a href="http://www.techopedia.com/definition/2447/next-hop">Next Hop</a>).</dd>
				<dt>"TPROXY" target support<br>CONFIG_NETFILTER_XT_TARGET_TPROXY</dt><dd>类似于REDIRECT,但并不依赖于连接追踪和NAT,也只能用于"mangle"表,用于将网络流量重定向到透明代理.</dd>
				<dt>"TRACE" target support<br>CONFIG_NETFILTER_XT_TARGET_TRACE</dt><dd>允许对包打标记,这样内核就可以记录每一个匹配到的规则.</dd>
				<dt>"SECMARK" target support<br>CONFIG_NETFILTER_XT_TARGET_SECMARK</dt><dd>允许对包进行安全标记,用于安全子系统</dd>
				<dt>"TCPMSS" target support<br>CONFIG_NETFILTER_XT_TARGET_TCPMSS</dt><dd>允许更改 TCP SYN 包的<a href="http://support.huawei.com/ecommunity/bbs/10156527.html">MSS(Maximum Segment Size)</a>值,通常=MTU-40.</dd>
				<dt>"TCPOPTSTRIP" target support<br>CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP</dt><dd>允许从TCP包头中剥离所有<a href="http://wenku.baidu.com/view/5c288b51ad02de80d4d84066">TCP选项</a>.</dd>
				<dt>"addrtype" address type match support<br>CONFIG_NETFILTER_XT_MATCH_ADDRTYPE</dt><dd>根据地址类型进行匹配: UNICAST, LOCAL, BROADCAST, ... Docker依赖于它.</dd>
				<dt>"bpf" match support<br>CONFIG_NETFILTER_XT_MATCH_BPF</dt><dd><a href="http://blog.csdn.net/dog250/article/details/9103817">BPF(BSD Packet Filter)</a>是一个强大的包匹配模块,用于匹配那些让过滤器返回非零值的包.</dd>
				<dt>"cluster" match support<br>CONFIG_NETFILTER_XT_MATCH_CLUSTER</dt><dd>这个模块可以用于创建网络服务器/防火墙集群,而无需借助价格昂贵的负载均衡设备.通常,在包必须被本节点处理的条件下,这个match返回"true".这样,所有节点都可以看到所有的包,但只有匹配的节点才需要进行处理,这样就将负载进行了分摊.而分摊算法是基于对源地址的哈希值.</dd>
				<dt>"comment" match support<br>CONFIG_NETFILTER_XT_MATCH_COMMENT</dt><dd>这是一个"伪match",目的是允许你在iptables规则集中加入注释</dd>
				<dt>"connbytes" per-connection counter match support<br>CONFIG_NETFILTER_XT_MATCH_CONNBYTES</dt><dd>允许针对单个连接内部每个方向(进/出)匹配已经传送的字节数/包数</dd>
				<dt>"connlabel" match support<br>CONFIG_NETFILTER_XT_MATCH_CONNLABEL</dt><dd>允许向连接分配用户自定义的标签名.内核仅存储bit值,而名称和bit之间的对应关系由用户空间处理.与"connmark"的不同之处在于:可以同时为一个连接分配32个标志位(flag bit).</dd>
				<dt>"connlimit" match support<br>CONFIG_NETFILTER_XT_MATCH_CONNLIMIT</dt><dd>允许根据每一个客户端IP地址(或每一段客户端IP地址段)持有的并发连接数进行匹配.</dd>
				<dt>"connmark" connection mark match support<br>CONFIG_NETFILTER_XT_MATCH_CONNMARK</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_CONNMARK</dd>
				<dt>"conntrack" connection tracking match support<br>CONFIG_NETFILTER_XT_MATCH_CONNTRACK</dt><dd>通用连接跟踪匹配,是"state"的超集,它允许额外的链接跟踪信息,在需要设置一些复杂的规则(比如网关)时很有用.Docker依赖于它.</dd>
				<dt>"cpu" match support<br>CONFIG_NETFILTER_XT_MATCH_CPU</dt><dd>根据处理包所使用的CPU是哪个进行匹配</dd>
				<dt>"dccp" protocol match support<br>CONFIG_NETFILTER_XT_MATCH_DCCP</dt><dd><a href="http://baike.baidu.com/view/1619398.htm">DCCP</a>是打算取代UDP的新传输协议,它在UDP的基础上增加了流控和拥塞控制机制,面向实时业务</dd>
				<dt>"devgroup" match support<br>CONFIG_NETFILTER_XT_MATCH_DEVGROUP</dt><dd>允许根据网卡所属的"设备组"进行匹配</dd>
				<dt>"dscp" and "tos" match support<br>CONFIG_NETFILTER_XT_MATCH_DSCP</dt><dd>dscp match 允许根据IPv4/IPv6包头的<a href="http://baike.baidu.com/view/98757.htm">DSCP</a>字段进行匹配, tos match 允许根据IPv4包头的<a href="http://baike.baidu.com/view/1047572.htm#5">TOS</a>字段进行匹配</dd>
				<dt>"ecn" match support<br>CONFIG_NETFILTER_XT_MATCH_ECN</dt><dd>允许根据IPv4 TCP包头的<a href="http://network.51cto.com/art/200901/107005.htm">ECN</a>字段进行匹配</dd>
				<dt>"esp" match support<br>CONFIG_NETFILTER_XT_MATCH_ESP</dt><dd>允许对<a href="http://zh.wikipedia.org/wiki/IPsec">IPSec</a>包的ESP头中的SPI(安全参数序列)范围进行匹配</dd>
				<dt>"hashlimit" match support<br>CONFIG_NETFILTER_XT_MATCH_HASHLIMIT</dt><dd>此项的目的是取代"limit",它基于你选定的源/目的地址和/或端口动态创建"limit bucket"哈希表.这样你就可以迅速创建类似这样的匹配规则:(1)为给定的目的地址以每秒10k个包的速度进行匹配;(2)为给定的源地址以每秒500个包的速率进行匹配</dd>
				<dt>"helper" match support<br>CONFIG_NETFILTER_XT_MATCH_HELPER</dt><dd>加载特定协议的连接跟踪辅助模块,由该模块过滤所跟踪的连接类型的包,比如ip_conntrack_ftp模块</dd>
				<dt>"hl" hoplimit/TTL match support<br>CONFIG_NETFILTER_XT_MATCH_HL</dt><dd>基于IPv6包头的hoplimit字段,或IPv4包头的time-to-live字段进行匹配</dd>
				<dt>"iprange" address range match support<br>CONFIG_NETFILTER_XT_MATCH_IPRANGE</dt><dd>根据IP地址范围进行匹配,而普通的iptables只能根据"IP/mask"的方式进行匹配.</dd>
				<dt>"ipvs" match support<br>CONFIG_NETFILTER_XT_MATCH_IPVS</dt><dd>允许根据包的<a href="http://baike.baidu.com/view/2428775.htm#1">IPVS</a>属性进行匹配</dd>
				<dt>"length" match support<br>CONFIG_NETFILTER_XT_MATCH_LENGTH</dt><dd>允许对包的长度进行匹配</dd>
				<dt>"limit" match support<br>CONFIG_NETFILTER_XT_MATCH_LIMIT</dt><dd>允许根据包的进出速率进行规则匹配,常和"LOG target"配合使用以抵抗某些Dos攻击</dd>
				<dt>"mac" address match support<br>CONFIG_NETFILTER_XT_MATCH_MAC</dt><dd>允许根据以太网的MAC地址进行匹配</dd>
				<dt>"mark" match support<br>CONFIG_NETFILTER_XT_MATCH_MARK</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MARK</dd>
				<dt>"multiport" Multiple port match support<br>CONFIG_NETFILTER_XT_MATCH_MULTIPORT</dt><dd>允许对TCP或UDP包同时匹配多个不连续的端口(通常情况下只能匹配单个端口或端口范围)</dd>
				<dt>"nfacct" match support<br>CONFIG_NETFILTER_XT_MATCH_NFACCT</dt><dd>允许通过nfnetlink_acct使用扩展记账</dd>
				<dt>"osf" Passive OS fingerprint match<br>CONFIG_NETFILTER_XT_MATCH_OSF</dt><dd>开启<a href="http://en.wikipedia.org/wiki/TCP/IP_stack_fingerprinting">Passive OS Fingerprinting</a>模块,以允许通过进入的TCP SYN包被动匹配远程操作系统.规则和加载程序可以从这里获取:http://www.ioremap.net/projects/osf</dd>
				<dt>"owner" match support<br>CONFIG_NETFILTER_XT_MATCH_OWNER</dt><dd>基于创建套接字的本地进程身份(user/group)进行匹配,还可以用于检查一个套接字是否确实存在</dd>
				<dt>IPsec "policy" match support<br>CONFIG_NETFILTER_XT_MATCH_POLICY</dt><dd>基于IPsec policy进行匹配</dd>
				<dt>"physdev" match support<br>CONFIG_NETFILTER_XT_MATCH_PHYSDEV</dt><dd>允许对进入或离开所经过的物理网口进行匹配</dd>
				<dt>"pkttype" packet type match support<br>CONFIG_NETFILTER_XT_MATCH_PKTTYPE</dt><dd>允许对封包目的地址类别(广播/组播/直播)进行匹配</dd>
				<dt>"quota" match support<br>CONFIG_NETFILTER_XT_MATCH_QUOTA</dt><dd>允许对总字节数的限额值进行匹配</dd>
				<dt>"rateest" match support<br>CONFIG_NETFILTER_XT_MATCH_RATEEST</dt><dd>根据 RATEEST target 评估的速率值进行匹配</dd>
				<dt>"realm" match support<br>CONFIG_NETFILTER_XT_MATCH_REALM</dt><dd>允许根据iptables中的路由子系统中的realm值进行匹配.它与tc中的CONFIG_NET_CLS_ROUTE4非常类似.</dd>
				<dt>"recent" match support<br>CONFIG_NETFILTER_XT_MATCH_RECENT</dt><dd><a href="http://snowman.net/projects/ipt_recent/">recent match</a> 用于创建一个或多个最近使用过的地址列表,然后又可以根据这些列表再进行匹配.</dd>
				<dt>"sctp" protocol match support<br>CONFIG_NETFILTER_XT_MATCH_SCTP</dt><dd>支持根据<a href="http://www.ibm.com/developerworks/cn/linux/l-sctp/">流控制传输协议(SCTP)</a>源/目的端口和"chunk type"进行匹配.</dd>
				<dt>"socket" match support<br>CONFIG_NETFILTER_XT_MATCH_SOCKET</dt><dd>can be used to match packets for which a TCP or UDP socket lookup finds a valid socket. It can be used in combination with the MARK target and policy routing to implement full featured non-locally bound sockets.</dd>
				<dt>"state" match support<br>CONFIG_NETFILTER_XT_MATCH_STATE</dt><dd>这是对包进行分类的有力工具,它允许利用连接跟踪信息对连接中处于特定状态的包进行匹配</dd>
				<dt>"statistic" match support<br>CONFIG_NETFILTER_XT_MATCH_STATISTIC</dt><dd>允许根据一个给定的百分率对包进行周期性的或随机性的匹配</dd>
				<dt>"string" match support<br>CONFIG_NETFILTER_XT_MATCH_STRING</dt><dd>允许根据包所承载的数据中包含的特定字符串进行匹配</dd>
				<dt>"tcpmss" match support<br>CONFIG_NETFILTER_XT_MATCH_TCPMSS</dt><dd>允许根据TCP SYN包头中的MSS(最大分段长度)选项的值进行匹配</dd>
				<dt>"time" match support<br>CONFIG_NETFILTER_XT_MATCH_TIME</dt><dd>根据包的到达时刻(外面进入的包)或者离开时刻(本地生成的包)进行匹配</dd>
				<dt>"u32" match support<br>CONFIG_NETFILTER_XT_MATCH_U32</dt><dd>"u32"允许从包中提取拥有特定mask的最多4字节数据,将此数据移动(shift)特定的位数,然后测试其结果是否位于特定的集合范围内.更多细节可以直接参考内核源码(net/netfilter/xt_u32.c)</dd>
			</dl></dd>
		</dl></dd>
		<dt>IP set support<br>CONFIG_IP_SET</dt><dd>为内核添加IP集(IP set)支持,然后就可以使用CONFIG_NETFILTER_XT_SET功能.此特性必须配合用户态工具<a href="http://ipset.netfilter.org/">ipset</a>一起使用.</dd>
		<dd><dl>
			<dt>Maximum number of IP sets<br>CONFIG_IP_SET_MAX</dt><dd>默认的最大"set"数,取值范围是[2,65534].此值也可以由ip_set模块的max_sets参数设置.</dd>
			<dt>bitmap:ip set support<br>CONFIG_IP_SET_BITMAP_IP</dt><dd>"bitmap:ip"集合类型.根据IP地址范围设定集合.</dd>
			<dt>bitmap:ip,mac set support<br>CONFIG_IP_SET_BITMAP_IPMAC</dt><dd>"bitmap:ip,mac"集合类型.根据IP/MAC地址对范围设定集合.</dd>
			<dt>bitmap:port set support<br>CONFIG_IP_SET_BITMAP_PORT</dt><dd>"bitmap:port"集合类型.根据端口范围设定集合.</dd>
			<dt>hash:ip set support<br>CONFIG_IP_SET_HASH_IP</dt><dd>"hash:ip"集合类型.为多个离散的IP地址设定集合.</dd>
			<dt>hash:ip,port set support<br>CONFIG_IP_SET_HASH_IPPORT</dt><dd>"hash:ip,port"集合类型.为多个离散的IP/MAC地址对设定集合.</dd>
			<dt>hash:ip,port,ip<br>CONFIG_IP_SET_HASH_IPPORTIP</dt><dd>"hash:ip,port,ip"集合类型.为多个离散的IP/端口/IP三元组设定集合.</dd>
			<dt>hash:ip,port,net set support<br>CONFIG_IP_SET_HASH_IPPORTNET</dt><dd>"hash:ip,port,net"集合类型.为多个离散的IP/端口/网段三元组设定集合.</dd>
			<dt>hash:net set support<br>CONFIG_IP_SET_HASH_NET</dt><dd>"hash:net"集合类型.为多个离散的网段设定集合</dd>
			<dt>hash:net,port set support<br>CONFIG_IP_SET_HASH_NETPORT</dt><dd>"hash:net,port"集合类型.为多个离散的网段/端口对设定集合</dd>
			<dt>hash:net,iface set support<br>CONFIG_IP_SET_HASH_NETIFACE</dt><dd>"hash:net,iface"集合类型.为多个离散的网段/网卡接口对设定集合</dd>
			<dt>list:set set support<br>CONFIG_IP_SET_LIST_SET</dt><dd>"list:set"集合类型.将多个集合组成一个更大的集合</dd>
		</dl></dd>
		<dt>IP virtual server support<br>CONFIG_IP_VS</dt><dd><a href="http://www.baike.com/wiki/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">IPVS</a>(<a href="http://www.linuxvirtualserver.org/software/ipvs.html">IP Virtual Server</a>)支持.IPVS可以帮助<a href="http://www.linuxvirtualserver.org/zh/lvs1.html">LVS</a>基于多个后端真实服务器创建一个高性能的虚拟服务器.可以使用三种具体的方法实现:NAT,隧道,直接路由(使用较广).</dd>
		<dd><dl>
			<dt>IPv6 support for IPVS<br>CONFIG_IP_VS_IPV6</dt><dd>为IPVS添加IPv6支持</dd>
			<dt>IP virtual server debugging<br>CONFIG_IP_VS_DEBUG</dt><dd>为IPVS添加调试支持</dd>
			<dt>IPVS connection table size (the Nth power of 2)<br>CONFIG_IP_VS_TAB_BITS</dt><dd>设置IPVS连接哈希表的大小(2<sup>CONFIG_IP_VS_TAB_BITS</sup>),取值范围是[8,20],默认值12的意思是哈希表的大小是2<sup>12</sup>=4096项.IPVS连接哈希表使用链表来处理哈希碰撞.使用大的哈希表能够显著减少碰撞几率,特别是哈希表中有成千上万连接的时候.比较恰当的值差不多等于每秒的新建连接数乘以每个连接的平均持续秒数.太小的值会造成太多碰撞,从而导致性能大幅下降;太大的值又会造成占用太多不必要的内存(每个表项8字节+每个连接128字节).该值也可以通过ip_vs模块的conn_tab_bits参数进行设置.</dd>
			<dt>TCP load balancing support<br>CONFIG_IP_VS_PROTO_TCP</dt><dd>TCP传输协议负载均衡支持</dd>
			<dt>UDP load balancing support<br>CONFIG_IP_VS_PROTO_UDP</dt><dd>UDP传输协议负载均衡支持</dd>
			<dt>ESP load balancing support<br>CONFIG_IP_VS_PROTO_ESP</dt><dd>IPSec ESP(Encapsulation Security Payload)传输协议负载均衡支持</dd>
			<dt>AH load balancing support<br>CONFIG_IP_VS_PROTO_AH</dt><dd>IPSec AH(Authentication Header)传输协议负载均衡支持.</dd>
			<dt>SCTP load balancing support<br>CONFIG_IP_VS_PROTO_SCTP</dt><dd>SCTP传输协议负载均衡支持</dd>
			<dt>round-robin scheduling<br>CONFIG_IP_VS_RR</dt><dd>循环分散算法:最简单的调度算法,将连接简单的循环分散到后端服务器上</dd>
			<dt>weighted round-robin scheduling<br>CONFIG_IP_VS_WRR</dt><dd>基于权重的循环分散算法:在循环分散的基础上,权重较高的后端服务器接纳较多的连接</dd>
			<dt>least-connection scheduling<br>CONFIG_IP_VS_LC</dt><dd>最少连接算法:将连接优先分配到活动连接最少的后端服务器</dd>
			<dt>weighted least-connection scheduling<br>CONFIG_IP_VS_WLC</dt><dd>基于权重的最少连接算法:结合考虑活动连接数与服务器权重</dd>
			<dt>locality-based least-connection scheduling<br>CONFIG_IP_VS_LBLC</dt><dd>基于目的IP的最少连接算法(常用于缓存集群):优先根据目的IP地址将连接分配到特定的后端,仅在这些后端过载时(活动连接数大于其权重)才分散到其他后端.</dd>
			<dt>locality-based least-connection with replication scheduling<br>CONFIG_IP_VS_LBLCR</dt><dd>与LBLC类似,不同之处在于:前端负载均衡器会像NAT一样同时记住客户端IP与后端的对应关系,并在新的连接到来的时候,复用这个对应关系.</dd>
			<dt>destination hashing scheduling<br>CONFIG_IP_VS_DH</dt><dd>目标地址哈希表算法:简单的根据静态设定的目标IP地址哈希表将连接分发到后端</dd>
			<dt>source hashing scheduling<br>CONFIG_IP_VS_SH</dt><dd>源地址哈希表算法:简单的根据静态设定的源IP地址哈希表将连接分发到后端</dd>
			<dt>shortest expected delay scheduling<br>CONFIG_IP_VS_SED</dt><dd>最小期望延迟算法:将连接分配到根据期望延迟公式((Ci+1)/Ui)算得的延迟最小的后端."i"是后端服务器编号,"Ci"是该服务器当前的连接数,"Ui"是该服务器的权重.</dd>
			<dt>never queue scheduling<br>CONFIG_IP_VS_NQ</dt><dd>无排队算法:这是一个两阶段算法,如果有空闲服务器,就直接分发到空闲服务器(而不是等待速度最快的服务器),如果没有空闲服务器,就分发到期望延迟最小的服务器(SED算法).</dd>
			<dt>IPVS source hashing table size (the Nth power of 2)<br>CONFIG_IP_VS_SH_TAB_BITS</dt><dd>将源IP地址映射到后端服务器所使用的哈希表的大小(2<sup>CONFIG_IP_VS_SH_TAB_BITS</sup>),取值范围是[4,20],默认值8的意思是哈希表的大小是2<sup>8</sup>=256项.理想的大小应该是所有后端的权重乘以后端总数?</dd>
			<dt>FTP protocol helper<br>CONFIG_IP_VS_FTP</dt><dd>FTP协议连接追踪帮助</dd>
			<dt>Netfilter connection tracking<br>CONFIG_IP_VS_NFCT</dt><dd>Netfilter连接追踪支持</dd>
			<dt>SIP persistence engine<br>CONFIG_IP_VS_PE_SIP</dt><dd>基于SIP Call-ID提供持久连接支持</dd>
		</dl></dd>
		<dt>IP: Netfilter Configuration</dt><dd>针对IPv4的Netfilter配置</dd>
		<dd><dl>
			<dt>IPv4 connection tracking support (required for NAT)<br>CONFIG_NF_CONNTRACK_IPV4</dt><dd>IPv4链接跟踪.可用于包伪装或地址转换,也可用于增强包过滤能力</dd>
			<dd><dl>
				<dt>proc/sysctl compatibility with old connection tracking<br>CONFIG_NF_CONNTRACK_PROC_COMPAT</dt><dd>用于兼容老旧的连接追踪用户态程序</dd>
			</dl></dd>
			<dt>IP tables support (required for filtering/masq/NAT)<br>CONFIG_IP_NF_IPTABLES</dt><dd>要用iptables就肯定要选上</dd>
			<dd><dl>
				<dt>"ah" match support<br>CONFIG_IP_NF_MATCH_AH</dt><dd>允许对IPSec包头的AH字段进行匹配</dd>
				<dt>"ecn" match support<br>CONFIG_IP_NF_MATCH_ECN</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MATCH_ECN</dd>
				<dt>"rpfilter" reverse path filter match support<br>CONFIG_IP_NF_MATCH_RPFILTER</dt><dd>对进出都使用同一个网络接口的包进行匹配</dd>
				<dt>"ttl" match support<br>CONFIG_IP_NF_MATCH_TTL</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MATCH_HL</dd>
				<dt>Packet filtering<br>CONFIG_IP_NF_FILTER</dt><dd>定义filter表,以允许对包进行过滤.Docker依赖于它.</dd>
				<dd><dl>
					<dt>REJECT target support<br>CONFIG_IP_NF_TARGET_REJECT</dt><dd>允许返回一个ICMP错误包而不是简单的丢弃包</dd>
				</dl></dd>
				<dt>ULOG target support<br>CONFIG_IP_NF_TARGET_ULOG</dt><dd>反对使用该选项,因为它已经被CONFIG_NETFILTER_NETLINK_LOG代替</dd>
				<dt>IPv4 NAT<br>CONFIG_NF_NAT_IPV4</dt><dd>允许进行伪装/端口转发以及其它的NAT功能,仅在你需要使用iptables中的nat表时才需要选择.Docker依赖于它.</dd>
				<dd><dl>
					<dt>MASQUERADE target support<br>CONFIG_IP_NF_TARGET_MASQUERADE</dt><dd>SNAT是指在数据包从网卡发送出去的时候,把数据包中的源地址部分替换为指定的IP,这样,接收方就认为数据包的来源是被替换的那个IP的主机.伪装(MASQUERADE)是一种特殊类型的SNAT:MASQUERADE是用发送数据的网卡上的IP来替换源IP,用于那些IP不固定的场合(比如拨号或者通过DHCP分配).Docker依赖于它.</dd>
					<dt>NETMAP target support<br>CONFIG_IP_NF_TARGET_NETMAP</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_TARGET_NETMAP.</dd>
					<dt>REDIRECT target support<br>CONFIG_IP_NF_TARGET_REDIRECT</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_TARGET_REDIRECT.</dd>
					<dt>Basic SNMP-ALG support<br>CONFIG_NF_NAT_SNMP_BASIC</dt><dd>为<a href="http://baike.baidu.com/view/2899.htm">SNMP</a>荷载实现ALG(Application Layer Gateway)支持(<a href="http://www.rfc-base.org/txt/rfc-2962.txt">RFC2962</a>).</dd>
				</dl></dd>
				<dt>Packet mangling<br>CONFIG_IP_NF_MANGLE</dt><dd>在iptables中启用mangle表以便对包进行各种修改,常用于改变包的路由</dd>
				<dd><dl>
					<dt>CLUSTERIP target support<br>CONFIG_IP_NF_TARGET_CLUSTERIP</dt><dd>CLUSTERIP target 允许你无需使用昂贵的负载均衡设备也能创建廉价的负载均衡集群</dd>
					<dt>ECN target support<br>CONFIG_IP_NF_TARGET_ECN</dt><dd>用于mangle表,可以去除IPv4包头的<a href="http://blog.sina.com.cn/s/blog_6cf9802d0100xtwv.html">ECN(Explicit Congestion Notification)</a>位,主要用于在保持ECN功能的前提下,去除网络上的"ECN黑洞".</dd>
					<dt>"TTL" target support<br>CONFIG_IP_NF_TARGET_TTL</dt><dd>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_TARGET_HL.</dd>
				</dl></dd>
				<dt>raw table support (required for NOTRACK/TRACE)<br>CONFIG_IP_NF_RAW</dt><dd>在iptables中添加一个raw表,该表在netfilter框架中非常靠前,并在PREROUTING和OUTPUT链上有钩子,从而可以对收到的数据包在连接跟踪前进行处理</dd>
				<dt>Security table<br>CONFIG_IP_NF_SECURITY</dt><dd>在iptables中添加一个security表,以支持<a href="http://baike.baidu.com/view/4420215.htm">强制访问控制(Mandatory Access Control)</a>策略</dd>
			</dl></dd>
			<dt>ARP tables support<br>CONFIG_IP_NF_ARPTABLES</dt><dd><a href="http://baike.baidu.com/view/3908213.htm">arptables</a>支持</dd>
			<dd><dl>
				<dt>ARP packet filtering<br>CONFIG_IP_NF_ARPFILTER</dt><dd>ARP包过滤.对于进入和离开本地的ARP包定义一个filter表,在桥接的情况下还可以应用于被转发的ARP包</dd>
				<dt>ARP payload mangling<br>CONFIG_IP_NF_ARP_MANGLE</dt><dd>允许对ARP包的荷载部分进行修改,比如修改源和目标物理地址</dd>
			</dl></dd>
		</dl></dd>
		<dt>IPv6: Netfilter Configuration</dt><dd>针对IPv6的Netfilter配置.其子项内容类似于IPv4,需要的话可以参考前面IPv4的Netfilter配置进行选择</dd>
		<dt>DECnet: Netfilter Configuration</dt><dd>针对<a href="http://baike.baidu.com/view/1449756.htm">DECnet</a>的Netfilter配置</dd>
		<dt>Ethernet Bridge tables (ebtables) support<br>CONFIG_BRIDGE_NF_EBTABLES</dt><dd>针对以太网桥的<a href="http://www.oschina.net/p/ebtables">ebtables</a> Netfilter配置</dd>
	</dl></dd>
	<dt>The DCCP Protocol<br>CONFIG_IP_DCCP</dt><dd>数据报拥塞控制协议(<a href="http://zh.wikipedia.org/wiki/DCCP">Datagram Congestion Control Protocol</a>)在UDP的基础上增加了流控和拥塞控制机制,使数据报协议能够更好地用于流媒体业务的传输</dd>
	<dt>The SCTP Protocol<br>CONFIG_IP_SCTP</dt><dd><a href="http://zh.wikipedia.org/wiki/%E6%B5%81%E6%8E%A7%E5%88%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">流控制传输协议</a>(<a href="http://www.ibm.com/developerworks/cn/linux/l-sctp/">Stream Control Transmission Protocol</a>)是一种新兴的传输层协议.TCP协议一次只能连接一个IP地址而在<a href="http://www.cnblogs.com/qlee/archive/2011/07/13/2105717.html">SCTP</a>协议一次可以连接多个IP地址且可以自动平衡网络负载,一旦某一个IP地址失效会自动将网络负载转移到其他IP地址上</dd>
	<dt>The RDS Protocol<br>CONFIG_RDS</dt><dd><a href="http://network.51cto.com/art/200711/60157.htm">可靠数据报套接字(Reliable Datagram Sockets)协议</a>支持.RDS可以使用Infiniband和iWARP作为支持RDMA(远程直接内存访问)的传输方式,RDMA用于一台远程计算机访问另一台计算机的内存而无需本机计算机操作系统的辅助,这就像直接内存访问(DMA),但是这里远程代替了本地计算机.</dd>
	<dt>The TIPC Protocol<br>CONFIG_TIPC</dt><dd>透明内部进程间通信协议(<a href="http://zh.wikipedia.org/wiki/TIPC">Transparent Inter Process Communication</a>),以共享内存为基础实现任务和资源的调度,专门用于集群内部通信</dd>
	<dt>Asynchronous Transfer Mode (ATM)<br>CONFIG_ATM</dt><dd>异步传输模式(<a href="http://baike.baidu.com/view/817251.htm">ATM</a>)支持.主要用于高速LAN和WAN.目前已经日薄西山了.</dd>
	<dt>Layer Two Tunneling Protocol (L2TP)<br>CONFIG_L2TP</dt><dd><a href="http://baike.baidu.com/view/32692.htm">第二层隧道协议</a>(RFC2661)是一种对应用透明的隧道协议,VPN经常使用它.</dd>
	<dt>802.1d Ethernet Bridging<br>CONFIG_BRIDGE</dt><dd><a href="http://baike.baidu.com/view/2019315.htm">802.1d</a>以太网桥(例如为QEMU虚拟机或Docker容器提供桥接网卡支持)</dd>
	<dd><dl>
		<dt>IGMP/MLD snooping<br>CONFIG_BRIDGE_IGMP_SNOOPING</dt><dd>选"Y"可以允许以太网桥根据<a href="http://baike.baidu.com/view/876138.htm">IGMP</a>(<a href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">Internet Group Management Protocol</a>, IPv4)/<a href="http://ithelp.ithome.com.tw/articles/10004381">MLD</a>(<a href="http://hanteye01.blog.fc2.com/blog-entry-6.html">Multicast Listener Discovery</a>, IPv6)负载选择性的转发不同端口上的多播包.选"N"可以减小二进制文件的体积.确定需要使用组播的选"Y".</dd>
	</dl></dd>
	<dt>802.1Q/802.1ad VLAN Support<br>CONFIG_VLAN_8021Q</dt><dd><a href="http://baike.baidu.com/view/116899.htm">802.1Q</a>虚拟局域网</dd>
	<dt>DECnet Support<br>CONFIG_DECNET</dt><dd><a href="http://baike.baidu.com/view/1449756.htm">DECnet</a>协议</dd>
	<dt>ANSI/IEEE 802.2 LLC type 2 Support<br>CONFIG_LLC2</dt><dd>PF_LLC类型套接字支持.也就是<a href="http://baike.baidu.com/view/193847.htm">IEEE 802.2 LLC 2</a></dd>
	<dt>The IPX protocol<br>CONFIG_IPX</dt><dd><a href="http://baike.baidu.com/view/32700.htm">IPX协议</a>是由Novell公司提出的运行于OSI模型第三层的协议,具有可路由的特性,IPX的地址分为网络地址和主机地址,网络地址由管理员分配,主机地址为MAC地址.由于IP协议的广泛使用,IPX的应用早已日薄西山.</dd>
	<dt>Appletalk protocol support<br>CONFIG_ATALK</dt><dd><a href="http://baike.baidu.com/view/25115.htm">Appletalk</a>是苹果公司创建的一组网络协议,仅用于苹果系列计算机.</dd>
	<dt>CCITT X.25 Packet Layer<br>CONFIG_X25</dt><dd><a href="http://www.baike.com/wiki/x.25">CCITT X.25</a>协议集支持.</dd>
	<dt>LAPB Data Link Driver<br>CONFIG_LAPB</dt><dd><a href="http://baike.baidu.com/view/1147867.htm">LAPB</a>协议支持.</dd>
	<dt>Phonet protocols family<br>CONFIG_PHONET</dt><dd>PhoNet是Nokia开发的面相数据包的通信协议,仅用于Nokia maemo/meego产品.</dd>
	<dt>IEEE Std 802.15.4 Low-Rate Wireless Personal Area Networks support<br>CONFIG_IEEE802154</dt><dd><a href="http://blog.csdn.net/zwlforever/article/details/6340366">IEEE Std 802.15.4</a> 定义了一个低速率/低功耗/低复杂度的短距离个人无线网络规范.主要用于物联网中的传感器/交换器之类设备之间的互联.</dd>
	<dd><dl>
		<dt>6lowpan support over IEEE 802.15.4<br>CONFIG_IEEE802154_6LOWPAN</dt><dd>在IEEE 802.15.4上支持IPv6压缩.</dd>
		<dt>Generic IEEE 802.15.4 Soft Networking Stack (mac802154)<br>CONFIG_MAC802154</dt><dd>为SoftMAC设备(仅实现了PHY层)实现硬件独立的<a href="http://blog.csdn.net/zwlforever/article/details/6340366">IEEE Std 802.15.4</a>协议栈.使用HardMAC设备的用户应该选"N".[注意]这里的实现既未经过认证,也未进行充分的兼容性测试.</dd>
	</dl></dd>
	<dt>QoS and/or fair queueing<br>CONFIG_NET_SCHED</dt><dd><a href="http://zh.wikipedia.org/zh-cn/QoS">QoS</a>(<a href="http://baike.baidu.com/view/20897.htm">Quality of Service</a>)支持.当内核有多个包需要通过网络发送的时候,它需要决定哪个包先发,那个包后发,哪个包丢弃.这就是包调度算法.关闭此项表示内核使用最简单的FIFO算法,开启此项后就可以使用多种不同的调度算法(需要配合用户层工具<a href="ftp://ftp.tux.org/pub/net/ip-routing/">iproute2+tc</a>).QoS还用于支持<a href="http://diffserv.sourceforge.net/">diffserv</a>(Differentiated Services)和<a href="http://baike.baidu.com/view/876124.htm">RSVP</a>(Resource Reservation Protocol)功能.包调度的状态信息可以从"/proc/net/psched"文件中获取.仅在你确实需要的时候选"Y".</dd>
	<dt>Data Center Bridging support<br>CONFIG_DCB</dt><dd><a href="http://zh.community.dell.com/techcenter/b/weblog/archive/2011/08/30/ready-for-the-dcb-coming.aspx">DCB(Data Center Bridging)</a>支持.数据中心桥接是一组可增强传统以太网功能,以管理通信的功能,尤其适用于网络通信流量和传输率都很高的环境中.光纤通道可专用于承载此类型的通信.但是,如果使用专用链路来仅提供光纤通道通信,则成本可能会很高.因此,更多情况下使用以太网光纤通道.DCB功能可满足光纤通道对遍历以太网时包丢失的敏感度要求.DCB允许对等方基于优先级区分通信.通过区分优先级,可确保在主机之间发生拥塞时,保持较高优先级通信的包完整性.使用DCB交换协议,通信主机可以交换会影响高速网络通信的配置信息.然后,对等方可对公用配置进行协商,确保通信流不中断,同时防止高优先级包出现包丢失.这些功能都需要底层的网卡支持.一般网卡都是不支持的.所以不确定的可以选"N".</dd>
	<dt>DNS Resolver support<br>CONFIG_DNS_RESOLVER</dt><dd>内核DNS解析支持.用于支持CONFIG_AFS_FS/CONFIG_CIFS/CONFIG_CIFS_SMB2/NFS_V4模块.此功能需要用户态程序"/sbin/dns.resolve"和配置文件"/etc/request-key.conf"的支持.更多信息参见"<a href="https://www.kernel.org/doc/Documentation/networking/dns_resolver.txt">Documentation/networking/dns_resolver.txt</a>"文档,不确定的选"N".</dd>
	<dt>B.A.T.M.A.N. Advanced Meshing Protocol<br>CONFIG_BATMAN_ADV</dt><dd>B.A.T.M.A.N.(更好的移动无线网络方案)是一种用于 multi-hop ad-hoc <a href="http://baike.baidu.com/view/1215700.htm">mesh</a> 网络的路由协议.它是一种去中心化分布式无线Adhoc模式,特别适用于自然灾害等紧急情况下,创建临时的无线网络.不确定的选"N".</dd>
	<dt>Open vSwitch<br>CONFIG_OPENVSWITCH</dt><dd><a href="http://bengo.blog.51cto.com/4504843/791213/">Open vSwitch</a> 是一个多层虚拟交换标准.此选项提供了内核级的高速转发功能(需要配合用户态守护进程ovs-vswitchd来实现).</dd>
	<dt>Virtual Socket protocol<br>CONFIG_VSOCKETS</dt><dd>这是一个类似于TCP/IP的协议,用于虚拟机之间以及虚拟机与宿主之间的通信.开启此项后,还需要从子项中选择适用于特定虚拟化技术的传输协议.</dd>
	<dd><dl>
		<dt>VMware VMCI transport for Virtual Sockets<br>CONFIG_VMWARE_VMCI_VSOCKETS</dt><dd>适用于VMware虚拟化技术的VMCI传输协议支持.</dd>
	</dl></dd>
	<dt>NETLINK: mmaped IO<br>CONFIG_NETLINK_MMAP</dt><dd>基于内存映射机制的 <a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a> IO 支持.可以避免在用户空间与内存空间之间复制数据,从而提升操作速度.不确定的选"N".</dd>
	<dt>NETLINK: socket monitoring interface<br>CONFIG_NETLINK_DIAG</dt><dd>NETLINK socket 监视接口.<a href="http://xikder.blog.51cto.com/1423200/869467">ss</a>这样的诊断工具需要它.</dd>
	<dt>MultiProtocol Label Switching<br>CONFIG_MPLS</dt><dd><a href="http://www.cisco.com/support/zh/105/mpls_faq_4649.shtml">多协议标签交换</a>(<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2">MPLS</a>)是新一代的IP高速骨干网络交换标准.不确定的选"N".</dd>
	<dt>High-availability Seamless Redundancy (HSR)<br>CONFIG_HSR</dt><dd>以太网HSR(高可用性无缝冗余)规范(IEC 62439-3:2010)支持.不确定的选"N".</dd>
	<dt>Network priority cgroup<br>CONFIG_NETPRIO_CGROUP<br>CONFIG_CGROUP_NET_PRIO</dt><dd>Cgroup子系统支持:基于每个网络接口为每个进程分配网络使用优先级.Docker依赖于它.</dd>
	<dt>enable BPF Just In Time compiler<br>CONFIG_BPF_JIT</dt><dd><a href="http://zh.wikipedia.org/wiki/BPF">BPF(Berkeley Packet Filter)</a>的过滤功能通常由一个解释器(interpreter)解释执行BPF虚拟机指令的方式工作.开启此项,内核在加载过滤指令后,会将其编译为本地指令,以加快执行速度.网络嗅探程序(libpcap/tcpdump)可以从中受益.注意:需要"echo 1 > /proc/sys/net/core/bpf_jit_enable"之后才能生效.</dd>
	<dt>Network testing</dt><dd>网络测试,仅供调试使用</dd>
</dl></dd>
<dt>Amateur Radio support<br>CONFIG_HAMRADIO</dt><dd>业余无线电支持.供无线电爱好者进行自我训练/相互通讯/技术研究</dd>
<dt>CAN bus subsystem support<br>CONFIG_CAN</dt><dd><a href="http://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8D%80%E5%9F%9F%E7%B6%B2%E8%B7%AF">CAN(Controller Area Network)</a>是一个低速串行通信协议.被广泛地应用于工业自动化/船舶/医疗设备/工业设备等嵌入式领域.更多信息参见"<a href="https://www.kernel.org/doc/Documentation/networking/can.txt">Documentation/networking/can.txt</a>"文件.</dd>
<dt>IrDA (infrared) subsystem support<br>CONFIG_IRDA</dt><dd><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E5%A4%96%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF">红外线通讯技术</a>支持,主要用于嵌入式环境,某些老旧的笔记本上也可能会有红外接口.</dd>
<dt>Bluetooth subsystem support<br>CONFIG_BT</dt><dd><a href="http://www.cppblog.com/iuranus/archive/2008/12/14/69391.html">蓝牙</a>支持.蓝牙目前已经基本取代红外线,成为嵌入式设备/智能设备/笔记本的标配近距离(小于10米)通信设备.在Linux上通常使用来自<a href="http://www.bluez.org/">BlueZ</a>的hciconfig和bluetoothd工具操作蓝牙通信.</dd>
<dd><dl>
	<dt>RFCOMM protocol support<br>CONFIG_BT_RFCOMM</dt><dd>虚拟串口协议(<a href="http://baike.baidu.com/view/493704.htm">RFCOMM</a>)是一个面向连接的流传输协议,提供<a href="http://baike.baidu.com/view/112004.htm">RS232</a>控制和状态信号,从而模拟串口的功能.它被用于支持拨号网络,<a href="http://blog.csdn.net/yangwenchao1983/article/details/4583140">OBEX(Object Exchange)</a>,以及某些蓝牙程序(例如文件传输).</dd>
	<dd><dl>
		<dt>RFCOMM TTY support<br>CONFIG_BT_RFCOMM_TTY</dt><dd>允许在RFCOMM通道上模拟<a href="http://baike.baidu.com/view/749979.htm">TTY</a>终端</dd>
	</dl></dd>
	<dt>BNEP protocol support<br>CONFIG_BT_BNEP</dt><dd>蓝牙网络封装协议(Bluetooth Network Encapsulation Protocol)可以在蓝牙上运行其他网络协议(TCP/IP). <a href="http://windows.microsoft.com/zh-cn/windows7/what-is-a-bluetooth-personal-area-network-pan">Bluetooth PAN</a>(Personal Area Network)需要它的支持.</dd>
	<dd><dl>
		<dt>Multicast filter support<br>CONFIG_BT_BNEP_MC_FILTER</dt><dd>组播支持</dd>
		<dt>Protocol filter support<br>CONFIG_BT_BNEP_PROTO_FILTER</dt><dd>协议过滤器支持</dd>
	</dl></dd>
	<dt>CMTP protocol support<br>CONFIG_BT_CMTP</dt><dd>CMTP(CAPI消息传输协议)用于支持已在上世纪被淘汰的ISDN设备.不确定的选"N".</dd>
	<dt>HIDP protocol support<br>CONFIG_BT_HIDP</dt><dd>人机接口设备协议(Human Interface Device Protocol)用于支持各种人机接口设备(比如鼠标/键盘/耳机等).</dd>
	<dt>Bluetooth device drivers</dt><dd>各种蓝牙设备驱动</dd>
	<dd><dl>
		<dt>HCI USB driver<br>CONFIG_BT_HCIBTUSB</dt><dd>使用USB接口的蓝牙设备支持</dd>
		<dt>HCI SDIO driver<br>CONFIG_BT_HCIBTSDIO</dt><dd>使用<a href="http://zh.wikipedia.org/wiki/Secure_Digital#SDIO_.E4.BB.8B.E7.BB.8D">SDIO</a>接口的蓝牙设备支持</dd>
		<dt>HCI UART driver<br>CONFIG_BT_HCIUART</dt><dd>使用串口的蓝牙设备支持.此外,基于<a href="http://baike.baidu.com/view/245027.htm">UART</a>的蓝牙<a href="http://baike.baidu.com/view/591980.htm">PCMCIA</a>和<a href="http://baike.baidu.com/view/3832.htm">CF</a>设备也需要此模块的支持.</dd>
		<dd><dl>
			<dt>UART (H4) protocol support<br>CONFIG_BT_HCIUART_H4</dt><dd>大多数使用UART接口的蓝牙设备(包括PCMCIA和CF卡)都使用这个协议.</dd>
			<dt>BCSP protocol support<br>CONFIG_BT_HCIUART_BCSP</dt><dd>基于CSR(Cambridge Silicon Radio)公司的BlueCore系列芯片的蓝牙设备(包括PCMCIA和CF卡)支持</dd>
			<dt>Atheros AR300x serial support<br>CONFIG_BT_HCIUART_ATH3K</dt><dd>基于Atheros AR300x系列芯片的蓝牙设备支持</dd>
			<dt>HCILL protocol support<br>CONFIG_BT_HCIUART_LL</dt><dd>基于Texas Instruments公司的BRF芯片的蓝牙设备支持</dd>
			<dt>Three-wire UART (H5) protocol support<br>CONFIG_BT_HCIUART_3WIRE</dt><dd>Three-wire UART (H5) 协议假定UART通信可能存在各种错误,从而使得CTS/RTS引脚线变得可有可无.看不懂就可以不选.</dd>
		</dl></dd>
		<dt>HCI VHCI (Virtual HCI device) driver<br>CONFIG_BT_HCIVHCI</dt><dd>模拟蓝牙设备支持.主要用于开发</dd>
		<dt class="omit">{大多数蓝牙设备并不需要特定的独立驱动,此处省略的独立驱动仅是为了驱动那些不严格遵守蓝牙规范的芯片}</dt>
	</dl></dd>
</dl></dd>
<dt>RxRPC session sockets<br>CONFIG_AF_RXRPC</dt><dd>RxRPC会话套接字支持(仅包括传输部分,不含表示部分).CONFIG_AFS_FS依赖于它.不确定的选"N".详情参见"<a href="https://www.kernel.org/doc/Documentation/networking/rxrpc.txt">Documentation/networking/rxrpc.txt</a>"文档.</dd>
<dt>Wireless<br>CONFIG_WIRELESS</dt><dd>无线网络支持.</dd>
<dd><dl>
	<dt>cfg80211 - wireless configuration API<br>CONFIG_CFG80211</dt><dd><a href="http://wireless.kernel.org/en/developers/Documentation/cfg80211">cfg80211</a>是<a href="http://www.crifan.com/files/doc/docbook/linux_wireless/release/htmls/ch05_linux_wireless_lan_80211.html">Linux无线局域网</a>(<a href="http://zh.wikipedia.org/zh/IEEE_802.11">802.11</a>)配置接口,是使用WiFi的前提.注意:"<a href="http://baike.baidu.com/view/3941.htm">WiFi</a>"是一个无线网路通信技术的品牌,由WiFi联盟所持有.目的是改善基于IEEE 802.11标准的无线网路产品之间的互通性.现时一般人会把WiFi及IEEE 802.11混为一谈,甚至把WiFi等同于无线网路(WiFi只是无线网络的一种).</dd>
	<dd><dl>
		<dt>nl80211 testmode command<br>CONFIG_NL80211_TESTMODE</dt><dd>仅供调试和特殊目的使用.</dd>
		<dt>enable developer warnings<br>CONFIG_CFG80211_DEVELOPER_WARNINGS</dt><dd>仅供调试开发使用</dd>
		<dt>cfg80211 regulatory debugging<br>CONFIG_CFG80211_REG_DEBUG</dt><dd>仅供调试开发使用</dd>
		<dt>cfg80211 certification onus<br>CONFIG_CFG80211_CERTIFICATION_ONUS</dt><dd>仅在你确实明白此项含义的情况下,才考虑选"Y",否则请选"N".</dd>
		<dt>enable powersave by default<br>CONFIG_CFG80211_DEFAULT_PS</dt><dd>若开启此项则表示默认开启省电模式(也就是默认"Soft blocked: yes").关闭此项则表示默认使用BIOS中的状态(通常是上一次关机时的状态).详情参见"<a href="https://www.kernel.org/doc/Documentation/power/pm_qos_interface.txt">Documentation/power/pm_qos_interface.txt</a>"文档.</dd>
		<dt>cfg80211 DebugFS entries<br>CONFIG_CFG80211_DEBUGFS</dt><dd>仅供调试</dd>
		<dt>use statically compiled regulatory rules database<br>CONFIG_CFG80211_INTERNAL_REGDB</dt><dd>由于绝大多数发行版都含有<a href="http://wireless.kernel.org/en/developers/Regulatory/CRDA">CRDA</a>软件包,所以绝大多数人应该选"N".如果你确实需要选"Y",那么请认真阅读"net/wireless/db.txt"文件.</dd>
		<dt>cfg80211 wireless extensions compatibility<br>CONFIG_CFG80211_WEXT</dt><dd>为那些老旧的用户空间程序提供兼容性,建议关闭.</dd>
	</dl></dd>
	<dt>lib80211 debugging messages<br>CONFIG_LIB80211_DEBUG</dt><dd>仅供调试</dd>
	<dt>Generic IEEE 802.11 Networking Stack (mac80211)<br>CONFIG_MAC80211</dt><dd>独立于硬件的通用<a href="http://wenku.baidu.com/view/7df7eb7f27284b73f24250e5.html">IEEE 802.11</a>协议栈模块(mac80211).它是驱动开发者用来编写softMAC无线设备驱动的框架,softMAC设备允许用软件实现帧的管理(包括解析和产生80211无线帧),从而让系统能更好的控制硬件,现在大多数的无线网卡都是softMAC设备.不确定的选"Y".</dd>
	<dt>PID controller based rate control algorithm<br>CONFIG_MAC80211_RC_PID</dt><dd>基于<a href="http://baike.baidu.com/view/104644.htm">比例-积分-微分控制器</a>(<a href="http://wireless.kernel.org/en/developers/Documentation/mac80211/RateControl/PID">PID controller</a>)的发送速率(TX rate)控制算法.用于CONFIG_MAC80211模块.不确定的选"N".</dd>
	<dt>Minstrel<br>CONFIG_MAC80211_RC_MINSTREL</dt><dd><a href="http://wireless.kernel.org/en/developers/Documentation/mac80211/RateControl/minstrel">minstrel</a>发送速率(TX rate)控制算法.用于CONFIG_MAC80211模块.这是首选的算法,不确定的选"Y".</dd>
	<dd><dl>
		<dt>Minstrel 802.11n support<br>CONFIG_MAC80211_RC_MINSTREL_HT</dt><dd><a href="http://lwn.net/Articles/376765/">minstrel_ht</a>发送速率(TX rate)控制算法.适用于<a href="http://baike.baidu.com/view/32843.htm">802.11n</a>规范.不确定的选"Y".</dd>
	</dl></dd>
	<dt>Default rate control algorithm</dt><dd>默认发送速率(TX rate)控制算法.相当于mac80211模块"ieee80211_default_rc_algo"参数的值.建议选择"Minstrel"算法.</dd>
	<dt>Enable mac80211 mesh networking (pre-802.11s) support<br>CONFIG_MAC80211_MESH</dt><dd><a href="http://baike.baidu.com/view/1720501.htm">802.11s</a>草案是无线网状网络(Mesh Networking)的延伸与增补标准(amendment).它扩展了IEEE 802.11 MAC(介质访问控制)标准,定义了利用自我组态的多点跳跃拓朴(multi-hop topologies),进行无线感知(radio-aware metrics),以支援广播/组播/单播传送网络封包的架构与协定.不确定的选"N".</dd>
	<dt>Enable LED triggers<br>CONFIG_MAC80211_LEDS</dt><dd>允许在接受/发送数据时触发无线网卡的LED灯闪烁.</dd>
	<dt>Export mac80211 internals in DebugFS<br>CONFIG_MAC80211_DEBUGFS</dt><dd>在DebugFS中显示mac80211模块内部状态的扩展信息,仅用于调试目的.</dd>
	<dt>Trace all mac80211 debug messages<br>CONFIG_MAC80211_MESSAGE_TRACING</dt><dd>跟踪所有mac80211模块的调试信息,仅用于调试目的.</dd>
	<dt>Select mac80211 debugging features<br>CONFIG_MAC80211_DEBUG_MENU</dt><dd>仅供调试</dd>
</dl></dd>
<dt>WiMAX Wireless Broadband support<br>CONFIG_WIMAX</dt><dd><a href="http://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E4%BA%92%E9%80%9A%E5%BE%AE%E6%B3%A2%E5%AD%98%E5%8F%96">WiMAX</a>(IEEE 802.16)协议支持.随着2010年英特尔放弃WiMAX以及LTE在4G市场成了唯一的主流标准,WiMAX的电信运营商也逐渐向LTE转移,WiMAX论坛也于2012年将TD-LTE纳入WiMAX2.1规范,一些WiMAX运营商也开始将设备升级为TD-LTE.</dd>
<dd><dl>
	<dt>WiMAX debug level<br>CONFIG_WIMAX_DEBUG_LEVEL</dt><dd>设置允许使用的最大调试信息详细等级,推荐使用默认值"8",设为"0"表示允许使用所有调试信息.运行时默认禁止使用调试信息,但可通过sysfs文件系统中的debug-levels文件开启调试信息.</dd>
</dl></dd>
<dt>RF switch subsystem support<br>CONFIG_RFKILL</dt><dd>为了节约电力,很多无线网卡和蓝牙设备都有内置的射频开关(<a href="http://blog.csdn.net/angelbosj/article/details/7247651">RF switche</a>)用于开启和关闭设备(通过<a href="https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Power_Management_Guide/RFKill.html">rfkill</a>命令).建议选"Y".更多详情参见"<a href="https://www.kernel.org/doc/Documentation/rfkill.txt">Documentation/rfkill.txt</a>"文档</dd>
<dd><dl>
	<dt>RF switch input support<br>CONFIG_RFKILL_INPUT</dt><dd>这是个反对使用的特性,一般情况下建议关闭.若关闭此项导致某些笔记本的无线网卡开关按钮失效,可以考虑开启.</dd>
	<dt>Generic rfkill regulator driver<br>CONFIG_RFKILL_REGULATOR</dt><dd>通用射频开关驱动,其射频开关连接在电压调节器(voltage regulator)上.依赖于CONFIG_REGULATOR框架.不确定的选"N"或"M"</dd>
	<dt>GPIO RFKILL driver<br>CONFIG_RFKILL_GPIO</dt><dd>通用GPIO射频开关驱动.仅用于嵌入式环境,其射频开关连接在<a href="http://baike.baidu.com/view/980829.htm">GPIO</a>总线上,比如NVIDIA的<a href="http://baike.baidu.com/view/1660634.htm">Tegra</a>和三星的<a href="http://baike.baidu.com/view/5821967.htm">Exynos 4</a>智能手机SoC芯片.</dd>
</dl></dd>
<dt>Plan 9 Resource Sharing Support (9P2000)<br>CONFIG_NET_9P</dt><dd>实验性的支持<a href="http://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB">Plan 9</a>的<a href="http://zh.wikipedia.org/wiki/9P">9P2000</a>协议.</dd>
<dt>CAIF support<br>CONFIG_CAIF</dt><dd>除非你为Android/MeeGo系统编译内核,并且需要使用PF_CAIF类型的socket,否则请选"N".</dd>
<dt>Ceph core library<br>CONFIG_CEPH_LIB</dt><dd>仅在你需要使用<a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/">Ceph</a>分布式文件系统,或者<a href="http://www.alidata.org/archives/1589">rados</a>块设备(rbd)时选"Y".否则应选"N".</dd>
<dt>NFC subsystem support<br>CONFIG_NFC</dt><dd><a href="http://zh.wikipedia.org/wiki/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A">NFC</a>(<a href="http://baike.baidu.com/view/917495.htm">近场通信</a>)子系统.这些设备主要用于智能手机之类的嵌入式领域.</dd>
<dt>Network light weight tunnels<br>CONFIG_LWTUNNEL</dt><dd>为<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2">MPLS</a>(<a href="http://www.cisco.com/support/zh/105/mpls_faq_4649.shtml">多协议标签交换</a>)之类的轻量级隧道提供基础结构支持.不确定的选"N".</dd>
</dl>






<h2>Device Drivers<br />设备驱动程序</h2>
<dl><!-- 设备驱动程序开始 -->


<dt>Generic Driver Options</dt><dd>驱动程序通用选项.[提示]<a href="https://cateee.net/lkddb/web-lkddb/">Linux Kernel Driver DataBase</a>网站是搜索驱动程序与硬件型号对应关系的绝佳网站.如果你不知道某个驱动(例如"CONFIG_INTEL_IOATDMA")究竟对应着哪些型号的硬件,那么可以直接根据该驱动选项的首字母(本例是"I")进入对应的索引页去查找到该驱动的详情页面(本例是"https://cateee.net/lkddb/web-lkddb/INTEL_IOATDMA.html").[提示]可以使用"lspci -nn"与"lsusb"命令查看本机所有PCI/USB设备的"vendor id"与"device id"及文本名称.也可以根据已知的id到<a href="http://pci-ids.ucw.cz/v2.2/pci.ids">pci.ids</a>与<a href="http://www.linux-usb.org/usb.ids">usb.ids</a>数据库中搜索设备的名称.</dd>
<dd><dl>
	<dt>Support for uevent helper<br>CONFIG_UEVENT_HELPER</dt><dd>早年的内核(切换到基于netlink机制之前),在发生<a href="http://blog.chinaunix.net/uid-22590270-id-3304271.html">uevent</a>事件(通常是热插拔)时,需要调用用户空间程序(通常是"/sbin/hotplug"),以帮助完成uevent事件的处理.此选项就是用于开启此功能.由于目前的发行版都已不再需要此帮助程序,所以请选"N".此外,如果你使用了systemd或udev则必须选"N".</dd>
	<dt>path to uevent helper<br>CONFIG_UEVENT_HELPER_PATH</dt><dd>早年的内核(切换到基于netlink机制之前),在发生<a href="http://blog.chinaunix.net/uid-22590270-id-3304271.html">uevent</a>事件(通常是热插拔)时,需要调用用户空间程序(通常是"/sbin/hotplug"),以帮助完成uevent事件的处理.此选项就是用于设定这个帮助程序的路径.由于目前的发行版都已不再需要此帮助程序,所以请保持空白.此外,如果你使用了systemd或udev则必须保持空白.</dd>
	<dt>Maintain a devtmpfs filesystem to mount at /dev<br>CONFIG_DEVTMPFS</dt><dd>devtmpfs是一种基于CONFIG_TMPFS的文件系统(与proc和sys有几分相似).在系统启动过程中,随着各个设备的初始化完成,内核将会自动在devtmpfs中创建相应的设备节点(使用默认的文件名和权限)并赋予正确的主次设备号.更进一步,在系统运行过程中,随着各种设备插入和拔除,内核也同样会自动在devtmpfs中创建和删除的相应的设备节点(使用默认的文件名和权限)并赋予正确的主次设备号.如果将devtmpfs挂载到"/dev"目录(通常是系统启动脚本),那么便拥有了一个全自动且全功能的"/dev"目录,而且用户空间程序(通常是<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-udev/">udevd</a>)还可以对其中的内容进行各种修改(增删节点,改变权限,创建符号链接).目前的发行版和各种嵌入式系统基本都依赖于此,除非你知道自己在做什么,否则请选"Y".</dd>
	<dd><dl>
		<dt>Automount devtmpfs at /dev, after the kernel mounted the rootfs<br>CONFIG_DEVTMPFS_MOUNT</dt><dd>在内核挂载根文件系统的同时,立即自动将devtmpfs挂载到"/dev"目录.因为此时init进程都还尚未启动,所以这就确保在进入用户空间之前,所有设备文件就都已经准备完毕.开启此选项相当于设置内核引导参数"devtmpfs.mount=1",关闭此选项相当于设置内核引导参数"devtmpfs.mount=0".开启此项后,你就可以放心的使用"init=/bin/sh"直接进入救援模式,而不必担心"/dev"目录空无一物.注意:此选项并不影响基于initramfs的启动,此种情况下,devtmpfs必须被手动挂载.所以,如果你的系统使用initrd或者有专门的启动脚本用于挂载"/dev"目录(大多数发行版都有这样的脚本),或者你看了前面的解释,还是不确定,那就选"N".对于实在想要使用"init=/bin/sh"直接进入救援模式的人来说,还是使用"init=/bin/sh devtmpfs.mount=1"吧!</dd>
	</dl></dd>
	<dt>Select only drivers that don't need compile-time external firmware<br>CONFIG_STANDALONE</dt><dd>只显示那些编译时不需要额外固件支持的驱动程序,除非你有某些怪异硬件,否则请选"Y".</dd>
	<dt>Prevent firmware from being built<br>CONFIG_PREVENT_FIRMWARE_BUILD</dt><dd>不编译固件(firmware).固件一般是随硬件的驱动程序提供的,仅在更新固件的时候才需要重新编译.建议选"Y".</dd>
	<dt>Userspace firmware loading support<br>CONFIG_FW_LOADER</dt><dd>用户空间固件加载支持.如果内核自带的模块需要它,它将会被自动选中.但某些内核树之外的模块也可能需要它,这时候就需要你根据实际情况手动开启了.</dd>
	<dd><dl>
		<dt>Include in-kernel firmware blobs in kernel binary<br>CONFIG_FIRMWARE_IN_KERNEL</dt><dd>内核源码树中包含了许多驱动程序需要的二进制固件(blob),推荐的方法是通过"make firmware_install"将"firmware"目录中所需的固件复制到系统的"/lib/firmware/"目录中,然后由用户空间帮助程序在需要的时候进行加载.开启此项后,将会把所需的"blob"直接编译进内核,这样就可以无需用户空间程序的帮助,而直接使用这些固件了(例如:当根文件系统依赖于此类固件,而你又不想使用initrd的时候).每个需要此类二进制固件的驱动程序,都会有一个"Include firmware for xxx device"的选项,如果此处选"Y",那么这些选项都将被隐藏.建议选"N".</dd>
		<dt>External firmware blobs to build into the kernel binary<br>CONFIG_EXTRA_FIRMWARE</dt><dd>指定要额外编译进内核的二进制固件(blob).此选项的值是一个空格分隔的固件文件名字符串,这些文件必须位于CONFIG_EXTRA_FIRMWARE_DIR目录中(其默认值是内核源码树下的"firmware"目录).</dd>
		<dt>Firmware blobs root directory<br>CONFIG_EXTRA_FIRMWARE_DIR</dt><dd>指定CONFIG_EXTRA_FIRMWARE中列出的文件位于哪个目录.默认值是当前内核源码树下的"firmware"目录.若有需要,你也可以修改成其他目录(例如"/lib/firmware/").</dd>
	</dl></dd>
	<dt>Fallback user-helper invocation for firmware loading<br>CONFIG_FW_LOADER_USER_HELPER</dt><dd>在内核自己直接加载固件失败后,作为补救措施,调用用户空间帮助程序(通常是udev)再次尝试加载.通常这个动作是不必要的,因此应该选"N",如果你使用了udev或systemd,则必须选"N".仅在某些特殊的固件位于非标准位置时,才需要选"Y".</dd>
	<dt>Allow device coredump<br>CONFIG_ALLOW_DEV_COREDUMP</dt><dd>为驱动程序开启coredump机制,仅供调试.</dd>
	<dt>Driver Core verbose debug messages<br>CONFIG_DEBUG_DRIVER</dt><dd>让驱动程序核心在系统日志中产生冗长的调试信息,仅供调试</dd>
	<dt>Managed device resources verbose debug messages<br>CONFIG_DEBUG_DEVRES</dt><dd>为内核添加一个"devres.log"引导参数.当被设为非零值时,将会打印出设备资源管理驱动(devres)的调试信息.仅供调试使用.</dd>
</dl></dd>


<dt>Bus devices</dt><dd>总线设备.此类设备仅出现在ARM平台.</dd>


<dt>Connector - unified userspace &lt;-&gt; kernelspace linker<br>CONFIG_CONNECTOR</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-connector/index.html">统一的用户空间和内核空间连接器</a>,工作在netlink socket协议的顶层.连接器是非常便利的用户态与内核态的通信方式,这些驱动使内核知道当进程fork并使用proc连接器更改UID/GID/SID(会话ID).内核需要知道什么时候进程fork(CPU中运行多个任务)并执行,否则,内核可能会低效管理资源.内核有几个连接器应用实例:CONFIG_HYPERV_UTILS,CONFIG_FB_UVESA,CONFIG_W1_CON,CONFIG_DM_LOG_USERSPACE.另外还有一个<a href="http://hily.me/blog/2008/10/gentoo_splash/">给Gentoo装上启动画面</a>的例子.建议选"Y".</dd>
<dd><dl>
	<dt>Report process events to userspace<br>CONFIG_PROC_EVENTS</dt><dd>提供一个向用户空间报告进程事件(fork,exec,id变化(uid,gid,suid))的连接器.建议选"Y".</dd>
</dl></dd>


<dt>Memory Technology Device (MTD) support<br>CONFIG_MTD</dt><dd><a href="http://www.linux-mtd.infradead.org/faq/general.html">MTD</a>子系统是一个<a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94%E8%BD%89%E6%8F%9B%E5%B1%A4">闪存转换层</a>.其主要目的是提供一个介于闪存硬件驱动程序与高级应用程序之间的抽象层,以简化闪存设备的驱动.注意:MTD常用于嵌入式系统,而我们常见的U盘/MMC卡/SD卡/CF卡等移动存储设备以及固态硬盘(SSD),虽然也叫"flash",但它们并不是使用MTD技术的存储器.仅在你需要使用主设备号为31的MTD块设备(/dev/romX,/dev/rromX,/dev/flashX,/dev/rflashX),或者主设备号为90的MTD字符设备(/dev/mtdX,/dev/mtdrX)时选"Y",否则选"N".</dd>


<dt>Device Tree and Open Firmware support<br>CONFIG_OF</dt><dd><a href="http://www.wowotech.net/device_model/why-dt.html">Device Tree</a>基础架构与<a href="https://en.wikipedia.org/wiki/Open_Firmware">Open Firmware</a>支持.主要用于嵌入式环境.不确定的选"N".内核中若有其它选项依赖于它,则会自动选中此项.</dd>


<dt>Parallel port support<br>CONFIG_PARPORT</dt><dd>25针并口(<a href="http://baike.baidu.com/view/79689.htm">LPT接口</a>)支持.古董级的打印机或扫描仪可能使用这种接口.目前已被淘汰.</dd>


<dt>Plug and Play support<br>CONFIG_PNP</dt><dd><a href="http://baike.baidu.com/view/33701.htm">即插即用</a>(PnP)支持.选"Y"表示让Linux为PnP设备分配中断和I/O端口(需要在BIOS中开启"PnP OS"),选"N"则表示让BIOS来分配(需要在BIOS中关闭"PnP OS").建议选"Y".</dd>
<dd><dl>
	<dt>PNP debugging messages<br>CONFIG_PNP_DEBUG_MESSAGES</dt><dd>允许使用"pnp.debug"内核参数在系统启动过程中输出PnP设备的调试信息,建议选"N".</dd>
</dl></dd>


<dt>Block devices<br>CONFIG_BLK_DEV</dt><dd>块设备,建议选"Y".</dd>
<dd><dl>
	<dt>Null test block driver<br>CONFIG_BLK_DEV_NULL_BLK</dt><dd>仅供调试使用</dd>
	<dt>Normal floppy disk support<br>CONFIG_BLK_DEV_FD</dt><dd>通用<a href="http://baike.baidu.com/view/9006.htm">软驱</a>支持.已被时代抛弃的设备</dd>
	<dt>Parallel port IDE device support<br>CONFIG_PARIDE</dt><dd>通过并口与计算机连接的IDE设备,比如某些老旧的外接光驱或硬盘之类.此类设备早就绝种了</dd>
	<dt>Block Device Driver for Micron PCIe SSDs<br>CONFIG_BLK_DEV_PCIESSD_MTIP32XX</dt><dd><a href="http://www.expreview.com/25252.html">Micron P320/P325/P420/P425 系列固态硬盘</a>支持</dd>
	<dt>Compressed RAM block device support<br>CONFIG_ZRAM</dt><dd><a href="http://wiki.gentoo.org/wiki/Zram">zram</a>是一种基于压缩内存的虚拟块设备,它允许你创建"/dev/zramN"块设备文件,并将它当作普通的磁盘一样使用.它完全位于物理内存中,并被实时压缩与解压以节约物理内存的用量,所有对"/dev/zramN"的读写实质上都是对内存的读写,从而可以获得比一般的磁盘快的多的IO速度.常将它用做'/tmp'分区或作为swap分区挂载.你可以把它看作是CONFIG_BLK_DEV_RAM的升级版.具体用法可以参考内核文档'<a href="https://www.kernel.org/doc/Documentation/blockdev/zram.txt">Documentation/blockdev/zram.txt</a>'.</dd>
	<dt>Compaq SMART2 support<br>CONFIG_BLK_CPQ_DA</dt><dd>基于 Compaq SMART2 控制器的磁盘阵列卡</dd>
	<dt>Compaq Smart Array 5xxx support<br>CONFIG_BLK_CPQ_CISS_DA</dt><dd>基于 Compaq Smart 控制器的磁盘阵列卡</dd>
	<dt>SCSI tape drive support for Smart Array 5xxx<br>CONFIG_CISS_SCSI_TAPE</dt><dd>在基于 Compaq Smart 控制器的磁盘阵列卡上使用的磁带机</dd>
	<dt>Mylex DAC960/DAC1100 PCI RAID Controller support<br>CONFIG_BLK_DEV_DAC960</dt><dd>Mylex DAC960, AcceleRAID, eXtremeRAID PCI RAID 控制器.很古董的设备了.</dd>
	<dt>Micro Memory MM5415 Battery Backed RAM support<br>CONFIG_BLK_DEV_UMEM</dt><dd>一种使用电池做后备电源的内存,但被用作块设备,可以像硬盘一样被分区</dd>
	<dt>Loopback device support<br>CONFIG_BLK_DEV_LOOP</dt><dd>loop是指拿文件来模拟块设备(/dev/loopX),比如可以将一个iso9660镜像文件当成文件系统来挂载.建议选"Y".</dd>
	<dd><dl>
		<dt>Number of loop devices to pre-create at init time<br>CONFIG_BLK_DEV_LOOP_MIN_COUNT</dt><dd>系统预先初始化的loop设备个数.此值可以通过内核引导参数"loop.max_loop"修改.如果你使用<a href="https://www.kernel.org/pub/linux/utils/util-linux/">util-linux</a>-2.21以上版本,建议设为"0"(loop设备将通过/dev/loop-control动态创建),否则保持默认值即可.</dd>
		<dt>Cryptoloop Support<br>CONFIG_BLK_DEV_CRYPTOLOOP</dt><dd>使用系统提供的CryptoAPI对loop设备加密.注意:因为不能在Cryptoloop上创建日志型文件系统(CONFIG_DM_CRYPT模块可以),所以Cryptoloop已经逐渐淡出了.建议选"N".</dd>
	</dl></dd>
	<dt>DRBD Distributed Replicated Block Device support<br>CONFIG_BLK_DEV_DRBD</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-drbd/">DRBD(Distributed Replicated Block Device)</a>是一种分布式储存系统.<a href="http://www.drbd.org/">DBRD</a>处于文件系统之下,比文件系统更加靠近操作系统内核及IO栈.DRBD类似RAID1磁盘阵列,只不过RAID1是在同一台电脑内,而DRBD是透过网络.注意:为了进行连接认证,你还需要选中CONFIG_CRYPTO_HMAC以及相应的哈希算法.不确定的选"N".</dd>
	<dd><dl>
		<dt>DRBD fault injection<br>CONFIG_DRBD_FAULT_INJECTION</dt><dd>模拟IO错误,以用于测试DRBD的行为.主要用于调试目的</dd>
	</dl></dd>
	<dt>Network block device support<br>CONFIG_BLK_DEV_NBD</dt><dd>让你的电脑成为网络块设备的客户端,也就是可以挂载远程服务器通过TCP/IP网络提供的块设备(/dev/ndX).提示:这与NFS或Coda没有任何关系.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/blockdev/nbd.txt">Documentation/blockdev/nbd.txt</a>".不确定的选"N".</dd>
	<dt>OSD object-as-blkdev support<br>CONFIG_BLK_DEV_OSD</dt><dd>允许将一个单独的 <a href="http://www.51cto.com/art/200608/30308.htm">SCSI OSD(Object-Based Storage Devices)</a> 对象当成普通的块设备来使用.举例来说,你可以在OSD设备上创建一个2G大小的对象,然后通过本模块将其模拟成一个2G大小的块设备使用.不确定的选"N".</dd>
	<dt>STEC S1120 Block Driver<br>CONFIG_BLK_DEV_SKD</dt><dd>STEC公司的S1120 PCIe SSD</dd>
	<dt>Promise SATA SX8 support<br>CONFIG_BLK_DEV_SX8</dt><dd>基于Promise公司的SATA SX8控制器的RAID卡</dd>
	<dt>RAM block device support<br>CONFIG_BLK_DEV_RAM</dt><dd>内存中的虚拟磁盘,大小固定.详情参阅"<a href="https://www.kernel.org/doc/Documentation/blockdev/ramdisk.txt">Documentation/blockdev/ramdisk.txt</a>".由于其功能比CONFIG_TMPFS和CONFIG_ZRAM弱许多,使用上也不方便,所以除非你有明确的理由,否则应该选"N",并转而使用CONFIG_TMPFS或CONFIG_ZRAM.</dd>
	<dd><dl>
		<dt>Default number of RAM disks<br>CONFIG_BLK_DEV_RAM_COUNT</dt><dd>默认RAM disk的数量.请保持默认值,除非你知道自己在做什么.</dd>
		<dt>Default RAM disk size (kbytes)<br>CONFIG_BLK_DEV_RAM_SIZE</dt><dd>默认RAM disk的大小.请保持默认值,除非你知道自己在做什么.</dd>
		<dt>Support XIP filesystems on RAM block device<br>CONFIG_BLK_DEV_XIP</dt><dd>XIP(eXecute In Place)支持(指应用程序可以直接在flash闪存内运行,不必再把代码读到系统RAM中).一般用于嵌入式设备.</dd>
	</dl></dd>
	<dt>Packet writing on CD/DVD media<br>CONFIG_CDROM_PKTCDVD</dt><dd>CD/DVD刻录机支持.详情参见"<a href="https://www.kernel.org/doc/Documentation/cdrom/packet-writing.txt">Documentation/cdrom/packet-writing.txt</a>"文档</dd>
	<dd><dl>
		<dt>Free buffers for data gathering<br>CONFIG_CDROM_PKTCDVD_BUFFERS</dt><dd>用于收集写入数据的缓冲区个数(每个占用64Kb内存),缓冲区越多性能越好.</dd>
		<dt>Enable write caching<br>CONFIG_CDROM_PKTCDVD_WCACHE</dt><dd>为CD-R/W设备启用写入缓冲,目前这是一个比较危险的选项.建议关闭.</dd>
	</dl></dd>
	<dt>ATA over Ethernet support<br>CONFIG_ATA_OVER_ETH</dt><dd>以太网ATA设备(<a href="http://zh.wikipedia.org/wiki/ATA_over_Ethernet">ATA over Ethernet</a>)支持.</dd>
	<dt>Xen virtual block device support<br>CONFIG_XEN_BLKDEV_FRONTEND</dt><dd>XEN虚拟块设备前端驱动.此驱动用于与实际驱动块设备的后端驱动(通常位于domain0)通信.</dd>
	<dt>Xen block-device backend driver<br>CONFIG_XEN_BLKDEV_BACKEND</dt><dd>XEN块设备后端驱动(通常位于domain0)允许内核将实际的块设备通过高性能的共享内存接口导出给其他客户端的前端驱动(通常位于非domain0)使用.</dd>
	<dt>Virtio block driver<br>CONFIG_VIRTIO_BLK</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>虚拟块设备驱动.仅可用在基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的半虚拟化客户机中(一般是<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>).</dd>
	<dt>Very old hard disk (MFM/RLL/IDE) driver<br>CONFIG_BLK_DEV_HD</dt><dd>又老又旧的MFM/RLL/ESDI硬盘驱动.无需犹豫,选"N".</dd>
	<dt>Rados block device (RBD)<br>CONFIG_BLK_DEV_RBD</dt><dd><a href="http://www.alidata.org/archives/1589">rados</a>块设备(rbd)支持.它可以与分布式文件系统<a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/">Ceph</a>合作,也能独立工作.</dd>
	<dt>IBM Flash Adapter 900GB Full Height PCIe Device Driver<br>CONFIG_BLK_DEV_RSXX</dt><dd>IBM Flash Adapter 900GB Full Height PCIe SSD 驱动</dd>
</dl></dd>


<dt>NVM Express block device<br>CONFIG_BLK_DEV_NVME</dt><dd><a href="http://news.mydrivers.com/1/187/187633.htm">NVM Express</a>是专门针对PCI-E接口高性能固态硬盘的标准规范.有了这一标准,操作系统厂商只需要编写一种驱动,就可以支持不同厂商的不同PCI-E SSD设备,以解决过去PCI-E SSD产品形态与规格五花八门,缺乏通用性和互用性的问题.如果你有一块较新的PCIE固态硬盘,那么很大可能就是NVMe接口.</dd>


<dt>Misc devices</dt><dd>杂项设备</dd>
<dd><dl>
	<dt class="omit">{省略的部分请按照实际的硬件状况进行选择}</dt>
	<dt>Integrated Circuits ICS932S401<br>CONFIG_ICS932S401</dt><dd><a href="http://lwn.net/Articles/306320/">IDT ICS932S401</a> 系列时钟频率控制芯片支持(可能会出现在某些主板上).</dd>
	<dt>Enclosure Services<br>CONFIG_ENCLOSURE_SERVICES</dt><dd>SES(<a href="http://wenku.baidu.com/view/dd358de86294dd88d0d26bec.html">SCSI Enclosure Services</a>)是SCSI协议中用于查询设备状态(温度/风扇/电源/指示灯)的一项服务.这里的设备可以是移动硬盘盒/磁盘阵列柜/硬盘托架等.SES可以让主机端透过SCSI命令去控制外接SCSI设备的电源/风扇以及其他与数据传输无关的东西.要使用这项技术,外置设备和主机上的SCSI/ATA控制芯片都需要支持SES技术才OK.事实上,目前大多数外置移动硬盘和所有磁盘阵列柜都支持SES规范.</dd>
	<dt>VMware Balloon Driver<br>CONFIG_VMWARE_BALLOON</dt><dd>VMware物理内存balloon驱动(将客户机操作系统不需要的物理内存页交还给宿主机).参见CONFIG_BALLOON_COMPACTION选项.</dd>
	<dt>Generic on-chip SRAM driver<br>CONFIG_SRAM</dt><dd>许多<a href="http://baike.baidu.com/view/882467.htm">SoC系统</a>都有芯片内嵌的<a href="http://baike.baidu.com/view/423438.htm">SRAM</a>.开启此项后,就可以声明将此段内存范围交给通用内存分配器(<a href="http://blog.csdn.net/g_salamander/article/details/8562424">genalloc</a>)管理.不确定的选"N".</dd>
	<dt>EEPROM support</dt><dd><a href="http://baike.baidu.com/view/93707.htm">EEPROM</a>主要用于保存主板或板卡的BIOS,如果你想通过此Linux系统刷写BIOS可以考虑开启相应的子项.不确定的全部选"N".</dd>
	<dt>Intel Management Engine Interface<br>CONFIG_INTEL_MEI</dt><dd><a href="https://software.intel.com/en-us/business-client/manageability">Intel芯片组管理引擎</a>,是一种面向企业环境的远程管理技术,其中的重头戏是<a href="https://software.intel.com/zh-cn/articles/amt">英特尔主动管理技术</a>.如果你的芯片组位于"CONFIG_INTEL_MEI_ME"中,可以考虑选"Y",不过如果你不明白这是什么东西,那就说明你不需要它,就应该选"N".此外,在某些服务器上此驱动(mei)还可能<a href="http://zh.community.dell.com/techcenter/b/weblog/archive/2012/10/23/ubuntu-on-dell-12g-poweredge-servers">可能导致监视程序计时器错误,还可能导致无法正常关机</a>.</dd>
	<dt>ME Enabled Intel Chipsets<br>CONFIG_INTEL_MEI_ME</dt><dd>请根据帮助中列出的芯片组对照实际情况选择.</dd>
	<dt>VMware VMCI Driver<br>CONFIG_VMWARE_VMCI</dt><dd><a href="http://pubs.vmware.com/vmci-sdk/VMCI_intro.html">VMware VMCI</a>(Virtual Machine Communication Interface)是一个在host和guest之间以及同一host上的guest和guest之间进行高速通信的虚拟设备.VMCI主要是提供一个接口让guest内的程序来调用,通过这个接口能在一个主机上的多个虚拟机之间进行直接的通信,而且无需经过更上层的其他途径,这样将有效地降低网络通信所产生的开支,但是这需要修改虚拟机上的软件,所以VMCI只适用于对虚拟机间通信要求非常高的情况.不确定的选"N".</dd>
</dl></dd>


<dt>ATA/ATAPI/MFM/RLL support (DEPRECATED)<br>CONFIG_IDE</dt><dd>已被废弃的IDE硬盘和ATAPI光驱等接口的驱动(已被CONFIG_ATA取代).选"N",除非你确实知道自己在干什么.</dd>


<dt>SCSI device support</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/">SCSI子系统</a></dd>
<dd><dl>
	<dt>RAID Transport Class<br>CONFIG_RAID_ATTRS</dt><dd>这只是用来得到RAID信息以及将来可能用于配置RAID方式的一个类.不管你的系统使用的是哪种RAID,都可以放心的关闭此项.不确定的选"N".</dd>
	<dt>SCSI device support<br>CONFIG_SCSI</dt><dd><a href="http://wenku.baidu.com/view/517ac1bfc77da26925c5b0bb.html">SCSI协议</a>支持.有任何SCSI/SAS/SATA/USB/Fibre Channel/FireWire设备之一就必须选上.选"Y".</dd>
	<dt>SCSI target support<br>CONFIG_SCSI_TGT</dt><dd>内核态的通用<a href="http://wangxu.me/blog/p/586">SCSI Target</a>实现(原<a href="http://linux-iscsi.org/wiki/Target">LIO</a>项目).SCSI子系统使用了一种客户机-服务器(C/S)模型.通常,一台计算机是这个模型中的客户机(称为"initiator"),向目标(target)发起块操作请求,这个"target"通常是一个存储设备(例如一块硬盘).此模块的功能是将一台计算机变成一个"target"(就像一个普通的硬盘一样),响应其他"initiator"节点的操作请求,从而让"target"能够提供更加高级的功能:复制,自动精简配置,重复数据删除,高可用性,自动备份等.不确定的选"N".</dd>
	<dt>SCSI: use blk-mq I/O path by default<br>CONFIG_SCSI_MQ_DEFAULT</dt><dd>对所有SCSI块设备默认使用新式的多重队列I/O调度机制(<a href="http://blog.csdn.net/zhufengtianya/article/details/43266415">blk-mq</a>),也就是将I/O请求分散至多个CPU处理以提高性能.相当于开启"scsi_mod.use_blk_mq"内核模块参数.尤其适合于SSD(高IOP)/磁盘阵列(多通道)这类存储设备.</dd>
	<dt>legacy /proc/scsi/ support<br>CONFIG_SCSI_PROC_FS</dt><dd>过时的/proc/scsi/接口.某些老旧的刻录程序可能需要它,建议选"N".</dd>
	<dt>SCSI disk support<br>CONFIG_BLK_DEV_SD</dt><dd>使用SCSI/SAS/SATA/PATA/USB/Fibre Channel存储设备的必选.选"Y".</dd>
	<dt>SCSI tape support<br>CONFIG_CHR_DEV_ST</dt><dd>通用SCSI磁带驱动</dd>
	<dt>SCSI OnStream SC-x0 tape support<br>CONFIG_CHR_DEV_OSST</dt><dd>专用于OnStream SC-x0/USB-x0/DI-x0的SCSI磁带/USB盘驱动</dd>
	<dt>SCSI CDROM support<br>CONFIG_BLK_DEV_SR</dt><dd>通过SCSI/FireWire/USB/SATA/IDE接口连接的DVD/CD驱动器(基本上涵盖了所有常见的接口).</dd>
	<dd><dl>
		<dt>Enable vendor-specific extensions (for SCSI CDROM)<br>CONFIG_BLK_DEV_SR_VENDOR</dt><dd>仅在某些古董级的SCSI CDROM设备上才需要:NEC/TOSHIBA cdrom, HP Writers</dd>
	</dl></dd>
	<dt>SCSI generic support<br>CONFIG_CHR_DEV_SG</dt><dd><a href="http://sg.danny.cz/sg/">通用SCSI协议</a>(/dev/sg*)支持.也就是除硬盘/光盘/磁带之外的SCSI设备(例如光纤通道).这些设备还需要额外的用户层工具支持才能正常工作.例如:<a href="http://www.sane-project.org/">SANE</a>,<a href="http://cdrecord.berlios.de/private/cdrecord.html">Cdrtools</a>,<a href="http://cdrdao.sourceforge.net/">CDRDAO</a>,<a href="http://www.xiph.org/paranoia/">Cdparanoia</a></dd>
	<dt>SCSI media changer support<br>CONFIG_CHR_DEV_SCH</dt><dd>SCSI介质转换设备(SCSI Medium Changer device)是一种控制多个SCSI介质的转换器(例如在多个磁带/光盘之间进行切换),常用于控制磁带库或者CD自动点歌机(jukeboxes).此种设备会在/proc/scsi/scsi中以"Type: Medium Changer"列出.控制此类设备的用户层工具包是<a href="http://linux.bytesex.org/misc/changer.html">scsi-changer</a>.更多细节参见"<a href="https://www.kernel.org/doc/Documentation/scsi/scsi-changer.txt">Documentation/scsi/scsi-changer.txt</a>"文档.不确定的选"N".</dd>
	<dt>SCSI Enclosure Support<br>CONFIG_SCSI_ENCLOSURE</dt><dd>"Enclosure"是一种用于管理SCSI设备的背板装置.移动硬盘盒与磁盘阵列柜就是最常见的"Enclosure"设备.此项主要用于向用户层报告一些"Enclosure"设备的状态,这些状态对于SCSI设备的正常运行并非必须.此项依赖于CONFIG_ENCLOSURE_SERVICES选项.</dd>
	<dt>Probe all LUNs on each SCSI device<br>CONFIG_SCSI_MULTI_LUN</dt><dd>默认强制在每个SCSI设备上探测所有的逻辑设备数量(Logical Unit Number),其值会被该模块的内核引导参数"max_luns"覆盖.只在一个SCSI设备上有多个逻辑设备时才需要选它,一般的SCSI设备并不需要.一个SCSI设备上有多个逻辑设备的典型例子:多端口USB读卡器,CD点唱机(jukebox),处于"mass storage"模式的智能手机,量产为多个设备后的U盘.注意:此项并不影响符合SCSI-3或更高标准的设备,因为这些设备会明确的向内核报告逻辑设备数.</dd>
	<dt>Verbose SCSI error reporting (kernel size +=75K)<br>CONFIG_SCSI_CONSTANTS</dt><dd>以易读的方式报告SCSI错误,内核将会增大75K</dd>
	<dt>SCSI logging facility<br>CONFIG_SCSI_LOGGING</dt><dd>启用SCSI日志(默认并不开启,需要"echo [bitmask] > /proc/sys/dev/scsi/logging_level"),可用于跟踪和捕获SCSI设备的错误.关于[bitmask]的说明可以查看"drivers/scsi/scsi_logging.h"文件.不确定的选"N".</dd>
	<dt>Asynchronous SCSI scanning<br>CONFIG_SCSI_SCAN_ASYNC</dt><dd>异步扫描的意思是,在内核引导过程中,SCSI子系统可以在不影响其他子系统引导的同时进行SCSI设备的探测(包括同时在多个总线上进行检测),这样可以加快系统的引导速度.但是如果SCSI设备驱动被编译为模块,那么异步扫描将会导致内核引导出现问题(解决方法是加载scsi_wait_scan模块,或者使用"scsi_mod.scan=sync"内核引导参数).不确定的选"N".</dd>
	<dt>SCSI Transports</dt><dd>SCSI接口类型,下面的子项可以全不选,内核中若有其他部分依赖它,会自动选上</dd>
	<dd><dl>
		<dt>Parallel SCSI (SPI) Transport Attributes<br>CONFIG_SCSI_SPI_ATTRS</dt><dd>传统的并行SCSI(Ultra320/160之类),已逐渐被淘汰</dd>
		<dt>FiberChannel Transport Attributes<br>CONFIG_SCSI_FC_ATTRS</dt><dd><a href="http://baike.baidu.com/view/15247.htm">光纤通道</a>接口</dd>
		<dd><dl>
			<dt>SCSI target support for FiberChannel Transport Attributes<br>CONFIG_SCSI_FC_TGT_ATTRS</dt><dd>为光纤通道添加"target"模式驱动</dd>
		</dl></dd>
		<dt>iSCSI Transport Attributes<br>CONFIG_SCSI_ISCSI_ATTRS</dt><dd><a href="http://zh.wikipedia.org/wiki/ISCSI">iSCSI</a>协议是利用TCP/IP网络传送SCSI命令和数据的I/O技术</dd>
		<dt>SAS Transport Attributes<br>CONFIG_SCSI_SAS_ATTRS</dt><dd>串行SCSI传输属性支持(<a href="http://storage.chinaunix.net/stor/raid/2008/05/22/1114713.shtml">SAS</a>对于SPI的关系犹如SATA对于IDE),这是目前的主流接口</dd>
		<dt>SAS Domain Transport Attributes<br>CONFIG_SCSI_SAS_LIBSAS</dt><dd>为使用了<a href="http://biz.chinabyte.com/24/2435024_4.shtml">SAS Domain</a>架构的驱动程序提供帮助.SAS Domain即整个SAS交换构架,由"SAS device"和"SAS expander device"组成,其中Device又区分为Initiator和Target,它们可以直接对接起来,也可以经过Expander进行连接,Expander起到通道交换或者端口扩展的作用.看不懂就说明你不需要它.</dd>
		<dd><dl>
			<dt>ATA support for libsas (requires libata)<br>CONFIG_SCSI_SAS_ATA</dt><dd>在libsas中添加ATA支持,从而让libata和libsas协同工作.</dd>
			<dt>Support for SMP interpretation for SAS hosts<br>CONFIG_SCSI_SAS_HOST_SMP</dt><dd>在libsas中添加SMP解释器,以允许主机支持SAS SMP协议.</dd>
		</dl></dd>
		<dt>SRP Transport Attributes<br>CONFIG_SCSI_SRP_ATTRS</dt><dd>SCSI <a href="http://wiki.mbalib.com/wiki/RDMA">RDMA</a> 协议(SCSI RDMA Protocol)通过将SCSI数据传输阶段映射到Infiniband远程直接内存访问(Remote Direct Memory Access)操作加速了SCSI协议.</dd>
		<dd><dl>
			<dt>SCSI target support for SRP Transport Attributes<br>CONFIG_SCSI_SRP_TGT_ATTRS</dt><dd>为SRP添加"target"模式驱动</dd>
		</dl></dd>
	</dl></dd>
	<dt>SCSI low-level drivers<br>CONFIG_SCSI_LOWLEVEL</dt><dd>底层SCSI驱动程序</dd>
	<dd><dl>
		<dt>iSCSI Initiator over TCP/IP<br>CONFIG_ISCSI_TCP</dt><dd><a href="http://zh.wikipedia.org/wiki/ISCSI">iSCSI</a>协议利用TCP/IP网络在"initiator"与"targets"间传送SCSI命令和数据.此选项便是iSCSI initiator驱动.相关的用户层工具/文档/配置示例,可以在<a href="http://open-iscsi.org">open-iscsi</a>找到.</dd>
		<dt>iSCSI Boot Sysfs Interface<br>CONFIG_ISCSI_BOOT_SYSFS</dt><dd>通过sysfs向用户空间显示iSCSI的引导信息.不确定的选"N".</dd>
		<dt class="omit">{此处省略的部分按照实际使用的控制器进行选择}</dt>
		<dt>VMware PVSCSI driver support<br>CONFIG_VMWARE_PVSCSI</dt><dd>VMware半虚拟化的SCSI HBA控制器</dd>
		<dt>Microsoft Hyper-V virtual storage driver<br>CONFIG_HYPERV_STORAGE</dt><dd>微软的Hyper-V虚拟存储控制器</dd>
		<dt>Intel(R) C600 Series Chipset SAS Controller<br>CONFIG_SCSI_ISCI</dt><dd>Intel C600 系列芯片组 6Gb/s SAS控制器</dd>
		<dt>virtio-scsi support<br>CONFIG_SCSI_VIRTIO</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">virtio</a>虚拟HBA控制器.仅可用在基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的半虚拟化客户机中(一般是<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>).</dd>
	</dl></dd>
	<dt>PCMCIA SCSI adapter support<br>CONFIG_SCSI_LOWLEVEL_PCMCIA</dt><dd>通过PCMCIA卡与计算机连接的SCSI设备</dd>
	<dt>SCSI Device Handlers<br>CONFIG_SCSI_DH</dt><dd>针对某些多路径安装的SCSI设备的驱动,用在每个节点都需要一个到SCSI存储单元的直接路径的集群中,具体子项请按照实际使用的控制器进行选择</dd>
	<dt>OSD-Initiator library<br>CONFIG_SCSI_OSD_INITIATOR</dt><dd><a href="http://xanpeng.github.io/linux/2012/12/30/object-storage.html">OSD(Object-Based Storage Device)</a>协议是一个T10 SCSI命令集,和SCSI处于同一级别,也跟SCSI很类似,分成osd-initiator/osd-target两部分,用于<a href="http://www.ibm.com/developerworks/cn/linux/l-ofs/index.html">对象存储文件系统</a>,此选项实现了<a href="http://lwn.net/Articles/305860/">OSD-Initiator库</a>(libosd.ko).更多细节参见"<a href="https://www.kernel.org/doc/Documentation/scsi/osd.txt">Documentation/scsi/osd.txt</a>"文件.看不懂就说明你不需要.[提示]此选项依赖于CONFIG_CRYPTO_SHA1和CONFIG_CRYPTO_HMAC模块.</dd>
	<dd><dl>
		<dt>OSD Upper Level driver<br>CONFIG_SCSI_OSD_ULD</dt><dd>提供OSD上层驱动(也就是向用户层提供/dev/osdX设备).从而允许用户层控制OSD设备(比如挂载基于OSD的<a href="http://www.ibm.com/developerworks/cn/linux/l-nilfs-exofs/">exofs文件系统</a>).</dd>
	</dl></dd>
</dl></dd>


<dt>Serial ATA and Parallel ATA drivers<br>CONFIG_ATA</dt><dd>SATA与PATA(IDE)设备.桌面级PC以及低端服务器的硬盘基本都是此种接口</dd>
<dd><dl>
	<dt>Verbose ATA error reporting<br>CONFIG_ATA_VERBOSE_ERROR</dt><dd>输出详细的ATA命令描述信息.大约会让内核增大6KB.禁用它将会导致调试ATA设备错误变得困难.</dd>
	<dt>ATA ACPI Support<br>CONFIG_ATA_ACPI</dt><dd>与ATA相关的ACPI对象支持.这些对象与性能/安全/电源管理等相关.不管你使用的是IDE硬盘还是SATA硬盘,都建议开启(可以使用内核引导参数"libata.noacpi=1"关闭).</dd>
	<dd><dl>
		<dt>SATA Zero Power Optical Disc Drive (ZPODD) support<br>CONFIG_SATA_ZPODD</dt><dd>这是<a href="http://news.mydrivers.com/1/199/199581.htm">SATA-3.1</a>版规范新增的节能相关内容,用新的电源管理策略降低了整个系统的电力需求,可以让处于空闲状态的光驱耗电量近乎于零.这需要主板和光驱两者都支持SATA-3.1规范才行.</dd>
	</dl></dd>
	<dt>SATA Port Multiplier support<br>CONFIG_SATA_PMP</dt><dd>SATA端口复用器(<a href="http://www.360doc.com/content/12/0424/16/5073814_206190083.shtml">Port Multiplier</a>)是一个定义在SATA规范里面的可以选择的功能,可以把一个活动主机连接多路复用至多个设备连接,相当于一个SATA HUB.不确定的选"N".</dd>
	<dt>AHCI SATA support<br>CONFIG_SATA_AHCI</dt><dd>AHCI SATA 支持.这是最佳的SATA模式(NCQ功能依赖于它).某些主板还需要在BIOS中将硬盘明确设为AHCI模式.使用SATA硬盘者必选"Y".[提示]由于各厂商芯片组内的SATA控制器都遵循同一种规范,所以并不需要各种各样针对不同SATA控制器的驱动,就这一个驱动基本就能通吃所有SATA控制器了,这比丰富多彩的网卡驱动省事多了.</dd>
	<dt>Platform AHCI SATA support<br>CONFIG_SATA_AHCI_PLATFORM</dt><dd>这是用于嵌入式系统的与AHCI接口兼容的SATA驱动.并不是常见的芯片组中的SATA控制器驱动.不确定的选"N".</dd>
	<dt class="omit">{此处省略几个特殊且不常见的SATA控制器驱动}</dt>
	<dt>ATA SFF support (for legacy IDE and PATA)<br>CONFIG_ATA_SFF</dt><dd>使用SATA硬盘的用户可无视此项,选"N"即可.对于依然使用老旧的IDE/PATA硬盘的用户而言,按照实际情况在子项中选择相应的控制器驱动即可.</dd>
	<dd><dl>
		<dt class="omit">{此处省略几个罕见的Pacific/Promise芯片组}</dt>
		<dt>ATA BMDMA support<br>CONFIG_ATA_BMDMA</dt><dd>这是IDE控制器的事实标准.除了上世纪的古董外,绝大多数芯片组都遵守这个标准,选"Y",然后从子项中选择恰当的芯片组/控制器.</dd>
		<dt class="omit">{此处省略的PIO-only SFF芯片组都是早就绝迹的老古董}</dt>
		<dt>ACPI firmware driver for PATA<br>CONFIG_PATA_ACPI</dt><dd>通过ACPI BIOS去操作IDE控制器.仅用于某些比较奇特的IDE控制器.选"N".</dd>
		<dt>Generic ATA support<br>CONFIG_ATA_GENERIC</dt><dd>这是通用的IDE控制器驱动.如果你无法确定IDE控制器的具体型号(比如需要面对未知的硬件状况),或者不想使用针对特定芯片组的IDE驱动,就选"Y"吧.</dd>
	</dl></dd>
</dl></dd>


<dt>Multiple devices driver support (RAID and LVM)<br>CONFIG_MD</dt><dd>多设备支持(<a href="http://zh.wikipedia.org/zh-cn/RAID">RAID</a>和<a href="https://wiki.archlinux.org/index.php/LVM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">LVM</a>).RAID和LVM的功能是使用多个物理设备组建成一个单独的逻辑设备</dd>
<dd><dl>
	<dt>RAID support<br>CONFIG_BLK_DEV_MD</dt><dd>"<a href="http://www.tldp.org/HOWTO/html_single/Software-RAID-HOWTO/">Software RAID</a>"(需要使用<a href="https://www.kernel.org/pub/linux/utils/raid/mdadm/">mdadm</a>工具)支持.也就是"<a href="http://molinux.blog.51cto.com/2536040/516008">软RAID</a>".使用硬件RAID卡的用户并不需要此项.</dd>
	<dd><dl>
		<dt>Autodetect RAID arrays during kernel boot<br>CONFIG_MD_AUTODETECT</dt><dd>在内核启动过程中自动检测RAID模式.如果你没有使用RAID,那么选中此项将会让内核在启动过程中增加几秒延迟.如果你使用了"raid=noautodetect"内核引导参数关闭了自动检测,或者此处选了"N",那么你必须使用"md=???"内核引导参数明确告诉内核RAID模式及配置.</dd>
		<dt>Linear (append) mode<br>CONFIG_MD_LINEAR</dt><dd>线性模式(简单的将一个分区追加在另一个分区之后),一般不使用这种模式.</dd>
		<dt>RAID-0 (striping) mode<br>CONFIG_MD_RAID0</dt><dd>RAID-0(等量分割)模式,可以获取最高性能,但是却损害了可靠性,一般也不使用这种模式.</dd>
		<dt>RAID-1 (mirroring) mode<br>CONFIG_MD_RAID1</dt><dd>RAID-1(镜像)模式.包含内核的引导分区只能使用这种模式.</dd>
		<dt>RAID-10 (mirrored striping) mode<br>CONFIG_MD_RAID10</dt><dd>RAID 1+0 模式</dd>
		<dt>RAID-4/RAID-5/RAID-6 mode<br>CONFIG_MD_RAID456</dt><dd>RAID-4/RAID-5/RAID-6 模式</dd>
		<dt>Multipath I/O support<br>CONFIG_MD_MULTIPATH</dt><dd>多路径IO支持是指在服务器和存储设备之间使用冗余的物理路径组件创建"逻辑路径",如果这些组件发生故障并造成路径失败,多路径逻辑将为I/O使用备用路径以使应用程序仍然可以访问其数据.该选项已废弃,并已被CONFIG_DM_MULTIPATH所取代.选"N".</dd>
		<dt>Faulty test module for MD<br>CONFIG_MD_FAULTY</dt><dd>用于MD(Multi-device)的缺陷测试模块,仅用于调试.</dd>
	</dl></dd>
	<dt>Block device as cache<br>CONFIG_BCACHE</dt><dd>将一个块设备用作其他块设备的缓存(<a href="https://wiki.archlinux.org/index.php/Bcache">Bcache</a>).此缓存使用btree(平衡树)索引,并专门为SSD进行了优化.仅在你打算<a href="http://www.expreview.com/25399.html">使用高速SSD作为普通硬盘的缓存</a>时才需要此功能.详情参见"<a href="https://www.kernel.org/doc/Documentation/bcache.txt">Documentation/bcache.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Bcache debugging<br>CONFIG_BCACHE_DEBUG</dt><dd>仅供内核开发者调试使用</dd>
		<dt>Extended runtime checks<br>CONFIG_BCACHE_EDEBUG</dt><dd>仅供内核开发者调试使用</dd>
		<dt>Debug closures<br>CONFIG_BCACHE_CLOSURES_DEBUG</dt><dd>仅供内核开发者调试使用</dd>
	</dl></dd>
	<dt>Device mapper support<br>CONFIG_BLK_DEV_DM</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/">Device-mapper</a>是一个底层的卷管理器,提供了一种从逻辑设备到物理设备的映射框架,用户可以很方便的根据自己的需要制定存储资源的管理策略.它不像RAID那样工作在设备层,而是通过块和扇区的映射机制,将不同磁盘的不同部分组合成一个大的块设备供用户使用.<a href="https://wiki.archlinux.org/index.php/LVM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">LVM2</a>和<a href="http://en.wikipedia.org/wiki/Enterprise_Volume_Management_System">EVMS</a>都依赖于它.此外,那些集成在南桥(例如ICH8R/ICH9R/ICH10R系列等)中所谓的"硬RAID"(准确的称呼应该是"<a href="http://wenku.baidu.com/view/195a16eae009581b6bd9eb1b.html">Device Mapper RAID</a>",又称为"Fake RAID"/"BIOS RAID")也依赖于它.还有企业级高可用环境中经常使用的多路径设备也依赖于它.</dd>
	<dd><dl>
		<dt>request-based DM: use blk-mq I/O path by default<br>CONFIG_DM_MQ_DEFAULT</dt><dd>对所有Device-mapper块设备默认使用新式的多重队列I/O调度机制(<a href="http://blog.csdn.net/zhufengtianya/article/details/43266415">blk-mq</a>),也就是将I/O请求映射至多个硬件或软件队列以提高性能.相当于开启"dm_mod.use_blk_mq"内核模块参数.推荐选"Y".</dd>
		<dt>Device mapper debugging support<br>CONFIG_DM_DEBUG</dt><dd>仅供内核开发者调试使用</dd>
		<dt>Keep stack trace of persistent data block lock holders<br>CONFIG_DM_DEBUG_BLOCK_STACK_TRACING</dt><dd>仅供内核开发者调试使用</dd>
		<dt>Crypt target support<br>CONFIG_DM_CRYPT</dt><dd>此模块允许你创建一个经过透明加密的逻辑设备(使用<a href="http://code.google.com/p/cryptsetup/">cryptsetup</a>工具),要使用加密功能,除此项外,还需要在"Cryptographic API"里选中相应的加密算法,例如CONFIG_CRYPTO_AES.更多文档请参考<a href="http://code.google.com/p/cryptsetup/wiki/FrequentlyAskedQuestions">LUKS FAQ</a>.</dd>
		<dt>Snapshot target<br>CONFIG_DM_SNAPSHOT</dt><dd>允许卷管理器为DM设备创建可写的快照(定格于特定瞬间的一个设备虚拟映像).<a href="http://blog.chinaunix.net/uid-8650524-id-6166.html">LVM2 Snapshot</a>需要它的支持.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/device-mapper/snapshot.txt">Documentation/device-mapper/snapshot.txt</a>"文档.不确定的选"N".</dd>
		<dt>Thin provisioning target<br>CONFIG_DM_THIN_PROVISIONING</dt><dd>"<a href="http://en.wikipedia.org/wiki/Thin_provisioning">Thin provisioning</a>"(某些地方翻译为"精简配置")的意思是允许分配给所有用户的总存储容量超过实际的存储容量(使用<a href="https://github.com/jthornber/thin-provisioning-tools">thin-provisioning-tools</a>工具).例如给100个用户分配空间,每个用户最大允许10G空间,共计需要1000G空间.但实际情况是95%的用户都只使用了不到1G的空间,那么实际准备1000G空间就是浪费.有了"thin provisioning"的帮助,你实际只需要准备150G的空间就可以了,之后,可以随着用户需求的增加,添加更多的实际存储容量,从而减少存储投资和避免浪费.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt">Documentation/device-mapper/thin-provisioning.txt</a>"文档.</dd>
		<dd><dl>
			<dt>Keep stack trace of thin provisioning block lock holders<br>CONFIG_DM_DEBUG_BLOCK_STACK_TRACING</dt><dd>仅用于调试目的</dd>
		</dl></dd>
		<dt>Cache target<br>CONFIG_DM_CACHE</dt><dd><a href="http://www.oschina.net/p/dm-cache">dm-cache</a>通过将频繁使用的热点数据缓存到一个容量较小但性能很高的存储设备上,从而提升块设备的性能.它支持<a href="http://blog.csdn.net/string19820108/article/details/7327552">writeback和writethrough</a>两种模式,并可以使用多种<a href="http://wangxu.me/blog/p/787">缓存策略(policy)</a>以判断哪些是热点数据以及哪些数据需要从缓存中移除.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/device-mapper/cache.txt">Documentation/device-mapper/cache.txt</a>"文档.不确定的选"N".</dd>
		<dd><dl>
			<dt>MQ Cache Policy<br>CONFIG_DM_CACHE_MQ</dt><dd>MQ缓存策略.这是目前唯一真正可用的缓存策略.</dd>
			<dt>Cleaner Cache Policy<br>CONFIG_DM_CACHE_CLEANER</dt><dd>Cleaner简单的把所有数据都同步写入到原始设备上,相当于关闭缓存.</dd>
		</dl></dd>
		<dt>Era target<br>CONFIG_DM_ERA</dt><dd>跟踪块设备上的哪些部分被写入,用于在使用vendor快照时维护缓存一致性.不确定的选"N".</dd>
		<dt>Mirror target<br>CONFIG_DM_MIRROR</dt><dd>允许对逻辑卷进行镜像,同时实时数据迁移工具<a href="http://francs3.blog.163.com/blog/static/40576727201223134340630/">pvmove</a>也需要此项的支持.</dd>
		<dt>RAID 1/4/5/6/10 target<br>CONFIG_DM_RAID</dt><dd>RAID 1/4/5/6/10 支持.即使使用ICH8R/ICH9R/ICH10R这样的南桥,也不推荐使用"Device Mapper RAID"(既无性能优势又依赖于特定硬件),应该直接使用更成熟的CONFIG_BLK_DEV_MD模块.</dd>
		<dt>Mirror userspace logging<br>CONFIG_DM_LOG_USERSPACE</dt><dd>device-mapper用户空间日志功能由内核模块和用户空间程序两部分组成,此选项是内核模块(API定义于"linux/dm-dirty-log.h"文件).不确定的选"N".</dd>
		<dt>Zero target<br>CONFIG_DM_ZERO</dt><dd>"Zero target"类似于"/dev/zero",所有的写入都被丢弃,所有的读取都可以得到无限多个零.可用于某些恢复场合.</dd>
		<dt>Multipath target<br>CONFIG_DM_MULTIPATH</dt><dd><a href="http://wenku.it168.com/d_000497278.shtml">设备映射多路径</a>(DM-Multipath)支持.常用于对可靠性要求比较苛刻的场合.</dd>
		<dd><dl>
			<dt>I/O Path Selector based on the number of in-flight I/Os<br>CONFIG_DM_MULTIPATH_QL</dt><dd>这是一个动态负载均衡路径选择器:选择当前正在处理中的I/O数量最小的通路.</dd>
			<dt>I/O Path Selector based on the service time<br>CONFIG_DM_MULTIPATH_ST</dt><dd>这是一个动态负载均衡路径选择器:选择完成此I/O操作预期时间最少的通路.</dd>
		</dl></dd>
		<dt>I/O delaying target<br>CONFIG_DM_DELAY</dt><dd>对读/写操作进行延迟,并可将其发送到不同的设备.仅用于测试DM子系统.</dd>
		<dt>DM uevents<br>CONFIG_DM_UEVENT</dt><dd>为DM事件透过<a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a>向用户层的udevd发出uevent通知,这样就允许udevd在"/dev/"目录中执行相应的操作.</dd>
		<dt>Flakey target<br>CONFIG_DM_FLAKEY</dt><dd>模拟间歇性的I/O错误,以用于调试DM子系统.</dd>
		<dt>Verity target support<br>CONFIG_DM_VERITY</dt><dd>Verity target 可以创建一个只读的逻辑设备,然后根据预先生成的哈希校验和(存储在其他设备上),校验底层设备上的数据正确性.要使此模块正常工作,还需要在"Cryptographic API"部分选中相应的哈希算法.</dd>
		<dt>Switch target support<br>CONFIG_DM_SWITCH</dt><dd>Switch target 可以创建这样的逻辑设备:将固定尺寸区块的I/O操作任意映射到一组固定的路径上.通过向target发送一个消息,即可动态的切换指定区块的I/O操作所使用的路径.</dd>
		<dt>Log writes target support<br>CONFIG_DM_LOG_WRITES</dt><dd>此种target需要两个设备:主设备按照常规方式使用,辅设备则专门记录所有主设备的写操作.主要用于帮助文件系统的开发者验证文件系统的一致性,仅供开发调试使用.</dd>
	</dl></dd>
</dl></dd>


<dt>Generic Target Core Mod (TCM) and ConfigFS Infrastructure<br>CONFIG_TARGET_CORE</dt><dd>通用TCM存储引擎与ConfigFS虚拟文件系统(/sys/kernel/config)支持.看不懂就说明你不需要.</dd>


<dt>Fusion MPT device support<br>CONFIG_FUSION</dt><dd><a href="http://storage.chinaunix.net/stor/other/2006/04/05/1109749.shtml">Fusion MPT</a>(Message Passing Technology) 是 LSI Logic 公司为了更容易实现SCSI和光纤通道而提出的技术,支持Ultra320 SCSI/光纤通道/SAS.</dd>


<dt>IEEE 1394 (FireWire) support</dt><dd>火线(<a href="http://baike.baidu.com/view/117006.htm">IEEE 1394</a>)是苹果公司开发的串行接口,类似于USB,但PC上并不常见,算得上是个没有未来的技术了.</dd>


<dt>I2O device support<br>CONFIG_I2O</dt><dd><a href="http://wenwen.soso.com/z/q59111011.htm">智能输入输出</a>(<a href="http://baike.baidu.com/view/272945.htm">Intelligent Input/Output</a>)架构让硬件驱动分成了两部分:OSM(特定于操作系统)+HDM(特定于硬件,与操作系统无关).由于<a href="http://i2o.shadowconnect.com/index.php">I2O设备</a>上集成有专用的I/O处理器,从而加快I/O速度(因为避免了CPU的参与).I2O属于已被废弃的技术,目前能见到的此类设备都属于老古董了.</dd>


<dt>Macintosh device drivers<br>CONFIG_MACINTOSH_DRIVERS</dt><dd>苹果的Macintosh电脑上的专有设备驱动</dd>


<dt>Network device support<br>CONFIG_NETDEVICES</dt><dd>网络设备.除非你不想连接任何网络,否则必选"Y".</dd>
<dd><dl>
	<dt>Network core driver support<br>CONFIG_NET_CORE</dt><dd>如果你不想使用任何高级网络功能(拨号网络/EQL/VLAN/bridging/bonding/team/光纤通道/<a href="http://www.ibm.com/developerworks/cn/linux/l-virtual-networking/">虚拟网络</a>等),仅仅是一般性质的联网(普通低端服务器,通过路由器或者局域网上网的常规个人电脑或办公电脑),可以选"N".</dd>
	<dd><dl>
		<dt>Bonding driver support<br>CONFIG_BONDING</dt><dd>链路聚合技术拥有多个不同的称谓:Linux称为"<a href="http://blog.csdn.net/wuweilong/article/details/39720571">Bonding</a>",IEEE称为"<a href="http://baike.baidu.com/view/1996279.htm">802.3ad</a>",Sun称为"Trunking",Cisco称为"<a href="http://baike.baidu.com/view/320130.htm">Etherchannel</a>".该技术可以将多个以太网通道聚合为一个单独的虚拟适配器,例如将两块网卡聚合成一个逻辑网卡,可以用来实现负载均衡或硬件冗余.此项技术目前已逐渐被CONFIG_NET_TEAM取代.</dd>
		<dt>Dummy net driver support<br>CONFIG_DUMMY</dt><dd>Dummy网络接口本质上是一个可以配置IP地址的bit-bucket(位桶,所有发送到此设备的流量都将被湮灭),以使应用程序看上去正在和一个常规的网络接口进行通信.使用<A href="http://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E7%BA%BF%E8%B7%AFIP%E5%8D%8F%E8%AE%AE">SLIP</a>(小猫拨号,目前应该已经绝迹了)或<a href="http://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">PPP</a>(常用于<a href="http://zh.wikipedia.org/wiki/PPPoE">PPPoE</a> ADSL)的用户需要它</dd>
		<dt>EQL (serial line load balancing) support<br>CONFIG_EQUALIZER</dt><dd>串行线路的负载均衡.如果有两个MODEM和两条SLIP/PPP线路,该选项可以让你同时使用这两个通道以达到双倍速度(网络的对端也要支持EQL技术).曾经昙花一现的<a href="http://baike.baidu.com/view/51012.htm">ISDN</a>就这项技术的一个实例.</dd>
		<dt>Fibre Channel driver support<br>CONFIG_NET_FC</dt><dd>光纤通道(Fibre Channel)是一种高速网络串行协议,主要用于存储局域网(SAN),与传统的iSCSI技术相比,除了提供更高的数据传输速度(此优势不是绝对的),更远的传输距离,更多的设备连接支持,更稳定的性能,更简易的安装以外,最重要的是支持网络区域存储(SAN)技术.FC与SCSI兼容,并意在取代iSCSI(看起来难以如愿,并且有可能被40Gb以上的iSCSI反超).如果你的机器上有光纤通道卡(FC卡),除了需要开启此项外,还需要开启相应的FC卡驱动,以及CONFIG_CHR_DEV_SG选项.</dd>
		<dt>Generic Media Independent Interface device support<br>CONFIG_MII</dt><dd><a href="http://baike.baidu.com/view/229282.htm">媒体独立接口</a>(<a href="http://www.cndzz.com/download/4105_0/102212.html">Media Independent Interface</a>)又称介质无关接口,是<a href="http://baike.baidu.com/view/203586.htm">IEEE-802.3</a>(规定了以太网相关协议的具体内容)定义的以太网行业标准.它包括一个数据接口,以及一个位于<a href="http://www.360doc.com/content/11/1020/23/1317564_157853470.shtml">MAC和PHY</a>之间的控制接口.[提示]大多数以太网卡都有MII收发器,其驱动都依赖于此项,也会自动选中此项.</dd>
		<dt>Intermediate Functional Block support<br>CONFIG_IFB</dt><dd><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/ifb">IFB</a>是一个中间层驱动,可以用来灵活的配置资源共享.更多信息参见iproute2文档.看不懂就说明你不需要.</dd>
		<dt>Ethernet team driver support<br>CONFIG_NET_TEAM</dt><dd><a href="http://ceyes.github.io/2014-07/Study-Linux-Team/">team驱动</a>.允许通过"ip link add link [ address MAC ] [ NAME ] type team"命令,或者使用将多个以太网卡(称为"port")组合在一起,创建一个虚拟的"<a href="https://linux.cn/article-5384-1.html">team</a>"网络设备,从而允许故障转移或者提高吞吐率,其目的是取代传统的"Bonding"(CONFIG_BONDING)驱动."ip"是iproute2包中的一个命令.不确定的选"N".</dd>
		<dd><dl>
			<dt>Broadcast mode support<br>CONFIG_NET_TEAM_MODE_BROADCAST</dt><dd>广播模式:所有网卡共用同一个MAC地址,每一个包都从所有网卡同时发送,不做负载均衡,仅做链路冗余,需要和交换机的"聚合强制不协商"方式配合使用.此模式最浪费资源,但可靠性最高,容错能力最强.常用于强调极端可靠的金融业.</dd>
			<dt>Round-robin mode support<br>CONFIG_NET_TEAM_MODE_ROUNDROBIN</dt><dd>循环均衡模式:所有网卡共用同一个MAC地址,数据包依次从每个网卡循环分发(例如,在三个网卡一组的情况下,第0个包走eth0,第1个包走eth1,第2个包走eth2,第3个包走eth0,第4个包走eth1,第5个包走eth2,第6个包走eth0,...一直循环分发下去,直到传输完毕),带宽增加,支持容错(故障链路会被自动踢出),交换机需要配置聚合口(思科叫"port channel").数据包从不同的网卡发出,若中途再经过不同的链路,在到达客户端时可能会乱序,从而造成吞吐量达不到理论上的翻倍效果.</dd>
			<dt>Random mode support<br>CONFIG_NET_TEAM_MODE_RANDOM</dt><dd>随机均衡模式:所有网卡共用同一个MAC地址,数据包依次随机选择一个网卡分发(例如,在三个网卡一组的情况下,第0个包走eth2,第1个包走eth0,第2个包走eth2,第3个包走eth1,第4个包走eth1,第5个包走eth0,第6个包走eth2,...一直随机分发下去,直到传输完毕),带宽增加,支持容错(故障链路会被自动踢出),交换机需要配置聚合口(思科叫"port channel").数据包从不同的网卡发出,若中途再经过不同的链路,在到达客户端时可能会乱序,从而造成吞吐量达不到理论上的翻倍效果.</dd>
			<dt>Active-backup mode support<br>CONFIG_NET_TEAM_MODE_ACTIVEBACKUP</dt><dd>主备模式:无需更改每个网卡的原生MAC地址,但是team的MAC地址对外仅在主网卡上可见并且保持不变,同一时刻仅有主网卡处于激活状态,其他备用网卡都处于等待状态,所有流量仅通过主网卡发送,仅在主网卡故障时,某个备用网卡才会被激活成主网卡.此模式仅提供容错能力,可靠性高,但是资源利用率最低.此模式最大的好处是不需要在交换机上做特别的设置.</dd>
			<dt>Load-balance mode support<br>CONFIG_NET_TEAM_MODE_LOADBALANCE</dt><dd>BPF均衡模式:均衡算法由用户空间通过BPF接口(bpf_hash_func)设置.</dd>
		</dl></dd>
		<dt>MAC-VLAN support<br>CONFIG_MACVLAN</dt><dd>MAC-VLAN是通过MAC地址来划分<a href="http://baike.baidu.com/view/21837.htm">VLAN</a>的方式,在Linux则用来给网卡添加多个MAC地址.你可以使用"ip link add link &lt;real dev&gt; [ address MAC ] [ NAME ] type macvlan"命令创建一个虚拟的"macvlan"设备(系统会自动打开网卡的<a href="http://baike.baidu.com/view/2521757.htm">混杂模式</a>),然后就可以在同一个物理网卡上虚拟出多个以太网口.Docker依赖于它.</dd>
		<dd><dl>
			<dt>MAC-VLAN based tap driver<br>CONFIG_MACVTAP</dt><dd>基于MAC-VLAN接口的tap(虚拟以太网设备)字符设备(<a href="http://blog.csdn.net/kl222/article/details/8513593">macvtap</a>)驱动,旨在简化虚拟化的桥接网络,目的是替代<a href="http://baike.baidu.com/view/8570754.htm">TUN/TAP</a>(CONFIG_TUN)和Bridge(CONFIG_BRIDGE)内核模块.可以通过与创建macvlan设备相同的"ip"命令创建一个虚拟的"macvtap"设备,并通过<a href="http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP">TAP</a>用户空间接口进行访问.</dd>
		</dl></dd>
		<dt>Virtual eXtensible Local Area Network (VXLAN)<br>CONFIG_VXLAN</dt><dd>"<a href="http://hb.qq.com/a/20111010/000076.htm">vxlan</a>"虚拟接口可以在第三层网络上创建第二层网络(跨多个物理IP子网的虚拟二层子网),是一种在UDP中封装MAC的简单机制,主要用于虚拟化环境下的隧道虚拟网络(tunnel virtual network).</dd>
		<dt>Network console logging support<br>CONFIG_NETCONSOLE</dt><dd>网络控制台(netconsole)的作用是通过网络记录内核日志信息.详情参见"<a href="https://www.kernel.org/doc/Documentation/networking/netconsole.txt">Documentation/networking/netconsole.txt</a>"文档.不确定的选"N".</dd>
		<dd><dl>
			<dt>Dynamic reconfiguration of logging targets<br>CONFIG_NETCONSOLE_DYNAMIC</dt><dd>允许通过configfs导出的用户空间接口,在运行时更改日志目标(网口, IP地址, 端口号, MAC地址).</dd>
		</dl></dd>
		<dt>Netpoll traffic trapping<br>CONFIG_NETPOLL_TRAP</dt><dd><a href="http://www.360doc.com/content/11/1023/09/7975692_158366329.shtml">netpoll</a>的目的是让内核在网络和I/O子系统尚不能完整可用时,依然能发送和接收数据包.主要用于网络控制台(netconsole)和远程内核调试(KGDBoE)中.不确定的选"N".</dd>
		<dt>Virtual Ethernet over NTB<br>CONFIG_NTB_NETDEV</dt><dd>PCI-E非透明桥(CONFIG_NTB)上的虚拟网卡.不确定的选"N".</dd>
		<dt>RapidIO Ethernet over messaging driver support<br>CONFIG_RIONET</dt><dd>在标准的<a href="http://www.big-bit.com/news/ic_29514.html">RapidIO</a>通信方式上发送以太网数据包.不确定的选"N".</dd>
		<dt>Universal TUN/TAP device driver support<br>CONFIG_TUN</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-tuntap/">TUN/TAP</a>可以为用户空间提供包的接收和发送服务,可以用来虚拟一张网卡或点对点通道(例如为QEMU提供虚拟网卡支持).当程序打开"/dev/net/tun"设备时,驱动程序就会注册相应的<a href="http://blog.csdn.net/wangxing1018/article/details/3510118">"tunX"或"tapX"</a>网络设备,当程序关闭"/dev/net/tun"设备时,驱动程序又会删除相应的"tunX"或"tapX"网络设备以及所有与之相关联的路由.详情参见"<a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt">Documentation/networking/tuntap.txt</a>"文档.看不懂就表明你不需要.</dd>
		<dt>Support for cross-endian vnet headers on little-endian kernels<br>CONFIG_TUN_VNET_CROSS_LE</dt><dd>允许小端序(little-endian)内核中的TUN/TAP与MACVTAP设备驱动解析来自大端序(big-endian)内核的老旧的virtio设备的vnet头.不确定的选"N".</dd>
		<dt>Virtual ethernet pair device<br>CONFIG_VETH</dt><dd>该驱动提供了一个本地以太网隧道(设备会被成对的创建).Docker依赖于它.</dd>
		<dt>Virtio network driver<br>CONFIG_VIRTIO_NET</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">virtio</a>虚拟网卡驱动.仅可用在基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的半虚拟化客户机中(一般是<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>).</dd>
		<dt>Virtual netlink monitoring device<br>CONFIG_NLMON</dt><dd>提供一个可以监视netlink skbs的网络设备,以允许tcpdump之类的工具通过packet socket来分析netlink消息.仅供调试使用.</dd>
	</dl></dd>
	<dt>ARCnet support<br>CONFIG_ARCNET</dt><dd><a href="http://baike.baidu.com/view/630530.htm">ARCnet</a>是1977年由Datapoint公司开发的一种局域网技术,它采用令牌总线方案来管理LAN上工作站和其他设备之间的共享线路,主要用于工业控制领域中.</dd>
	<dt>ATM drivers<br>CONFIG_ATM_DRIVERS</dt><dd>可怜的ATM(异步传输模式),曾经在90年代风靡一时,现在已经消失的无影无踪了.</dd>
	<dt class="omit">{这里省略几个专用于Android/MeeGo系统的PF_CAIF类型套接字相关的选项}</dt>
	<dt>Distributed Switch Architecture drivers</dt><dd>分布式交换架构驱动,其子项都是Marvell系列以太网交换机芯片组的驱动</dd>
	<dt>Ethernet driver support<br>CONFIG_ETHERNET</dt><dd>最常见的以太网卡驱动</dd>
	<dd><dl>
		<dt class="omit">{省略的部分请按照实际的硬件状况进行选择,这里仅以两个常见公司的以太网芯片为例进行说明}</dt>
		<dt>AMD devices<br>CONFIG_NET_VENDOR_AMD</dt><dd>AMD出品的以太网控制芯片</dd>
		<dd><dl>
			<dt>AMD PCnet32 PCI support<br>CONFIG_PCNET32</dt><dd>这是VMware/VirtualBox虚拟机中常用的网卡</dd>
		</dl></dd>
		<dt>Broadcom devices<br>CONFIG_NET_VENDOR_BROADCOM</dt><dd>博通(Broadcom)公司的网卡</dd>
		<dd><dl>
			<dt>Broadcom 440x/47xx ethernet support<br>CONFIG_B44</dt><dd>Broadcom 44xx/47xx 10/100M PCI</dd>
			<dt>Broadcom NetXtremeII support<br>CONFIG_BNX2</dt><dd>NetXtreme II 1 Gigabit ( BCM5706/5708/5709/5716 )</dd>
			<dt>Broadcom CNIC support<br>CONFIG_CNIC</dt><dd>NetXtremeII 系列网卡的<a href="http://www.sansky.net/article/2007-11-17-toe-technology-and-the-working-principle-of-toe-nic.html">TCP减负引擎</a>(<a href="http://en.wikipedia.org/wiki/TCP_offload_engine">TCP Offload Engine</a>)特性支持.不过,<a href="http://www.cnblogs.com/pandaeye/archive/2013/05/20/3089635.html">TOE并不适合高连接数/小文件的Web服务器类应用</a>,它的主要目的是和IP存储协议(iSCSI/NFS)一起使用.[注意]TOE与"Large Receive Offload"是两个不同的东西,不要混淆.</dd>
			<dt>Broadcom Tigon3 support<br>CONFIG_TIGON3</dt><dd>这是最流行的驱动,其涵盖的型号特别多,但是"Tigon3"的名称却非常具有迷惑性.简单说来,除了B44,BNX2,BNX2X中明确列出的型号外,其他型号用的都是这个驱动.[注意]某些型号还需要额外到固件支持,例如:BCM5703/BCM5704需要tigon/tg3_tso.bin,BCM5701A0需要tigon/tg3.bin,BCM5705需要tigon/tg3_tso5.bin</dd>
			<dt>Broadcom NetXtremeII 10Gb support<br>CONFIG_BNX2X</dt><dd>NetXtreme II 10 Gigabit ( BCM57710/57711/57711E/57712/57800/57810  )</dd>
			<dd><dl>
				<dt>Broadcom 578xx and 57712 SR-IOV support<br>CONFIG_BNX2X_SRIOV</dt><dd>支持578xx/57712的<a href="http://blog.sina.com.cn/s/blog_582a1a4b0100zvnh.html">单根I/O虚拟化</a>(<a href="http://www.openstack.cn/?p=2118">Single Root IOV</a>)技术</dd>
			</dl></dd>
		</dl></dd>
	</dl></dd>
	<dt>FDDI driver support<br>CONFIG_FDDI</dt><dd><a href="http://baike.baidu.com/view/876931.htm">光纤分布式数据接口</a>(FDDI)</dd>
	<dt>HIPPI driver support<br>CONFIG_HIPPI</dt><dd><a href="http://baike.baidu.com/view/5423623.htm">高性能并行接口</a>(HIgh Performance Parallel Interface)是一个在短距离内高速传送大量数据的点对点协议.常用于集群和超级计算机.</dd>
	<dt>General Instruments Surfboard 1000<br>CONFIG_NET_SB1000</dt><dd>SURFboard 1000 插卡式Cable Medem(ISA接口),这玩意早就绝种了</dd>
	<dt>PHY Device support and infrastructure<br>CONFIG_PHYLIB</dt><dd>数据链路层芯片简称为MAC控制器,物理层芯片简称之为PHY,通常的网卡把MAC和PHY的功能做到了一颗芯片中,但也有一些仅含PHY的"软网卡".此选项就是对这些"软网卡"的支持.请根据实际情况选择其下的子项.</dd>
	<dt>Micrel KS8995MA 5-ports 10/100 managed Ethernet switch<br>CONFIG_MICREL_KS8995MA</dt><dd><a href="http://www.micrel.com.cn/">Micrel</a> KS8995MA 5端口 10/100M 以太网交换芯片</dd>
	<dt>PLIP (parallel port) support<br>CONFIG_PLIP</dt><dd><a href="http://fanqiang.chinaunix.net/a3/b2/20010421/173510_b.html">PLIP</a>(Parallel Line Internet Protocol)用于将两台电脑通过并口进行联网,组成一个简单的客户机/服务器结构.详情参见"<a href="https://www.kernel.org/doc/Documentation/networking/PLIP.txt">Documentation/networking/PLIP.txt</a>".现在的电脑都使用网卡进行互联,并口早就经被丢进历史的垃圾箱了.</dd>
	<dt>PPP (point-to-point protocol) support<br>CONFIG_PPP</dt><dd><a href="http://zh.wikipedia.org/zh-cn/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点协议</a>(<a href="http://www.cnblogs.com/zmkeil/archive/2013/05/02/3055518.html">Point to Point Protocol</a>)是SLIP的继任者,使用PPP需要用户层程序<a href="http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html">pppd</a>的帮助.PPP实际上有两个版本:基于普通模拟电话线的"异步PPP"和基于数字线路(例如ISDN线路)的"同步PPP".<a href="http://wiki.ubuntu.org.cn/ADSL%EF%BC%88PPPOE%EF%BC%89%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97">使用电脑直接拨号的 PPPoE ADSL 用户</a>需要此项.</dd>
	<dd><dl>
		<dt>PPP BSD-Compress compression<br>CONFIG_PPP_BSDCOMP</dt><dd>为PPP提供BSD(等价于LZW压缩算法,没有gzip高效)压缩算法支持,需要通信双方的支持才有效.大多数ISP都不支持此算法.</dd>
		<dt>PPP Deflate compression<br>CONFIG_PPP_DEFLATE</dt><dd>为PPP提供Deflate(等价于gzip压缩算法)压缩算法支持,需要通信双方的支持才有效.这是比BSD更好的算法(压缩率更高且无专利障碍).</dd>
		<dt>PPP filtering<br>CONFIG_PPP_FILTER</dt><dd>允许对通过PPP接口的包进行过滤.仅在你需要使用pppd的pass-filter/active-filter选项时才需要开启.不确定的选"N".</dd>
		<dt>PPP MPPE compression (encryption)<br>CONFIG_PPP_MPPE</dt><dd>为PPP提供MPPE加密协议支持,它被用于微软的P2P隧道协议中.此特性需要<a href="https://wiki.archlinux.org/index.php/Microsoft_VPN_client_setup_with_pptpclient_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">PPTP Client</a>工具的支持.</dd>
		<dt>PPP multilink support<br>CONFIG_PPP_MULTILINK</dt><dd>多重链路协议(RFC1990)允许你将多个线路(物理的或逻辑的)组合为一个PPP连接一充分利用带宽,这不但需要pppd的支持,还需要ISP的支持</dd>
		<dt>PPP over ATM<br>CONFIG_PPPOATM</dt><dd>在ATM上跑的PPP.果断"N".</dd>
		<dt>PPP over Ethernet<br>CONFIG_PPPOE</dt><dd>这就是ADSL用户最常见的PPPoE,也就是在以太网上跑的PPP协议.这需要<a href="http://www.roaringpenguin.com/pppoe">RP-PPPoE</a>工具的帮助</dd>
		<dt>PPP over IPv4 (PPTP)<br>CONFIG_PPTP</dt><dd><a href="http://zh.wikipedia.org/zh-cn/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0">点对点隧道协议</a>(<a href="http://baike.baidu.com/view/32771.htm">Point-to-Point Tunneling Protocol</a>)是一种主要用于VPN的数据链路层网络协议.此功能需要<a href="http://accel-pptp.sourceforge.net/">ACCEL-PPTP</a>工具的支持.</dd>
		<dt>PPP over L2TP<br>CONFIG_PPPOL2TP</dt><dd><a href="http://zh.wikipedia.org/zh-cn/%E7%AC%AC%E4%BA%8C%E5%B1%82%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">第二层隧道协议</a>(<a href="http://baike.baidu.com/view/32692.htm">L2TP</a>)是一种通过UDP隧道传输PPP流量的技术,对于VPN用户来说,<a href="http://www.h3c.com.cn/MiniSite/Technology_Circle/Technology_Column/ICG/ICG_Technology/201004/671383_97665_0.htm">L2TP VPN</a>是比PPTP VPN的更好解决方案.</dd>
		<dt>PPP support for async serial ports<br>CONFIG_PPP_ASYNC</dt><dd>基于普通模拟电话线或标准异步串口(COM1,COM2)的"异步PPP"支持. PPPoE ADSL 使用的就是这个.不能与下面的CONFIG_PPP_SYNC_TTY同时并存.</dd>
		<dt>PPP support for sync tty ports<br>CONFIG_PPP_SYNC_TTY</dt><dd>基于同步tty设备(比如SyncLink适配器)的"同步PPP"支持.常用于高速租用线路(比如T1/E1).不确定的选"N".</dd>
	</dl></dd>
	<dt>SLIP (serial line) support<br>CONFIG_SLIP</dt><dd>一个在串行线上(例如电话线)传输IP数据报的TCP/IP协议.最原始的通过电话线拨号上网就用这个协议,如今基本绝迹了.不确定的选"N".</dd>
	<dt>CSLIP compressed headers<br>CONFIG_SLIP_COMPRESSED</dt><dd>CSLIP协议基于SLIP,但比SLIP快,它将TCP/IP头(而非数据)进行压缩传送,需要通信双方的支持才有效</dd>
	<dt>Keepalive and linefill<br>CONFIG_SLIP_SMART</dt><dd>让SLIP驱动支持RELCOM linefill和keepalive监视,这在信号质量比较差的模拟线路上是个好主意</dd>
	<dt>Six bit SLIP encapsulation<br>CONFIG_SLIP_MODE_SLIP6</dt><dd>这种线路非常罕见,选"N".</dd>
	<dt>USB Network Adapters</dt><dd>USB网络适配器</dd>
	<dt>Wireless LAN<br>CONFIG_WLAN</dt><dd><a href="http://wireless.kernel.org/en/users/Drivers">无线网卡</a></dd>
	<dd><dl>
		<dt class="omit">{省略的部分请按照实际的硬件状况进行选择,这里仅以Intel公司的主流无线网卡为例进行说明}</dt>
		<dt>Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate-N (iwlwifi)<br>CONFIG_IWLWIFI</dt><dd>这是目前主流Intel无线网卡的驱动.此驱动依赖于<a href="http://intellinuxwireless.org/">二进制uCode微代码</a>,它通常被安装到"/lib/firmware"目录,不过你最好亲自用眼睛检查一下其中是否存在"iwlwifi-*.ucode"这样的文件.</dd>
		<dd><dl>
			<dt>Intel Wireless WiFi DVM Firmware support<br>CONFIG_IWLDVM</dt><dd>DVM固件支持(这也是当前唯一可用的固件).选"Y/M".[提示]如果你将此驱动静态编译进内核,那么务必使用CONFIG_EXTRA_FIRMWARE功能将固件也一起编译进内核.</dd>
			<dt>Intel Wireless WiFi MVM Firmware support<br>CONFIG_IWLMVM</dt><dd>MVM固件支持(这是专用于7000系列无线网卡的固件).</dd>
		</dl></dd>
		<dt>Debugging Options</dt><dd>仅供调试使用,其下所有选项都选"N".</dd>
		<dt>iwlwifi experimental P2P support<br>CONFIG_IWLWIFI_P2P</dt><dd>iwlwifi驱动实验性的P2P支持.不确定的选"N".</dd>
	</dl></dd>
	<dt>WiMAX Wireless Broadband devices</dt><dd>WiMAX无线设备</dd>
	<dt>Wan interfaces support<br>CONFIG_WAN</dt><dd><a href="http://baike.baidu.com/view/21956.htm">广域网</a>(Wide Area Network)网卡支持.这种网卡很罕见.不确定的选"N".</dd>
	<dt>IEEE 802.15.4 drivers<br>CONFIG_IEEE802154_DRIVERS</dt><dd><a href="http://baike.baidu.com/view/1915042.htm">IEEE 802.15.4</a>描述了低速率无线个人局域网的物理层和媒体接入控制协议</dd>
	<dt>Xen network device frontend driver<br>CONFIG_XEN_NETDEV_FRONTEND</dt><dd>XEN半虚拟化网络设备前端驱动(通常是被"domain 0"导出的)</dd>
	<dt>Xen backend network device<br>CONFIG_XEN_NETDEV_BACKEND</dt><dd>XEN半虚拟化网络设备后端驱动,通常被用在"domain 0"内核上,用于向其他domain导出半虚拟化网络设备.</dd>
	<dt>VMware VMXNET3 ethernet driver<br>CONFIG_VMXNET3</dt><dd>VMware vmxnet3 虚拟以太网卡驱动</dd>
	<dt>FUJITSU Extended Socket Network Device driver<br>CONFIG_FUJITSU_ES</dt><dd>FUJITSU PRIMEQUEST 2000 E2 系列网卡</dd>
	<dt>Microsoft Hyper-V virtual network driver<br>CONFIG_HYPERV_NET</dt><dd>Microsoft <a href="http://baike.baidu.com/view/1359943.htm">Hyper-V</a> 虚拟以太网卡驱动</dd>
	<dt>ISDN support<br>CONFIG_ISDN</dt><dd>上世纪在ADSL流行之前曾经有过短暂流行,但现在已经绝迹了</dd>
</dl></dd>


<dt>Open-Channel SSD target support<br>CONFIG_NVM</dt><dd><a href="http://www.ssdfans.com/?p=628">Open-channel</a> SSD 是一种遵守<a href="http://diy.pconline.com.cn/611/6111798_all.html">NVMe</a>规范且不使用<a href="http://www.tuicool.com/articles/ba6rmi">FTL</a>技术的固态硬盘.目前此种SSD由于过于前卫还非常罕见.但是非常有前途.</dd>
<dd><dl>
	<dt>Open-Channel SSD debugging support<br>CONFIG_NVM_DEBUG</dt><dd>提供 /sys/module/lnvm/parameters/configure_debug 调试接口以允许创建/删除"target".仅供调试使用.</dd>
	<dt>Generic NVM manager for Open-Channel SSDs<br>CONFIG_NVM_GENNVM</dt><dd>为Open-Channel SSD提供NVM介质管理(media manager)支持,也就是将数据存放位置与垃圾回收策略的决定权收归操作系统内核,以剥夺固态硬盘设备自身的介质管理功能,或者说允许使用自身不包含介质管理功能的固态硬盘.</dd>
	<dt>Round-robin Hybrid Open-Channel SSD target<br>CONFIG_NVM_RRPC</dt><dd>允许将open-channel SSD在主机上显示为一个块设备:使用线性映射表实现,使用基于开销(cost-based)的垃圾回收机制,并对4K大小的IO操作进行了优化.</dd>
</dl></dd>


<dt>Input device support</dt><dd>输入设备</dd>
<dd><dl>
	<dt>Generic input layer (needed for keyboard, mouse, ...)<br>CONFIG_INPUT</dt><dd>通用输入层.只要你有任何输入设备(键盘,鼠标,手写板,触摸板,游戏杆,方向盘,游戏键盘...),就必须选"Y".</dd>
	<dd><dl>
		<dt>Export input device LEDs in sysfs<br>CONFIG_INPUT_LEDS</dt><dd>将输入设备上的LED指示灯当作标准的LED类设备导出到sysfs中.不确定的选"Y".</dd>
		<dt>Support for memoryless force-feedback devices<br>CONFIG_INPUT_FF_MEMLESS</dt><dd>游戏玩家使用的<a href="http://baike.baidu.com/view/351163.htm">力反馈</a>设备,例如: <a href="http://www.chiphell.com/forum.php?mod=viewthread&tid=94160">Logitech WingMan Force 3D 飞行摇杆</a>, <a href="http://www.dansdata.com/images/tmsticks/fsdp480.jpg">ThrustMaster FireStorm Dual Power 2</a>.如果你有此类设备,除了本项之外,还需要开启特定于硬件的驱动.</dd>
		<dt>Polled input device skeleton<br>CONFIG_INPUT_POLLDEV</dt><dd>使用轮询机制的输入设备支持,此项主要是为源码树之外的驱动准备的,内核自带的驱动若有需要会自动选中.不确定的选"N".</dd>
		<dt>Sparse keymap support library<br>CONFIG_INPUT_SPARSEKMAP</dt><dd>使用"sparse keymap"的输入设备支持,此项主要是为源码树之外的驱动准备的,内核自带的驱动若有需要会自动选中.不确定的选"N".</dd>
		<dt>Matrix keymap support library<br>CONFIG_INPUT_MATRIXKMAP</dt><dd>使用"matrix keymap"的输入设备支持,此项主要是为源码树之外的驱动准备的,内核自带的驱动若有需要会自动选中.不确定的选"N".</dd>
		<dt>Mouse interface<br>CONFIG_INPUT_MOUSEDEV</dt><dd>鼠标接口(/dev/input/mouseX,/dev/input/mice).用鼠标的必选(包括USB鼠标).[提示]如果系统上有多个鼠标,那么,mouseX对应单个特定的鼠标,而mice则是所有鼠标的集合(所有鼠标的事件都会被发送到这个设备文件中).</dd>
		<dd><dl>
			<dt>Provide legacy /dev/psaux device<br>CONFIG_INPUT_MOUSEDEV_PSAUX</dt><dd>仍然支持传统的/dev/psaux接口,这是为兼容老旧的程序而设置.选"N".</dd>
			<dt>Horizontal screen resolution<br>CONFIG_INPUT_MOUSEDEV_SCREEN_X</dt><dd>作为鼠标使用的数字化转换器(digitizer)或<a href="http://www.youliv.com/products/700187.aspx">手写板</a>(graphic tablet)需要知道X window的水平分辩率.一般可理解为显示屏的水平分辨率.</dd>
			<dt>Vertical screen resolution<br>CONFIG_INPUT_MOUSEDEV_SCREEN_Y</dt><dd>作为鼠标使用的数字化转换器(digitizer)或<a href="http://www.zgcprice.org/pic/multipic/l/041500555/0415005550031_634109858768281250.jpg">手写板</a>(graphic tablet)需要知道X window的垂直分辩率.一般可理解为显示屏的垂直分辨率.</dd>
		</dl></dd>
		<dt>Joystick interface<br>CONFIG_INPUT_JOYDEV</dt><dd>游戏杆(<a href="http://en.wikipedia.org/wiki/Joystick">joystick</a>)和游戏键盘(<a href="http://en.wikipedia.org/wiki/Gamepad">gamepad</a>)支持(/dev/input/jsX)</dd>
		<dt>Event interface<br>CONFIG_INPUT_EVDEV</dt><dd>将所有的输入设备事件都通过"/dev/input/eventX"以一种通用的方式进行处理.Xorg需要使用此接口.不确定的选"Y".</dd>
		<dt>Event debugging<br>CONFIG_INPUT_EVBUG</dt><dd>将所有输入设备的动作(键盘按下,鼠标移动等)都记录到系统日志当中.主要用于调试,同时也会带来安全漏洞(键盘输入中很可能包含你的密码).选"N".</dd>
		<dt>Keyboards<br>CONFIG_INPUT_KEYBOARD</dt><dd>键盘驱动</dd>
		<dd><dl>
			<dt>AT keyboard<br>CONFIG_KEYBOARD_ATKBD</dt><dd>标准AT键盘或者<a href="http://baike.baidu.com/view/1110237.htm">PS/2</a>键盘.[提示]除了台式机PS/2接口上的键盘外,许多笔记本的键盘其实也是PS/2键盘.使用USB键盘或者ADB键盘(旧式苹果键盘)的可以选"N".</dd>
			<dt class="omit">{此处被省略的键盘都很罕见,基本上不必考虑}</dt>
		</dl></dd>
		<dt>Mice<br>CONFIG_INPUT_MOUSE</dt><dd>鼠标驱动</dd>
		<dd><dl>
			<dt>PS/2 mouse<br>CONFIG_MOUSE_PS2</dt><dd>标准的两键或三键的<a href="http://zh.wikipedia.org/wiki/PS/2%E6%8E%A5%E5%8F%A3">PS/2</a>鼠标,同时兼容Microsoft/Logitech/Genius生产的带有滚轮或者额外按键的PS/2鼠标.使用Synaptics/ALPS/Elantech触摸板的用户还可以看看其<a href="http://xorg.freedesktop.org/archive/individual/driver/">专用的X驱动</a>,这些驱动可以提供更多的高级功能.使用USB鼠标的可以选"N".其下的子项是针对各厂商特定产品的扩展协议支持.按需选择即可.[提示]除了台式机PS/2接口上的鼠标外,许多笔记本的触摸板其实也是PS/2鼠标.</dd>
			<dt class="omit">{此处被省略的鼠标都很罕见,基本上不必考虑}</dt>
		</dl></dd>
		<dt>Joysticks/Gamepads<br></dt><dd>游戏杆,6自由度摇杆,游戏键盘,方向盘,射击武器...等各种游戏装置</dd>
		<dt>Tablets<br>CONFIG_INPUT_TABLET</dt><dd>平板输入设备</dd>
		<dt>Touchscreens<br>CONFIG_INPUT_TOUCHSCREEN</dt><dd>触摸屏输入设备</dd>
		<dt>Miscellaneous devices<br>CONFIG_INPUT_MISC</dt><dd>其他杂项输入设备</dd>
		<dd><dl>
			<dt>PC Speaker support<br>CONFIG_INPUT_PCSPKR</dt><dd>标准<a href="http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html">蜂鸣器</a>.建议开启.</dd>
			<dt class="omit">{此处被省略的其他设备都很罕见,基本上不必考虑}</dt>
		</dl></dd>
	</dl></dd>
	<dt>Hardware I/O ports</dt><dd>硬件I/O端口</dd>
	<dd><dl>
		<dt>Serial I/O support<br>CONFIG_SERIO</dt><dd>串行I/O硬件支持.标准AT键盘,PS/2鼠标,串口鼠标,Sun键盘,游戏杆,6自由度摇杆等设备都依赖于它.不确定的选"Y".</dd>
		<dt>i8042 PC Keyboard controller<br>CONFIG_SERIO_I8042</dt><dd>标准AT键盘,PS/2鼠标,这两种设备需要它的支持.</dd>
		<dt>Serial port line discipline<br>CONFIG_SERIO_SERPORT</dt><dd>RS232串口(COM).串口鼠标,游戏杆,6自由度摇杆等设备都依赖于它.</dd>
		<dt>ct82c710 Aux port controller<br>CONFIG_SERIO_CT82C710</dt><dd>一种德州仪器TravelMate笔记本上使用QuickPort接口的鼠标</dd>
		<dt>Parallel port keyboard adapter<br>CONFIG_SERIO_PARKBD</dt><dd>并口键盘适配器,用于将AT/XT键盘或PS/2鼠标转接到并口上.非常罕见.</dd>
		<dt>PCI PS/2 keyboard and PS/2 mouse controller<br>CONFIG_SERIO_PCIPS2</dt><dd>接在移动式扩展坞(Docking station)上的PS/2键盘或鼠标</dd>
		<dt>PS/2 driver library<br>CONFIG_SERIO_LIBPS2</dt><dd>为PS/2接口上的设备提供驱动(比如PS/2鼠标和标准AT键盘)</dd>
		<dt>Raw access to serio ports<br>CONFIG_SERIO_RAW</dt><dd>以raw方式访问serio接口(echo -n "serio_raw" > /sys/bus/serio/devices/serioX/drvctl),例如i8042键盘控制器的AUX端口.看不懂的就别选了.</dd>
		<dt>Altera UP PS/2 controller<br>CONFIG_SERIO_ALTERA_PS2</dt><dd>Altera University Program PS/2 端口支持.不确定的选"N".</dd>
		<dt>TQC PS/2 multiplexer<br>CONFIG_SERIO_PS2MULT</dt><dd>TQC板上的PS/2端口复用器(multiplexer)</dd>
		<dt>ARC PS/2 support<br>CONFIG_SERIO_ARC_PS2</dt><dd>ARC FPGA 平台上的PS/2控制器</dd>
		<dt>Gameport support<br>CONFIG_GAMEPORT</dt><dd>15针电脑游戏接口(<a href="http://en.wikipedia.org/wiki/Game_port">Gameport</a>).<a href="http://content.answcdn.com/main/content/img/CDE/_PCPORTS.JPG">图</a></dd>
	</dl></dd>
</dl></dd>


<dt>Character devices</dt><dd><a href="http://baike.baidu.com/view/1913432.htm">字符设备</a></dd>
<dd><dl>
	<dt>Enable TTY<br>CONFIG_TTY</dt><dd>字符终端和串口都需要<a href="http://baike.baidu.com/view/749979.htm">TTY</a>的支持.选"Y",除非你知道自己在干什么.[提示]你想<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-termi-hanzi/index.html">在控制台上显示汉字</a>吗?试试<a href="https://github.com/gentoo-zh/linux-cjktty/">CJKTTY</a>补丁吧!</dd>
	<dd><dl>
		<dt>Virtual terminal<br>CONFIG_VT</dt><dd><a href="http://baike.baidu.com/view/694267.htm">虚拟终端</a>可以在一个物理终端设备上虚拟出多个"显示器+键盘"的组合(可以使用"Alt+Fn"组合键在多个虚拟终端间切换).除非是嵌入式系统,否则必选"Y".</dd>
		<dd><dl>
			<dt>Enable character translations in console<br>CONFIG_CONSOLE_TRANSLATIONS</dt><dd>在虚拟控制台(console)上支持字体映射和Unicode转换.建议选"Y",否则将无法在控制台上显示Unicode字符.[提示]如果已经使用了<a href="https://github.com/gentoo-zh/linux-cjktty/">CJKTTY</a>补丁,则必选"Y".</dd>
			<dt>Support for console on virtual terminal<br>CONFIG_VT_CONSOLE</dt><dd>内核默认将第一个虚拟终端(/dev/tty0)用作系统控制台(可以通过"console=tty3"这样的参数去修改),将诸如模块错误/内核错误/启动信息之类的警告信息发送到这里,而且以单用户模式登录时也需要使用这个控制台.若选"N"则会导致黑屏.除非是嵌入式系统,否则必选"Y".</dd>
			<dt>Support for binding and unbinding console drivers<br>CONFIG_VT_HW_CONSOLE_BINDING</dt><dd>虚拟终端是通过控制台驱动程序与物理终端交互的,但在某些系统上可以使用多个控制台驱动程序(如framebuffer控制台驱动程序),该选项使得你可以选择其中之一.如果你需要使用多个控制台驱动,可以选"Y",不确定的选"N".参见"<a href="https://www.kernel.org/doc/Documentation/console/console.txt">Documentation/console/console.txt</a>"和"<a href="https://www.kernel.org/doc/Documentation/fb/fbcon.txt">Documentation/fb/fbcon.txt</a>"获取更多细节.</dd>
		</dl></dd>
		<dt>Unix98 PTY support<br>CONFIG_UNIX98_PTYS</dt><dd>伪终端(PTY)是指一个"软件终端",它是由slave(等价于一个物理终端)和master(被一个诸如xterm之类的进程用来读写slave设备)两部分组成的软设备.图形界面用户与需要支持ssh/telnet远程登录者必选.</dd>
		<dd><dl>
			<dt>Support multiple instances of devpts<br>CONFIG_DEVPTS_MULTIPLE_INSTANCES</dt><dd>允许多个"devpts"文件系统实例(使用"-o newinstance"挂载选项),以允许相互隔离的PTY命名空间(比如在虚拟化容器中).Docker依赖于它.systemd的PrivateNetwork/PrivateDevices特性依赖于它.</dd>
		</dl></dd>
		<dt>Legacy (BSD) PTY support<br>CONFIG_LEGACY_PTYS</dt><dd>使用过时的BSD风格的/dev/ptyxx作为master,/dev/ttyxx作为slave,这个方案有一些安全问题,选"N".</dd>
		<dt>Non-standard serial port support<br>CONFIG_SERIAL_NONSTANDARD</dt><dd>非标准串口支持.这样的设备非常罕见,选"N".</dd>
		<dt>HSDPA Broadband Wireless Data Card - Globe Trotter<br>CONFIG_NOZOMI</dt><dd>一种PCMCIA接口的<a href="http://baike.baidu.com/view/10159.htm">HSDPA</a>(WCDMA) 3G 无线上网卡</dd>
		<dt>Multi-Tech multiport card support<br>CONFIG_ISI</dt><dd><a href="http://www.multi-tech.com.hk/">Multi-Tech</a>公司生产的多端口卡(拥有多个串口)实验性支持.不确定的选"N".</dd>
		<dt>HDLC line discipline support<br>CONFIG_N_HDLC</dt><dd>Microgate SyncLink.不确定的选"N".</dd>
		<dt>GSM MUX line discipline support<br>CONFIG_N_GSM</dt><dd>GSM MUX(多路复用器)支持.不确定的选"N".</dd>
		<dt>Trace data router for MIPI P1149.7 cJTAG standard<br>CONFIG_TRACE_ROUTER</dt><dd>仅用于调试内含modem设备的手机系统.</dd>
		<dt>Trace data sink for MIPI P1149.7 cJTAG standard<br>CONFIG_TRACE_SINK</dt><dd>仅用于调试内含modem设备的手机系统.</dd>
	</dl></dd>
	<dt>KCopy</dt><dd>内核Copy</dd>
	<dd><dl>
		<dt>Memory-to-memory copies using kernel assist<br>CONFIG_KCOPY</dt><dd>高性能的进程间内存复制(可以减少一次向共享内存的复制动作).主要用于高性能并行计算领域,比如基于<a href="http://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E4%BB%8B%E9%9D%A2">消息传递接口</a>(<a href="http://wenku.baidu.com/view/ee8bf3390912a216147929f3.html">Message Passing Interface</a>)协议的开发的并行程序.不确定的选"N".</dd>
	</dl></dd>
	<dt>/dev/mem virtual device support<br>CONFIG_DEVMEM</dt><dd>"<a href="http://blog.csdn.net/skyflying2012/article/details/47611399">/dev/mem</a>"虚拟设备是整个处理器地址空间的全映射(包括所有物理内存/设备IO空间/总线映射空间),可以用来直接存取物理内存,常用于访问物理IO设备,例如<a href="http://www.ha97.com/4120.html">dmidecode</a>工具可以从中提取系统识别信息(序列号,制造商,型号,等等),或者Xorg可以用来访问显卡的物理内存或者<a href="http://blog.csdn.net/su_linux/article/details/8737690">实现用户空间驱动</a>,同时拥有root权限的攻击者也可以使用它完成很多标准rootkit的行为.如果你需要使用用户空间的驱动或不确定,那么选"Y".如果你觉得安全特别重要,可以选"N".</dd>
	<dt>/dev/kmem virtual device support<br>CONFIG_DEVKMEM</dt><dd>"/dev/kmem"虚拟设备是内核看到的虚拟内存的全镜像,可以用来访问内核内存.一般可以用来查看内核变量或者用作rootkit之类(!危险!).仅供调试,不确定的选"N".</dd>
	<dt>Serial drivers</dt><dd><a href="http://zh.wikipedia.org/zh-cn/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串口</a>(COM)驱动.串口在台式机主板上正在逐渐消亡,而在笔记本和服务器上早就已经绝迹了.大多数人应该将所有子项都选"N".</dd>
	<dd><dl>
		<dt>8250/16550 and compatible serial support<br>CONFIG_SERIAL_8250</dt><dd>这是标准<a href="http://zh.wikipedia.org/zh-cn/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串口(COM)</a>驱动.只要你想使用串口,就必选此项.不过,大多数人应该选"N".</dd>
		<dd><dl>
			<dt>Support 8250_core.* kernel options<br>CONFIG_SERIAL_8250_DEPRECATED_OPTIONS</dt><dd>选"N".</dd>
			<dt>8250/16550 PNP device support<br>CONFIG_SERIAL_8250_PNP</dt><dd>即插即用串口支持,不确定的选"Y".</dd>
			<dt>Console on 8250/16550 and compatible serial port<br>CONFIG_SERIAL_8250_CONSOLE</dt><dd>将串口当做系统控制台(接受所有内核消息,单用户模式登录)使用(需要使用"console=ttyS1"参数).仅在没有显示接口嵌入式设备上有用.不确定的选"N".</dd>
		</dl></dd>
		<dt>DMA support for 16550 compatible UART controllers<br>CONFIG_SERIAL_8250_DMA</dt><dd>与标准8250/16650兼容的<a href="http://baike.baidu.com/view/245027.htm">通用异步收发传输器</a>(<a href="http://zh.wikipedia.org/wiki/UART">Universal Asynchronous Receiver/Transmitter</a>)的<a href="http://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a>支持.在嵌入式设计中,UART用来主机与辅助设备通信,如汽车音响与外接AP之间的通信,与PC机通信包括与监控调试器和其它器件(如EEPROM)通信.不确定的选"Y".</dd>
		<dt>8250/16550 PCI device support<br>CONFIG_SERIAL_8250_PCI</dt><dd>PCI串口支持.选"N"表示仅支持传统的标准串口.</dd>
		<dt>8250/16550 PCMCIA device support<br>CONFIG_SERIAL_8250_CS</dt><dd>16-bit PCMCIA串口支持.选"N"表示仅支持传统的标准串口.</dd>
		<dt>Maximum number of 8250/16550 serial ports<br>CONFIG_SERIAL_8250_NR_UARTS</dt><dd>允许的最大串口数量,保持默认值即可.</dd>
		<dt>Number of 8250/16550 serial ports to register at runtime<br>CONFIG_SERIAL_8250_RUNTIME_UARTS</dt><dd>内核在启动时注册的串口数量(可以通过"8250.nr_uarts"参数修改),保持默认即可.</dd>
		<dt>Extended 8250/16550 serial driver options<br>CONFIG_SERIAL_8250_EXTENDED</dt><dd>非标准的串口驱动选项(例如HUB6,中断共享,多端口,超过4个COM口).不确定的选"N".</dd>
		<dd><dl>
			<dt>Support more than 4 legacy serial ports<br>CONFIG_SERIAL_8250_MANY_PORTS</dt><dd>如果你的板子上有超过4个COM接口就选"Y".</dd>
			<dt>Support for sharing serial interrupts<br>CONFIG_SERIAL_8250_SHARE_IRQ</dt><dd>有些板子上集成了共享IRQ的硬件支持.如果有就选"Y".</dd>
			<dt>Autodetect IRQ on standard ports (unsafe)<br>CONFIG_SERIAL_8250_DETECT_IRQ</dt><dd>让内核去猜串口的IRQ号.不安全,选"N".</dd>
			<dt>Support RSA serial ports<br>CONFIG_SERIAL_8250_RSA</dt><dd>RSA(Remote Supervisor Adapter)串口,是一种IBM特定的硬件.看不懂的选"N".</dd>
		</dl></dd>
		<dt>Support for Synopsys DesignWare 8250 quirks<br>CONFIG_SERIAL_8250_DW</dt><dd>Synopsys DesignWare APB UART 中非标准特性的支持.</dd>
		<dt>Medfield High Speed UART support<br>CONFIG_SERIAL_MFD_HSU</dt><dd><a href="http://baike.baidu.com/view/5112631.htm">Medfield</a>是Intel以x86为架构开发的SoC手机芯片.</dd>
		<dt class="omit">{此处被省略的都是非标准的串口设备,按实际情况选择即可}</dt>
	</dl></dd>
	<dt>TTY driver to output user messages via printk<br>CONFIG_TTY_PRINTK</dt><dd>通过"/dev/ttyprintk"设备使用printk发送用户消息.用于在内核中嵌入用户消息.不确定的选"N".</dd>
	<dt>Parallel printer support<br>CONFIG_PRINTER</dt><dd>并口打印机</dd>
	<dt>Support for user-space parallel port device drivers<br>CONFIG_PPDEV</dt><dd>用户空间的原始并口设备(/dev/parportN)支持,这样用户空间的程序就可以用原始模式直接访问并口(相当于并口版本的CONFIG_CHR_DEV_SG).并口打印机/CD-ROM/硬盘都不依赖于此项,所以大部分人可以关闭该选项.</dd>
	<dt>Xen Hypervisor Console support<br>CONFIG_HVC_XEN</dt><dd>XEN虚拟控制台设备驱动</dd>
	<dd><dl>
		<dt>Xen Hypervisor Multiple Consoles support<br>CONFIG_HVC_XEN_FRONTEND</dt><dd>如果你需要多个虚拟控制台,可以选"Y".</dd>
	</dl></dd>
	<dt>Virtio console<br>CONFIG_VIRTIO_CONSOLE</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>虚拟控制台设备驱动.此外,该驱动还可以作为普通的串口设备(/dev/vportNpX),用于客户机和宿主机之间的通信.仅可用在基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的半虚拟化客户机中(一般是<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>).</dd>
	<dt>IPMI top-level message handler<br>CONFIG_IPMI_HANDLER</dt><dd><a href="http://blog.csdn.net/yuxiaohui78/article/details/7585280">智能平台管理接口</a>(<a href="http://baike.baidu.com/view/1595174.htm">Intelligent Platform Management Interface</a>)是标准的传感器(温度,电压,风扇,电源,机箱入侵)管理规范.IPMI的核心是专用的基板管理控制器(BMC)硬件,BMC并不依赖于服务器的CPU/BIOS/OS,是一个独立运行的管理子系统,只要有BMC与IPMI固件便可工作.BMC通常是一个安装在服务器主板上的独立的板卡(也有少数服务器主板内置).IPMI良好的独立特性便克服了以往基于操作系统的管理方式所受的限制,例如操作系统不响应或未加载的情况下,仍然可以进行开关机等操作.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/IPMI.txt">Documentation/IPMI.txt</a>"文档.此项技术主要用于服务器领域,个人PC和笔记本上是没有的.</dd>
	<dd><dl>
		<dt>Generate a panic event to all BMCs on a panic<br>CONFIG_IPMI_PANIC_EVENT</dt><dd>当内核panic(发生紧急情况)时,IPMI消息处理器将会向每一个已注册的底板管理控制器(BMC)接口生成一个描述该panic的IPMI事件,这些事件可以引发日志记录/报警/重启/关机等动作.</dd>
		<dd><dl>
			<dt>Generate OEM events containing the panic string<br>CONFIG_IPMI_PANIC_STRING</dt><dd>当发生紧急情况(panic)时,IPMI消息处理器将会产生OEM类型(f0)的事件</dd>
		</dl></dd>
		<dt>Device interface for IPMI<br>CONFIG_IPMI_DEVICE_INTERFACE</dt><dd>为IPMI消息处理器提供一个IOCTL接口以便用户空间进程也可以使用IPMI,目前支持 poll() 和 select()</dd>
		<dt>IPMI System Interface handler<br>CONFIG_IPMI_SI</dt><dd>向系统提供接口(KCS,SMIC),建议选"Y".</dd>
		<dd><dl>
			<dt>Probe for all possible IPMI system interfaces by default<br>CONFIG_IPMI_SI_PROBE_DEFAULTS</dt><dd>较新的硬件通常使用ACPI或DMI机制导出IPMI接口,但是老旧的硬件并不这么做,所以驱动程序必须直接探测硬件,这会导致启动延迟.选"N"表示禁止直接探测.选"Y"表示强制直接探测(相当于使用"ipmi_si_intf.trydefaults=1"内核引导选项).</dd>
		</dl></dd>
		<dt>IPMI SMBus handler (SSIF)<br>CONFIG_IPMI_SSIF</dt><dd>使用I2C总线上的SMBus接口访问BMC(而不是标准接口).建议选"N".</dd>
		<dt>IPMI Watchdog Timer<br>CONFIG_IPMI_WATCHDOG</dt><dd>启用IPMI Watchdog定时器.如果硬件有这种功能,推荐选"Y".</dd>
		<dt>IPMI Poweroff<br>CONFIG_IPMI_POWEROFF</dt><dd>允许通过IPMI消息处理器关闭机器</dd>
	</dl></dd>
	<dt>Hardware Random Number Generator Core support<br>CONFIG_HW_RANDOM</dt><dd>硬件随机数发生器设备(/dev/hw_random)支持.此设备并不会直接向内核的随机数发生器填充(这是"<a href="http://linux.die.net/man/8/rngd">rngd</a>"守护进程的职责).详情参见"<a href="https://www.kernel.org/doc/Documentation/hw_random.txt">Documentation/hw_random.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Timer IOMEM HW Random Number Generator support<br>CONFIG_HW_RANDOM_TIMERIOMEM</dt><dd>Technologic Systems 的TS-7800单板计算机,这是一个嵌入式设备.</dd>
		<dt>Intel HW Random Number Generator support<br>CONFIG_HW_RANDOM_INTEL</dt><dd>Intel基于i8xx芯片组(这是2005年以前的老产品了)的硬件随机数发生器</dd>
		<dt>AMD HW Random Number Generator support<br>CONFIG_HW_RANDOM_AMD</dt><dd>AMD基于76x芯片组的硬件随机数发生器</dd>
		<dt>Atmel Random Number Generator support<br>CONFIG_HW_RANDOM_ATMEL</dt><dd>Atmel AT91 硬件随机数发生器</dd>
		<dt>VIA HW Random Number Generator support<br>CONFIG_HW_RANDOM_VIA</dt><dd>VIA芯片组的硬件随机数发生器</dd>
		<dt>VirtIO Random Number Generator support<br>CONFIG_HW_RANDOM_VIRTIO</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>虚拟的硬件随机数发生器.仅可用在基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的半虚拟化客户机中(一般是<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>).</dd>
	</dl></dd>
	<dt>EXYNOS HW random number generator support<br>CONFIG_HW_RANDOM_EXYNOS</dt><dd>基于<a href="http://baike.baidu.com/view/5821967.htm">EXYNOS</a>的SOC嵌入式系统上的硬件随机数发生器</dd>
	<dt>TPM HW Random Number Generator support<br>CONFIG_HW_RANDOM_TPM</dt><dd><a href="http://baike.baidu.com/view/1130324.htm">可信赖平台模块</a>(<a href="http://baike.baidu.com/view/687208.htm">Trusted Platform Module</a>)提供的硬件随机数发生器</dd>
	<dt>/dev/nvram support<br>CONFIG_NVRAM</dt><dd>直接存取主板上"CMOS RAM"的接口,太危险!建议选"N".</dd>
	<dt>Siemens R3964 line discipline<br>CONFIG_R3964</dt><dd>与使用西门子R3964协议的设备同步通信,除非你有一些诸如PLC之类的特殊设备,否则别选</dd>
	<dt>Applicom intelligent fieldbus card support<br>CONFIG_APPLICOM</dt><dd>Applicom international公司生产的用于现场总线(fieldbus)的连接卡.不确定的选"N".</dd>
	<dt>PCMCIA character devices</dt><dd>PCMCIA接口的字符设备</dd>
	<dt>ACP Modem (Mwave) support<br>CONFIG_MWAVE</dt><dd>IBM Thinkpad上的一种软猫,古董产品</dd>
	<dt>RAW driver (/dev/raw/rawN)<br>CONFIG_RAW_DRIVER</dt><dd><a href="http://czmmiao.iteye.com/blog/1587170">裸设备</a>的含义是将一个原始块设备(可以是一整块磁盘,也可以是一个分区)当做一个线性的字节流来访问.它是一种没有经过格式化,不经过操作系统缓存,也不能通过文件系统来访问的特殊字符设备.与FreeBSD不同,Linux反对使用裸设备,且被列入了废除计划(建议的做法是使用"O_DIRECT"标志打开对应的块设备文件,例如"/dev/hda1").不确定的选"N".</dd>
	<dt>HPET - High Precision Event Timer<br>CONFIG_HPET</dt><dd>高精度事件定时器(<a href="http://en.wikipedia.org/wiki/High_Precision_Event_Timer">HPET Timer</a>),又被称为"Multimedia Timer",是一种取代传统"ACPI Timer"(CONFIG_X86_PM_TIMER)的硬件时钟发生器,提供14.31818MHz固定频率.2007年以后的芯片组一般都支持(有的主板还需要在BIOS里面明确开启HPET支持),建议开启.</dd>
	<dd><dl>
		<dt>Allow mmap of HPET<br>CONFIG_HPET_MMAP</dt><dd>允许对HPET寄存器进行映射以提高访问速度.但是某些包含HPET硬件寄存器的页中同时还含有其他不该暴露给用户的信息,在此种情况下,需要选"N".</dd>
		<dd><dl>
			<dt>Enable HPET MMAP access by default<br>CONFIG_HPET_MMAP_DEFAULT</dt><dd>默认开启HPET寄存器映射</dd>
		</dl></dd>
	</dl></dd>
	<dt>Hangcheck timer<br>CONFIG_HANGCHECK_TIMER</dt><dd>宕机检测定时器周期性地检查系统任务调度程序以确定系统的运行状况,如果超过阈值,计算机将重新启动.不确定的选"N".</dd>
	<dt>TPM Hardware Support<br>CONFIG_TCG_TPM</dt><dd>基于硬件的<a href="http://baike.baidu.com/view/1130324.htm">可信赖平台模块</a>(<a href="http://baike.baidu.com/view/687208.htm">Trusted Platform Module</a>),它实际上是一个含有密码运算部件和存储部件的小芯片上的系统,由CPU,存储器,I/O,密码运算器,随机数产生器和嵌入式操作系统等部件组成.使用此功能需要<a href="http://sourceforge.net/projects/trousers/">TrouSerS</a>工具的帮助.</dd>
	<dd><dl>
		<dt>TPM Interface Specification 1.2 Interface<br>CONFIG_TCG_TIS</dt><dd>TCG TIS 1.2 TPM 规范支持</dd>
		<dt>TPM Interface Specification 1.2 Interface (I2C - Infineon)<br>CONFIG_TCG_TIS_I2C_INFINEON</dt><dd>仅需要对Infineon的TPM设备选"Y".</dd>
		<dt>National Semiconductor TPM Interface<br>CONFIG_TCG_NSC</dt><dd>仅需要对National的TPM设备选"Y".</dd>
		<dt>Atmel TPM Interface<br>CONFIG_TCG_ATMEL</dt><dd>仅需要对Atmel的TPM设备选"Y".</dd>
		<dt>Infineon Technologies TPM Interface<br>CONFIG_TCG_INFINEON</dt><dd>仅需要对Infineon的TPM设备(SLD 9630 TT 1.1 或 SLB 9635 TT 1.2)选"Y".此驱动支持的<a href="http://www.trust.rub.de/projects/linux-device-driver-infineon-tpm/">硬件列表</a>.</dd>
		<dt>STMicroelectronics ST33 I2C TPM<br>CONFIG_TCG_ST33_I2C</dt><dd><a href="http://www.st.com/web/cn/home.html">意法半导体</a>(STMicroelectronics)出品的I2C总线的TPM安全芯片.</dd>
	</dl></dd>
	<dt>Telecom clock driver for ATCA SBC<br>CONFIG_TELCLOCK</dt><dd>没见过这种硬件,选"N".</dd>
	<dt>Xillybus generic FPGA interface<br>CONFIG_XILLYBUS</dt><dd><a href="http://www.xillybus.com/">Xillybus</a>是一个通用的<a href="http://baike.baidu.com/view/51371.htm">FPGA</a>接口,仅用于嵌入式设备.</dd>
</dl></dd>


<dt>I2C support<br>CONFIG_I2C</dt><dd><a href="http://blog.sina.com.cn/s/blog_697e8abb0100m5mf.html">I2C与SMBus</a>支持.<a href="http://blog.csdn.net/apple_guet/article/details/21379425">I2C</a>(读着"I-squared-C")是用于<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E6%9C%BA">单片机</a>(又称"微控制器")的低速串行总线协议,它为<a href="http://zhidao.baidu.com/question/221932968.html">微控制器</a>(Microcontroller)与各种不同的低速设备通信提供了一种廉价的总线(因为只需要使用两个引脚,称为"2线"),因此广泛的应用于嵌入式环境.<a href="http://baike.baidu.com/view/1835675.htm">SMBus</a>(System Management Bus)差不多相当于是I2C的子集,最初的目的是为了管理智能电池,现在常用于硬件监控(电压/风扇转速/温度/电池等)以及内存模块的配置(使用I2C EEPROM),因此所有PC主板都依赖于SMBus协议.系统硬件监控工具<a href="http://www.lm-sensors.org/">lm_sensors</a>和<a href="http://www.lm-sensors.org/wiki/I2CTools">i2c-tools</a>依赖于此模块,硬件传感器和"Video For Linux"也需要该模块的支持.详情参见"<a href="https://www.kernel.org/doc/Documentation/i2c/summary">Documentation/i2c/summary</a>"文档及整个"i2c"文件夹.不确定的选"Y".</dd>
<dd><dl>
	<dt>ACPI I2C Operation region support<br>CONFIG_ACPI_I2C_OPREGION</dt><dd>3.17版内核新增功能,允许BIOS中的代码通过I2C主机控制器驱动访问I2C slave设备(例如智能电池).</dd>
	<dt>Enable compatibility bits for old user-space<br>CONFIG_I2C_COMPAT</dt><dd>为了与 lm-sensors 3.1.2 之前的版本兼容而设置.某些2011年之前版本的i2c相关程序也需要此兼容性.</dd>
	<dt>I2C device interface<br>CONFIG_I2C_CHARDEV</dt><dd>I2C设备通常都是由内核控制的,但此选项可以向用户空间提供I2C设备接口,以允许用户空间的程序通过/dev/i2c-*字符设备文件使用I2C总线."<a href="http://dl.lm-sensors.org/lm-sensors/files/sensors-detect">sensors-detect</a>"工具依赖于此功能.详情参见"<a href="https://www.kernel.org/doc/Documentation/i2c/dev-interface">Documentation/i2c/dev-interface</a>"文档.建议选"M".</dd>
	<dt>I2C bus multiplexing support<br>CONFIG_I2C_MUX</dt><dd>多路复用I2C总线支持.不确定的选"N".</dd>
	<dd><dl>
		<dt>Multiplexer I2C Chip support</dt><dd>I2C多路复用芯片,其下的子项按实际情况选择就OK了</dd>
	</dl></dd>
	<dt>Autoselect pertinent helper modules<br>CONFIG_I2C_HELPER_AUTO</dt><dd>有一些I2C驱动程序需要"I2C algorithm"的帮助才能工作.而"I2C算法"本质上是I2C接口的纯软件抽象.开启此项后,如有需要,则会自动选上这些算法,而无需你再手动选择.推荐选"Y".仅在你想使用额外的算法时,才选"N".</dd>
	<dd><dl>
		<dt>SMBus-specific protocols<br>CONFIG_I2C_SMBUS</dt><dd>SMBus特有的扩展支持.目前唯一实际支持的扩展是SMBus报警协议.建议选"Y".</dd>
	</dl></dd>
	<dt>I2C Algorithms</dt><dd>I2C算法,子项可以全不选,若有其他部分依赖其子项时,会自动选上</dd>
	<dt>I2C Hardware Bus support</dt><dd>I2C硬件支持</dd>
	<dd><dl>
		<dt>*** PC SMBus host controller drivers ***</dt><dd>这部分按照主板芯片组的实际情况选择就OK了.[提示]可用"<a href="http://dl.lm-sensors.org/lm-sensors/files/sensors-detect">sensors-detect</a>"工具帮助检测</dd>
		<dt>SMBus Control Method Interface<br>CONFIG_I2C_SCMI</dt><dd><a href="http://wenku.baidu.com/view/f3e3550a763231126edb112a.html">SMBus控制方法接口</a>(Control Method Interface)是SMBus的ACPI接口.用于在ACPI环境中使用SMBus设备.不确定的选"M"(i2c-scmi).</dd>
		<dt class="omit">{其余被省略的都是用于嵌入式系统或者额外的I2C/SMBus扩展卡,按实际情况选择即可}</dt>
	</dl></dd>
	<dt>I2C/SMBus Test Stub<br>CONFIG_I2C_STUB</dt><dd>用于帮助开发SMBus client驱动(特别是某些传感器芯片).详情参见"<a href="https://www.kernel.org/doc/Documentation/i2c/i2c-stub">Documentation/i2c/i2c-stub</a>"文档.不确定的选"N".</dd>
	<dt>I2C slave support<br>CONFIG_I2C_SLAVE</dt><dd><a href="http://www.zybang.com/question/55e97b751975a03c9481271ee78ecff8.html">I2C slave模式</a>支持.不确定的选"N".</dd>
	<dt>I2C Core debugging messages<br>CONFIG_I2C_DEBUG_CORE</dt><dd>向系统日志中传递大量的I2C Core调试信息.仅用于调试I2C设备故障</dd>
	<dt>I2C Algorithm debugging messages<br>CONFIG_I2C_DEBUG_ALGO</dt><dd>向系统日志中传递大量的I2C Algorithm调试信息.仅用于调试I2C设备故障</dd>
	<dt>I2C Bus debugging messages<br>CONFIG_I2C_DEBUG_BUS</dt><dd>向系统日志中传递大量的I2C Bus调试信息.仅用于调试I2C设备故障</dd>
</dl></dd>


<dt>SPI support<br>CONFIG_SPI</dt><dd>串行外设接口(Serial Peripheral Interface)是一种标准的四线同步双向串行总线.<a href="http://wenku.baidu.com/view/99164c1dfad6195f312ba6e4.html">SPI类似于I2C</a>,但比I2C的"2线"稍微复杂一些,SPI需要4个引脚("4线"),不但传输速率比I2C更高,还能实现全双工通信.大多数SPI设备不支持动态设备检测,有些甚至是只读或者只写的.SPI常用于微控制器(Microcontroller)与外围设备(RTC,传感器,EEPROM,FLASH,解/编码器,模数转换器,数字信号处理器)之间的通信,MMC和SD卡也可以通过SPI协议访问,而MMC接口的DataFlash卡则必须通过SPI才能访问.仅用于嵌入式环境,PC平台上没有这样的设备.</dd>


<dt>SPMI support<br>CONFIG_SPMI</dt><dd>系统电源管理接口(SPMI, System Power Management Interface)是一种连接PMIC(Power Management Integrated Circuits)的双线串行接口.仅用于嵌入式环境.</dd>


<dt>Qualcomm MSM SSBI bus support<br>CONFIG_SSBI</dt><dd><a href="http://www.qualcomm.cn/snapdragon/processors">高通(Qualcomm)骁龙</a>系列智能手机处理器内嵌的单线串行总线接口(Single-wire Serial Bus Interface)</dd>


<dt>HSI support<br>CONFIG_HSI</dt><dd>高速同步串行接口(<a href="http://www.mipi.org/specifications/high-speed-synchronous-serial-interface-hsi">High speed synchronous Serial Interface</a>)是移动产业处理器接口(<a href="http://zh.wikipedia.org/wiki/MIPI">MIPI</a>)联盟的高速同步接口工作组发布的一项技术规范.MIPI(Mobile Industry Processor Interface)是2003年由ARM,Nokia,ST,TI等公司成立的一个联盟,目的是把手机内部的接口(如摄像头,显示屏接口,射频/基带接口等)标准化,从而减少手机设计的复杂程度和增加设计灵活性.MIPI联盟下面有不同的工作组,分别定义了一系列的手机内部接口标准,比如摄像头接口CSI,显示接口DSI,射频接口DigRF,麦克风/扬声器接口SLIMbus等.统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组,更改设计和功能时更加快捷方便.目前,MIPI联盟的董事成员包括英特尔,摩托罗拉,诺基亚,三星,意法半导体,德州仪器.</dd>


<dt>PPS support<br>CONFIG_PPS</dt><dd>秒脉冲(Pulse Per Second)驱动用来控制电流脉冲速率,可用于计时.PPS的精度可以到纳秒级,而且没有累积误差.这通常是GPS天线的一项功能,用于获取GPS卫星的授时.</dd>


<dt>PTP clock support<br>CONFIG_PTP_1588_CLOCK</dt><dd><a href="http://wenku.baidu.com/view/004716040740be1e650e9a49">精密时间协议</a>(<a href="http://en.wikipedia.org/wiki/Precision_Time_Protocol">Precision Time Protocol</a>)是<a href="http://baike.baidu.com/view/1885838.htm">IEEE 1588</a>定义的一种基于以太网的高精度时间同步协议.PTP采用硬件与软件结合设计,可以提供比纯软件方式的NTP(网络时间协议)高的多的精度(微秒级).与GPS授时相比,在提供和GPS相同的精度情况下,PTP不需要为每个设备安装GPS那样昂贵的组件,只需要一个高精度的本地时钟和提供高精度时钟戳的部件,成本较低.一般的PC和服务器上没有PTP硬件.</dd>


<dt>Pin controllers</dt><dd>Pin控制器.其下的各选项请根据实际硬件状况选择(皆为低功耗或嵌入式平台).</dd>


<dt>GPIO Support<br>CONFIG_GPIOLIB</dt><dd>每个芯片都会有至少一个引脚(PIN),像CPU或者芯片组这种复杂的芯片,其引脚会有成白上千个,这些PIN就是芯片与外部沟通的渠道,每个PIN都会有它特定的功能.<a href="http://baike.baidu.com/view/980829.htm">GPIO</a>(<a href="http://en.wikipedia.org/wiki/General-purpose_input/output">General Purpose I/O</a>)就是芯片上的一种通用功能的引脚,其功能可由使用者通过编程的方式自定义(所谓"可编程引脚"),比如使用两条PIN就可以组成I2C,使用4条PIN就可以组成SPI.嵌入式系统经常需要控制结构简单但数量众多的外部设备(比如LED的亮与灭),使用传统的串口或者并口就太"大炮打蚊子",而GPIO则非常适合用于控制此类数量众多的简单设备.GPIO在嵌入式设备中使用广泛,但PC平台的芯片组南桥大多也集成有<a href="http://blog.csdn.net/gjsisi/article/details/7712538">GPIO</a>引脚(但只有BIOS才知道如何使用他们),以支持某些特殊的定制硬件.详情参见"<a href="https://www.kernel.org/doc/Documentation/gpio/gpio.txt">Documentation/gpio/gpio.txt</a>"文档.不确定的选"N".</dd>
<dd><dl>
	<dt>Debug GPIO calls<br>CONFIG_DEBUG_GPIO</dt><dd>仅供调试使用</dd>
	<dt>/sys/class/gpio/... (sysfs interface)<br>CONFIG_GPIO_SYSFS</dt><dd>为GPIO设备添加sysfs接口.主要用于调试和问题排查.不确定的选"N".</dd>
	<dt>Generic memory-mapped GPIO controller support (MMIO platform device)<br>CONFIG_GPIO_GENERIC_PLATFORM</dt><dd>这是最简单的GPIO控制器驱动(<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform总线</a>驱动),仅支持单独一个"data"寄存器,用于读/写GPIO的状态.不确定的选"Y".</dd>
	<dt class="omit">{这里被省略的部分,按主板上实际集成的芯片选择即可}</dt>
</dl></dd>


<dt>Dallas's 1-wire support<br>CONFIG_W1</dt><dd>Dallas公司发明的单总线是比I2C更简单的总线,仅使用一个引脚(1-wire),使用Master-Slave结构,用于连接慢速的单引脚设备,比如<a href="http://baike.baidu.com/view/2521664.htm">iButton</a>和热传感器.主要用于嵌入式系统.</dd>


<dt>Power supply class support<br>CONFIG_POWER_SUPPLY</dt><dd>允许用户空间程序通过sysfs/uevent接口对电源(电池,交流电,USB)进行监控.主要用于笔记本与嵌入式设备.</dd>
<dd><dl>
	<dt>Power supply debug<br>CONFIG_POWER_SUPPLY_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>Generic PDA/phone power driver<br>CONFIG_PDA_POWER</dt><dd>通用的PDA/phone电源切换驱动.用于在内部电池和外部电源(AC/USB)之间进行切换.</dd>
	<dt>Generic battery support using IIO<br>CONFIG_GENERIC_ADC_BATTERY</dt><dd>为使用IIO总线(CONFIG_IIO)的电池提供的通用驱动</dd>
	<dt>Test power driver<br>CONFIG_TEST_POWER</dt><dd>仅供测试使用</dd>
	<dt>SBS Compliant gas gauge<br>CONFIG_BATTERY_SBS</dt><dd>与<a href="http://baike.baidu.com/view/1938623.htm">智能电池系统</a>(<a href="http://www.chinacpec.com/news/display.php?aid=88">Smart Battery System</a>)规范兼容的气压计(集成在电池组中)支持.</dd>
	<dt>GPIO charger<br>CONFIG_CHARGER_GPIO</dt><dd>支持充电器通过GPIO引脚报告其在线状态.</dd>
	<dt>Board level reset or power off<br>CONFIG_POWER_RESET</dt><dd>允许通过操作板载的主电源,关闭或重启整个系统.仅用于嵌入式系统.</dd>
	<dt class="omit">{这里被省略的部分,按实际电池控制芯片选择即可}</dt>
</dl></dd>


<dt>Adaptive Voltage Scaling class support<br>CONFIG_POWER_AVS</dt><dd>自适应电压调节(Adaptive Voltage Scaling)技术能够动态的对设备工作电压进行精细的调整,拥有比<a href="http://baike.baidu.com/view/7861420.htm">DVFS</a>更佳的电力利用效率,是一种降低功耗与优化性能并举的电源与性能管理技术.AVS在OMAP设备上也被称为"<a href="http://yanqin.spaces.eepw.com.cn/articles/article/item/50555">SmartReflex</a>".目前仅用于嵌入式领域.</dd>


<dt>Hardware Monitoring support<br>CONFIG_HWMON</dt><dd>当前主板大多都有一个监控硬件温度/电压/风扇转速等状况的设备,请按照主板实际使用的芯片选择相应的子项.如果你不知道究竟需要使用哪个驱动,可以使用<a href="http://www.coreboot.org/Superiotool">Superiotool</a>和<a href="http://www.lm-sensors.org/wiki/man/sensors-detect">sensors-detect</a>工具进行检测.另外,某些子项可能还需要CONFIG_I2C的支持.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/hwmon/userspace-tools">Documentation/hwmon/userspace-tools</a>"文档.</dd>
<dd><dl>
	<dt>Hardware Monitoring Chip debugging messages<br>CONFIG_HWMON_DEBUG_CHIP</dt><dd>在系统日志中输出大量的I2C调试信息,仅用于故障调试</dd>
	<dt class="omit">{被省略的部分,按实际的硬件监控芯片选择即可}</dt>
	<dt>GPIO fan<br>CONFIG_SENSORS_GPIO_FAN</dt><dd>连接在GPIO引脚上的风扇</dd>
	<dt>PMBus support<br>CONFIG_PMBUS</dt><dd><a href="http://baike.baidu.com/view/2526981.htm">电源管理总线</a>(Power Management Bus)是一种基于SMBus(CONFIG_I2C)的开放标准的数字电源管理协议,可以用于配置/监控/操作电源变换器,目前全球有<a href="http://smiforum.org/members.html">超过40个IC厂商</a>提供<a href="http://pmbus.org/products.html">满足PMBus标准的产品</a>.最新的<a href="http://pmbus.org/docs/20130815PMBus+(tm)_PLUS_Announce.pdf">PMBus+ 1.3</a>标准增加AVS(CONFIG_POWER_AVS)支持,可以动态控制设备的工作电压.根据你的实际硬件状况选择子项.</dd>
	<dt>ACPI 4.0 power meter<br>CONFIG_SENSORS_ACPI_POWER</dt><dd>将<a href="http://www.acpi.info/">ACPI</a> 4.0(2009年6月发布)中定义的瓦特表(用于测量功耗)当做硬件监控设备导出到用户空间.需要固件支持ACPI 4.0规范,并且有一个瓦特表.不确定的选"N".</dd>
	<dt>ASUS ATK0110<br>CONFIG_SENSORS_ATK0110</dt><dd>许多华硕主板都有这种ACPI硬件监控接口.此驱动可以通过主板固件读取风扇/电压/温度信息.</dd>
</dl></dd>


<dt>Generic Thermal sysfs driver<br>CONFIG_THERMAL</dt><dd>为ACPI规范中定义的"thermal"(发热控制)提供一个通用的sysfs接口,以方便与诸如温度传感器和风扇之类的设备通信.由于目前所有PC和服务器都已支持ACPI,并且发热控制也越来越重要,所以建议选"Y".详情参见"<a href="https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt">Documentation/thermal/sysfs-api.txt</a>"文档.</dd>
<dd><dl>
	<dt>Expose thermal sensors as hwmon device<br>CONFIG_THERMAL_HWMON</dt><dd>将温度传感器同时注册为一个硬件监控设备,从而让温度传感器同样在sysfs中拥有hwmon接口.</dd>
	<dt>Enable writable trip points<br>CONFIG_THERMAL_WRITABLE_TRIPS</dt><dd>允许用户空间程序更改温度报警阀值(trip temperature).</dd>
	<dt>Default Thermal governor</dt><dd>选择默认的热调节器,建议选"step_wise".</dd>
	<dt>Fair-share thermal governor<br>CONFIG_THERMAL_GOV_FAIR_SHARE</dt><dd>此调节器根据设备对所属区域的"贡献"(contribution)进行调节.</dd>
	<dt>Step_wise thermal governor<br>CONFIG_THERMAL_GOV_STEP_WISE</dt><dd>此调节器以线性方式进行调节,也就是每次调节都只在紧邻的两档之间进行切换.</dd>
	<dt>Bang Bang thermal governor<br>CONFIG_THERMAL_GOV_BANG_BANG</dt><dd>此调节器仅能让散热风扇处于开/关两种状态(根据温度阀值)而不能调节风扇的速度.某些Acer笔记本风扇驱动(acerhdf)依赖于此调节器.不能将此调节器设为默认调节器.</dd>
	<dt>User_space thermal governor<br>CONFIG_THERMAL_GOV_USER_SPACE</dt><dd>此调节器让用户空间程序去决定如何调节</dd>
	<dt>Power allocator thermal governor<br>CONFIG_THERMAL_GOV_POWER_ALLOCATOR</dt><dd>此调节器可对特定的设备动态分配和限制能量的使用.不确定的选"N".</dd>
	<dt>generic cpu cooling support<br>CONFIG_CPU_THERMAL</dt><dd>通用的CPU降温机制(通过降低频率来实现,而不是通过ACPI接口).显然通过ACPI接口是更好的机制,所以建议选"N".</dd>
	<dt>Thermal emulation mode support<br>CONFIG_THERMAL_EMULATION</dt><dd>"Thermal"模拟.仅供调试使用,切勿用于生产系统!!</dd>
	<dt>Intel PowerClamp idle injection driver<br>CONFIG_INTEL_POWERCLAMP</dt><dd>Intel <a href="http://lwn.net/Articles/528124/">PowerClamp</a> 驱动通过利用<a href="http://zh.wikipedia.org/wiki/Intel_Nehalem">Nehalem</a>之后的CPU支持的"package-level C-state"特性,强制为在线的CPU注入"idle"指令(通过"/sys/class/thermal/"接口设定"idle"百分比),以确保CPU的功耗不会超过特定的阈值(发热量也就不会超过特定的阈值).这样刻意的降低系统性能峰值还有一个好处,那就是相对于传统的动态频率调节技术而言,能够达到更高的每瓦特性能.详见<a href="https://www.kernel.org/doc/Documentation/thermal/intel_powerclamp.txt">Documentation/thermal/intel_powerclamp.txt</a>文档.如果你对节能和限制发热量特别在意,同时又不在乎系统峰值性能的降低,可以选"Y".</dd>
	<dt>X86 package temperature thermal driver<br>CONFIG_X86_PKG_TEMP_THERMAL</dt><dd>所谓"<a href="https://forum-sc.msi.com/index.php?topic=247.0">CPU温度</a>"实际上是个多重概念:(1)Socket温度,是指CPU插座里的测温二极管探测到的温度,相当于CPU外表面的温度;(2)Package温度,是封装在CPU内部的测温二极管探测到的温度,是真正的CPU内部的温度,此温度永远比Socket温度高;(3)Core温度,是每个CPU核心内嵌的温度传感器检测到的温度,有多少个核心就有多少个Core温度;此选项提供了检测Package温度的驱动.并将此温度用于监控CPU温度(对于拥有多颗物理CPU的服务器来说每颗物理CPU对应一个Package温度).同时,选中此项后,温度报警阀值也变为可以设置两个严重级别不同的值.建议选"Y".</dd>
	<dt>Intel SoCs DTS thermal driver<br>CONFIG_INTEL_SOC_DTS_THERMAL</dt><dd>专用于Intel SoC(BayTrail等)平台的CPU内嵌温度传感器驱动.</dd>
	<dt>ACPI INT340X thermal drivers<br>CONFIG_INT340X_THERMAL</dt><dd>除了CPU/SOC内置的温度传感器之外,新式笔记本或平板电脑还经常包含探测整机不同位置温度的传感器,这些温度传感器以INT3400 ACPI设备作为主设备(master),并以INT3401~INT340B ACPI设备为从设备(slave),此选项提供了对此类温度传感器的驱动支持.</dd>
	<dt>Intel PCH Thermal Reporting Driver<br>CONFIG_INTEL_PCH_THERMAL</dt><dd>专用于Intel PCH芯片组内置温度传感器的驱动.</dd>
</dl></dd>


<dt>Watchdog Timer Support<br>CONFIG_WATCHDOG</dt><dd>选"Y"并选中下面相应的驱动之后,再创建一个主/次设备号为10/130的字符设备"/dev/watchdog",即可拥有一只<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-watchdog/">看门狗</a>.其工作原理是:当/dev/watchdog设备被打开后,如果<a href="http://ibiblio.org/pub/Linux/system/daemons/watchdog/">喂狗守护进程</a>超过60秒没有喂狗(写入"/dev/watchdog"),那么底层的看门狗硬件将会触发整个机器硬重启(相当于按下面板上的"RESET"按钮).这对于提高服务器的在线率来说意义重大.详情参见"<a href="https://www.kernel.org/doc/Documentation/watchdog/watchdog-api.txt">Documentation/watchdog/watchdog-api.txt</a>"文档.</dd>
<dd><dl>
	<dt>WatchDog Timer Driver Core<br>CONFIG_WATCHDOG_CORE</dt><dd>看门狗核心驱动,它为所有特定于具体硬件的看门狗驱动提供了统一的框架和"/dev/watchdog"接口(未来还会包括sysfs接口).使用看门狗的必选.</dd>
	<dt>Disable watchdog shutdown on close<br>CONFIG_WATCHDOG_NOWAYOUT</dt><dd>默认情况下(此项="N")如果喂狗进程关闭"/dev/watchdog"文件,那么表示停止看门狗功能.开启此项后,看门狗一旦启用就不能被停止(即使关闭"/dev/watchdog"文件也不会停止).</dd>
	<dt>Software watchdog<br>CONFIG_SOFT_WATCHDOG</dt><dd>内核提供的"软看门狗".使用它不需要有任何硬件的支持,但可靠性不如硬件看门狗,仅能应对喂狗进程的崩溃,不能应对内核本身的崩溃.在某些情况下(例如Oracle数据库),CONFIG_HANGCHECK_TIMER是比"软看门狗"更好的选择.</dd>
	<dt class="omit">{此处省略的看门狗硬件请按照实际使用的芯片进行选择}</dt>
</dl></dd>


<dt>Sonics Silicon Backplane support<br>CONFIG_SSB</dt><dd>SSB(Sonics Silicon Backplane)是一种仅在嵌入式环境中使用的总线.</dd>


<dt>Broadcom specific AMBA<br>CONFIG_BCMA</dt><dd>Broadcom特有的<a href="http://blog.163.com/meteora_wzh/blog/static/369626752007102752315710/">AMBA</a>(Advanced Microcontroller Bus Architecture)总线支持.仅用于嵌入式环境</dd>


<dt>Multifunction device drivers</dt><dd>MFD(多功能设备)的含义是"在单个芯片上集成多个功能(GPIO,触摸屏,键盘,电流调节,电源管理...)".此种芯片通常通过一个或多个IRQ线和低速数据总线(SPI/I2C/GPIO)与主CPU进行通信.对于主系统来说,它们通过数据总线显示为一个单独的MFD设备.但透过MFD框架,又可以拥有多个相互独立的子设备(子功能).</dd>
<dd><dl>
	<dt>Intel ICH LPC<br>CONFIG_LPC_ICH</dt><dd><a href="http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC</a>(Low Pin Count)总线是Intel于1998年发布的一个旨在取代传统ISA总线的接口规范,用于连接南桥和<a href="http://zh.wikipedia.org/wiki/Super_I/O">Super I/O</a>芯片(用于连接低速外设:串口,并口,PS/2键鼠,软盘控制器,TPM(可信平台模块),温度传感器,风扇速度监测器)以及Flash芯片(BIOS).以往南桥必须保留ISA总线,以连接老旧的ISA插槽和<a href="http://www.esupport.com/techsupport/award/superio.php">Super I/O芯片</a>(可以使用<a href="http://www.coreboot.org/Superiotool">Superiotool</a>和<a href="http://www.lm-sensors.org/wiki/man/sensors-detect">sensors-detect</a>工具检测)以及Flash芯片.但是ISA需要占用大量针脚,主板的线路设计也比较复杂.随着ISA插槽的消失,LPC就顺理成章的出现了,它与ISA在软件层面是类似的,同时LPC工作速率由PCI总线速率同步驱动,但是引脚数大大降低,以方便在拥挤的现代主板上布局,这也是取名"Low Pin Count"的原因.此选项支持几乎所有Intel芯片组的LPC总线,以方便其他驱动控制MFD(目前仅有GPIO和watchdog).具体<a href="https://cateee.net/lkddb/web-lkddb/LPC_ICH.html">支持的芯片</a>可以查看"drivers/mfd/lpc_ich.c"文件.不确定的选"Y".</dd>
	<dt>Intel SCH LPC<br>CONFIG_LPC_SCH</dt><dd>用于 Intel Atom 处理器的 Intel SCH(System Controller Hub) LPC 总线支持.目前仅支持SMBus和GPIO.</dd>
	<dt class="omit">{此处省略的硬件请按照实际使用的芯片进行选择}</dt>
</dl></dd>


<dt>Voltage and Current Regulator Support<br>CONFIG_REGULATOR</dt><dd>通用的电压与电流调节器框架.除了提供通用的电压与电流调节接口外,还能通过sysfs向用户空间提供电压与电流的状态信息.目的在于通过动态调节电压和电流,降低能耗,延长电池寿命.主要用于嵌入式环境.</dd>


<dt>Multimedia support<br>CONFIG_MEDIA_SUPPORT</dt><dd>多媒体设备:摄像头,视频采集,模拟电视,数字电视,机顶盒,收音机,遥控器,数字视频广播(DVB)...内核多媒体子系统由<a href="http://linuxtv.org/">LinuxTV</a>项目负责维护.</dd>
<dd><dl>
	<dt>Cameras/video grabbers support<br>CONFIG_MEDIA_CAMERA_SUPPORT</dt><dd>摄像头,视频采集卡</dd>
	<dt>Analog TV support<br>CONFIG_MEDIA_ANALOG_TV_SUPPORT</dt><dd>模拟电视信号接收器,包括那些既能接收模拟信号又能接收数字信号的电视卡</dd>
	<dt>Digital TV support<br>CONFIG_MEDIA_DIGITAL_TV_SUPPORT</dt><dd>数字电视信号接收器,包括那些既能接收模拟信号又能接收数字信号的电视卡</dd>
	<dt>AM/FM radio receivers/transmitters support<br>CONFIG_MEDIA_RADIO_SUPPORT</dt><dd>AM/FM无线电接收机和发射机,包括那些带有收音机功能的电视卡</dd>
	<dt>Remote Controller support<br>CONFIG_MEDIA_RC_SUPPORT</dt><dd>基于红外线/射频的遥控器,用于控制视频采集卡或者电视卡.大多数电视卡和视频采集卡都需要它的支持,即使这些卡实际并不需要遥控器.</dd>
	<dt>Media Controller API<br>CONFIG_MEDIA_CONTROLLER</dt><dd>此API用于查询多媒体设备内部的拓扑结构,并进行动态配置.主要用于嵌入式环境中的摄像头配置.</dd>
	<dt>V4L2 sub-device userspace API<br>CONFIG_VIDEO_V4L2_SUBDEV_API</dt><dd>此API用于配置视频的格式/尺寸/帧率.主要用于嵌入式环境中的摄像头配置.</dd>
	<dt>Enable advanced debug functionality on V4L2 drivers<br>CONFIG_VIDEO_ADV_DEBUG</dt><dd>开启<a href="http://baike.baidu.com/view/5494174.htm">V4L2</a>驱动程序的高级调试特性,不确定的选"N".</dd>
	<dt>Enable old-style fixed minor ranges on drivers/video devices<br>CONFIG_VIDEO_FIXED_MINOR_RANGES</dt><dd>仅在你使用mknod而不是udev进行设备管理时才需要开启.不确定的选"N".</dd>
	<dt>V4L2 int device (DEPRECATED)<br>CONFIG_VIDEO_V4L2_INT_DEVICE</dt><dd>仅用于旧式的图像传感器驱动(omap24xxcam和tcm825x),反对使用此项.选"N".</dd>
	<dt>DVB Network Support<br>CONFIG_DVB_NET</dt><dd><a href="http://zh.wikipedia.org/wiki/DVB">DVB</a>(<a href="http://baike.baidu.com/view/73510.htm#sub5082257">数字视频广播</a>)是一系列国际公认的数字电视标准.此项提供了DVB网络(DVB标准的一部分)支持,可用于数字机顶盒(Set-Top-Box)的自动固件升级以及通过DVB卡访问互联网.</dd>
	<dt>maximum number of DVB/ATSC adapters<br>CONFIG_DVB_MAX_ADAPTERS</dt><dd>最大允许的<a href="http://www.eefocus.com/pixela/blog/08-03/144874_3fa2b.html">DVB/ATSC</a>电视卡数量.取值范围是[1,255],但经过测试的范围是[4,32].不确定的请保持默认值"8".</dd>
	<dt>Dynamic DVB minor allocation<br>CONFIG_DVB_DYNAMIC_MINORS</dt><dd>为DVB设备节点动态分配次设备号,这样每张DVB卡就可以拥有最多4个同类型的设备(例如demux(分离器)和frontend(前端)).此特性需要udev的支持.</dd>
	<dt>Compile Remote Controller keymap modules<br>CONFIG_RC_MAP</dt><dd>将各种遥控器的keymap表编译进内核.这些表都很小,但是如果你不打算使用遥控器,或者更喜欢使用<a href="http://linuxtv.org/downloads/v4l-utils/">v4l-utils</a>包内的<a href="http://manpages.ubuntu.com/manpages/natty/man1/ir-keytable.1.html">ir-keytable</a>工具从用户空间加载这些表,可以选"N".</dd>
	<dt>Remote controller decoders<br>CONFIG_RC_DECODERS</dt><dd>遥控器解码器.其下的子项是各种不同的遥控通信协议.</dd>
	<dt>Remote Controller devices<br>CONFIG_RC_DEVICES</dt><dd>各种遥控器产品.其下子项按实际的厂商和型号选择即可.</dd>
	<dt>Media USB Adapters<br>CONFIG_MEDIA_USB_SUPPORT</dt><dd>各种USB总线的多媒体设备</dd>
	<dd><dl>
		<dt>USB Video Class (UVC)<br>CONFIG_USB_VIDEO_CLASS</dt><dd><a href="http://zh.wikipedia.org/wiki/USB%E8%A6%96%E9%A0%BB%E9%A1%9E%E5%88%A5">UVC</a>(<a href="http://en.wikipedia.org/wiki/USB_video_device_class">USB Video Class</a>)是一个开放的通用USB视频捕获标准.目前大多数摄像头都是UVC摄像头,也就是俗称的"免驱摄像头".所有符合UVC规格的硬件都可以使用<a href="http://linux-uvc.berlios.de/">通用UVC驱动程序</a>,而无需再使用专用驱动.</dd>
		<dd><dl>
			<dt>UVC input events device support<br>CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV</dt><dd>某些UVC摄像头上会带有按钮(常用于开关LED灯/拍照),此选项可以将此按钮注册为一个输入设备,以用于报告按钮事件.</dd>
		</dl></dd>
		<dt>GSPCA based webcams<br>CONFIG_USB_GSPCA</dt><dd>基于GSPCA框架的摄像头驱动(依赖于CONFIG_VIDEO_V4L2),这是<a href="http://news.mydrivers.com/1/82/82885.htm">一位60岁的法国医生的杰作</a>.该驱动适用于大多数常见的非UVC摄像头.具体支持的芯片列表可以查看"<a href="https://www.kernel.org/doc/Documentation/video4linux/gspca.txt">Documentation/video4linux/gspca.txt</a>"文档.</dd>
		<dt class="omit">{此处省略的非GSPCA摄像头,电视卡,电视棒等其他硬件请按照实际使用的芯片进行选择}</dt>
	</dl></dd>
	<dt>Media PCI Adapters<br>CONFIG_MEDIA_PCI_SUPPORT</dt><dd>各种PCI/PCIe总线的多媒体设备</dd>
	<dt>V4L platform devices<br>CONFIG_V4L_PLATFORM_DRIVERS</dt><dd>特定于平台的V4L(Video For Linux)设备,这些设备不是通过USB/PCI这样的总线连接的.一般用于单片机之类的嵌入式环境.</dd>
	<dd><dl>
		<dt>SoC camera support<br>CONFIG_SOC_CAMERA</dt><dd>所谓"SoC Camera"是指那些不通过PCI或USB总线连接的摄像头(例如通过I2C直接与SoC数据总线连接).此选项为这类摄像头提供了通用的支持.</dd>
		<dd><dl>
			<dt>platform camera support<br>CONFIG_SOC_CAMERA_PLATFORM</dt><dd>仅用于调试目的</dd>
		</dl></dd>
		<dt class="omit">{此处省略的部分请按照实际使用的芯片进行选择}</dt>
	</dl></dd>
	<dt>Memory-to-memory multimedia devices<br>CONFIG_V4L_MEM2MEM_DRIVERS</dt><dd>使用系统内存作为源和目标缓存(Memory-to-memory)的多媒体设备.一般的采集输出驱动仅将系统内存用于源或目标缓存之一.不确定的选"N".</dd>
	<dt>Media test drivers<br>CONFIG_V4L_TEST_DRIVERS</dt><dd>仅用于调试目的.</dd>
	<dt>Siano SMS1xxx based MDTV via SDIO interface<br>CONFIG_SMS_SDIO_DRV</dt><dd>使用<a href="http://bbs.ednchina.com/BLOG_ARTICLE_198217.HTM">SDIO</a>接口的一种移动数字电视(MDTV)卡,基于<a href="http://www.ic72.com/technology/circuit_info_104158.html">Siano SMS1xxx</a>芯片.主要用于嵌入式设备</dd>
	<dt>ISA and parallel port devices<br>CONFIG_MEDIA_PARPORT_SUPPORT</dt><dd>使用ISA或并口的多媒体设备,古董级别的设备</dd>
	<dt>Radio Adapters<br>CONFIG_RADIO_ADAPTERS</dt><dd>AM/FM无线电广播接收设备</dd>
	<dt>FireDTV and FloppyDTV<br>CONFIG_DVB_FIREDTV</dt><dd><a href="http://www.digital-everywhere.com/">Digital Everywhere</a>生产的FireWire(IEEE 1394)接口的DVB电视接收卡</dd>
	<dt>Cypress firmware helper routines<br>CONFIG_CYPRESS_FIRMWARE</dt><dd><a href="http://baike.baidu.com/view/1367502.htm">Cypress</a>(<a href="http://china.cypress.com/">赛普拉斯</a>)多媒体产品的固件加载帮助程序.</dd>
	<dt>Enable Remote Controller support for Siano devices<br>CONFIG_SMS_SIANO_RC</dt><dd><a href="http://www.siano-ms.com/CN/">Siano</a>多媒体设备遥控器</dd>
	<dt>Enable debugfs for smsdvb<br>CONFIG_SMS_SIANO_DEBUGFS</dt><dd>仅供调试使用,当前仅可用于Siano USB设备</dd>
	<dt>Autoselect ancillary drivers (tuners, sensors, i2c, frontends)<br>CONFIG_MEDIA_SUBDRV_AUTOSELECT</dt><dd>为多媒体设备驱动自动选择所有相关的辅助驱动(tuner[调谐器],sensor[传感器],视频编/解码器以及前端),以免去手动选择的麻烦.通常这是个好主意,建议选"Y".但是对于某些嵌入式环境来说,却希望去掉部分有用的辅助驱动以保持内核尽可能短小,这时应该选"N".</dd>
	<dt>I2C module for IR<br>CONFIG_VIDEO_IR_I2C</dt><dd>大多数板子都通过GPIO总线连接红外线芯片,但少数板子却使用I2C总线连接.此项即是对I2C总线连接的红外线芯片提供支持.</dd>
	<dt>Encoders, decoders, sensors and other helper chips</dt><dd>编码器,解码器,传感器,混频器...等辅助芯片</dd>
	<dt>Sensors used on soc_camera driver</dt><dd>用于"SoC Camera"(CONFIG_SOC_CAMERA)的各种传感器</dd>
	<dt>Customize TV tuners</dt><dd>各种专用的电视调谐器</dd>
	<dt>Customise DVB Frontends</dt><dd>各种专用的数字电视前端</dd>
</dl></dd>


<dt>Graphics support</dt><dd>图形设备/显卡支持.对于不需要使用图形界面的服务器环境来说,必须的最小选项集取决于平台(BIOS/UEFI)和引导程序(GRUB/LILO/GRUB4DOS)的设置(全选"N"则屏幕将无任何显示).具体如下:(1)以UEFI方式启动的,一律都必须"CONFIG_FB=y,CONFIG_FB_EFI=y,CONFIG_FRAMEBUFFER_CONSOLE=y"[补充说明:对于3.12或以上版本,则应该是"CONFIG_X86_SYSFB=y,CONFIG_FB=y,CONFIG_FB_SIMPLE=y,FRAMEBUFFER_CONSOLE=y"];(2)以BIOS+GRUB2启动,且在'grub.cfg'中明确将"gfxpayload"变量设置为非'text'值或者内核引导参数中存在'vga=...',那么必须"CONFIG_FB=y,CONFIG_FB_VESA=y,CONFIG_FRAMEBUFFER_CONSOLE=y"[补充说明:对于3.12或以上版本,则应该是"CONFIG_X86_SYSFB=y,CONFIG_FB=y,CONFIG_FB_SIMPLE=y,FRAMEBUFFER_CONSOLE=y"];(3)以BIOS方式启动的其他情况,必须"CONFIG_VGA_CONSOLE=y"</dd>
<dd><dl>
	<dt>/dev/agpgart (AGP Support)<br>CONFIG_AGP</dt><dd><a href="http://en.wikipedia.org/wiki/Graphics_address_remapping_table">GART</a>(<a href="http://blog.csdn.net/zkami/article/details/3576809">图形地址重映射表</a>)可以看做一种被各种显卡(不只是<a href="http://zh.wikipedia.org/wiki/AGP">AGP</a>显卡,还包括<a href="http://zh.wikipedia.org/wiki/PCI_Express">PCI-E</a>显卡与<a href="http://baike.baidu.com/view/9082.htm">集成显卡</a>以及<a href="http://baike.baidu.com/view/4503595.htm">核心显卡</a>)使用的"伪<a href="http://server.zdnet.com.cn/files/all-1836536.htm">IOMMU</a>"(参见CONFIG_GART_IOMMU选项),它将物理地址不连续的系统内存映射成连续的"显存"供GPU使用.当物理显存容量不够时(大多数集成显卡甚至根本没有物理显存),GART允许通过DMA(<a href="http://blog.csdn.net/wzhwho/article/details/5638045">直接内存访问</a>)方式将这部分"显存"用于<a href="http://zh.wikipedia.org/wiki/%E6%9D%90%E8%B4%A8%E8%B4%B4%E5%9B%BE">纹理贴图</a>,<a href="http://www.cnblogs.com/jiahuafu/archive/2011/02/19/1958467.html">Z轴缓冲</a>,<a href="http://baike.baidu.com/view/736358.htm">ALPHA混合</a>,<a href="http://en.wikipedia.org/wiki/Polygon_mesh">多边形网格</a>生成...等各种3D操作.如果没有GART支持,<a href="http://zh.wikipedia.org/zh-cn/OpenGL">OpenGL</a>直接渲染将会变得特别慢.<a href="http://liyanrui.is-programmer.com/2009/2/7/glx-notes.7061.html">GLX</a>与<a href="http://www.linuxgraphics.cn/xwindow/dri_intro.html">DRI</a>(CONFIG_DRM)也依赖于此.简而言之,需要使用图形化界面的人都应该选"Y".不需要图形界面的用户应该选"N".[注意]对于使用304或更老版本的nVidia闭源驱动的用户,如果使用的是<a href="http://us.download.nvidia.com/XFree86/Linux-x86/304.108/README/configuringagp.html">某些老旧的芯片组</a>,那么此处应该选"N".因为在这些特定的芯片组上,闭源驱动自己的agpgart实现(<a href="http://en.wikipedia.org/wiki/NvAGP">NvAGP</a>)是更好的选择.[提示]老版本的AMD/ATI/NVIDIA闭源驱动都曾经有自己的agpgart实现,但在新版本中都已经被移除.而Intel显卡一直使用的都是内核的agpgart实现.</dd>
	<dd><dl>
		<dt>AMD Opteron/Athlon64 on-CPU GART support<br>CONFIG_AGP_AMD64</dt><dd>该项仅适用于如下AMD处理器:(1)<a href="http://zh.wikipedia.org/wiki/AMD_K8">AMD K8</a>微架构CPU[cpu family : 15] (2)<a href="http://en.wikipedia.org/wiki/AMD_10h">AMD K10</a>微架构CPU[cpu family : 16] (3)<a href="http://zh.wikipedia.org/wiki/AMD_Bulldozer">AMD 推土机</a>微架构CPU[cpu family : 21 并且 model: 小于15].[提示]除了前面列出的三种CPU外,其他AMD处理器(例如A4/A6/A8系列APU)并不需要此选项.具体支持的CPU可以查看"arch/x86/kernel/amd_nb.c"文件中的"AMD_NB_GART"常量的使用.</dd>
		<dt>Intel 440LX/BX/GX, I8xx and E7x05 chipset support<br>CONFIG_AGP_INTEL</dt><dd>该项仅适用于:(1)某些<a href="http://en.wikipedia.org/wiki/List_of_Intel_chipsets">Intel芯片组</a>(440LX/BX/GX, 8xx系列, E7205/E7505/E7221, 9xx系列, 所有3/4系列). (2)全部<a href="http://en.wikipedia.org/wiki/Intel_GMA">Intel集成显卡</a>(包括<a href="http://zh.wikipedia.org/wiki/Intel_HD_Graphics">Intel核心显卡</a>).具体支持的芯片组和集显可以查看"drivers/char/agp/intel-*"系列文件.[提示]如果你使用的既不是此处所列的芯片组(例如<a href="http://en.wikipedia.org/wiki/Intel_Xeon_chipsets">Xeon芯片组</a>或者<a href="https://en.wikipedia.org/wiki/List_of_Intel_chipsets#5.2F6.2F7.2F8.2F9_Series_chipsets">5/6/7/8/9系列芯片组</a>)也不是Intel的集成显卡(例如AMD/nVidia独立显卡),那么应该选"N".</dd>
		<dt>SiS chipset support<br>CONFIG_AGP_SIS</dt><dd>该项仅适用于<a href="http://zh.wikipedia.org/wiki/%E7%9F%BD%E7%B5%B1%E7%A7%91%E6%8A%80">SiS</a>芯片组,但不包括上世纪古董级的SiS 5591/5592芯片组.</dd>
		<dt>VIA chipset support<br>CONFIG_AGP_VIA</dt><dd>该项仅适用于<a href="http://zh.wikipedia.org/wiki/%E5%A8%81%E7%9B%9B%E9%9B%BB%E5%AD%90">VIA</a>芯片组.具体支持的芯片组型号可以查看"drivers/char/agp/via-agp.c"中的"via_agp_device_ids"数组.</dd>
	</dl></dd>
	<dt>VGA Arbitration<br>CONFIG_VGA_ARB</dt><dd>图形设备是通过I/O或内存的特定地址范围进行访问的.大多数现代的显卡都允许对这个范围进行重新定位,但是某些基于PCI的"传统"VGA设备仍然使用"硬编码"的地址范围,无法对其进行重新定位.如果系统上有多个这样的"传统"VGA设备,就会造成地址冲突,这时候就需要进行<a href="http://www.x.org/wiki/VgaArbiter/">VGA仲裁</a>.此选项主要用于处理多个显卡(比如集成显卡和独立显卡)之间的切换.如果你的系统上有多个显卡,可以选"Y",否则应该选"N".详情参见"<a href="https://www.kernel.org/doc/Documentation/vgaarbiter.txt">Documentation/vgaarbiter.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Maximum number of GPUs<br>CONFIG_VGA_ARB_MAX_GPUS</dt><dd>最多允许支持多少个显卡</dd>
	</dl></dd>
	<dt>Laptop Hybrid Graphics - GPU switching support<br>CONFIG_VGA_SWITCHEROO</dt><dd>支持多个显卡之间的切换(通常是在集显和独显之间),这项技术有多个不同的名称:"<a href="http://www.amd.com/cn/products/technologies/ati-hybrid-graphics/Pages/ati-hybrid-graphics.aspx">Hybrid Graphics</a>","<a href="http://baike.baidu.com/view/2165615.htm">PowerXpress</a>","<a href="http://baike.baidu.com/view/1632721.htm">HybridPower</a>".这项特性主要用于笔记本,台式机一般不支持.</dd>
	<dt>Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)<br>CONFIG_DRM</dt><dd><a href="http://blog.csdn.net/datangsoc/article/details/5900025">DRI</a>(<a href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure">Direct Rendering Infrastructure</a>)允许应用程序以高效安全的方式直接访问GPU,主要用于硬件3D加速.不需要图形界面的用户应该选"N".桌面用户建议选"Y".[提示]KMS+DRI2+GEM+UXA+<a href="http://linuxtoy.org/archives/gnome-to-wayland-roadmap.html">Wayland</a>是<a href="http://muses2006.blog.163.com/blog/static/11436549520094411927792/">Linux图形革命</a>的基石,这里还有两篇需要越墙的文章可以帮助加深对Linux图形技术的理解:(1)<a href="http://huanhaoadam.wordpress.com/2010/03/03/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Exorg%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86/">关于Xorg的一些整理</a>,(2)<a href="http://www.linuxgraphics.cn/xwindow/some_concepts_of_xorg.html">厘清了xorg里的一些概念</a>.</dd>
	<dd><dl>
		<dt>Enable legacy fbdev support for your modesetting driver<br>CONFIG_DRM_FBDEV_EMULATION</dt><dd>为传统的fbdev设备提供支持,由于CONFIG_FRAMEBUFFER_CONSOLE依赖于fbdev设备,因此务必选"Y",否则将会遭遇控制台黑屏.</dd>
	</dl></dd>
	<dt>Allow to specify an EDID data set instead of probing for it<br>CONFIG_DRM_LOAD_EDID_FIRMWARE</dt><dd><a href="http://zh.wikipedia.org/wiki/EDID">EDID</a>(<a href="http://blog.csdn.net/zhouzhuan2008/article/details/8072745">扩展显示器识别数据</a>)是一种<a href="http://zh.wikipedia.org/wiki/VESA">VESA(视频电子标准协会)</a>制定的标准数据格式,其中包含有关显示器的各种参数:供应商信息,最大图像尺寸,颜色设置,厂商预设置,频率范围,显示器名,序列号字符串等等.EDID保存在显示器的PROM或EEPROM中,显卡或<a href="http://www.polypux.org/projects/read-edid/">read-edid</a>一般通过I2C总线使用DDC协议进行读取.但是在某些脑残的硬件(显示器或显卡)上却不能正确获取EDID数据.此选项就是为了解决这个问题而设置的.此选项可以允许从"/lib/firmware/"目录加载EDID数据,或者将EDID数据在编译时直接嵌入内核.不确定的选"N".详情参见"<a href="https://www.kernel.org/doc/Documentation/EDID/HOWTO.txt">Documentation/EDID/HOWTO.txt</a>"文档.[提示]EDID的继任者是<a href="http://wenku.baidu.com/view/ee4dcfc608a1284ac850439e">DisplayID</a>,但目前DisplayID尚未被广泛应用.</dd>
	<dt>I2C encoder or helper chips</dt><dd>I2C编码器或辅助芯片</dd>
	<dd><dl>
		<dt>Chrontel ch7006 TV encoder<br>CONFIG_DRM_I2C_CH7006</dt><dd><a href="http://www.chrontel.com/index.php/ch7006-tv-encoder">Chrontel ch7006</a> 电视解码器支持.某些nVidia显卡上有这个芯片.此选项仅对NVIDIA显卡开源驱动(<a href="http://nouveau.freedesktop.org/wiki/">nouveau</a>)有意义.</dd>
		<dt>Silicon Image sil164 TMDS transmitter<br>CONFIG_DRM_I2C_SIL164</dt><dd><a href="http://www.siliconimage.com/solutions/pc/hdmi-dvi-tx/">Silicon Image SIL164</a> <a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%8C%96%E5%82%B3%E8%BC%B8%E5%B7%AE%E5%88%86%E8%A8%8A%E8%99%9F">最小化传输差分信号</a>(<a href="http://www.dzsc.com/data/html/2009-6-16/76874.html">TMDS</a>)发送器,用于实现<a href="http://zh.wikipedia.org/wiki/DVI">DVI</a>信号的合成和发送.TMDS不如<a href="http://zh.wikipedia.org/wiki/%E4%BD%8E%E9%9B%BB%E5%A3%93%E5%B7%AE%E5%88%86%E4%BF%A1%E8%99%9F">LVDS</a>应用广泛,仅在某些nVidia显卡上有出现.</dd>
		<dt>NXP Semiconductors TDA998X HDMI encoder<br>CONFIG_DRM_I2C_NXP_TDA998X</dt><dd><a href="http://www.cn.nxp.com/">NXP(恩智浦)</a> TDA998X <a href="http://zh.wikipedia.org/wiki/HDMI">HDMI</a> 发射器.用于实现<a href="http://diy.pconline.com.cn/display/study_screen/1102/2348992_all.html">HDMI</a>信号的合成和发送.</dd>
	</dl></dd>
	<dt>3dfx Banshee/Voodoo3+<br>CONFIG_DRM_TDFX</dt><dd><a href="http://baike.baidu.com/view/993916.htm">3dfx</a> Banshee/Voodoo3+ 系列古董显卡</dd>
	<dt>ATI Rage 128<br>CONFIG_DRM_R128</dt><dd><a href="http://baike.baidu.com/view/1493224.htm">ATI Rage 128</a> 系列古董显卡</dd>
	<dt>ATI Radeon<br>CONFIG_DRM_RADEON</dt><dd>Radeon系列显卡开源驱动(<a href="http://wiki.x.org/wiki/radeon/">radeon</a>).[提示]R600及更新的GPU需要额外的固件/微代码(<a href="http://git.exherbo.org/summer/packages/firmware/radeon-ucode/">radeon-ucode</a>)的帮助才能使用开源驱动.如果你打算在R600及更新的GPU上使用此开源驱动,那么建议选"M"而不是"Y".因为"Y"需要将微代码(通常位于"/lib/firmware/radeon/"目录)一起编译进内核(使用CONFIG_EXTRA_FIRMWARE="radeon/<a href="http://wiki.gentoo.org/wiki/Radeon#Firmware">GPU-MODEL</a>.bin").[注意]如果你打算使用目前尚不支持<a href="https://wiki.archlinux.org/index.php/Kernel_Mode_Setting_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">KMS</a>的Radeon闭源驱动(<a href="http://support.amd.com/US/GPUDOWNLOAD/Pages/index.aspx">Catalyst/fglrx</a>),那么此项必须选"N".</dd>
	<dd><dl>
		<dt>Enable userspace modesetting on radeon (DEPRECATED)<br>CONFIG_DRM_RADEON_UMS</dt><dd>禁用KMS支持.目的是为了兼容远古版本的DDX驱动.除非你有充足的理由,否则请选"N".</dd>
	</dl></dd>
	<dt>Nouveau (nVidia) cards<br>CONFIG_DRM_NOUVEAU</dt><dd>nVidia系列显卡开源驱动(<a href="http://nouveau.freedesktop.org/wiki/">nouveau</a>).[注意]如果你打算使用也许永远不会支持<a href="http://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E8%AE%BE%E5%AE%9A">KMS</a>的nVidia闭源驱动(<a href="http://www.nvidia.com/object/unix.html">nvidia-drivers</a>),那么此项必须选"N".</dd>
	<dd><dl>
		<dt>Maximum debug level<br>CONFIG_NOUVEAU_DEBUG</dt><dd>最大调试级别,也就是最高允许显示的调试信息详细程度.取值范围是[0,7],数字越大,在内核中编入的调试信息就越多,建议设为"4",过大的级别会导致驱动运行缓慢.</dd>
		<dt>Default debug level<br>CONFIG_NOUVEAU_DEBUG_DEFAULT</dt><dd>默认调试级别,必须小于等于CONFIG_NOUVEAU_DEBUG的值.数字越大,输出的调试信息就越详细,建议设为"2",过大的级别会导致驱动运行缓慢.</dd>
		<dt>Support for backlight control<br>CONFIG_DRM_NOUVEAU_BACKLIGHT</dt><dd>允许调整显示器背光亮度,主要用于液晶显示屏等使用背光技术的显示器.建议选"Y".</dd>
	</dl></dd>
	<dt>Intel I810<br>CONFIG_DRM_I810</dt><dd>专为古董级Intel集成显卡(i810/i815)准备的驱动</dd>
	<dt>Intel 8xx/9xx/G3x/G4x/HD Graphics<br>CONFIG_DRM_I915</dt><dd>Intel <a href="http://en.wikipedia.org/wiki/Intel_GMA">GMA</a>(芯片组集成显卡)与<a href="http://zh.wikipedia.org/wiki/Intel_HD_Graphics">HD Graphics</a>(核心集成显卡)开源驱动(<a href="https://01.org/linuxgraphics/">intel</a>).除了个别老古董(i810/i815)与基于PowerVR的芯片(Atom z5xx)之外,此驱动支持所有Intel集成显卡(包括Atom中的集成显卡).[提示]<a href="http://linuxtoy.org/archives/compare-linux-driver-support-between-three-major-gpus.html">三大主流显卡厂商对Linux的驱动支持</a>,Intel是最彻底的,官方只提供开源驱动.</dd>
	<dd><dl>
		<dt>Enable modesetting on intel by default<br>CONFIG_DRM_I915_KMS</dt><dd>默认开启<a href="http://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E8%AE%BE%E5%AE%9A">KMS</a>(<a href="https://wiki.archlinux.org/index.php/Kernel_Mode_Setting_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Kernel Mode Setting</a>)特性,作用是可以在内核级别(而不是用户级别)设置显示分辨率和颜色深度.KMS使用了更新的技术,可以减少失真,增强3D性能,甚至可以使用内核的节能功能.KMS是大势所趋,只要用户层软件不太旧(2010年之后),都建议开启.[注意]开启此项后,应该:(1)关闭CONFIG_FB_INTEL选项并禁止加载任何framebuffer驱动(包括CONFIG_FB_UVESA),(2)取消内核引导参数"vga=xxx"和"video=xxx",(3)必须开启CONFIG_FRAMEBUFFER_CONSOLE选项.</dd>
		<dt>Enable legacy fbdev support for the modesetting intel driver<br>CONFIG_DRM_I915_FBDEV</dt><dd>使用此驱动为传统的fbdev设备提供支持,由于CONFIG_FRAMEBUFFER_CONSOLE依赖于fbdev设备,因此务必选"Y",否则将会遭遇控制台黑屏.</dd>
		<dt>Enable preliminary support for prerelease Intel hardware by default<br>CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT</dt><dd>为尚未正式发布的显卡提供支持,相当于设置"i915.preliminary_hw_support=1"引导参数.一般应该选"N"</dd>
		<dt>Enable userspace modesetting on Intel hardware (DEPRECATED)<br>CONFIG_DRM_I915_UMS</dt><dd>为古董级的DDX驱动提供用户空间模式设置支持.选"N".</dd>
	</dl></dd>
	<dt>Matrox g200/g400<br>CONFIG_DRM_MGA</dt><dd>Matrox G200, G400, G450 系列古董显卡</dd>
	<dt>SiS video cards<br>CONFIG_DRM_SIS</dt><dd>SiS 630 系列古董显卡</dd>
	<dt>Via unichrome video cards<br>CONFIG_DRM_VIA</dt><dd>Via unichrome 系列古董显卡</dd>
	<dt>Savage video cards<br>CONFIG_DRM_SAVAGE</dt><dd>Savage3D/4/SuperSavage/Pro/Twister 系列古董显卡</dd>
	<dt>DRM driver for VMware Virtual GPU<br>CONFIG_DRM_VMWGFX</dt><dd>VMware SVGA2 虚拟显卡驱动.支持3D加速,支持KMS.如果你打算在VMware内使用图形化界面,建议选"Y".</dd>
	<dd><dl>
		<dt>Enable framebuffer console under vmwgfx by default<br>CONFIG_DRM_VMWGFX_FBCON</dt><dd>如果你使用的VMware Tools不太旧就选"Y".</dd>
	</dl></dd>
	<dt>Intel GMA5/600 KMS Framebuffer<br>CONFIG_DRM_GMA500</dt><dd>Intel基于Poulsbo架构的集成显卡实验性支持.此类显卡并不常见,仅用于Atom z5xx系列处理器.</dd>
	<dt>DisplayLink<br>CONFIG_DRM_UDL</dt><dd><a href="http://baike.baidu.com/view/1485403.htm">DisplayLink</a>是一个通过USB接口实现显示器连接到电脑的连接技术,可以非常简单的连接电脑和多个显示设备,常用于通过USB接口扩展虚拟的电脑的桌面.目前DisplayLink技术最多可以支持<a href="http://publish.it168.com/2008/0825/20080825015701.shtml">6台显示器同时显示</a>32位色彩的任意分辨率画面.</dd>
	<dt>AST server chips<br>CONFIG_DRM_AST</dt><dd>AST系列显卡实验性支持.此种显卡仅出现在服务器环境.</dd>
	<dt>Kernel modesetting driver for MGA G200 server engines<br>CONFIG_DRM_MGAG200</dt><dd><a href="https://cateee.net/lkddb/web-lkddb/DRM_MGAG200.html">MGA G200系列服务器显卡芯片</a>的KMS支持.[注意]仅用于服务器芯片,不要用于桌面芯片!此驱动需要v0.3.0版本的用户空间modesetting驱动.</dd>
	<dt>Cirrus driver for QEMU emulated device<br>CONFIG_DRM_CIRRUS_QEMU</dt><dd>这是<a href="http://www.ibm.com/developerworks/cn/linux/l-qemu/">QEMU</a>虚拟的cirrus显卡KMS驱动,仅可用于客户机中.千万不要用于真正的物理cirrus显卡.</dd>
	<dt>QXL virtual GPU<br>CONFIG_DRM_QXL</dt><dd>用于<a href="http://os.51cto.com/art/201104/255032.htm">SPICE</a>的虚拟桌面的QXL虚拟显卡(cirrus)KMS支持.</dd>
	<dt>Lowlevel video output switch controls<br>CONFIG_VIDEO_OUTPUT_CONTROL</dt><dd>底层视频输出开关控制(通过sysfs接口).这是ACPI视频控制所依赖的功能,也被许多显卡驱动所依赖.可以选"N",若有其它驱动需要它,会被自动选中.</dd>
	<dt>Support for frame buffer devices<br>CONFIG_FB</dt><dd><a href="http://baike.baidu.com/view/1040793.htm">帧缓冲</a>(<a href="http://bbs.chinaunix.net/thread-1932291-1-1.html">framebuffer</a>)设备(/dev/fb*)是一种对图形硬件的抽象,它把屏幕上的所有像素点都直接映射到一段线性的内存空间,这样就为软件提供了访问图形硬件的统一接口,这些软件不需要了解硬件的底层细节(例如寄存器),只要简单的改变相应内存位置的值,就能改变屏幕上显示的内容(颜色/亮度等).Xorg的高度可移植性也就根源于此.图形界面用户必选.<a href="https://github.com/gentoo-zh/linux-cjktty/">CJKTTY</a>补丁也依赖于它.</dd>
	<dd><dl>
		<dt>Enable firmware EDID<br>CONFIG_FIRMWARE_EDID</dt><dd><a href="http://zh.wikipedia.org/wiki/EDID">EDID</a>(<a href="http://av.imaschina.com/issue/t_obs/2010/5476.html">扩展显示器识别数据</a>)保存在显示器的PROM或EEPROM中,显卡或<a href="http://www.polypux.org/projects/read-edid/">read-edid</a>一般通过I2C总线使用DDC协议进行读取.但是在某些脑残的硬件(显示器或显卡)上却不能正确获取EDID数据.此选项就是为了解决这个问题而设置的(参见CONFIG_DRM_LOAD_EDID_FIRMWARE).开启此项后,将允许三种驱动(nvidiafb,i810fb,savagefb)通过Video BIOS获取EDID.建议选"N",仅在你确实遭遇EDID读取失败,并且确实需要使用nvidiafb/i810fb/savagefb驱动的时候才需要考虑选"Y".[提示]EDID的继任者是<a href="http://wenku.baidu.com/view/ee4dcfc608a1284ac850439e">DisplayID</a>,但目前DisplayID尚未被广泛应用.</dd>
		<dt>Framebuffer foreign endianness support<br>CONFIG_FB_FOREIGN_ENDIAN</dt><dd>如果你想混合使用不同<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节序</a>的主板和显卡(在Little-Endian主板上使用Big-Endian显卡,或者相反),可以选"Y".绝大多数人都应该选"N".除非你确实知道自己在做什么.</dd>
		<dt>Enable Video Mode Handling Helpers<br>CONFIG_FB_MODE_HELPERS</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Generalized_Timing_Formula">GTF</a>和EDID解析程序来帮助处理显示模式,建议选"N",若有其他选项依赖于它时,会自动选上.</dd>
		<dt>Enable Tile Blitting Support<br>CONFIG_FB_TILEBLITTING</dt><dd>此项仅对matroxfb驱动有意义,建议选"N",若有其他选项依赖于它时,会自动选上</dd>
		<dt class="omit">{虽然此处省略的各种Framebuffer驱动提供了对图形硬件的统一抽象,让Xorg不必与硬件直接对话,但这些Framebuffer驱动仅能提供2D功能,在如今3D硬件加速和视频硬件解码早已铺天盖地的情况下,让Xorg直接与GPU硬件对话才更符合潮流,而传统的Framebuffer驱动(CONFIG_FB_*)反而成为了绊脚石,不但没有必要与新的DRI驱动(CONFIG_DRM_*)共存,而且还会相互冲突.所以切勿选中这里省略的任何Framebuffer驱动.除非你确实知道自己在做什么.}</dt>
	</dl></dd>
	<dt>Exynos Video driver support<br>CONFIG_EXYNOS_VIDEO</dt><dd>三星基于ARM构的<a href="http://baike.baidu.com/view/5821967.htm">EXYNOS</a>处理器内置显卡</dd>
	<dt>Backlight &amp; LCD device support<br>CONFIG_BACKLIGHT_LCD_SUPPORT</dt><dd>背光与液晶支持.</dd>
	<dd><dl>
		<dt>Lowlevel LCD controls<br>CONFIG_LCD_CLASS_DEVICE</dt><dd>液晶(LCD)底层控制框架.用于控制对比度和LCD开关(而不是背光亮度).这些LCD硬件目前仅用于智能手机/平板电脑等嵌入式环境.</dd>
		<dt>Lowlevel Backlight controls<br>CONFIG_BACKLIGHT_CLASS_DEVICE</dt><dd>背光(Backlight)底层控制框架.用于控制背光源的亮度和开关.选中此项后还需要从子项中选择特定于硬件的驱动.</dd>
		<dd><dl>
			<dt>Generic PWM based Backlight Driver<br>CONFIG_BACKLIGHT_PWM</dt><dd>液晶显示器(包括台式机和笔记本)的<a href="http://www.zhihu.com/question/21127560">背光亮度调整方式</a>有两种:(1)<a href="http://www.cnledw.com/knowledge/detail-21714.htm">PWM调光</a>,(2)非PWM调光.目前主流的液晶显示器基本上都是PWM调光,仅有少数是<a href="http://www.chiphell.com/thread-650884-1-1.html">非PWM调光型号</a>(而且越来越少).</dd>
			<dt>Apple Backlight Driver<br>CONFIG_BACKLIGHT_APPLE</dt><dd>基于Intel处理器的苹果Macbook笔记本和iMac台式机显示器背光控制</dd>
			<dt class="omit">{其它省略的驱动仅用于智能手机/平板电脑等嵌入式环境}</dt>
		</dl></dd>
	</dl></dd>
	<dt>Console display driver support</dt><dd>控制台显示驱动.每个人都需要.下面的"VGA text"与"Framebuffer"至少应该选中一个.</dd>
	<dd><dl>
		<dt>VGA text console<br>CONFIG_VGA_CONSOLE</dt><dd>VGA文本模式控制台.建议选"N".仅某些服务器环境可以考虑选"Y".</dd>
		<dd><dl>
			<dt>Enable Scrollback Buffer in System RAM<br>CONFIG_VGACON_SOFT_SCROLLBACK</dt><dd>标准的VGA控制台回滚缓冲区位于VGA RAM中,但是其空间非常小,并且是固定的.开启此项后,就可以在内存中开辟更大的屏幕回滚缓冲区,这将允许你回滚更多的屏幕(Shift+PageUp),但是控制台的速度会略有下降.经常使用文本控制台的可以选"Y",不确定的选"N".</dd>
			<dd><dl>
				<dt>Scrollback Buffer Size (in KB)<br>CONFIG_VGACON_SOFT_SCROLLBACK_SIZE</dt><dd>在内存中开辟的屏幕回滚缓冲区大小.每个80x25屏幕需要4KB内存</dd>
			</dl></dd>
		</dl></dd>
		<dt>Framebuffer Console support<br>CONFIG_FRAMEBUFFER_CONSOLE</dt><dd>基于Framebuffer的图形模式控制台.KMS特性依赖于它.<a href="https://github.com/gentoo-zh/linux-cjktty/">CJKTTY</a>补丁也依赖于它.桌面用户必选"Y"(使用了CONFIG_DRM_*的用户必须开启),服务器以UEFI方式启动的也必选"Y".</dd>
		<dd><dl>
			<dt>Map the console to the primary display device<br>CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY</dt><dd>选"Y"表示自动将控制台映射到"主"显卡,选"N"表示自动将控制台映射到第一个加载的显卡驱动.无论是否选中此项,都可以通过"fbcon=map:N"内核引导参数更改映射关系.仅在系统拥有多个显卡时此选项才有意义.参见"<a href="https://www.kernel.org/doc/Documentation/fb/fbcon.txt">Documentation/fb/fbcon.txt</a>"文档.</dd>
			<dt>Framebuffer Console Rotation<br>CONFIG_FRAMEBUFFER_CONSOLE_ROTATION</dt><dd>显示画面旋转,由于是纯软件方式实现,所以会大大降低显示速度,除非你确实需要,否则建议选"N".若使用了<a href="https://github.com/gentoo-zh/linux-cjktty/">CJKTTY</a>补丁,则必须选"N".</dd>
			<dt>Support for the Framebuffer Console Decorations<br>CONFIG_FB_CON_DECOR</dt><dd>允许在控制台上显示<a href="http://linux-wiki.cn/images/b/bf/Debian_bootsplash.jpg">背景图像</a>,例如在系统启动时,在一堆滚动的字符背后显示漂亮的<a href="http://fatcat.ftj.agh.edu.pl/~przyboro/other/kon.png">背景图像</a>.当然,要实现这个功能,还需要用户空间程序的帮助.详见"<a href="https://www.kernel.org/doc/Documentation/fb/fbcondecor.txt">Documentation/fb/fbcondecor.txt</a>"文档以及<a href="http://wiki.gentoo.org/wiki/Fbsplash">fbsplash</a>的wiki页.</dd>
		</dl></dd>
	</dl></dd>
	<dt>Bootup logo<br>CONFIG_LOGO</dt><dd>启动时显示linux的logo(一幅企鹅图像),企鹅的数量表示内核检测到的CPU数目,喜欢炫一下的就选吧.子项是三种不同质量的图片,分别是黑白,16色,224色.按需选择.</dd>
</dl></dd>


<dt>Sound card support<br>CONFIG_SOUND</dt><dd>声卡支持</dd>
<dd><dl>
	<dt>Preclaim OSS device numbers<br>CONFIG_SOUND_OSS_CORE_PRECLAIM</dt><dd>开启此项后,只要OSS支持被开启,无论相应的模块是否被加载,内核都会预先声明所有OSS设备号.当其中一个设备被打开时,将会尝试使用"sound-slot/service-*"与"char-major-*"两种别名去加载相应的模块.关闭此项后, 内核将仅声明实际使用中的OSS设备号.当打开一个不存在的设备时,将会仅尝试使用标准的"char-major-*"别名去加载相应的模块.由于"sound-slot/service-*"将会在未来移除,此选项仅是一个为了兼容性而保留的过渡选项,未来会被移除(相当于设为"N").</dd>
	<dt>Advanced Linux Sound Architecture<br>CONFIG_SND</dt><dd><a href="http://blog.csdn.net/absurd/article/details/1323006">ALSA</a>(高级Linux声音架构)是内核默认的声音子系统.ALSA除了提供了声音设备的驱动,还提供了一个用户空间的函数库,这样用户空间程序就可以通过统一的API使用驱动功能,而不必直接与内核驱动交互.[吐槽]<a href="http://www.cnblogs.com/jiqingwu/p/linux_sound_system.html">Linux音频系统</a>,比意大利面条更混乱的系统!</dd>
	<dd><dl>
		<dt>Sequencer support<br>CONFIG_SND_SEQUENCER</dt><dd><a href="http://baike.baidu.com/view/7969.htm">MIDI</a><a href="http://baike.baidu.com/view/494975.htm">音序器</a>支持,如果你是MIDI玩家,请选"Y",但如果你不知道MIDI是什么,请选"N".</dd>
		<dd><dl>
			<dt>Sequencer dummy client<br>CONFIG_SND_SEQ_DUMMY</dt><dd>除非你要同时连接到多个MIDI设备或应用程序,否则请不要选中</dd>
		</dl></dd>
		<dt>OSS Mixer API<br>CONFIG_SND_MIXER_OSS</dt><dd>模拟OSS混音器API(/dev/mixer*),某些老旧的程序仍然使用它,建议不选</dd>
		<dt>OSS PCM (digital audio) API<br>CONFIG_SND_PCM_OSS</dt><dd>模拟OSS数字音频(<a href="http://blog.csdn.net/DroidPhone/article/details/6308006">PCM</a>)API(/dev/dsp*),某些老旧的程序仍然使用它,建议不选.</dd>
		<dd><dl>
			<dt>OSS PCM (digital audio) API - Include plugin system<br>CONFIG_SND_PCM_OSS_PLUGINS</dt><dd>让ALSA模拟的 OSS PCM API 支持channel/format/rate的转换.选"N",除非你确实知道为什么要选"Y".</dd>
		</dl></dd>
		<dt>OSS Sequencer API<br>CONFIG_SND_SEQUENCER_OSS</dt><dd>模拟OSS音序器(/dev/sequencer,/dev/music),某些老旧的程序仍然使用它,建议不选</dd>
		<dt>HR-timer backend support<br>CONFIG_SND_HRTIMER</dt><dd>允许将高精度定时器(CONFIG_HIGH_RES_TIMERS)用作ALSA高精度时间源,建议选中</dd>
		<dd><dl>
			<dt>Use HR-timer as default sequencer timer<br>CONFIG_SND_SEQ_HRTIMER_DEFAULT</dt><dd>将高精度定时器(HR-timer)当作默认的时序脉冲发生器时间源,建议选中</dd>
		</dl></dd>
		<dt>Dynamic device file minor numbers<br>CONFIG_SND_DYNAMIC_MINORS</dt><dd>动态分配ALSA设备的次设备号.如果你有8个以上的声卡,可以选"Y",否则应该选"N".</dd>
		<dt>Support old ALSA API<br>CONFIG_SND_SUPPORT_OLD_API</dt><dd>支持已被废弃的老旧版本的ALSA PCM API,选"N".</dd>
		<dt>Verbose procfs contents<br>CONFIG_SND_VERBOSE_PROCFS</dt><dd>仅供调试使用</dd>
		<dt>Verbose printk<br>CONFIG_SND_VERBOSE_PRINTK</dt><dd>仅供调试使用</dd>
		<dt>Debug<br>CONFIG_SND_DEBUG</dt><dd>仅供调试使用</dd>
		<dt>Generic sound devices<br>CONFIG_SND_DRIVERS</dt><dd>通用声音设备</dd>
		<dd><dl>
			<dt>PC-Speaker support (READ HELP!)<br>CONFIG_SND_PCSP</dt><dd>如果你有声卡,务必选"N".如果你的系统没有声卡,仅在认真阅读了帮助之后,确实知道自己在干什么的情况下,才可以开启此项.</dd>
			<dt>Dummy (/dev/null) soundcard<br>CONFIG_SND_DUMMY</dt><dd>仅供调试使用</dd>
			<dt>Generic loopback driver (PCM)<br>CONFIG_SND_ALOOP</dt><dd><a href="http://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E7%B7%A8%E7%A2%BC%E8%AA%BF%E8%AE%8A">PCM</a>环回(loopback)设备非常类似于网卡的环回接口(127.0.0.1),它会将输入的音频流原封不动的返回给用户空间.PCM回环设备常用来将A程序输出的音频流作为B程序的输入(A以写模式打开环回设备,而B以读模式打开),比如用B程序记录A程序的输出,或做进一步的处理.</dd>
			<dt>Virtual MIDI soundcard<br>CONFIG_SND_VIRMIDI</dt><dd>虚拟<a href="http://zh.wikipedia.org/wiki/MIDI">MIDI</a>驱动,允许将使用原始MIDI设备的应用程序连接到音序器客户端,如果你不知道MIDI是什么就选"N".</dd>
			<dt class="omit">{此处省略几种MIDI设备(事实上大部分人都没有这些设备)}</dt>
			<dt>AC97 Power-Saving Mode<br>CONFIG_SND_AC97_POWER_SAVE</dt><dd><a href="http://baike.baidu.com/view/117423.htm">AC97</a>(Audio Codec 97)自动节能模式支持.在此模式下,如果音频设备闲置超过"/sys/module/snd_ac97_codec/parameters/power_save"设定的秒数("0"表示关闭节能模式),那么驱动程序将会关闭音频设备以节约电力.建议选"Y".详见"<a href="https://www.kernel.org/doc/Documentation/sound/alsa/powersave.txt">Documentation/sound/alsa/powersave.txt</a>"文档.</dd>
			<dd><dl>
				<dt>Default time-out for AC97 power-save mode<br>CONFIG_SND_AC97_POWER_SAVE_DEFAULT</dt><dd>默认的超时秒数,也就是"/sys/module/snd_ac97_codec/parameters/power_save"的默认值."0"表示关闭节能模式.建议设为"10"这个久经考验的合理数字.</dd>
			</dl></dd>
		</dl></dd>
		<dt>ISA sound devices<br>CONFIG_SND_ISA</dt><dd>基于ISA总线的声卡,已经绝种了.</dd>
		<dt>PCI sound devices<br>CONFIG_SND_PCI</dt><dd>基于PCI总线的声卡,绝大多数声卡都是PCI接口</dd>
		<dd><dl>
			<dt class="omit">{此处省略的声卡按实际情况选择即可(都是些比较旧的AC97声卡)}</dt>
			<dt>Intel HD Audio<br>CONFIG_SND_HDA_INTEL</dt><dd>符合<a href="http://acc.pconline.com.cn/vocality/study_vocality/0801/1212973_all.html">Intel HD Audio</a>规范的声卡是目前的主流声卡.如果选"M",那么下面的每个驱动也都会被编译成模块,如果选"Y",那么下面的每个驱动也都会直接编译进内核.</dd>
			<dd><dl>
				<dt>Pre-allocated buffer size for HD-audio driver<br>CONFIG_SND_HDA_PREALLOC_SIZE</dt><dd>为HD-audio驱动程序预先分配的缓冲区大小(kB),较大的值拥有更好的性能,例如对于使用<a href="http://zh.wikipedia.org/zh-cn/PulseAudio">PulseAudio</a>声音服务器的系统来说,推荐使用"4096".默认值"64"仅仅是为了历史兼容的原因.[提示]ALSA+PulseAudio是目前的主流搭配.</dd>
				<dt>Build hwdep interface for HD-audio driver<br>CONFIG_SND_HDA_HWDEP</dt><dd>为HD-audio驱动添加hwdep接口.仅用于调试目的</dd>
				<dt>Support digital beep via input layer<br>CONFIG_SND_HDA_INPUT_BEEP</dt><dd>为HD-audio驱动添加数字蜂鸣(beep)接口.如果你的主板没有<a href="http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html">蜂鸣器</a>(不是能够播放音乐的扬声器),可以考虑选"Y".</dd>
				<dd><dl>
					<dt>Digital beep registration mode (0=off, 1=on)<br>CONFIG_SND_HDA_INPUT_BEEP_MODE</dt><dd>设为"0"表示默认禁用数字蜂鸣接口,设为"1"表示默认启用数字蜂鸣接口.</dd>
				</dl></dd>
				<dt>Support jack plugging notification via input layer<br>CONFIG_SND_HDA_INPUT_JACK</dt><dd>通过输入层支持<a href="http://zh.wikipedia.org/wiki/JACK_Audio_Connection_Kit">JACK</a>插件通知.JACK是一个比PulseAudio更专业的声音服务器,重点是低延迟,是专业音频软件(例如:<a href="http://zh.wikipedia.org/wiki/Ardour_%28%E8%BD%AF%E4%BB%B6%29">Ardour</a>,Rezound,LinuxSampler)首选的音频服务器.如果你打算使用JACK,可以选"Y".[提示]如果要<a href="http://tonychee1989.diandian.com/about-jack-audio-connection-kit">将JACK和PulseAudio一起使用</a>,需要安装PulseAudio的JACK支持模块.</dd>
				<dt>Support initialization patch loading for HD-audio<br>CONFIG_SND_HDA_PATCH_LOADER</dt><dd>仅用于调试目的</dd>
				<dt class="omit">{此处省略的HD-audio声卡按实际情况选择即可.[提示]如果CONFIG_SND_HDA_INTEL被编译为模块,这里的每一个驱动也都会被编译成模块.}</dt>
				<dt>Build HDMI/DisplayPort HD-audio codec support<br>CONFIG_SND_HDA_CODEC_HDMI</dt><dd>在HD-audio驱动中添加<a href="http://diy.pconline.com.cn/display/study_screen/1102/2348992_all.html">HDMI和DisplayPort</a>支持.如果你需要使用<a href="http://tv.ea3w.com/20/206229_all.html">HDMI/DisplayPort</a>接口,可以选"Y".</dd>
				<dt>Enable generic HD-audio codec parser<br>CONFIG_SND_HDA_GENERIC</dt><dd>通用HD-audio编解码器(<a href="http://zh.wikipedia.org/wiki/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8">codec</a>)支持,必选.</dd>
				<dt>Default time-out for HD-audio power-save mode<br>CONFIG_SND_HDA_POWER_SAVE_DEFAULT</dt><dd>HD-audio自动节能模式默认的超时秒数."0"表示关闭节能模式.建议设为"10"这个久经考验的合理数字.详见"<a href="https://www.kernel.org/doc/Documentation/sound/alsa/powersave.txt">Documentation/sound/alsa/powersave.txt</a>"文档与CONFIG_SND_AC97_POWER_SAVE_DEFAULT选项.</dd>
			</dl></dd>
		</dl></dd>
		<dt>SPI sound devices<br>CONFIG_SND_SPI</dt><dd>基于SPI总线的声卡,仅出现在嵌入式设备上</dd>
		<dt>USB sound devices<br>CONFIG_SND_USB</dt><dd>基于USB总线的声卡,主要是外接声卡,并不常用</dd>
		<dt>FireWire sound devices<br>CONFIG_SND_FIREWIRE</dt><dd>基于IEEE-1394/FireWire/iLink总线的声卡,主要用于苹果的产品</dd>
		<dt>PCMCIA sound devices<br>CONFIG_SND_PCMCIA</dt><dd>基于PCMCIA接口的声卡,主要是外接声卡,并不常用</dd>
		<dt>ALSA for SoC audio support<br>CONFIG_SND_SOC</dt><dd>SoC系统音频设备支持,重点是节能支持.仅用于嵌入式设备</dd>
	</dl></dd>
	<dt>Open Sound System (DEPRECATED)<br>CONFIG_SOUND_PRIME</dt><dd>OSS早已被废弃(已被ALSA取代).选"N".</dd>
</dl></dd>


<dt>HID support</dt><dd><a href="http://en.wikipedia.org/wiki/Human_interface_device">HID</a>(<a href="http://wenku.baidu.com/view/7fd4df21192e45361066f5f2.html">人机接口设备</a>)是一种定义计算机如何与人类交互的规范,常与USB或蓝牙搭配使用,常见的设备有:键盘,鼠标,触摸板,游戏杆,遥控器,蓝牙耳机,游戏手柄,手写板,等等.不过HID设备不一定要有人机接口,只要符合HID规范,就是HID设备.</dd>
<dd><dl>
	<dt>HID bus support<br>CONFIG_HID</dt><dd><a href="http://www.usb.org/developers/hidpage/">HID</a>(human interface device)总线及通用HID层.要使用HID设备就必须开启.[提示]PS/2接口的鼠标和键盘不是HID设备,USB或蓝牙接口的才是HID设备.</dd>
	<dd><dl>
		<dt>Battery level reporting for HID devices<br>CONFIG_HID_BATTERY_STRENGTH</dt><dd>为那些支持power_supply类的HID电池,向用户空间报告电池的剩余电量(可以通过<a href="http://upower.freedesktop.org/">upower</a>工具显示).</dd>
		<dt>/dev/hidraw raw HID device support<br>CONFIG_HIDRAW</dt><dd>如果你想支持那些严格说来并不属于人机交互设备的硬件(使用额外的/dev/hidraw接口),例如显示控制装置(monitor control)或不间断电源(UPS)以及某些罗技的无线鼠标接收器,可以选"Y".与CONFIG_USB_HIDDEV选项(/dev/hiddev)相比,/dev/hidraw设备直接无视一切hid事件(既不解析也不查找),这样就允许应用程序直接处理和操作原始的hid事件,从而避免使用用户层libhid/libusb库.详见"<a href="https://www.kernel.org/doc/Documentation/hid/hidraw.txt">Documentation/hid/hidraw.txt</a>"文档.</dd>
		<dt>User-space I/O driver support for HID subsystem<br>CONFIG_UHID</dt><dd>HID子系统需要两种驱动:(1)"HID I/O Driver"是特定于硬件的驱动,直接与底层总线交互,并向"HID Device Driver"提供了一致接口用于收发HID数据.(2)"HID Device Driver"是硬件无关的通用驱动,其任务是按照HID规范解析和处理来自于"HID I/O Driver"的HID数据,并将组装好的数据通过"HID I/O Driver"提供的统一接口发送给底层硬件.开启此项后,将允许在用户空间实现"HID I/O Driver".不确定的选"N".详见"<a href="https://www.kernel.org/doc/Documentation/hid/uhid.txt">Documentation/hid/uhid.txt</a>"文档.</dd>
		<dt>Generic HID driver<br>CONFIG_HID_GENERIC</dt><dd>HID总线通用驱动,也就是前面说的"HID Device Driver".它实现了对各种常见<a href="http://wenku.baidu.com/view/e9a54a3467ec102de2bd89ff.html">HID协议</a>的支持:键盘,鼠标,游戏杆,手写板,数字画板.不确定的选"Y".</dd>
		<dt>Special HID drivers</dt><dd>各种不严格遵守HID协议的"HID Device Driver"</dd>
		<dd><dl>
			<dt class="omit">{此处省略的硬件按实际情况选择即可}</dt>
			<dt>Lenovo ThinkPad USB Keyboard with TrackPoint<br>CONFIG_HID_LENOVO_TPKBD</dt><dd>带有"小红帽(TrackPoint)"的联想(Lenovo)<a href="http://www.thinkpads.com/2009/08/31/finally-photos-of-new-thinkpad-usb-trackpoint-keyboard/">ThinkPad USB键盘</a>.</dd>
			<dt>Logitech devices<br>CONFIG_HID_LOGITECH</dt><dd>某些并不完全遵从HID标准的罗技(Logitech)外设</dd>
			<dt>HID Multitouch panels<br>CONFIG_HID_MULTITOUCH</dt><dd>HID<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E9%BB%9E%E8%A7%B8%E6%8E%A7">多点触控</a>(<a href="http://en.wikipedia.org/wiki/Multi-touch">Multitouch</a>)板的通用支持</dd>
			<dt>HID Sensors framework support<br>CONFIG_HID_SENSOR_HUB</dt><dd>HID传感器支持框架.详见"<a href="https://www.kernel.org/doc/Documentation/hid/hid-sensor.txt">Documentation/hid/hid-sensor.txt</a>"文档</dd>
		</dl></dd>
	</dl></dd>
	<dt>USB HID support</dt><dd>基于USB接口的HID设备,这是目前最常见的HID设备</dd>
	<dd><dl>
		<dt>USB HID transport layer<br>CONFIG_USB_HID</dt><dd>特定于USB接口的"HID I/O Driver".用于和USB总线上的硬件进行交互.只要你想使用任何基于USB接口的HID设备(键盘,鼠标,游戏杆,手写板,手绘板,不间断电源(UPS),显示控制装置(monitor control),等等),就必须选"Y".[例外]在嵌入式环境中使用的HIDBP(HID Boot Protocol)键盘和鼠标不在此列,而且两者也不能共存.</dd>
		<dt>PID device support<br>CONFIG_HID_PID</dt><dd><a href="http://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8">PID</a>兼容的力反馈设备,例如:<a href="http://bak1.beareyes.com.cn/2/lib/200102/28/20010228026.htm">Microsoft Sidewinder Force Feedback 2</a></dd>
		<dt>/dev/hiddev raw HID device support<br>CONFIG_USB_HIDDEV</dt><dd>如果你想支持那些严格说来并不属于人机交互设备的硬件(使用额外的/dev/usb/hiddevX[char 180:96~111]接口),例如显示控制装置(monitor control)或不间断电源(UPS)以及某些罗技的无线鼠标接收器,可以选"Y".参见CONFIG_HIDRAW选项.</dd>
		<dt>USB HID Boot Protocol drivers</dt><dd>如果你有绝对的把握确信不为自己的键盘和鼠标使用常规的HID驱动,而要使用Boot Protocol模式的HID驱动(常见于嵌入式环境)就选吧</dd>
	</dl></dd>
	<dt>I2C HID support</dt><dd>基于I2C总线的HID设备</dd>
	<dd><dl>
		<dt>HID over I2C transport layer<br>CONFIG_I2C_HID</dt><dd>特定于I2C总线的"HID I/O Driver".用于和I2C总线上的硬件进行交互.只要你想使用任何基于I2C总线的HID设备(键盘,触摸板,触摸屏,等等),就必须选"Y".I2C-HID主要用于嵌入式设备.</dd>
	</dl></dd>
</dl></dd>


<dt>USB support<br>CONFIG_USB_SUPPORT</dt><dd><a href="http://www.crifan.com/files/doc/docbook/usb_basic/release/html/usb_basic.html">通用串行总线</a>(<a href="http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%B2%E8%A1%8C%E7%B8%BD%E7%B7%9A">Universal Serial Bus</a>)的目标是统一电脑的外设接口.目前几乎找不到没有USB接口的电脑,而且各种智能设备也大多带有USB接口.不要犹豫,选"Y".</dd>
<dd><dl>
	<dt>Support for Host-side USB<br>CONFIG_USB</dt><dd>主机端(Host-side)USB支持.通用串行总线(USB)是一个串行总线子系统规范,它比传统的串口速度更快并且特性更丰富(供电,热插拔,最多可接127个设备等),其目标是统一PC外设接口.USB总体上呈现一种树型结构,USB的"Host"(主设备)被称为"根"(也可以理解为是主板上的USB控制器),USB的"Slave"(从设备)被称为"叶子",而内部的节点则称为"hub"(集线器).只要使用任何USB设备都必须选中此项.另外,你还需要从下面选中至少一个HCD(Host Controller Driver),比如适用于USB1.1的"UHCI HCD support"或"OHCI HCD support",适用于USB2.0的"EHCI HCD (USB 2.0) support".如果你拿不准的话把他们都选中一般也不会出问题.如果你的系统有设备端的USB接口(也就是你的系统可以作为"叶子"使用),请到"USB Gadget"中进行选择.</dd>
	<dd><dl>
		<dt>USB verbose debug messages<br>CONFIG_USB_DEBUG</dt><dd>仅供调试使用</dd>
		<dt>USB announce new devices<br>CONFIG_USB_ANNOUNCE_NEW_DEVICES</dt><dd>在syslog中记录每个新接入系统的USB设备的详细标识信息(idVendor,idProduct,Manufacturer,Product,SerialNumber),主要用于系统调试.不确定的选"N".</dd>
		<dt>Enable USB persist by default<br>CONFIG_USB_DEFAULT_PERSIST</dt><dd>根据USB规范,当USB总线被挂起(休眠)后,它必须继续提供挂起电流(1-5毫安),以确保USB设备能保持其内部状态,并且USB集线器(HUB)能够检测连接变化(设备插入和拔出).这在技术上被称为"电力会话"(power session).如果一个USB设备的电力会话被中断,那么系统必须按照该设备已经被拔出进行处理,这是一种保守的做法,因为没有挂起电流,计算机不可能知道外围设备究竟发生了什么变化:也许依然保持连接,也许已经被拔出并在同一端口上插入了一个新设备.系统必须做最坏的打算.默认情况下,Linux的行为符合USB规范的要求.当整个电脑进入休眠状态(例如挂起到硬盘)时,包括USB总线在内所有总线都将掉电,然后当系统被唤醒,所有USB设备都会被当做在休眠前就已经被拔出来处理.这样做始终是安全的,并且也是"官方正确"的做法.对于大多数USB设备来说,这样做没有任何问题,但是对于USB存储设备(例如移动硬盘/U盘)来说,如果在休眠前有尚未卸载的文件系统(特别是根文件系统),当系统被唤醒之后,由于无法访问该文件系统,系统可能会立即崩溃!其实不只有掉电,只要"power session"被中断(例如BIOS在唤醒过程中重置了USB控制器),都会导致这种故障.此选项(USB-persist)就是为了解决这个问题而设置的,虽然解决的不甚完美(参见"<a href="https://www.kernel.org/doc/Documentation/usb/persist.txt">Documentation/usb/persist.txt</a>"),但是依然推荐选"Y",除非你确实有选"N"的理由.当然,最保险的做法是在休眠之前先卸载所有USB设备上的文件系统,而如果根文件系统位于USB设备上,就根本不使用任何休眠功能(不论是挂起到硬盘还是挂起到内存).</dd>
		<dt>Dynamic USB minor allocation<br>CONFIG_USB_DYNAMIC_MINORS</dt><dd>动态分配USB设备的次设备号(仅限于主设备号为180的字符设备[通常位于"/dev/usb/"目录下]).除非你有超过16个同类型(仅限:打印机,鼠标,扫描仪)的USB设备,否则应选"N".[提示]即使你有100个U盘或者USB移动硬盘,也不需要开启此项,因为他们不是"主设备号为180的字符设备".</dd>
		<dt>OTG support<br>CONFIG_USB_OTG</dt><dd>传统上,码照相机,手机,打印机,播放器,移动硬盘等设备之间要交换数据,都要作为PC的外围设备,在PC的控制下进行数据交换.一旦离开了PC,由于没有一个设备能够充当PC的"Host"角色,所以无法直接通信.<a href="http://baike.baidu.com/view/146799.htm">USB-OTG</a>(On-The-Go)就是为了解决这个问题而诞生的,它是USB2.0规格的补充标准,支持"双角色"设备(既可以当Host,也可以当Slave),从而实现外围设备之间的数据传送.例如,将数码相机直接连接到打印机上将相片打印出来.仅在你的主板上有<a href="http://upload.wikimedia.org/wikipedia/commons/4/44/Mini-AB-Receptacle.jpg">Mini-AB</a>/<a href="http://upload.wikimedia.org/wikipedia/commons/7/71/USB_Micro-AB_receptacle.jpg">Micro-AB</a>接口(目前仅用于嵌入式设备)时才需要选"Y".</dd>
		<dt>Rely on OTG and EH Targeted Peripherals List<br>CONFIG_USB_OTG_WHITELIST</dt><dd>将"otg_whitelist.h"文件用作"OTG Targeted Peripherals List"(外设白名单),白名单之外的USB外设将按照OTG规范的要求不被枚举(也就是初始化).同样,"Embedded Host"也只支持限定的外设.如果选"N",那么白名单之外的外设也同样会被枚举(但会产生一个警告),这将大大方便嵌入式产品的开发.</dd>
		<dt>Disable external hubs<br>CONFIG_USB_OTG_BLACKLIST_HUB</dt><dd>选"Y"将禁止枚举(也就是初始化)外部USB集线器(HUB).这样,OTG主机就可以通过省去对外部集线器的支持,降低系统软硬件的成本.不确定的选"N".</dd>
		<dt>USB ULPI PHY interface support<br>CONFIG_USB_ULPI_BUS</dt><dd>ULPI(UTMI+ Low Pin Interface)是一种2005年开始兴起的通用USB 2.0 PHY接口.可有效地减少主机/外设/On-The-Go(OTG)USB收发器的针脚数量(从32个减少到12个).仅用于嵌入式设备.</dd>
		<dt>USB Monitor<br>CONFIG_USB_MON</dt><dd>选"Y"后,将可以捕获特定USB外设与USB主控器之间的数据流量,<a href="http://biot.com/usbdump/">usbdump</a>和<a href="http://www.linuxcertif.com/man/8/usbmon/">usbmon</a>工具依赖于此项.详见"<a href="https://www.kernel.org/doc/Documentation/usb/usbmon.txt">Documentation/usb/usbmon.txt</a>"文档.</dd>
		<dt>Enable Wireless USB extensions<br>CONFIG_USB_WUSB</dt><dd>主机端的<a href="http://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%80%9A%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%AF%E6%B5%81%E6%8E%92">WUSB</a>(<a href="http://network.51cto.com/art/201111/300392.htm">无线USB</a>)支持.</dd>
		<dt>Support WUSB Cable Based Association (CBA)<br>CONFIG_USB_WUSB_CBAF</dt><dd>WUSB CBA(Cable Based Association)是一项保障主机和WUSB设备之间通信安全的技术.如果你的WUSB设备在建立无线连接前必须先建立有线连接,可以选"Y".</dd>
		<dd><dl>
			<dt>Enable CBA debug messages<br>CONFIG_USB_WUSB_CBAF_DEBUG</dt><dd>仅供调试使用</dd>
		</dl></dd>
		<dt>Cypress C67x00 HCD support<br>CONFIG_USB_C67X00_HCD</dt><dd><a href="http://china.cypress.com/?id=167">Cypress</a> C67x00 (<a href="http://china.cypress.com/?id=187">EZ-Host</a>/<a href="http://china.cypress.com/?id=188">EZ-OTG</a>) USB 1.1 "双角色"控制器</dd>
		<dt>xHCI HCD (USB 3.0) support<br>CONFIG_USB_XHCI_HCD</dt><dd><a href="http://baike.baidu.com/view/9007709.htm">xHCI</a>(<a href="http://en.wikipedia.org/wiki/Extensible_Host_Controller_Interface">eXtensible Host Controller Interface</a>)就是当下大红大紫的<a href="http://www.expreview.com/20142-all.html">USB3.0</a>(SuperSpeed USB)主机控制器规范.[提示]因为xHCI移除了EHCI中为兼容USB1.1而引入的"Companion"模式,所以仅用一个单独的xHCI驱动就可以兼容所有USB3.0/2.0/1.1外设.也就是说,对于蓝色的USB3.0接口来说,开启此项之后,就不需要再额外开启EHCI/OHCI/UHCI选项了.[注意]如果你的电脑上除了蓝色的USB3.0接口,还存在黑色的USB2.0接口,那么你仍然需要开启EHCI/OHCI/UHCI选项,除非你不想使用这些黑色的USB2.0接口.</dd>
		<dd><dl>
			<dt>Debugging for the xHCI host controller<br>CONFIG_USB_XHCI_HCD_DEBUGGING</dt><dd>仅供调试使用</dd>
			<dt>Generic xHCI driver for a platform device<br>CONFIG_USB_XHCI_PLATFORM</dt><dd>通用<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform</a>设备的xHCI驱动.仅用于嵌入式环境.不确定的选"N".</dd>
		</dl></dd>
		<dt>EHCI HCD (USB 2.0) support<br>CONFIG_USB_EHCI_HCD</dt><dd><a href="http://baike.baidu.com/view/1678341.htm">EHCI</a>(Enhanced Host Controller Interface)就是渐成昨日黄花的USB2.0(HighSpeed USB)主机控制器规范.[提示]因为EHCI通过"Companion"模式来支持USB1.1设备,所以一般还需要额外再开启OHCI或UHCI选项(除非你不想兼容任何USB1.1设备).详见"<a href="https://www.kernel.org/doc/Documentation/usb/ehci.txt">Documentation/usb/ehci.txt</a>"文档.</dd>
		<dd><dl>
			<dt>Root Hub Transaction Translators<br>CONFIG_USB_EHCI_ROOT_HUB_TT</dt><dd>带有USB2.0接口的主板上都有一个"根集线器"(Root Hub)以允许在无需额外购买hub的情况下就可以提供多个USB插口,而大多数主板还在其中集成了事务转换(Transaction Translator)功能,这样就不需要再额外使用一个OHCI或UHCI控制器来兼容USB1.1,建议选"Y",除非你不想兼容任何USB1.1设备.</dd>
			<dt>Improved Transaction Translator scheduling<br>CONFIG_USB_EHCI_TT_NEWSCHED</dt><dd>改变周期性调度代码的工作方式,当多个USB1.1设备连接在同一个USB2.0集线器上时,可以获得更高的运行速度.建议选"Y"</dd>
		</dl></dd>
		<dt>Generic EHCI driver for a platform device<br>CONFIG_USB_EHCI_HCD_PLATFORM</dt><dd>通用<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform</a>设备的EHCI驱动.仅用于嵌入式环境.不确定的选"N".</dd>
		<dt>OHCI HCD support<br>CONFIG_USB_OHCI_HCD</dt><dd>OHCI(Open Host Controller Interface)是主要用于嵌入式环境的USB1.1(LowSpeed/FullSpeed USB)主机控制器规范.但也存在于某些老旧的SiS芯片组的PC上.</dd>
		<dt>UHCI HCD (most Intel and VIA) support<br>CONFIG_USB_UHCI_HCD</dt><dd>UHCI(Universal Host Controller Interface)是主要用于PC环境的USB1.1(LowSpeed/FullSpeed USB)主机控制器规范.</dd>
		<dt class="omit">{此处省略的USB控制器请按照实际硬件状况选择(基本上都仅用于嵌入式环境)}</dt>
		<dt>Wireless USB Host Controller Interface (WHCI) driver<br>CONFIG_USB_WHCI_HCD</dt><dd>WHCI(<a href="http://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%80%9A%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%AF%E6%B5%81%E6%8E%92">Wireless USB</a> Host Controller Interface)是<a href="http://baike.baidu.com/view/1621053.htm">无线USB</a>主机控制器规范.目前市场上带有WUSB主控器的主板很少.不确定的选"N".</dd>
		<dt>Host Wire Adapter (HWA) driver<br>CONFIG_USB_HWA_HCD</dt><dd>USB接口的3G/4G<a href="http://baike.baidu.com/view/46275.htm">无线上网卡</a>(通常需要搭配SIM卡使用),常见制式有:WCDMA/LTE/HSPA等.</dd>
		<dt>BCMA usb host driver<br>CONFIG_USB_HCD_BCMA</dt><dd>BCMA(Broadcom specific AMBA)总线上的EHCI/OCHI主机控制器支持.仅用于嵌入式环境.</dd>
		<dt>SSB usb host driver<br>CONFIG_USB_HCD_SSB</dt><dd>BCMA(Broadcom specific AMBA)总线上的EHCI/OCHI主机控制器支持.仅用于嵌入式环境.</dd>
		<dt>Inventra Highspeed Dual Role Controller (TI, ADI, ...)<br>CONFIG_USB_MUSB_HDRC</dt><dd>一系列基于<a href="http://www.mentor.com/">Mentor Graphics</a>公司silicon <a href="http://zh.wikipedia.org/wiki/IP%E6%A0%B8">IP核</a>的USB控制器.仅用于嵌入式环境.</dd>
		<dt>Renesas USBHS controller<br>CONFIG_USB_RENESAS_USBHS</dt><dd>一系列基于<a href="http://cn.renesas.com/">Renesas</a>公司USBHS <a href="http://zh.wikipedia.org/wiki/IP%E6%A0%B8">IP核</a>的USB控制器.仅用于嵌入式环境.</dd>
		<dt>USB Modem (CDC ACM) support<br>CONFIG_USB_ACM</dt><dd>USB接口的猫或ISDN适配器,基本没人用的东西.</dd>
		<dt>USB Printer support<br>CONFIG_USB_PRINTER</dt><dd>USB接口的打印机,这是主流的打印机</dd>
		<dt>USB Wireless Device Management support<br>CONFIG_USB_WDM</dt><dd>为符合<a href="http://justmei.blog.163.com/blog/static/1160998532010321112522467/">CDC</a>(Communication Device CIass)和<a href="http://baike.baidu.com/view/397907.htm">WMC</a>(Wireless Mobile Communication)标准的手机提供WMC设备管理支持,这样你可以在这些手机上使用<a href="http://zh.wikipedia.org/wiki/%E6%B5%B7%E6%96%AF%E5%91%BD%E4%BB%A4%E9%9B%86">AT命令</a>(被所有调制解调器制造商采用的一个调制解调器命令语言).</dd>
		<dt>USB Test and Measurement Class support<br>CONFIG_USB_TMC</dt><dd><a href="http://www.eet-china.com/ART_8800424718_675277_TA_b4a8c334.HTM">USBTMC</a>(USB Test and Measurement Class)协议支持.主要适用于测试仪器的USB通信开发.不确定的选"N".</dd>
		<dt>USB Mass Storage support<br>CONFIG_USB_STORAGE</dt><dd>USB存储设备(U盘,USB硬盘,USB软盘,USB光盘,USB磁带,<a href="http://baike.baidu.com/view/26952.htm">记忆棒</a>,数码相机,<a href="http://baike.baidu.com/view/6239.htm">读卡器</a>[包括某些笔记本内置的SD卡读卡器]等等).该选项依赖于CONFIG_SCSI和CONFIG_BLK_DEV_SD选项.选"Y",除非你确实知道自己在干什么.</dd>
		<dd><dl>
			<dt>USB Mass Storage verbose debug<br>CONFIG_USB_STORAGE_DEBUG</dt><dd>仅供调试使用</dd>
			<dt class="omit">{省略的部分请按照自己实际使用的硬件选择(事实上大部分人都没有这些设备)}</dt>
		</dl></dd>
		<dt>USB Mustek MDC800 Digital Camera support<br>CONFIG_USB_MDC800</dt><dd>一款上世纪生产的数码相机</dd>
		<dt>Microtek X6USB scanner support<br>CONFIG_USB_MICROTEK</dt><dd>几款上世纪生产的扫描仪</dd>
	</dl></dd>
	<dt>DesignWare USB3 DRD Core Support<br>CONFIG_USB_DWC3</dt><dd>基于DesignWare USB3 IP核的USB3.0控制器.仅用于嵌入式环境.</dd>
	<dt>ChipIdea Highspeed Dual Role Controller<br>CONFIG_USB_CHIPIDEA</dt><dd>基于ChipIdea silicon IP核的USB2.0控制器.仅用于嵌入式环境.</dd>
	<dt>USS720 parport driver<br>CONFIG_USB_USS720</dt><dd>一种USB转并口的转换设备.不确定的选"N".</dd>
	<dt>USB Serial Converter support<br>CONFIG_USB_SERIAL</dt><dd>USB-串口转换支持:(1)USB-串口转换器,(2)连接在USB口上的串口设备.详情参见"<a href="https://www.kernel.org/doc/Documentation/usb/usb-serial.txt">Documentation/usb/usb-serial.txt</a>"文档.不确定的选"N".</dd>
	<dt class="omit">{此处省略的各种杂七杂八的USB设备,要么是老古董,要么是很罕见,不确定的可以全部选"N"}</dt>
	<dt>USB testing driver<br>CONFIG_USB_TEST</dt><dd>仅供调试使用</dd>
	<dt>USB DSL modem support<br>CONFIG_USB_ATM</dt><dd>USB DSL modem 已经是绝迹的古董猫了</dd>
	<dt>USB Physical Layer drivers<br>CONFIG_USB_PHY</dt><dd>这类设备仅在嵌入式系统上存在</dd>
	<dt>USB Gadget Support<br>CONFIG_USB_GADGET</dt><dd>USB是一个主/从协议,一个主机最多控制127个外设,其结构是非对称的,所以你无法把一个"到主机"的插头连接到外设上.Linux既可以在USB主机上运行,也可以在USB外设上运行.外设USB控制器可以是单独的芯片,也可以是集成在CPU中的微控制器,而常见的主机端控制器通常集成在芯片组的南桥中(xHCI/EHCI/OHCI/UHCI).如果你打算在外设中运行Linux,那么就必须开启此项,然后还需要为外设段的总线控制器配置一个硬件驱动,以及一个用于外设协议的"配件驱动".不过对于大多数人来说,并不将Linux运行于外设端,因此可以放心的选"N".仅那些嵌入式设备(例如智能手机)上运行的Linux才可能由此需求.</dd>
</dl></dd>


<dt>Ultra Wideband devices<br>CONFIG_UWB</dt><dd><a href="http://baike.baidu.com/view/5958.htm">UWB</a>(<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E5%AF%AC%E9%A0%BB">Ultra Wideband</a>)是一种高带宽,低能耗,点对点,抗干扰性能强的无载波通信技术.UWB在较宽的频谱(3.1-10.6GHz)上,使用极低的功率(约为蓝牙的1/20),以时间间隔极短(小于1ns)的脉冲信号进行通信.UWB主要应用于室内通信(2米范围内实现480Mbps速率,10米范围内实现110Mbps速率),例如<a href="http://news.mydrivers.com/1/130/130214.htm">作为WUSB(Wireless USB)协议的传输层</a>.如果你有UWB无线控制器,可以选"Y",不确定的选"N".详见"<a href="https://www.kernel.org/doc/Documentation/usb/WUSB-Design-overview.txt">Documentation/usb/WUSB-Design-overview.txt</a>"文档.</dd>


<dt>MMC/SD/SDIO card support<br>CONFIG_MMC</dt><dd><a href="http://baike.baidu.com/view/8802.htm">MMC</a>(<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94%E8%A8%98%E6%86%B6%E5%8D%A1">MultiMediaCard</a>)/<a href="http://baike.baidu.com/view/2228.htm">SD</a>(<a href="http://zh.wikipedia.org/wiki/SD%E5%8D%A1">Secure Digital</a>)/<a href="http://baike.baidu.com/view/1456746.htm">SDIO</a>(<a href="http://wenku.baidu.com/view/187c0ad1240c844769eaee19">Secure Digital I/O</a>)主机控制器。[提示]虽然许多笔记本上有SD卡插槽,但其实它们大多使用的是CONFIG_USB_STORAGE驱动,而不是这里的驱动.</dd>
<dd><dl>
	<dt>MMC debugging<br>CONFIG_MMC_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>Assume MMC/SD cards are non-removable (DANGEROUS)<br>CONFIG_MMC_UNSAFE_RESUME</dt><dd>假定在系统休眠的过程中,所有MMC/SD/SDIO卡依然插在各自的插槽上没有变动.也许只有嵌入式系统才可以做这样的假定.不确定的选"N".参见CONFIG_USB_DEFAULT_PERSIST选项.</dd>
	<dt>MMC host clock gating<br>CONFIG_MMC_CLKGATE</dt><dd>尝试激进的"gate the clock to the MMC card"(啥意思?).这样当MMC卡不使用的时候,就可以进入节电状态.主机控制器必须支持此特性.不确定的选"N".</dd>
	<dt>MMC block device driver<br>CONFIG_MMC_BLOCK</dt><dd>MMC块设备驱动.基本上MMC卡都是作为块设备(就像U盘一样)使用.所以只要使用MMC卡就应该开启.</dd>
	<dd><dl>
		<dt>Number of minors per block device<br>CONFIG_MMC_BLOCK_MINORS</dt><dd>为每个MMC块设备保留的次设备号数量.取值范围是[4,256].这里设置的值应该等于"最大可能的分区数+1".因为总的次设备号只有256个,所以最大能支持的MMC块设备数量就等于256除以此处设置的值.默认值"8"可以保证最大的向后兼容性.不确定的请保持默认值.</dd>
		<dt>Use bounce buffer for simple hosts<br>CONFIG_MMC_BLOCK_BOUNCE</dt><dd>为SD/MMC控制器提供更多的缓存(最大64KB),从而可以大幅提升其性能.建议选"Y".</dd>
	</dl></dd>
	<dt>SDIO UART/GPS class support<br>CONFIG_SDIO_UART</dt><dd>实现了<a href="http://zh.wikipedia.org/wiki/UART">UART</a>类的SDIO卡支持.包括那些表现的像UART一样的<a href="http://baike.baidu.com/view/7773.htm">GPS</a>类支持.主要用于嵌入式设备.不确定的选"N".</dd>
	<dt>MMC host test driver<br>CONFIG_MMC_TEST</dt><dd>仅供调试使用</dd>
	<dt>Secure Digital Host Controller Interface support<br>CONFIG_MMC_SDHCI</dt><dd>通用SD主控支持.笔记本电脑上用的SD主控(TI(德州仪器)/Ricoh(理光)/Toshiba(东芝)等厂商)基本上都是这个驱动.选中此项后,还需要选中相应的总线驱动(见下,通常是CONFIG_MMC_SDHCI_PCI).</dd>
	<dt>SDHCI support on PCI bus<br>CONFIG_MMC_SDHCI_PCI</dt><dd>PCI总线的SD主控支持,目前的笔记本的SD主控基本都接在PCI总线上.</dd>
	<dd><dl>
		<dt>Ricoh MMC Controller Disabler<br>CONFIG_MMC_RICOH_MMC</dt><dd>用于修正Ricoh(理光)MMC主控的bug,如果你需要使用Ricoh主控,就选"Y".</dd>
	</dl></dd>
	<dt>SDHCI support for ACPI enumerated SDHCI controllers<br>CONFIG_MMC_SDHCI_ACPI</dt><dd>专用于"ACPI Compatibility ID"等于"PNP0D40"的SD主控,以及"ACPI Hardware ID"等于"INT33C6,INT33BB,80860F14"的SD主控.</dd>
	<dt>SDHCI platform and OF driver helper<br>CONFIG_MMC_SDHCI_PLTFM</dt><dd>基于<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform</a>总线和<a href="http://www.openfirmware.org/">OpenFirmware</a>的SD主控.</dd>
	<dt class="omit">{此处省略的SD主控请按照实际使用的芯片进行选择}</dt>
	<dt>MMC/SD/SDIO over SPI<br>CONFIG_MMC_SPI</dt><dd>基于SPI总线的MMC/SD/SDIO主控.仅用于嵌入式环境.</dd>
</dl></dd>


<dt>Sony MemoryStick card support<br>CONFIG_MEMSTICK</dt><dd>Sony<a href="http://zh.wikipedia.org/wiki/Memory_Stick">记忆棒</a>是一种Sony专用的存储设备.</dd>
<dd><dl>
	<dt>MemoryStick debugging<br>CONFIG_MEMSTICK_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>Allow unsafe resume (DANGEROUS)<br>CONFIG_MEMSTICK_UNSAFE_RESUME</dt><dd>假定在系统休眠的过程中,所有记忆棒依然插在各自的插槽上没有变动.也许只有嵌入式系统才可以做这样的假定.不确定的选"N".参见CONFIG_USB_DEFAULT_PERSIST选项.</dd>
	<dt>MemoryStick Pro block device driver<br>CONFIG_MSPRO_BLOCK</dt><dd>"Memory Stick PRO"是SONY从2003开始引入的升级版标准,早已成为主流,所以应该选"Y"(除非你仍在使用十年前的老VAIO笔记本).</dd>
	<dt class="omit">{此处省略的MemoryStick主控请按照实际使用的芯片进行选择}</dt>
</dl></dd>


<dt>LED Support<br>CONFIG_NEW_LEDS</dt><dd>发光二级管(LED)支持.[提示]标准键盘上的LED灯不在此列(由input子系统控制)</dd>


<dt>Accessibility support<br>CONFIG_ACCESSIBILITY</dt><dd>无障碍(Accessibility)支持.各种帮助残疾人使用计算机的软硬件技术.例如:盲文设备,语音合成,键盘映射,等等.</dd>


<dt>InfiniBand support<br>CONFIG_INFINIBAND</dt><dd><a href="http://server.it168.com/a2012/0924/1401/000001401869_all.shtml">InfiniBand</a>是一种低延迟/高带宽数据中心互联架构,采用远程直接内存存取(RDMA)实现高性能处理器间通信(IPC),同时对虚拟化技术也提供了良好的支持.主要用于服务器集群与高性能计算(HPC)领域.</dd>


<dt>EDAC (Error Detection And Correction) reporting<br>CONFIG_EDAC</dt><dd>在电磁环境比较恶劣的情况下,一些大规模集成电路常常会受到干扰,特别是像<a href="http://baike.baidu.com/view/943101.htm">RAM</a>这种利用双稳态进行存储的器件,往往会在强干扰下发生翻转,使原来存储的"0"变为"1",或者"1"变为"0",造成严重的后果(例如控制程序跑飞,关键数据出错).随着芯片集成度的增加,发生错误的可能性也在增大,这已经成为一个不能忽视的问题.错误检测与纠正(<a href="http://blog.163.com/somen111@126/blog/static/115586684201356451437/">EDAC</a>)技术的目标就是发现并报告甚至纠正在计算机系统中发生的错误,这些错误是由CPU或芯片组报告的底层错误(内存错误/缓存错误/PCI错误/温度过高,等等),建议选"Y".如果这些代码报告了一个错误,请到<a href="http://bluesmoke.sourceforge.net/">http://bluesmoke.sourceforge.net/</a>和<a href="http://buttersideup.com/edacwiki">http://buttersideup.com/edacwiki</a>查看更多信息.详见"<a href="https://www.kernel.org/doc/Documentation/edac.txt">Documentation/edac.txt</a>"文档.</dd>
<dd><dl>
	<dt>EDAC legacy sysfs<br>CONFIG_EDAC_LEGACY_SYSFS</dt><dd>仅在你需要使用老版本<a href="http://sourceforge.net/projects/edac-utils/">edac-utils</a>的情况下才需要选"Y".</dd>
	<dt>Debugging<br>CONFIG_EDAC_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>Decode MCEs in human-readable form (only on AMD for now)<br>CONFIG_EDAC_DECODE_MCE</dt><dd>将<a href="http://ilinuxkernel.com/?p=303">MCE</a>(<a href="http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&docname=c02691010">Machine Check Exception</a>)解码为人类可读的形式(目前仅支持AMD).建议选"Y".</dd>
	<dd><dl>
		<dt>Simple MCE injection interface over /sysfs<br>CONFIG_EDAC_MCE_INJ</dt><dd>仅供调试使用</dd>
	</dl></dd>
	<dt>Main Memory EDAC (Error Detection And Correction) reporting<br>CONFIG_EDAC_MM_EDAC</dt><dd>一些系统能够检测和修正主内存中的错误,EDAC能够报告这些信息(EDAC自己检测到的或者根据<a href="http://baike.baidu.com/view/93728.htm">ECC</a>得到的).EDAC还会尽量检测这些错误发生在哪里以便于替换损坏的内存.建议选"Y"并按照你实际硬件状况选取子项</dd>
	<dd><dl>
		<dt>Output ACPI APEI/GHES BIOS detected errors via EDAC<br>CONFIG_EDAC_GHES</dt><dd>并不是所有机器都提供基于硬件的EDAC技术,有部分机器提供的是基于ACPI BIOS的报告机制(使用CONFIG_ACPI_APEI_GHES驱动).开启此项后,如果检测到GHES BIOS,那么CONFIG_ACPI_APEI_GHES驱动提供的错误报告将会通过EDAC API发送到用户空间,同时,硬件EDAC也会被禁用,也就是进入"固件优先"模式.注意:GHES BIOS和硬件EDAC两者不能共存,因为BIOS和操作系统在读取error寄存器时会相互竞争.所以如果你不想使用"固件优先"模式,应该选"N",或者使用"ghes.disable=1"内核引导参数.否则应该选"Y".</dd>
		<dt class="omit">{此处省略的芯片请按照实际情况选择}</dt>
	</dl></dd>
</dl></dd>


<dt>Real Time Clock<br>CONFIG_RTC_CLASS</dt><dd>通用<a href="http://zh.wikipedia.org/wiki/%E5%AF%A6%E6%99%82%E6%99%82%E9%90%98">RTC</a>(实时时钟)类支持.所有的PC机主板都包含一个电池动力的<a href="http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime2/index.html">实时时钟芯片</a>,以便在断电后仍然能够继续保持时间,RTC通常与<a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94">CMOS</a>集成在一起,因此BIOS可以从中读取当前时间(精度一般是秒级).选中此项后你就可以在操作系统中使用一个或多个RTC设备(你还必须从下面启用一个或多个RTC接口).[注意]Clock与Timer没有任何关系,Timer是定时器(用于计量时长),Clock是时钟(用于记录当前的时刻"年-月-日 时:分:秒")</dd>
<dd><dl>
	<dt>Set system time from RTC on startup and resume<br>CONFIG_RTC_HCTOSYS</dt><dd>系统启动时从指定的RTC设备(CONFIG_RTC_HCTOSYS_DEVICE)中读取时间,以设定系统时间,这将有助于避免时间不准导致的麻烦(例如不必要的文件系统检测(fsck)以及网络故障).建议选"Y".</dd>
	<dt>Set the RTC time based on NTP synchronization<br>CONFIG_RTC_SYSTOHC</dt><dd>如果用户空间报告了"<a href="http://baike.baidu.com/view/60648.htm">NTP</a>已同步",那么每隔大约11分钟,内核将会自动把系统时间写入指定的RTC设备(CONFIG_RTC_HCTOSYS_DEVICE)中.建议选"Y".</dd>
	<dd><dl>
		<dt>RTC used to set the system time<br>CONFIG_RTC_HCTOSYS_DEVICE</dt><dd>默认的RTC设备(通常是"rtc0").该设备的驱动必须静态编译进内核(而不能作为模块加载).</dd>
	</dl></dd>
	<dt>RTC debug support<br>CONFIG_RTC_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>/sys/class/rtc/rtcN (sysfs)<br>CONFIG_RTC_INTF_SYSFS</dt><dd>允许通过sysfs接口使用RTC,允许多个RTC设备,也就是/sys/class/rtc/rtc0~N</dd>
	<dt>/proc/driver/rtc (procfs for rtcN)<br>CONFIG_RTC_INTF_PROC</dt><dd>允许通过proc接口使用RTC,仅允许一个RTC设备,也就是/proc/driver/rtc(若有多个RTC设备,则其将对应"rtc0")</dd>
	<dt>/dev/rtcN (character devices)<br>CONFIG_RTC_INTF_DEV</dt><dd>允许通过dev接口使用RTC,允许多个RTC设备,也就是/dev/rtc0~N,某些程序(比如<a href="http://baike.baidu.com/view/4808064.htm">hwclock</a>)需要使用/dev/rtc(这是个软连接,udev会自动将其指向默认的RTC设备)</dd>
	<dd><dl>
		<dt>RTC UIE emulation on dev interface<br>CONFIG_RTC_INTF_DEV_UIE_EMUL</dt><dd>如果底层rtc芯片驱动没有提供RTC_UIE就仿真一个RTC_UIE.选"N",除非你确实知道自己在做什么.</dd>
	</dl></dd>
	<dt>Test driver/device<br>CONFIG_RTC_DRV_TEST</dt><dd>仅供调试使用</dd>
	<dt class="omit">{此处省略的其他RTC设备一般仅用于非PC环境}</dt>
	<dt>PC-style 'CMOS'<br>CONFIG_RTC_DRV_CMOS</dt><dd>这是所有PC和基于ACPI的系统通用的RTC驱动.必须选"Y"(不能选"M"),除非你是嵌入式系统.</dd>
</dl></dd>


<dt>DMA Engine support<br>CONFIG_DMADEVICES</dt><dd>DMA引擎(<a href="http://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> Engine)可以看做是传统DMA控制器(DMA controller)的新生.在DMA引擎的协助下,CPU只需初始化一个传输动作,其余的动作就可以由DMA引擎独立完成(完成后以中断的方式通知CPU),这对于高速传输大量数据以及"分散-收集"操作大有益处,可以节约大量的CPU资源(有时也可节约大量的内存操作).目前,DMA引擎有两个用途:(1)卸载高速网络栈中的内存COPY操作,(2)加速CONFIG_MD_RAID456驱动中的RAID操作."DMA引擎"只是一个统称,在不同场合对应着不同的技术,例如<a href="http://www.intel.cn/content/www/cn/zh/wireless-network/accel-technology.html">Intel I/OAT</a>(PC平台)和<a href="http://baike.baidu.com/view/1362076.htm">AHB</a>(嵌入式).[提示]历史上,ISA架构的电脑都有一个专用的"DMA控制器"(最常见的是<a href="http://en.wikipedia.org/wiki/Intel_8237">Intel 8237</a>),但是到了PCI架构,由于每一个PCI设备都可以控制PCI总线(成为"<a href="http://en.wikipedia.org/wiki/Bus_mastering">bus master</a>")并直接读写系统内存,所以虽然DMA的操作方式依然存在,但是"DMA控制器"却消失了.现在新生的"DMA引擎"目前仍然主要出现在<a href="http://cateee.net/lkddb/web-lkddb/DMADEVICES.html">Intel的高端芯片</a>上.</dd>
<dd><dl>
	<dt>DMA Engine debugging<br>CONFIG_DMADEVICES_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>Intel MID DMA support for Peripheral DMA controllers<br>CONFIG_INTEL_MID_DMAC</dt><dd>Intel <a href="http://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E8%81%AF%E7%B6%B2%E8%A3%9D%E7%BD%AE">MID</a> DMA引擎,搭配Atom处理器使用.</dd>
	<dt>Intel integrated DMA 64-bit support<br>CONFIG_INTEL_IDMA64</dt><dd>为Intel低功耗子系统(Intel Low Power Subsystem)中整合的64位DMA提供支持.Intel <a href="http://www.expreview.com/42154-all.html">Skylake</a> <a href="http://www.expreview.com/42166.html">PCH</a> 就是一个支持Intel低功耗子系统的例子.</dd>
	<dt>Intel I/OAT DMA support<br>CONFIG_INTEL_IOATDMA</dt><dd>带有<a href="http://www.intel.cn/content/www/cn/zh/wireless-network/accel-technology.html">英特尔I/O加速技术</a>(<a href="http://cateee.net/lkddb/web-lkddb/INTEL_IOATDMA.html">I/O Acceleration Technology</a>)的至强芯片组DMA引擎</dd>
	<dt>Synopsys DesignWare AHB DMA support<br>CONFIG_DW_DMAC</dt><dd>基于<a href="http://www.synopsys.com.cn/products-and-solutions/ip">Synopsys DesignWare</a> IP核的<a href="http://baike.baidu.com/view/1362076.htm">AHB</a>总线DMA引擎.例如<a href="http://www.atmel.com/zh/cn/">Atmel</a> <a href="http://www.eet-china.com/ART_8800458944_617693_NP_375c2322.HTM">AT32ap7000</a>中就整合了这个引擎.</dd>
	<dt>Timberdale FPGA DMA support<br>CONFIG_TIMB_DMA</dt><dd>Timberdale FPGA DMA引擎."Timberdale FPGA"是一个多功能设备,出现在基于Intel Atom的车载信息娱乐系统<a href="http://wiki.meego.com/In-vehicle">IVI(In-Vehicle Infotainment)</a>上.</dd>
	<dt>Intel EG20T PCH / LAPIS Semicon IOH(ML7213/ML7223/ML7831) DMA<br>CONFIG_PCH_DMA</dt><dd>所有与<a href="http://www.youcpu.com/chipset/Intel-Platform-Controller-Hub-EG20T-Intel-EG20T-PCH">Intel EG20T PCH</a>兼容的芯片的DMA引擎支持,具体型号可以查看内核帮助.都是嵌入式芯片.</dd>
	<dt>Network: TCP receive copy offload<br>CONFIG_NET_DMA</dt><dd>通过在网络栈中利用DMA引擎来减少接收数据包时的copy-to-user操作以释放CPU资源,仅在CONFIG_INTEL_IOATDMA开启的前提下才有意义.</dd>
	<dt>Async_tx: Offload support for the async_tx api<br>CONFIG_ASYNC_TX_DMA</dt><dd>如果你开启了CONFIG_MD_RAID456,同时你的硬件又支持DMA引擎,那么开启此项后可以加速RAID操作.</dd>
	<dt>DMA Test client<br>CONFIG_DMATEST</dt><dd>仅供调试使用</dd>
</dl></dd>


<dt>Auxiliary Display support<br>CONFIG_AUXDISPLAY</dt><dd>辅助显示设备.例如基于<a href="http://blog.sina.com.cn/s/blog_4a3946360100obaf.html">KS0108</a>控制器的<a href="http://www.crystalfontz.com/product/CFAG12864BTFHV">Crystalfontz CFAG12864B</a>单色液晶屏(分辨率:128x64).仅用于嵌入式系统.</dd>


<dt>Userspace I/O drivers<br>CONFIG_UIO</dt><dd><a href="http://baike.baidu.com/view/8975902.htm">UIO</a>(Userspace I/O)是运行在用户空间的I/O技术,它为开发用户空间的驱动提供了一个简单的架构(/dev/uioN).使用uio的设备一般都属于嵌入式系统.不确定的选"N".[提示]<a href="http://www.osadl.org/projects/downloads/UIO/user/">lsuio</a>工具可以列出所有UIO的模块和其映射的内存地址.</dd>


<dt>VFIO Non-Privileged userspace driver framework<br>CONFIG_VFIO</dt><dd><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/vfio">VFIO</a>是一套无特权用户空间I/O驱动框架,需要有<a href="http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware">IOMMU虚拟化硬件</a>支持(AMD-Vi/<a href="http://software.intel.com/zh-cn/articles/io-vt-d-io">Intel VT-d</a>).此选项仅用于宿主机内核.VFIO的目标是在IOMMU硬件的帮助下,取代CONFIG_UIO和CONFIG_KVM_DEVICE_ASSIGNMENT.VFIO主要用于编写高效的用户态驱动,以及在虚拟化环境的属主机中高效的实现<a href="http://blog.csdn.net/halcyonbaby/article/details/37776211">设备直通(passthrough)</a>且无须root特权,可用于详见"<a href="https://www.kernel.org/doc/Documentation/vfio.txt">Documentation/vfio.txt</a>"文档.[提示]<a href="http://wiki.qemu.org/ChangeLog/1.3">QEMU 1.3</a>以上版本才能利用VFIO特性.不玩KVM虚拟化的选"N".</dd>
<dd><dl>
	<dt>VFIO support for PCI devices<br>CONFIG_VFIO_PCI</dt><dd>允许PCI设备使用VFIO框架.这是VFIO框架当前的主要用途.选"Y".</dd>
	<dd><dl>
		<dt>VFIO PCI support for VGA devices<br>CONFIG_VFIO_PCI_VGA</dt><dd>让VFIO PCI支持VGA扩展,此选项依赖于CONFIG_VGA_ARB,建议选"Y".</dd>
	</dl></dd>
</dl></dd>


<dt>Virtualization drivers<br>CONFIG_VIRT_DRIVERS</dt><dd>这个选项仅对<a href="http://baike.baidu.com/view/405903.htm">PowerPC</a>架构有意义</dd>


<dt>Virtio drivers</dt><dd>仅可用于客户机内核的<a href="http://smilejay.com/2012/11/virtio-overview/">Virtio</a>驱动.<a href="http://www.linux-kvm.org/page/Virtio">Virtio</a>的目标是为各种半虚拟化的<a href="http://www.ibm.com/developerworks/cn/linux/l-hypervisor/">虚拟机管理程序</a>(特别是<a href="http://smilejay.com/kvm_theory_practice/">KVM</a>)提供一组通用的模拟设备,目前已实现:network/block/balloon/console/hw_random,未来还会实现更多.下列驱动仅可用在基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的半虚拟化客户机中(一般是<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>).</dd>
<dd><dl>
	<dt>PCI driver for virtio devices<br>CONFIG_VIRTIO_PCI</dt><dd>半虚拟化PCI设备驱动.VMM(虚拟机管理程序)必须要有相应的"PCI virtio backend".基于QEMU的VMM(KVM,Xen)一般都支持该驱动.[提示]由于目前的ABI尚不稳定,建议使用时注意版本匹配.</dd>
	<dt>Virtio balloon driver<br>CONFIG_VIRTIO_BALLOON</dt><dd><a href="http://smilejay.com/2012/11/kvm-ballooning-overview/">balloon</a>驱动支持按需扩展或减少KVM客户机内的内存大小.</dd>
	<dt>Platform bus driver for memory mapped virtio devices<br>CONFIG_VIRTIO_MMIO</dt><dd>支持使用内存映射机制的virtio设备驱动</dd>
	<dd><dl>
		<dt>Memory mapped virtio devices parameter parsing<br>CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES</dt><dd>允许通过"virtio_mmio.device"内核模块参数实例化virtio-mmio设备.注意,错误的参数(特别是"baseaddr"错误)会导致系统崩溃.详见"<a href="https://www.kernel.org/doc/Documentation/kernel-parameters.txt">Documentation/kernel-parameters.txt</a>"文档中对"virtio_mmio.device"的说明.</dd>
	</dl></dd>
</dl></dd>


<dt>Microsoft Hyper-V guest support</dt><dd>仅在将此Linux内核作为<a href="http://technet.microsoft.com/zh-cn/library/hh831531.aspx">微软Hyper-V虚拟机</a>的来宾操作系统运行时,才需要开启这里的选项.</dd>
<dd><dl>
	<dt>Microsoft Hyper-V client drivers<br>CONFIG_HYPERV</dt><dd>将Linux内核作为Hyper-V的来宾操作系统运行</dd>
	<dd><dl>
		<dt>Microsoft Hyper-V Utilities driver<br>CONFIG_HYPERV_UTILS</dt><dd><a href="http://technet.microsoft.com/zh-cn/library/cc794756.aspx">Hyper-V管理工具</a>驱动.</dd>
		<dt>Microsoft Hyper-V Balloon driver<br>CONFIG_HYPERV_BALLOON</dt><dd>Hyper-V <a href="http://technet.microsoft.com/zh-cn/library/hh831766.aspx">Balloon</a>驱动</dd>
	</dl></dd>
</dl></dd>


<dt>Xen driver support</dt><dd>仅在将此Linux内核作为半虚拟化模式的<a href="http://cn.opensuse.org/Xen%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%80%E4%BB%8B">XEN虚拟机</a>的来宾操作系统运行时,才需要开启这里的选项.由于KVM的高歌猛进,特别是Ubuntu和Redhat的力挺,与昔日的辉煌相比,<a href="http://virtual.51cto.com/art/201212/375071.htm">XEN现在已经没落许多了</a>.</dd>


<dt>Staging drivers<br>CONFIG_STAGING</dt><dd>尚在开发中或尚未完成的,目前尚不完善的驱动,切勿用于生产环境.仅供测试人员或者开发者试用.</dd>


<dt>X86 Platform Specific Device Drivers<br>CONFIG_X86_PLATFORM_DEVICES</dt><dd>特定于X86平台的设备驱动.例如很多笔记本厂商的专有硬件和特色功能.大多数笔记本用户都应该进去看看(简单易懂,一看即知).</dd>
<dd><dl>
	<dt class="omit">{此处省略所有特定于笔记本厂商的驱动}</dt>
	<dt>Thermal Management driver for Intel menlow platform<br>CONFIG_INTEL_MENLOW</dt><dd>此驱动专用于<a href="http://www.inpai.com.cn/doc/hard/105589.htm">Intel Menlow</a>平台(搭配Atom处理器),提供了增强的ACPI热量管理能力.</dd>
	<dt>WMI<br>CONFIG_ACPI_WMI</dt><dd>ACPI-WMI(<a href="http://technet.microsoft.com/zh-cn/library/ee692772.aspx">Windows管理规范</a>)映射设备(find /sys/devices/ -name "PNP0C14*")支持.<a href="http://en.wikipedia.org/wiki/Windows_Management_Instrumentation">WMI</a>是微软对ACPI规范的专有扩展,可将部分ACPI固件内容通过PNP0C14设备映射到用户空间,以方便用户空间调用ACPI固件的功能.本选项仅为那些依赖于WMI的驱动提供支持(并不真正导出到用户空间),例如CONFIG_DRM_NOUVEAU驱动以及专用于Acer/Asus/Dell/MSI/HP等品牌笔记本的WMI驱动.</dd>
	<dt>Intel Intelligent Power Sharing<br>CONFIG_INTEL_IPS</dt><dd>Intel <a href="http://baike.baidu.com/view/1502112.htm">Calpella</a>平台支持Intel的智能电源共享(Intelligent Power Sharing)技术,可以在保持功耗不变的前提下,在CPU和GPU之间智能分配电力.开启此项和CONFIG_CPU_FREQ以及CONFIG_DRM_I915之后,即可实现此功能.</dd>
	<dt>WMI support for MXM Laptop Graphics<br>CONFIG_MXM_WMI</dt><dd><a href="http://baike.baidu.com/view/776209.htm">MXM接口</a>笔记本显卡的WMI支持.目前主要用于nvidia显卡.</dd>
	<dt>Intel Oaktrail Platform Extras<br>CONFIG_INTEL_OAKTRAIL</dt><dd>Intel <a href="http://baike.baidu.com/view/4045526.htm">Oak Trail</a>嵌入式平台需要此驱动来开关WiFi/相机/蓝牙等设备.</dd>
	<dt>Intel Rapid Start Technology Driver<br>CONFIG_INTEL_RST</dt><dd><a href="http://www.360doc.com/content/13/1117/08/14641369_329810630.shtml">英特尔快速启动技术</a>(<a href="http://tieba.baidu.com/p/2335330015">Intel Rapid Start Technology</a>)通过在SSD上建立与本机内存容量一致的休眠分区,在休眠时将内存数据保存到SSD休眠分区上,从而实现快速唤醒.</dd>
	<dt>Intel Smart Connect disabling driver<br>CONFIG_INTEL_SMARTCONNECT</dt><dd>禁用<a href="http://baike.baidu.com/view/10453085.htm">英特尔智能连接技术</a>(<a href="http://www.dell.com/support/article/tw/en/twdhs1/SLN262060/zh">Intel Smart Connect Technology</a>)的驱动.此技术旨在通过定期将处于睡眠/待机状态的PC唤醒一小段时间,联网一段时间让应用程序(如电子邮件)更新,但是不打开屏幕,然后又自动回到睡眠状态,以此循环重复.这意味着,当您唤醒PC时,程序数据已经处于最新状态.主要针对超级本用户且需要BIOS支持,必须在BIOS中将Intel Smart Connect Technology设为"Enabled".如果你的超级本支持此技术且同时安装了Windows系统,那么务必选"Y".</dd>
	<dt>pvpanic device support<br>CONFIG_PVPANIC</dt><dd>pvpanic是<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-qemu-monitor/">QEMU</a>提供的一种准虚拟化(paravirtualized)设备,允许客户机向宿主机报告panic事件.此驱动仅可用于客户机内核.</dd>
	<dt>Intel PMC IPC Driver<br>CONFIG_INTEL_PMC_IPC</dt><dd>为某些Intel平台的PMC控制器提供支持.这里的"PMC"是一个RISC架构的32位<a href="http://book.2cto.com/201511/57901.html">ARC处理器</a>(Argonaut RISC Core processor).不确定的选"N".</dd>
</dl></dd>


<dt>Platform support for Chrome hardware<br>CONFIG_CHROME_PLATFORMS</dt><dd>专用于Google公司的<a href="http://www.zhihu.com/question/19657427">Chromebook</a>笔记本/<a href="http://tech2ipo.com/64234">Chromebox</a>迷你机的设备驱动.</dd>


<dt>Common Clock Framework</dt><dd>CCF(<a href="http://lwn.net/Articles/472998/">Common Clock Framework</a>)是从3.4内核开始引入的新时钟框架,用于取代原有的"Clock Framework".详见"<a href="https://www.kernel.org/doc/Documentation/clk.txt">Documentation/clk.txt</a>"文档.这里还有一个<a href="http://events.linuxfoundation.org/images/stories/slides/elc2013_clement.pdf">讲解CCF的PDF</a>.</dd>
<dd><dl>
	<dt>DebugFS representation of clock tree<br>CONFIG_COMMON_CLK_DEBUG</dt><dd>仅供调试使用</dd>
	<dt class="omit">{此处省略的时钟设备请按实际情况选择(主要用于嵌入式设备)}</dt>
</dl></dd>


<dt>Hardware Spinlock drivers</dt><dd>硬件<a href="http://blog.chinaunix.net/uid-20543672-id-3252604.html">自旋锁</a>驱动.目前仅出现在嵌入式处理器上.自旋锁是保护共享资源的一种锁机制,与互斥锁比较类似,都是为了解决对某项资源的互斥使用.无论是互斥锁,还是自旋锁,在任何时刻,最多只能有一个持有者.也就是说,在任何时刻最多只能有一个执行单元获得锁.但是两者在调度机制上略有不同,对于互斥锁,如果资源已经被占用,资源申请者只能进入睡眠状态.但是自旋锁不会引起申请者睡眠,如果自旋锁已经被别的执行单元保持,调用者就一直在循环中"忙等"(占用CPU但无事可做),直到该自旋锁被释放."自旋"一词就是因此而得名.自旋锁的使用非常方便,但仅适用于需要极短时间锁定的场合(例如1毫秒),以避免消耗太多的CPU空等时间.</dd>


<dt>Clock Source drivers</dt><dd>"时钟源"驱动.主要面向嵌入式设备.</dd>


<dt>Mailbox Hardware Support<br>CONFIG_MAILBOX</dt><dd>Mailbox硬件支持.这里的"Mailbox"是一个框架,通过消息队列和中断驱动信号,控制芯片上的多个处理器之间的通信.仅用于嵌入式环境.</dd>


<dt>IOMMU Hardware Support<br>CONFIG_IOMMU_SUPPORT</dt><dd><a href="http://en.wikipedia.org/wiki/IOMMU">IOMMU</a>硬件主要出现在<a href="http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware">带有I/O虚拟化技术的硬件</a>上,例如带有<a href="http://www.amd.com/cn/products/server/processors/Pages/amd-platform-specifications.aspx">AMD-Vi</a>或<a href="http://software.intel.com/zh-cn/articles/io-vt-d-io">VT-d</a>技术的芯片.IOMMU主要作用:(1)内存地址转换(例如DMA地址转换,scatter-gather),(2)中断重映射,(3)对设备读取和写入的进行权限检查.这对于提高虚拟化性能和安全性,以及在64位系统上更好的使用32位设备,意义重大.[提示]此选项仅对宿主机有意义,如果此内核要作为来宾操作系统运行,请选"N".</dd>
<dd><dl>
	<dt>AMD IOMMU support<br>CONFIG_AMD_IOMMU</dt><dd>AMD IOMMU 硬件支持.一般还需要在BIOS中开启相应选项.</dd>
	<dd><dl>
		<dt>Export AMD IOMMU statistics to debugfs<br>CONFIG_AMD_IOMMU_STATS</dt><dd>仅供调试使用</dd>
		<dt>AMD IOMMU Version 2 driver<br>CONFIG_AMD_IOMMU_V2</dt><dd>新一代的AMD IOMMUv2硬件(支持PCI PRI和PASID接口)支持.首次出现在AMD Opteron 4000/6000系列平台上.</dd>
	</dl></dd>
	<dt>Support for Intel IOMMU using DMA Remapping Devices<br>CONFIG_INTEL_IOMMU</dt><dd>让Intel IOMMU支持DMA重映射,这是IOMMU的主要用途,只要你的芯片支持VT-d,就选"Y".</dd>
	<dd><dl>
		<dt>Support for Shared Virtual Memory with Intel IOMMU<br>CONFIG_INTEL_IOMMU_SVM</dt><dd><a href="http://server.zdnet.com.cn/files/all-1543447.htm">共享虚拟内存</a>(<a href="http://blog.csdn.net/zhangoi391/article/details/41674029">SVM</a>, Shared Virtual Memory)允许不同设备(例如CPU与GPU)以PASID(Process Address Space ID)为各自的身份标识,统一使用CPU地址空间访问系统内存的DMA资源,也就是<a href="http://diy.pconline.com.cn/485/4850158.html">内存统一寻址</a>,以提升异构计算性能.<a href="http://news.mydrivers.com/1/307/307829.htm">传说Skylake会支持SVM</a>.</dd>
		<dt>Enable Intel DMA Remapping Devices by default<br>CONFIG_INTEL_IOMMU_DEFAULT_ON</dt><dd>默认开启DMA重映射支持,相当于设置"intel_iommu=on"内核引导参数.选"Y".</dd>
	</dl></dd>
	<dt>Support for Interrupt Remapping<br>CONFIG_IRQ_REMAP</dt><dd>支持对IO-APIC和MSI设备开启中断重映射,这也是IOMMU的主要用途,只要你的芯片支持VT-d,就选"Y".</dd>
</dl></dd>


<dt>Remoteproc drivers</dt><dd>现代的SoC芯片一般都会以<a href="http://baike.baidu.com/view/6350155.htm">AMP</a>(<a href="http://www.go-gddq.com/html/QiTa-ZongHe_tx/2012-04/946163.htm">非对称多处理器</a>)方式集成多个不同的处理器(例如<a href="http://www.ti.com.cn/general/cn/docs/wtbu/wtbuproductcontent.tsp?templateId=6123&navigationId=12864&contentId=103103">OMAP5432</a>就在单个芯片上集成了2个Cortex-A15处理器,2个Cortex-M4处理器,1个C64x DSP),这样就可在不同的处理器上分别运行多个不同的操作系统实例(例如,在2个Cortex-A9处理器上以SMP(对称多处理器)方式运行Linux,在2个Cortex-M3和1个C64x上分别运行不同的实时操作系统).而Remoteproc驱动对此种场合下的处理器间通信非常有用.详见"<a href="https://www.kernel.org/doc/Documentation/remoteproc.txt">Documentation/remoteproc.txt</a>"和"<a href="https://www.kernel.org/doc/Documentation/rpmsg.txt">Documentation/rpmsg.txt</a>"文档.目前仅对嵌入式系统有意义.不确定的选"N".</dd>


<dt>Rpmsg drivers</dt><dd>此项和上面的Remoteproc紧密相关,目前其下尚无子项可选.</dd>


<dt>SOC (System On Chip) specific Drivers</dt><dd>专用于单片机的设备驱动.皆为嵌入式系统.</dd>


<dt>Generic Dynamic Voltage and Frequency Scaling (DVFS) support<br>CONFIG_PM_DEVFREQ</dt><dd>DVFS(<a href="http://www.360doc.com/content/09/0710/14/74585_4212349.shtml">动态电压与频率调整</a>)可以根据系统负载动态调节设备的运行频率和电压(对于同一芯片,频率越高,需要的电压也越高),从而达到节能目的.此选项提供了一个类似CPUfreq(CONFIG_CPU_FREQ)的通用DVFS框架(devfreq).目前DVFS技术进在嵌入式设备(例如Exynos4/Exynos5)上普遍存在.不确定的选"N".</dd>


<dt>External Connector Class (extcon) support<br>CONFIG_EXTCON</dt><dd>extcon(外部连接器类)允许用户空间通过sysfs和uevent监控外部连接器,同时也支持多状态外部连接器(也就是拥有多个连接线缆的外部连接器).例如,一端连接到主机USB端口的多状态外部连接器,另一端可以同时连接一条<a href="http://baike.baidu.com/view/50611.htm">HDMI</a>线缆和一个<a href="http://baike.baidu.com/view/3591885.htm">AC适配器</a>.30针的<a href="http://zh.wikipedia.org/wiki/PDMI">PDMI</a>连接器也是多状态外部连接器的常见例子.不确定的选"N".</dd>


<dt>Memory Controller drivers<br>CONFIG_MEMORY</dt><dd>内存控制器驱动.这里所说的"内存控制器"仅指嵌入式SoC系统中的各种控制器.不确定的选"N".</dd>


<dt>Industrial I/O support<br>CONFIG_IIO</dt><dd><a href="http://blog.chinaunix.net/uid-20543672-id-2976189.html">IIO子系统</a>为各种不同总线(i2c,spi,等)的嵌入式传感器驱动提供了一个统一的框架.例如:(1)模数转换器,(2)加速度传感器,(3)陀螺仪,(4)惯性测量仪,(5)电容-数字转换器,(6)压力/温度/光线传感器,等等.主要用于工业领域和嵌入式领域.不确定的选"N".</dd>


<dt>Non-Transparent Bridge support<br>CONFIG_NTB</dt><dd><a href="http://www.chinabaike.com/2011/0324/599696.html">PCI-E非透明桥</a>是一个点对点PCI-E总线,用于连接两条对等的PCI-E总线.例如英特尔 Atom S1200处理器, Xeon C5500/C3500 嵌入式处理器等.具体支持的设备号(PCI_DEVICE_ID)可以查看"drivers/ntb/ntb_hw.h"文件或<a href="https://cateee.net/lkddb/web-lkddb/NTB.html">NTB</a>驱动数据库.不确定的选"N".</dd>


<dt>VME bridge support<br>CONFIG_VME_BUS</dt><dd><a href="http://baike.baidu.com/view/1548999.htm">VME</a>(VersaModule Eurocard)总线是一种通用的计算机总线,主要用于工业控制/军用系统/航空航天/交通运输/医疗等嵌入式领域.而<a href="http://zh.idt.com/products/interface-connectivity/vme/pci-vme-bridge">VME桥</a>则是其他总线(例如PCI/PCI-E)到VME总线之间的转换芯片.不确定的选"N".</dd>


<dt>Pulse-Width Modulation (PWM) Support<br>CONFIG_PWM</dt><dd><a href="http://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E5%AF%AC%E5%BA%A6%E8%AA%BF%E8%AE%8A">PWM</a>(<a href="http://baike.baidu.com/view/631384.htm">脉宽调制</a>)是将模拟信号转换为脉波的一种技术.在计算机领域,这项技术常被用于控制风扇转速和背光显示器的亮度.很多微型处理器内部都包含有PWM控制器,此选项为所有PWM控制器驱动提供了一个统一的框架.不确定的选"N".</dd>
<dd><dl>
	<dt>Intel LPSS PWM support<br>CONFIG_PWM_LPSS</dt><dd>适用于"Intel Low Power Subsystem" PWM 控制器的通用框架驱动.适用于 Atom Z36xxx/Z37xxx 系列处理器.</dd>
	<dt>NXP PCA9685 PWM driver<br>CONFIG_PWM_PCA9685</dt><dd>适用于 NXP PCA9685 LED 亮度控制器.</dd>
</dl></dd>


<dt>IndustryPack bus support<br>CONFIG_IPACK_BUS</dt><dd><a href="http://www.acromag.com/catalog/818">IndustryPack</a>是工业控制领域常用的一种总线.不确定的选"N".</dd>


<dt>Reset Controller Support<br>CONFIG_RESET_CONTROLLER</dt><dd>为GPIO总线或者芯片内置的重启控制器提供通用支持.仅用于嵌入式设备.不确定的选"N".</dd>


<dt>FMC support<br>CONFIG_FMC</dt><dd><a href="http://www.eetrend.com/interview/100024251">FMC(FPGA Mezzanine Carrier)</a>是一个定义如何将FPGA夹层卡(<a href="http://www.iianews.com/ca/_01-ABC00000000000241496.shtml">FPGA Mezzanine Card</a>)连接到主机电路板的接口标准,仅用于嵌入式环境.</dd>


<dt>PHY Subsystem</dt><dd><a href="http://www.cnblogs.com/jason-lu/articles/3195473.html">PHY</a>子系统.</dd>
<dd><dl>
	<dt>PHY Core<br>CONFIG_GENERIC_PHY</dt><dd>为内核中的所有PHY设备提供一个通用的<a href="http://blog.chinaunix.net/uid-20528014-id-3050217.html">PHY</a>框架.不确定的选"N".内核中若有其他部分依赖它,会自动选上.</dd>
	<dt class="omit">{此处省略的部分请按照硬件的实际情况选择}</dt>
</dl></dd>


<dt>Generic powercap sysfs driver<br>CONFIG_POWERCAP</dt><dd>"<a href="http://server.it168.com/server/2008-07-09/200807090907703_all.shtml">power capping</a>"的意思是允许用户把设备的总功耗限定在指定的范围内.此选项允许内核子系统将"power capping"的设置以sysfs的方式导出到用户空间.不确定的选"N".</dd>


<dt>MCB support<br>CONFIG_MCB</dt><dd>MCB(MEN Chameleon Bus)是专用于德国<a href="https://www.men.de/">MEN Mikro Elektronik</a>公司的FPGA设备的总线.MEN Mikro Elektronik公司的嵌入式计算主要是为航空/航海/铁路及陆地车辆的应用,以及自动化/电力/能源和医疗用途.不确定的选"N".</dd>


<dt>Performance monitor support</dt><dd>专用于ARM架构的CPU性能监控框架.</dd>


<dt>Reliability, Availability and Serviceability (RAS) features<br>CONFIG_RAS</dt><dd>RAS(可靠,可用,可维护)是一个计算机硬件术语,可靠性描述系统能够持续正确工作多长时间,可用性描述系统能够正确工作的时间百分比,可维护性描述系统从错误恢复到正常需要多长时间.具有高等级RAS的硬件会有一系列额外的技术保障数据的可靠性与正确性.</dd>


<dt>Thunderbolt support for Apple devices<br>CONFIG_THUNDERBOLT</dt><dd>苹果公司的<a href="http://www.leiphone.com/news/201503/bIKjgTD7IHEkU3hs.html">雷电接口</a>支持.</dd>


<dt>Android Drivers<br>CONFIG_ANDROID</dt><dd>安卓平台专用驱动</dd>


<dt>NVDIMM (Non-Volatile Memory Device) Support<br>CONFIG_LIBNVDIMM</dt><dd><a href="http://servers.pconline.com.cn/522/5222919.html">NVDIMM</a>(<a href="http://www.cnblogs.com/presida/p/3552935.html">非易失性内存</a>)支持.</dd>


<dt>NVMEM Support<br>CONFIG_NVMEM</dt><dd>NVMEM(非易失性存储器)设备支持.包括:<a href="http://baike.baidu.com/view/93707.htm">EEPROM</a>,EFUSES...不确定的选"N".</dd>


<dt>System Trace Module devices<br>CONFIG_STM</dt><dd>仅供调试使用</dd>


<dt>Dummy STM driver<br>CONFIG_STM_DUMMY</dt><dd>仅供调试使用</dd>


<dt>Kernel console over STM devices<br>CONFIG_STM_SOURCE_CONSOLE</dt><dd>仅供调试使用</dd>


<dt>Intel(R) Trace Hub controller<br>CONFIG_INTEL_TH</dt><dd>仅供调试使用</dd>


<dt>FPGA Configuration Framework<br>CONFIG_FPGA</dt><dd>FPGA配置框架支持.仅用于嵌入式系统.</dd>


</dl><!-- 设备驱动程序结束 -->






<h2>Firmware Drivers<br />固件(<a href="http://baike.baidu.com/view/33738.htm">Firmware</a>)驱动</h2>
<dl>
<dt>BIOS Enhanced Disk Drive calls determine boot disk<br>CONFIG_EDD</dt><dd>这是一个实验性选项,支持<a href="http://baike.baidu.com/view/404433.htm">实模式</a>BIOS中的增强磁盘服务(EDD),从而允许内核从BIOS中获取第一启动盘(可以从sysfs中查看具体是哪个硬盘),大多数BIOS提供商都没有实现这个特性.不确定的选"N".</dd>
<dd><dl>
	<dt>Sets default behavior for EDD detection to off<br>CONFIG_EDD_OFF</dt><dd>选"Y"相当于使用"edd=off"内核引导参数(禁用EDD),选"N"相当于使用"edd=on"内核引导参数(启用EDD).语法:edd={on|skipmbr|off}.</dd>
</dl></dd>
<dt>Add firmware-provided memory map to sysfs<br>CONFIG_FIRMWARE_MEMMAP</dt><dd>将原始的固件内容映射到"/sys/firmware/memmap"文件.主要用于调试目的,以及kexec为下一个内核设置参数.详见"<a href="https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-firmware-memmap">Documentation/ABI/testing/sysfs-firmware-memmap</a>"文档.不确定的选"N".</dd>
<dt>BIOS update support for DELL systems via sysfs<br>CONFIG_DELL_RBU</dt><dd>允许<a href="http://zh.community.dell.com/techcenter/systems-management/w/wiki/380.openmanage.aspx">Dell OpenManage</a>或<a href="http://wenku.baidu.com/view/1c00d6b2fd0a79563c1e72c9.html">DUP</a>(Dell Update Packages)工具通过sysfs更新DELL服务器主板的BIOS.详见"<a href="https://www.kernel.org/doc/Documentation/dell_rbu.txt">Documentation/dell_rbu.txt</a>"文档.即使你确实需要此功能,也建议选"M"而不是"Y".毕竟刷BIOS不能当做家常便饭.留着刷BIOS的接口,总是件危险的事.</dd>
<dt>Dell Systems Management Base Driver<br>CONFIG_DCDBAS</dt><dd>该驱动为DELL服务器专用的系统管理软件(Dell OpenManage)提供了sysfs接口.详见"<a href="https://www.kernel.org/doc/Documentation/dcdbas.txt">Documentation/dcdbas.txt</a>"文档.</dd>
<dt>Export DMI identification via sysfs to userspace<br>CONFIG_DMIID</dt><dd>将<a href="http://baike.baidu.com/view/1790409.htm">SMBIOS</a>(<a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a>)/<a href="http://www.dmtf.org/standards/dmi">DMI</a>(<a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface">Desktop Management Interface</a>)中的系统识别信息(序列号,制造商,型号,等等)导出到用户空间(/sys/class/dmi/id/).开启此项后,<a href="http://www.joecen.com/2007/04/19/view-bios-operating-system-in-the-dmi-smbios-information/">dmidecode</a>工具就可以显示与制造商相关的信息.此外,基于DMI的模块的自动加载也依赖于此项.建议选"Y",因为某些Udev规则和虚拟化检测需要它.</dd>
<dt>DMI table support in sysfs<br>CONFIG_DMI_SYSFS</dt><dd>将SMBIOS/DMI中的原始数据(包含大量的系统硬件信息)导出到用户空间(/sys/firmware/dmi/).以允许<a href="http://blog.sina.com.cn/s/blog_4152a9f50100wh48.html">dmidecode</a>工具无需访问/dev/mem设备(需要root权限)即可将这些信息显示出来.</dd>
<dt>iSCSI Boot Firmware Table Attributes<br>CONFIG_ISCSI_IBFT_FIND</dt><dd>使内核能定位iBFT(<a href="http://zh.wikipedia.org/wiki/ISCSI">iSCSI</a> Boot Firmware Table)在内存中的位置.目的是为了能够从iSCSI驱动器中启动操作系统.不确定的选"N".</dd>
<dd><dl>
	<dt>iSCSI Boot Firmware Table Attributes module<br>CONFIG_ISCSI_IBFT</dt><dd>将iBFT(<a href="http://baike.baidu.com/view/120148.htm">iSCSI</a> Boot Firmware Table)的内容通过sysfs导出到用户空间.如果你想在系统引导过程中动态检测iSCSI引导参数,可以选"Y",否则应选"N".</dd>
</dl></dd>
<dt>Google Firmware Drivers<br>CONFIG_GOOGLE_FIRMWARE</dt><dd>仅用于Google自家的服务器</dd>
<dt>EFI (Extensible Firmware Interface) Support</dt><dd><a href="http://www.intel.cn/content/www/cn/zh/architecture-and-technology/unified-extensible-firmware-interface/efi-homepage-general-technology.html">EFI/UEFI</a>(<a href="http://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">统一可扩展固件接口</a>)支持.2010年之后,UEFI已经基本全线取代了BIOS.</dd>
<dd><dl>
	<dt>EFI Variable Support via sysfs<br>CONFIG_EFI_VARS</dt><dd>通过sysfs接口操作(读/写/新建/删除)EFI变量的老旧方式,并且可能与新方式(CONFIG_EFIVAR_FS)冲突.应该选"N".</dd>
	<dd><dl>
		<dt>Register efivars backend for pstore<br>CONFIG_EFI_VARS_PSTORE</dt><dd>将efivars模块(CONFIG_EFI_VARS)用作pstore文件系统(CONFIG_PSTORE)的后端.这样就可以向EFI变量中写入各种pstore支持的信息,例如,控制台消息,崩溃转储,等等.</dd>
		<dd><dl>
			<dt>Disable using efivars as a pstore backend by default<br>CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE</dt><dd>禁止默认将efivars模块(CONFIG_EFI_VARS)用作pstore文件系统(CONFIG_PSTORE)的后端.</dd>
		</dl></dd>
		<dt>Enable EFI fake memory map<br>CONFIG_EFI_FAKE_MEMMAP</dt><dd>选"Y"等价于使用"efi_fake_mem"内核引导参数,仅供调试使用.</dd>
	</dl></dd>
</dl></dd>
</dl>






<h2>File systems<br />文件系统</h2>
<dl>
<dt>Second extended fs support<br>CONFIG_EXT2_FS</dt><dd>Ext2文件系统,无日志.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/ext2.txt">Documentation/filesystems/ext2.txt</a>"文档.</dd>
<dd><dl>
	<dt>Ext2 extended attributes<br>CONFIG_EXT2_FS_XATTR</dt><dd>Ext2文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选"N".</dd>
	<dd><dl>
		<dt>Ext2 POSIX Access Control Lists<br>CONFIG_EXT2_FS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
		<dt>Ext2 Security Labels<br>CONFIG_EXT2_FS_SECURITY</dt><dd>"安全标签"允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选"N".</dd>
	</dl></dd>
	<dt>Ext2 execute in place support<br>CONFIG_EXT2_FS_XIP</dt><dd><a href="http://blog.chinaunix.net/uid-26404697-id-3152290.html">芯片内执行</a>(<a href="http://en.wikipedia.org/wiki/Execute_in_place">execute in place</a>)的意思是程序在写入存储介质时就已经分配好运行时的地址,因此不需要载入内存即可在芯片内执行,一般仅在嵌入式系统上才使用这种技术.</dd>
</dl></dd>
<dt>Ext3 journalling file system support<br>CONFIG_EXT3_FS</dt><dd>Ext3日志型文件系统.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/ext3.txt">Documentation/filesystems/ext3.txt</a>"文档.</dd>
<dd><dl>
	<dt>Default to 'data=ordered' in ext3<br>CONFIG_EXT3_DEFAULTS_TO_ORDERED</dt><dd>选"Y"表示将默认的日志模式设为"data=ordered"(更安全),选"N"表示将默认的日志模式设为"data=writeback"(更危险).选"Y",仅在你确实明白"data=writeback"的风险,以及确实有充足的理由的时候,才能选"N".</dd>
	<dt>Ext3 extended attributes<br>CONFIG_EXT3_FS_XATTR</dt><dd>Ext3文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选"N".</dd>
	<dd><dl>
		<dt>Ext3 POSIX Access Control Lists<br>CONFIG_EXT3_FS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
		<dt>Ext3 Security Labels<br>CONFIG_EXT3_FS_SECURITY</dt><dd>"安全标签"允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选"N".</dd>
	</dl></dd>
</dl></dd>
<dt>The Extended 4 (ext4) filesystem<br>CONFIG_EXT4_FS</dt><dd>Ext4日志型文件系统.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/ext4.txt">Documentation/filesystems/ext4.txt</a>"文档.</dd>
<dd><dl>
	<dt>Use ext4 for ext2/ext3 file systems<br>CONFIG_EXT4_USE_FOR_EXT23</dt><dd>在ext2/ext3文件系统上使用ext4驱动.这样可以对ext2/ext3/ext4三种文件系统只使用同一个驱动.主要目的是减少内核尺寸.</dd>
	<dt>Ext4 POSIX Access Control Lists<br>CONFIG_EXT4_FS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
	<dt>Ext4 Security Labels<br>CONFIG_EXT4_FS_SECURITY</dt><dd>"安全标签"允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选"N".</dd>
	<dt>EXT4 debugging support<br>CONFIG_EXT4_DEBUG</dt><dd>仅供调试使用</dd>
</dl></dd>
<dt>JBD (ext3) debugging support<br>CONFIG_JBD_DEBUG</dt><dd>仅供调试使用</dd>
<dt>JBD2 (ext4) debugging support<br>CONFIG_JBD2_DEBUG</dt><dd>仅供调试使用</dd>
<dt>Reiserfs support<br>CONFIG_REISERFS_FS</dt><dd>曾经的明星文件系统,特别擅长处理大量小文件的场合,由于其创始人入狱,前景不明.</dd>
<dd><dl>
	<dt>Enable reiserfs debug mode<br>CONFIG_REISERFS_CHECK</dt><dd>仅供调试使用</dd>
	<dt>Stats in /proc/fs/reiserfs<br>CONFIG_REISERFS_PROC_INFO</dt><dd>在/proc/fs/reiserfs文件中显示Reiserfs文件系统的状态,仅供调试使用</dd>
	<dt>ReiserFS extended attributes<br>CONFIG_REISERFS_FS_XATTR</dt><dd>ReiserFS文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选"N".</dd>
	<dd><dl>
		<dt>ReiserFS POSIX Access Control Lists<br>CONFIG_REISERFS_FS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
		<dt>ReiserFS Security Labels<br>CONFIG_REISERFS_FS_SECURITY</dt><dd>"安全标签"允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选"N".</dd>
	</dl></dd>
</dl></dd>
<dt>JFS filesystem support<br>CONFIG_JFS_FS</dt><dd>JFS日志型文件系统.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/jfs.txt">Documentation/filesystems/jfs.txt</a>"文档.</dd>
<dd><dl>
	<dt>JFS POSIX Access Control Lists<br>CONFIG_JFS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
	<dt>JFS Security Labels<br>CONFIG_JFS_SECURITY</dt><dd>"安全标签"允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选"N".</dd>
	<dt>JFS debugging<br>CONFIG_JFS_DEBUG</dt><dd>仅供调试使用</dd>
	<dt>JFS statistics<br>CONFIG_JFS_STATISTICS</dt><dd>在/proc/fs/jfs/目录中显示JFS文件系统的统计信息</dd>
</dl></dd>
<dt>XFS filesystem support<br>CONFIG_XFS_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/XFS">XFS</a>日志型文件系统是一个高性能的文件系统(笔者的最爱),<a href="http://os.51cto.com/art/201202/315553.htm">擅长大文件和多线程</a>.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/">Documentation/filesystems/</a>"目录中"xfs*.txt"系列文档.</dd>
<dd><dl>
	<dt>XFS Quota support<br>CONFIG_XFS_QUOTA</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-4/index.html">XFS磁盘配额</a>(使用专用的<a href="http://linux.die.net/man/8/xfs_quota">xfs_quota</a>工具)比通用磁盘配额模块(CONFIG_QUOTA)拥有更高级的特性,它不但能够控制用户或组的磁盘用量,还能控制项目(文件夹)的磁盘用量(无论哪个用户在项目的文件夹中创建文件),但是不能同时使用组配额和项目配额.此外,对XFS来说,配额数据记录在文件系统元数据中,而不是像CONFIG_QUOTA那样记录在aquota.user和aquota.group文件中.最后,XFS配额和通用磁盘配额是两个相互独立的系统,可以同时并存.</dd>
	<dt>XFS POSIX ACL support<br>CONFIG_XFS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
	<dt>XFS Realtime subvolume support<br>CONFIG_XFS_RT</dt><dd>"实时子卷"是专门存储文件数据的卷,可以允许将日志与数据分开在不同的磁盘上,例如将大块头的流媒体文件存储在高速磁盘组成的实时子卷上.详见<a href="http://linux.die.net/man/5/xfs">xfs</a>手册页.</dd>
	<dt>XFS Verbose Warnings<br>CONFIG_XFS_WARN</dt><dd>仅供调试使用</dd>
	<dt>XFS Debugging support<br>CONFIG_XFS_DEBUG</dt><dd>仅供调试使用</dd>
</dl></dd>
<dt>GFS2 file system support<br>CONFIG_GFS2_FS</dt><dd><a href="https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Global_File_System_2/ch-overview-GFS2.html">GFS2</a>可用于<a href="http://dreamfire.blog.51cto.com/418026/1219221">搭建高可用集群文件系统</a>,由红帽公司开发,允许所有集群节点并行访问,同时又能够完美的保持文件系统的一致性:一个节点对文件系统的任何修改都立即对所有其他节点可见.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/">Documentation/filesystems/</a>"目录中"gfs*.txt"系列文档.</dd>
<dd><dl>
	<dt>GFS2 DLM locking<br>CONFIG_GFS2_FS_LOCKING_DLM</dt><dd>GFS2分布式锁管理器(<a href="https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Global_File_System_2/s1-ov-lockbounce.html">DLM</a>).务必选"Y",除非你知道自己在做什么.</dd>
</dl></dd>
<dt>OCFS2 file system support<br>CONFIG_OCFS2_FS</dt><dd><a href="http://www.oracle.com/us/technologies/linux/025995.htm">OCFS2</a>(<a href="http://wenku.baidu.com/view/2ee98027192e45361066f5d1.html">Oracle集群文件系统</a>)的目标是成为一种通用文件系统.OCFS2能使集群中的所有节点并发的通过标准文件系统接口来访问存储备.要使用OCFS2还需要<a href="http://oss.oracle.com/projects/ocfs2-tools">ocfs2-tools</a>的帮助.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/ocfs2.txt">Documentation/filesystems/ocfs2.txt</a>"文档.</dd>
<dd><dl>
	<dt>O2CB Kernelspace Clustering<br>CONFIG_OCFS2_FS_O2CB</dt><dd>O2CB(OCFS2 Cluster Base)是位于内核空间的集群服务结构.具体包括:NM(节点管理器,监控所有节点),HB(心跳服务),TCP(控制节点间的通讯),DLM(分布式锁管理器),CONFIGFS(用户配置文件系统驱动,挂载点是/config),DLMFS(用户空间和内核空间DLM的接口).开启此项后,将只需要很少量的用户空间组件(也就是<a href="http://oss.oracle.com/projects/ocfs2-tools">ocfs2-tools</a>),OCFS2就可以转起来了.但它只能玩转OCFS2自身,玩不了其他集群.</dd>
	<dt>OCFS2 Userspace Clustering<br>CONFIG_OCFS2_FS_USERSPACE_CLUSTER</dt><dd>为用户空间的集群服务提供支持.目的是为了配合CONFIG_DLM模块一起使用.</dd>
	<dt>OCFS2 statistics<br>CONFIG_OCFS2_FS_STATS</dt><dd>允许对OCFS2的使用状况进行一些统计.开启后会增加内存占用.</dd>
	<dt>OCFS2 logging support<br>CONFIG_OCFS2_DEBUG_MASKLOG</dt><dd>仅供调试使用</dd>
	<dt>OCFS2 expensive checks<br>CONFIG_OCFS2_DEBUG_FS</dt><dd>以性能为代价提供了存储一致性检测,仅供调试使用</dd>
</dl></dd>
<dt>Btrfs filesystem support<br>CONFIG_BTRFS_FS</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/">Btrfs</a>是由Oracle于2007年宣布的支持写时复制(COW)的文件系统.拥有众多抢眼球的特性:软RAID管理,卷管理,克隆/快照,压缩功能,支持跨多块磁盘动态增大或收缩卷.其目标是成为<a href="http://os.51cto.com/art/201004/195096.htm">下一代Linux标准文件系统</a>.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/btrfs.txt">Documentation/filesystems/btrfs.txt</a>"文档.</dd>
<dd><dl>
	<dt>Btrfs POSIX Access Control Lists<br>CONFIG_BTRFS_FS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选"N".</dd>
	<dt>Btrfs with integrity check tool compiled in (DANGEROUS)<br>CONFIG_BTRFS_FS_CHECK_INTEGRITY</dt><dd>仅供调试使用</dd>
	<dt>Btrfs will run sanity tests upon loading<br>CONFIG_BTRFS_FS_RUN_SANITY_TESTS</dt><dd>仅供调试使用</dd>
	<dt>Btrfs debugging support<br></dt><dd>仅供调试使用</dd>
</dl></dd>
<dt>NILFS2 file system support<br>CONFIG_NILFS2_FS</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-nilfs2/index.html">NILFS2</a>是一种非常前卫的"log-structured"文件系统,是<a href="http://www.ibm.com/developerworks/cn/linux/l-nilfs-exofs/">Linux下一代文件系统</a>的有力竞争者.NILFS2将底层设备当作一种只能追加写(append)的设备,文件系统的任何修改都只以顺序追加的方式写入磁盘(而是不覆盖旧数据),从而避免耗时的寻道(seek)操作,从而大幅提升写入性能(因为文件系统的整体效率主要由写操作的效率决定).此种思路带来了一系列靓瞎眼的特性:自动不间断快照(可以迅速恢复被删除的文件或者回到先前某个特定的时间点),快速崩溃恢复(比大多数日志型文件系统还要快),高性能(在SSD上更有绝对优势).但也带来了一个新问题:需要垃圾收集机制以清理旧数据,造成垃圾收集时的性能降低(可以通过合理安排垃圾收集时间来避免).NILFS2目前不支持如下功能:atime(访问时间),POSIX ACL,扩展属性.不过考虑到SSD(固态硬盘)即将成为主流,假以时日,前途大大的啊!.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/nilfs2.txt">Documentation/filesystems/nilfs2.txt</a>"文档.</dd>
<dt>F2FS filesystem support<br>CONFIG_F2FS_FS</dt><dd><a href="http://blog.chinaunix.net/uid-28989651-id-3878690.html">F2FS</a>也是一种非常前卫的"log-structured"文件系统,针对基于NAND闪存的存储设备进行了特别设计,使之更加适应新的存储介质(也就是闪存),据称它<a href="http://www.linuxidc.com/Linux/2015-04/116189.htm">是目前SSD上性能最好的文件系统</a>.</dd>
<dt>Direct Access (DAX) support<br>CONFIG_FS_DAX</dt><dd>DAX(Direct Access)的含义是绕过内存缓冲直接访问块设备.选"Y"后,就可以用"mount -o dax"方式挂载块设备以避免使用pagecache作为I/O缓冲.例如将持续性非易失内存(断电内容不丢失)作磁盘用时,或者挂载内存盘时,使用此特性便恰到好处.还有一种用法是在虚拟机内使用"mount -o dax"方式挂载已经缓存在宿主机内存中的块设备文件(或者倒过来也可以).</dd>
<dt>Enable POSIX file locking API<br>CONFIG_FILE_LOCKING</dt><dd>POSIX标准文件锁定API支持.NFS之类的网络文件系统和给文件加锁与解锁的<a href="http://blog.sina.com.cn/s/blog_484102dd0101385h.html">flock()</a>系统调用需要它.不确定的选"Y".</dd>
<dt>Dnotify support<br>CONFIG_DNOTIFY</dt><dd>旧式的基于目录的文件变化的通知机制(已被Inotify取代),目前仅有NFSv4以及少量古董程序依赖它.不确定的选"N".</dd>
<dt>Inotify support for userspace<br>CONFIG_INOTIFY_USER</dt><dd>用户空间的Inotify支持.<a href="http://zh.wikipedia.org/zh-cn/Inotify">Inotify</a>是替代Dnotify的文件系统变化通知机制.建议选"Y".[提示]如果你使用了<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>作为init,那就必须选"Y".</dd>
<dt>Filesystem wide access notification<br>CONFIG_FANOTIFY</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-fanotify/">fanotify</a>是一种打算取代Inotify的文件系统变化通知机制,不过,由于目前<a href="http://blog.yikuyiku.com/?p=2885">Fanotify比inotify</a>支持的文件系统事件类型少很多,完全取代Inotify还不现实.Udev的"<a href="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">Predictable Network Interface Names</a>"功能依赖于它.建议选"Y".[提示]如果你使用了<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>作为init,那就必须选"Y".</dd>
<dd><dl>
	<dt>fanotify permissions checking<br>CONFIG_FANOTIFY_ACCESS_PERMISSIONS</dt><dd>允许fanotify的监听器(listener)对文件系统事件进行权限检查.这样,监听器就可以在系统访问某个文件之前,首先扫描此文件.某些防病毒程序以及<a href="http://www.searchstorage.com.cn/whatis/word_2112.htm">分级存储管理</a>系统可能需要此特性.不确定的选"N".</dd>
</dl></dd>
<dt>Quota support<br>CONFIG_QUOTA</dt><dd>通用的磁盘配额支持(限制某个用户或者某组用户的磁盘占用空间).需要配合<a href="http://sourceforge.net/projects/linuxquota/">quota-tools</a>工具使用.</dd>
<dt>Report quota messages through netlink interface<br>CONFIG_QUOTA_NETLINK_INTERFACE</dt><dd>通过<a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a>接口报告QUOTA的警告信息(例如"到达限额").不确定的选"Y".</dd>
<dt>Print quota warnings to console (OBSOLETE)<br>CONFIG_PRINT_QUOTA_WARNING</dt><dd>将QUOTA的警告信息直接显示在控制台上.反对使用,未来会移除此项.选"N".</dd>
<dt>Additional quota sanity checks<br>CONFIG_QUOTA_DEBUG</dt><dd>对quota内部结构进行额外的完整性检查.主要用于调试目的.不确定的选"N".</dd>
<dt>Old quota format support<br>CONFIG_QFMT_V1</dt><dd>老旧的v1版配额格式(linux-2.4.22之前使用的格式)支持.选"N".</dd>
<dt>Quota format vfsv0 and vfsv1 support<br>CONFIG_QFMT_V2</dt><dd>vfsv0/vfsv1配额格式支持.两者都支持32位的UID/GID,而vfsv1还支持64位的inode/block配额.建议开启.</dd>
<dt>Kernel automounter version 4 support (also supports v3)<br>CONFIG_AUTOFS4_FS</dt><dd>第四版内核按需自动挂载文件系统的支持(也支持v3).此特性需要配合用户空间工具(<a href="https://www.kernel.org/pub/linux/daemons/autofs/v5/">autofs</a>或<a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">Systemd</a>)使用,以实现仅在某个文件系统挂载点真正被访问到的时候才触发挂载操作.[提示]使用了<a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">systemd</a>的系统建议选"Y".</dd>
<dt>FUSE (Filesystem in Userspace) support<br>CONFIG_FUSE_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/FUSE">FUSE</a>允许在用户空间实现一个全功能的文件系统,还有一个与之对应的<a href="http://fuse.sourceforge.net/">libfuse2</a>库和相关工具.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/fuse.txt">Documentation/filesystems/fuse.txt</a>"文档.如果你打算开发一个自己的文件系统或者使用一个基于FUSE的文件系统(例如<a href="https://wiki.archlinux.org/index.php/NTFS-3G_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">NTFS-3G</a>或<a href="http://www.ibm.com/developerworks/cn/linux/l-zfs/index.html">ZFS-FUSE</a>或<a href="http://my.oschina.net/uvwxyz/blog/176839">GlusterFS</a>),可以选"Y".</dd>
<dd><dl>
	<dt>Character device in Userspace support<br>CONFIG_CUSE</dt><dd>这是一个FUSE扩展,用于在用户空间实现字符设备支持.</dd>
</dl></dd>
<dt>Overlay filesystem support<br>CONFIG_OVERLAY_FS</dt><dd><a href="http://www.udpwork.com/item/6821.html">overlay</a>的含意是以层叠的方式组合上下两个文件系统层,常和容器技术配合使用.详见<a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt">Documentation/filesystems/overlayfs.txt</a>文档.</dd>
<dt>Caches</dt><dd>文件系统缓存</dd>
<dd><dl>
	<dt>General filesystem local caching manager<br>CONFIG_FSCACHE</dt><dd>通用文件系统本地缓存管理器.它为各种不同的文件系统(例如网络文件系统)提供了统一的本地缓存框架.这样各种缓存实现可以作为插件添加进来.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/caching/fscache.txt">Documentation/filesystems/caching/fscache.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Gather statistical information on local caching<br>CONFIG_FSCACHE_STATS</dt><dd>收集本地缓存的统计信息(这会增加系统运行负载),并通过/proc/fs/fscache/stats文件导出到用户空间.主要用于调试目的.</dd>
		<dt>Gather latency information on local caching<br>CONFIG_FSCACHE_HISTOGRAM</dt><dd>收集本地缓存的延迟信息(这会增加系统运行负载),并通过/proc/fs/fscache/histogram文件导出到用户空间.主要用于调试目的.</dd>
		<dt>Debug FS-Cache<br>CONFIG_FSCACHE_DEBUG</dt><dd>仅供调试使用</dd>
		<dt>Maintain global object list for debugging purposes<br>CONFIG_FSCACHE_OBJECT_LIST</dt><dd>在/proc/fs/fscache/objects文件中维护一个活动缓存对象的全局列表.仅用于调试目的.</dd>
		<dt>Filesystem caching on files<br>CONFIG_CACHEFILES</dt><dd>将一个已挂载的文件系统用作另一个文件系统的缓存.例如将一个本地磁盘分区挂载为一个远程网络文件系统的缓存,或者将一个高速设备(例如SSD)用作一个低速设备(例如普通硬盘)的缓存.</dd>
		<dd><dl>
			<dt>Debug CacheFiles<br>CONFIG_CACHEFILES_DEBUG</dt><dd>仅供调试使用</dd>
			<dt>Gather latency information on CacheFiles<br>CONFIG_CACHEFILES_HISTOGRAM</dt><dd>收集本地缓存的延迟信息(这会增加系统运行负载),并通过/proc/fs/cachefiles/histogram文件导出到用户空间.主要用于调试目的.</dd>
		</dl></dd>
	</dl></dd>
</dl></dd>
<dt>CD-ROM/DVD Filesystems</dt><dd>CD-ROM/DVD<a href="http://blog.chinaunix.net/uid-11647316-id-2858441.html">光盘文件系统</a></dd>
<dd><dl>
	<dt>ISO 9660 CDROM file system support<br>CONFIG_ISO9660_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/ISO_9660">ISO9660</a>是所有CD/DVD光盘通用的标准文件系统.建议选"Y".详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/isofs.txt">Documentation/filesystems/isofs.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Microsoft Joliet CDROM extensions<br>CONFIG_JOLIET</dt><dd>Microsoft对ISO9660文件系统的<a href="http://baike.baidu.com/view/32493.htm">Joliet扩展</a>,允许在文件名中使用Unicode字符,也允许长文件名.建议选"Y".</dd>
		<dt>Transparent decompression extension<br>CONFIG_ZISOFS</dt><dd>Linux对ISO9660文件系统的扩展,允许将数据透明的压缩存储在CD上.使用并不广泛,不确定的可以选"N".</dd>
	</dl></dd>
	<dt>UDF file system support<br>CONFIG_UDF_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%85%89%E7%A2%9F%E6%A0%BC%E5%BC%8F">UDF</a>被设计为可擦写格式(其实质是管理增量写入),其目标是取代ISO9660,现已经广泛地用于大容量DVD光盘上(特别是刻录盘).建议选"Y".详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/udf.txt">Documentation/filesystems/udf.txt</a>"文档.</dd>
</dl></dd>
<dt>DOS/FAT/NT Filesystems</dt><dd>DOS/FAT/NTFS文件系统</dd>
<dd><dl>
	<dt>MSDOS fs support<br>CONFIG_MSDOS_FS</dt><dd>古老的MSDOS文件系统(FAT16),基本绝种了</dd>
	<dt>VFAT (Windows-95) fs support<br>CONFIG_VFAT_FS</dt><dd>从Win95开始使用的VFAT文件系统(FAT32).如果你要使用基于UEFI平台的电脑,并且使用GPT磁盘分区,则必须选"Y".详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/vfat.txt">Documentation/filesystems/vfat.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Default codepage for FAT<br>CONFIG_FAT_DEFAULT_CODEPAGE</dt><dd>在FAT系列文件系统上,"8.3"格式的短文件名以特定的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%A1%B5">代码页</a>进行存储(可以通过chcp命令查看),但长文件名却以Unicode进行存储.此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页.可以通过"codepage"挂载选项进行修改.简体中文通常使用"936",繁体中文通常使用"950".</dd>
		<dt>Default iocharset for FAT<br>CONFIG_FAT_DEFAULT_IOCHARSET</dt><dd>指定默认以什么<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符集</a>显示文件名,这个值可以通过"iocharset"挂载选项修改.但必须与系统的locale设置保持一致.例如在"zh_CN.UTF-8"或"en_US.UTF-8"的情况下应该使用"utf8".[注意]应谨慎使用"iocharset=utf8",因为它会导致FAT文件系统上的文件名变得大小写敏感.</dd>
	</dl></dd>
	<dt>exFAT fs support<br>CONFIG_EXFAT_FS</dt><dd><a href="https://github.com/dorimanx/exfat-nofuse/">exfat-nofuse</a>开源项目提供的内核级exFAT,FAT12,FAT16,FAT32(vfat)文件系统支持<a href="https://github.com/dorimanx/exfat-nofuse/archive/master.zip">补丁</a>.此补丁是取代前面两个内核自带的FAT驱动的更优秀替代品.</dd>
	<dd><dl>
		<dt>enable discard support<br>CONFIG_EXFAT_DISCARD</dt><dd>"discard"挂载选项支持.在U盘或者SSD上使用此文件系统的用户必选"Y".</dd>
		<dt>enable delayed sync<br>CONFIG_EXFAT_DELAYED_SYNC</dt><dd>延迟刷写磁盘脏数据,可提高文件系统性能.有电池的笔记本或者有UPS的台式机建议选"Y".</dd>
		<dt>enable kernel debug features via ioctl<br>CONFIG_EXFAT_KERNEL_DEBUG</dt><dd>仅供调试使用.</dd>
		<dt>print debug messages<br>CONFIG_EXFAT_DEBUG_MSG</dt><dd>仅供调试使用</dd>
		<dt>Default codepage for exFAT<br>CONFIG_EXFAT_DEFAULT_CODEPAGE</dt><dd>在FAT系列文件系统上,"8.3"格式的短文件名以特定的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%A1%B5">代码页</a>进行存储(可以通过chcp命令查看),但长文件名却以Unicode进行存储.此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页.可以通过"codepage"挂载选项进行修改.简体中文通常使用"936",繁体中文通常使用"950".</dd>
		<dt>Default iocharset for exFAT<br>CONFIG_EXFAT_DEFAULT_IOCHARSET</dt><dd>指定默认以什么<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符集</a>显示文件名,这个值可以通过"iocharset"挂载选项修改.但必须与系统的locale设置保持一致.例如在"zh_CN.UTF-8"或"en_US.UTF-8"的情况下应该使用"utf8".[注意]应谨慎使用"iocharset=utf8",因为它会导致FAT文件系统上的文件名变得大小写敏感.</dd>
	</dl></dd>
	<dt>NTFS file system support<br>CONFIG_NTFS_FS</dt><dd>NTFS文件系统.仅选中此项表示仅支持只读(不支持NTFS压缩或加密文件),不支持写入.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/ntfs.txt">Documentation/filesystems/ntfs.txt</a>"文档.</dd>
	<dd><dl>
		<dt>NTFS debugging support<br>CONFIG_NTFS_DEBUG</dt><dd>仅供调试使用</dd>
		<dt>NTFS write support<br>CONFIG_NTFS_RW</dt><dd>由于微软没有公开NTFS的技术标准,所以内核只能支持非常残缺的写入功能:仅能覆盖已存在的文件但不能改变其长度,不能创建文件或目录.建议选"N".[提示]在Linux环境下写入NTFS始终是一件危险的事情,即使对于<a href="http://www.oschina.net/question/12_4941">NTFS-3G</a>也是如此,除了不支持压缩或加密文件之外,网上还有不少<a href="http://bbs.cfanclub.net/thread-497916-1-1.html">血的教训</a>,有兴趣可以搜搜.</dd>
	</dl></dd>
</dl></dd>
<dt>Pseudo filesystems</dt><dd>伪文件系统</dd>
<dd><dl>
	<dt>/proc file system support<br>CONFIG_PROC_FS</dt><dd>显示系统状态的虚拟文件系统(进程信息,irq设置,内存使用,设备驱动,网络状态等),通常挂载到"<a href="http://www.ibm.com/developerworks/cn/linux/l-proc.html">/proc</a>"目录.许多程序依赖于它,systemd也依赖于它.选"Y",除非你知道自己在做什么.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/proc.txt">Documentation/filesystems/proc.txt</a>"文档.</dd>
	<dd><dl>
		<dt>/proc/kcore support<br>CONFIG_PROC_KCORE</dt><dd>系统物理内存的映象.建议选"N".</dd>
		<dt>/proc/vmcore support<br>CONFIG_PROC_VMCORE</dt><dd>以ELF格式转储的已崩溃内核镜像,仅供调试使用</dd>
		<dt>Sysctl support (/proc/sys)<br>CONFIG_PROC_SYSCTL</dt><dd>显示各种不同的内核调节参数,并让root用户能通过/proc/sys/目录交互地更改其中的某些内容.必选"Y",除非你是嵌入式系统并且知道自己在做什么.详见"<a href="https://www.kernel.org/doc/Documentation/sysctl/">Documentation/sysctl/</a>"目录中的文档.</dd>
		<dt>Enable /proc page monitoring<br>CONFIG_PROC_PAGE_MONITOR</dt><dd>用于监视进程内存占用的接口(/proc/&lt;pid&gt;/{smaps,clear_refs,pagemap}和/proc/{kpagecount,kpageflags}).建议选"Y".</dd>
	</dl></dd>
	<dt>sysfs file system support<br>CONFIG_SYSFS</dt><dd>导出内核内部对象及其属性和对象之间的相互关系的文件系统,通常挂载到"<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/index.html">/sys</a>"目录,sysfs把连接在系统上的设备和总线以及驱动程序等组织成为一个分级的文件,并允许通过该文件系统调整某些内核子系统以及设备的参数.内核启动时依靠它挂载类似"/dev/sda1"这样形式的根分区,禁用sysfs后必须在内核引导参数中使用设备号指定根分区(类似"root=03:01"这样).systemd依赖于它.选"Y",除非你知道自己在做什么.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/">Documentation/filesystems/</a>"目录中"sysfs*.txt"系列文档.</dd>
	<dt>Tmpfs virtual memory file system support (former shm fs)<br>CONFIG_TMPFS</dt><dd><a href="http://baike.baidu.com/view/1511292.htm">tmpfs</a>文件系统(以前叫shm[共享内存]文件系统),大多数系统的正常运行都依赖于它(例如<a href="http://zh.wikipedia.org/wiki/Udev">Udev</a>使用的"/dev/"目录通常挂载为tmpfs).选"Y",除非你知道自己在做什么.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt">Documentation/filesystems/tmpfs.txt</a>"文档.</dd>
	<dd><dl>
		<dt>Tmpfs POSIX Access Control Lists<br>CONFIG_TMPFS_POSIX_ACL</dt><dd>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越"owner/group/world"的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.许多发行版都要求/dev/目录支持ACL(例如让ALSA相关的文件可以正常工作),并且systemd也建议开启它.不确定的选"Y".</dd>
		<dt>Tmpfs extended attributes<br>CONFIG_TMPFS_XATTR</dt><dd>TMPFS文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持(仅支持trusted.*和security.*命名空间).详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.由于它被CONFIG_TMPFS_POSIX_ACL依赖,并且systemd也建议开启它.建议选"Y".</dd>
	</dl></dd>
	<dt>HugeTLB file system support<br>CONFIG_HUGETLBFS</dt><dd>这是使用大内存页的传统方式,需要专门进行配置以及应用程序的特别支持.推荐使用较新的<a href="http://blog.chinaunix.net/uid-26489617-id-3205109.html">透明大内存页</a>(CONFIG_TRANSPARENT_HUGEPAGE).选"N".</dd>
	<dt>Userspace-driven configuration filesystem<br>CONFIG_CONFIGFS_FS</dt><dd><a href="http://lwn.net/Articles/148973/">configfs</a>是一个基于内存的虚拟文件系统,与sysfs类似但又有不同:configfs用于从用户空间查看/修改/创建/删除内核对象,而sysfs仅能查看/修改由内核负责创建和删除的对象.通常挂载到"/config"目录.详见"<a href="https://www.kernel.org/doc/Documentation/configfs/">Documentation/configfs/</a>"目录中的文档.不确定的选"N".</dd>
</dl></dd>
<dt>Miscellaneous filesystems<br>CONFIG_MISC_FILESYSTEMS</dt><dd>各种非主流的杂项文件系统,有些是专用于嵌入式系统,有些是来自于其他操作系统,还有些专用于某些特定场合.</dd>
<dd><dl>
	<dt class="omit">{此处省略哪些非常非主流的文件系统}</dt>
	<dt>eCrypt filesystem layer support<br>CONFIG_ECRYPT_FS</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-ecryptfs/">eCryptfs</a>是一个符合POSIX标准的企业级文件系统加密栈(加密/解密转换层),工作在<a href="http://www.ibm.com/developerworks/cn/linux/l-virtual-filesystem-switch/">VFS</a>(虚拟文件系统)层,可以在各种普通文件系统上使用(需要<a href="http://ecryptfs.org/">ecryptfs-utils</a>工具).eCryptfs将加密元数据保存在每个文件的首部,从而允许文件在不同主机之间任意移动,同时又能确保仅在内核密钥环中拥有正确密钥的时候才能解密文件的内容.此外,eCryptfs还支持高级密匙管理和配置策略.[提示]<a href="http://wiki.ubuntu.org.cn/Ecryptfs%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">使用eCryptfs</a>之后,读操作性能最大可下降1/3左右,写操作性能则普遍下降一个数量级.</dd>
	<dd><dl>
		<dt>Enable notifications for userspace key wrap/unwrap<br>CONFIG_ECRYPT_FS_MESSAGING</dt><dd>允许ecryptfsd守护进程操作/dev/ecryptfs设备.这将允许用户空间使用其他后端(例如OpenSSL)加密/解密FEK(file encryption key).不确定的选"N".</dd>
	</dl></dd>
	<dt>SquashFS 4.0 - Squashed file system support<br>CONFIG_SQUASHFS</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/1306_qinzl_squashfs/">SquashFS</a>是一种高压缩率的只读文件系统,可以使用多种压缩算法(例如zlib,xz,lzo).<a href="http://squashfs.sourceforge.net/">SquashFS</a>常用于嵌入式设备和LiveCD系统.</dd>
	<dd><dl>
		<dt>Squashfs XATTR support<br>CONFIG_SQUASHFS_XATTR</dt><dd>Squashfs文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选"N".</dd>
		<dt>Include support for ZLIB compressed file systems<br>CONFIG_SQUASHFS_ZLIB</dt><dd>ZLIB是Squashfs默认的标准压缩算法.在压缩率和性能之间达到了最佳的平衡.</dd>
		<dt>Include support for LZO compressed file systems<br>CONFIG_SQUASHFS_LZO</dt><dd>LZO是性能最佳的压缩算法(CPU和内存占用都很低),但是压缩率确是最差的.常用于资源有限的嵌入式系统.</dd>
		<dt>Include support for XZ compressed file systems<br>CONFIG_SQUASHFS_XZ</dt><dd>XZ是压缩率最佳的压缩算法,但其CPU和内存占用都最高.可用于PC环境.</dd>
		<dt>Use 4K device block size?<br>CONFIG_SQUASHFS_4K_DEVBLK_SIZE</dt><dd>出于降低潜伏时间的考虑,Squashfs默认使用1K大小的块.但是在<a href="http://www.cnblogs.com/hnrainll/archive/2011/05/17/2048288.html">MTD NAND</a>设备上,使用4K大小的块才可以获得最佳性能.此外,在大多数设备上,使用4K大小的块才能获得最佳连续读取性能.如果你的Squashfs位于闪存设备上,建议选"Y".否则建议选"N".</dd>
		<dt>Additional option for memory-constrained systems<br>CONFIG_SQUASHFS_EMBEDDED</dt><dd>允许强制指定缓存大小.不确定的选"N".</dd>
		<dd><dl>
			<dt>Number of fragments cached<br>CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE</dt><dd>SquashFS默认缓存最后3个从文件系统上读取的片段.降低此值(最小值是"1",不能设为"0")可以降低内存的占用,但是会增加底层物理设备的读取次数.增加此值则正好相反.[提示]按一般经验,大于"3"的值并不能带来显著的性能提升.</dd>
		</dl></dd>
	</dl></dd>
	<dt>EFI Variable filesystem<br>CONFIG_EFIVAR_FS</dt><dd>efivarfs是访问"EFI变量"的新方式,意在取代传统的sysfs(CONFIG_EFI_VARS)方式,其主要优点是可以突破sysfs中变量值不能超出1024字节的限制.开启后可支持各种<a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Userspace_Tools">操作EFI变量的工具</a>:<a href="https://github.com/vathpela/efivar">efivar‎</a>,<a href="http://linux.dell.com/efibootmgr/">efibootmgr</a>,<a href="https://github.com/vathpela/efibootmgr">vathpela/efibootmgr</a>,<a href="https://github.com/fpmurphy/Various">uefivars</a>,<a href="http://git.kernel.org/cgit/linux/kernel/git/jejb/efitools.git">efitools</a>,<a href="https://wiki.ubuntu.com/Kernel/Reference/fwts">fwts</a>(Firmware Test Suite).systemd依赖于它.建议选"Y".</dd>
</dl></dd>
<dt>Network File Systems<br>CONFIG_NETWORK_FILESYSTEMS</dt><dd>网络文件系统</dd>
<dd><dl>
	<dt>NFS client support<br>CONFIG_NFS_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">NFS</a>(Network File System)客户端支持,这样就可以使用<a href="http://linux-nfs.org/">nfs-utils</a>包中的<a href="http://linux.die.net/man/8/mount.nfs">mount.nfs</a>工具挂载远程服务器提供的NFS文件系统.详见<a href="http://linux.die.net/man/5/nfs">nfs</a>手册页.</dd>
	<dd><dl>
		<dt>NFS client support for NFS version 2<br>CONFIG_NFS_V2</dt><dd>NFSv2(RFC 1094)版本协议支持</dd>
		<dt>NFS client support for NFS version 3<br>CONFIG_NFS_V3</dt><dd>NFSv3(RFC 1813)版本协议支持</dd>
		<dd><dl>
			<dt>NFS client support for the NFSv3 ACL protocol extension<br>CONFIG_NFS_V3_ACL</dt><dd>为NFSv3添加POSIX ACL支持(Solaris NFSv3 ACL).大多数NFS服务器都不支持这个扩展.不确定的选"N".</dd>
		</dl></dd>
		<dt>NFS client support for NFS version 4<br>CONFIG_NFS_V4</dt><dd>NFSv4(RFC 3530)版本协议支持</dd>
		<dt>Provide swap over NFS support<br>CONFIG_NFS_SWAP</dt><dd>允许将NFS文件系统用做swap分区.</dd>
	</dl></dd>
	<dt>NFS client support for NFSv4.1<br>CONFIG_NFS_V4_1</dt><dd><a href="http://stor-age.zdnet.com.cn/stor-age/2008/0331/786932.shtml">NFSv4.1</a>(RFC 5661)版本协议客户端支持,这样就可以使用<a href="http://linux-nfs.org/">nfs-utils</a>包中的<a href="http://linux.die.net/man/8/mount.nfs">mount.nfs</a>工具挂载远程服务器提供的NFS文件系统.详见<a href="http://linux.die.net/man/5/nfs">nfs</a>手册页以及<a href="http://blog.csdn.net/ycnian/article/details/8515517">NFS各个版本之间的比较</a>.</dd>
	<dd><dl>
		<dt>NFSv4.1 Implementation ID Domain<br>CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN</dt><dd>NFSv4.1规范新引入了<a href="http://www.cnblogs.com/zhenjing/archive/2011/05/29/NFS4_1_session.html">会话机制</a>,该选项定义在建立会话过程中使用在EXCHANGE_ID指令中的"domain"部分的值.这个值必须是个标准的DNS域名格式.如果你没有修改内核的NFS客户端代码,那么请保持默认值"kernel.org".</dd>
	</dl></dd>
	<dt>Root file system on NFS<br>CONFIG_ROOT_NFS</dt><dd>允许将NFS挂载为根文件系统(root=/dev/nfs),通常用于没有本地存储设备的无盘工作站(还必须开启CONFIG_IP_PNP以及至少一个子项).详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt">Documentation/filesystems/nfs/nfsroot.txt</a>"文档.</dd>
	<dt>Provide NFS client caching support<br>CONFIG_NFS_FSCACHE</dt><dd>为NFS提供本地缓存支持,也就是利用CONFIG_FSCACHE选项的功能.</dd>
	<dt>Use the legacy NFS DNS resolver<br>CONFIG_NFS_USE_LEGACY_DNS</dt><dd>内核现在有自己的DNS解析实现,如果你依然想使用老式的DNS解析脚本,可以选"Y".不确定的选"N".</dd>
	<dt>NFS server support<br>CONFIG_NFSD</dt><dd>NFS服务器端支持.要实现此功能,还需要<a href="http://linux-nfs.org/">nfs-utils</a>软件包的支持.详见<a href="http://linux.die.net/man/5/nfs">nfs</a>手册页.这里也有一个<a href="http://blog.csdn.net/ycnian/article/category/1320297">NFS文章系列</a>可以看看.此选项内嵌了NFSv2协议支持.</dd>
	<dd><dl>
		<dt>NFS server support for NFS version 3<br>CONFIG_NFSD_V3</dt><dd>NFSv3(RFC 1813)版本协议支持</dd>
		<dd><dl>
			<dt>NFS server support for the NFSv3 ACL protocol extension<br>CONFIG_NFSD_V3_ACL</dt><dd>为NFSv3添加POSIX ACL支持(Solaris NFSv3 ACL).此扩展并不属于NFSv3协议的官方内容.</dd>
		</dl></dd>
		<dt>NFS server support for NFS version 4<br>CONFIG_NFSD_V4</dt><dd>NFSv4(RFC 3530)版本协议支持</dd>
		<dd><dl>
			<dt>NFS server manual fault injection<br>CONFIG_NFSD_FAULT_INJECTION</dt><dd>仅供调试使用</dd>
		</dl></dd>
	</dl></dd>
	<dt>Secure RPC: Kerberos V mechanism<br>CONFIG_RPCSEC_GSS_KRB5</dt><dd>为使用<a href="http://zh.wikipedia.org/wiki/Kerberos">Kerberos</a> V5 GSS-API身份验证机制(RFC1964)的<a href="http://docs.oracle.com/cd/E19253-01/819-7061/auth-2/index.html">安全RPC</a>提供支持.要实现此功能,还需要<a href="http://linux-nfs.org/">nfs-utils</a>软件包以及用户空间的<a href="http://zhumeng8337797.blog.163.com/blog/static/10076891420104410573960/">Kerberos</a>支持.</dd>
	<dt>RPC: Enable dprintk debugging<br>CONFIG_SUNRPC_DEBUG</dt><dd>允许使用rpcdebug工具调试RPC故障,如果选"N"会让故障调试特别困难.</dd>
	<dt>Ceph distributed file system<br>CONFIG_CEPH_FS</dt><dd>允许挂载<a href="http://ceph.newdream.net/">Ceph</a>分布式文件系统.不确定的选"N".详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/ceph.txt">Documentation/filesystems/ceph.txt</a>"文档.</dd>
	<dt>CIFS support (advanced network filesystem, SMBFS successor)<br>CONFIG_CIFS</dt><dd><a href="http://baike.baidu.com/view/1034390.htm">CIFS</a>(Common Internet File System)协议客户端支持.CIFS主要用于Linux与Windows之间共享文件系统.如果你打算挂载<a href="http://www.microsoft.com/china/windowsxp/pro/using/itpro/managing/filesharing.mspx">Windows的共享文件夹</a>,或者由<a href="http://linux.vbird.org/linux_server/0370samba.php">Samba</a>提供的文件系统,就选"Y".详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/cifs.txt">Documentation/filesystems/cifs.txt</a>"文档.</dd>
	<dd><dl>
		<dt>CIFS statistics<br>CONFIG_CIFS_STATS</dt><dd>在/proc/fs/cifs/Stats文件中显示每个被挂载的CIFS文件系统的统计信息</dd>
		<dd><dl>
			<dt>Extended statistics<br>CONFIG_CIFS_STATS2</dt><dd>在/proc/fs/cifs/目录下显示更详细的统计信息.对运行性能和内存占用都有些影响.不确定的选"N".</dd>
		</dl></dd>
		<dt>Support legacy servers which use weaker LANMAN security<br>CONFIG_CIFS_WEAK_PW_HASH</dt><dd>选"N",除非你确实知道自己在干什么.</dd>
		<dt>Kerberos/SPNEGO advanced session setup<br>CONFIG_CIFS_UPCALL</dt><dd>Kerberos/<a href="http://baike.baidu.com/view/5160766.htm">SPNEGO</a>高级会话支持.不确定的选"N".</dd>
		<dt>CIFS extended attributes<br>CONFIG_CIFS_XATTR</dt><dd>CIFS文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.不确定的选"N".</dd>
		<dd><dl>
			<dt>CIFS POSIX Extensions<br>CONFIG_CIFS_POSIX</dt><dd>CIFS POSIX扩展.不确定的选"N".</dd>
			<dt>Provide CIFS ACL support<br>CONFIG_CIFS_ACL</dt><dd>允许从服务器抓取CIFS/NTFS ACL.不确定的选"N".</dd>
		</dl></dd>
		<dt>Enable CIFS debugging routines<br>CONFIG_CIFS_DEBUG</dt><dd>仅供调试使用</dd>
		<dt>DFS feature support<br>CONFIG_CIFS_DFS_UPCALL</dt><dd><a href="http://technet.microsoft.com/library/Cc960860">DFS</a>(Distributed File System)支持.不确定的选"N".</dd>
		<dt>SMB2 network file system support<br>CONFIG_CIFS_SMB2</dt><dd>仅供开发与调试使用</dd>
	</dl></dd>
	<dt>Provide CIFS client caching support<br>CONFIG_CIFS_FSCACHE</dt><dd>为CIFS提供本地缓存支持,也就是利用CONFIG_FSCACHE选项的功能.</dd>
	<dt>NCP file system support (to mount NetWare volumes)<br>CONFIG_NCP_FS</dt><dd>NCP(NetWare Core Protocol)协议支持.这东西早就销声匿迹了,选"N".</dd>
	<dt>Coda file system support (advanced network fs)<br>CONFIG_CODA_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/Coda">Coda</a>是一种比NFS更先进的分布式集群文件系统.<a href="http://zh.linuxvirtualserver.org/">LVS</a>(Linux Virtual Server)就采用了<a href="http://www.bsdmap.com/diary/coda.php">Coda分布式文件系统</a>.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/coda.txt">Documentation/filesystems/coda.txt</a>"文档.</dd>
	<dt>Andrew File System support<br>CONFIG_AFS_FS</dt><dd><a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%BE%B7%E9%AD%AF%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1">AFS</a>(Andrew File System)文件系统的实验性支持,目前仅支持只读访问.详见"<a href="https://www.kernel.org/doc/Documentation/filesystems/afs.txt">Documentation/filesystems/afs.txt</a>"文档.</dd>
	<dt>Provide AFS client caching support<br>CONFIG_AFS_FSCACHE</dt><dd>为AFS提供本地缓存支持,也就是利用CONFIG_FSCACHE选项的功能.</dd>
	<dt>Plan 9 Resource Sharing Support (9P2000)<br>CONFIG_9P_FS</dt><dd>9P2000协议是<a href="http://baike.baidu.com/view/1597745.htm">Plan 9</a>概念网络操作系统上使用的资源共享协议.不确定的选"N".</dd>
</dl></dd>
<dt>Native language support<br>CONFIG_NLS</dt><dd>本地语言支持.仅在你使用FAT/NTFS/JOLIET文件系统的情况下才需要这个东西.</dd>
<dd><dl>
	<dt>Default NLS Option<br>CONFIG_NLS_DEFAULT</dt><dd>挂载文件系统时,控制台的默认本地语言(不是文件系统用于存储文件名的语言),建议设为"utf8"(因为控制台的默认编码是"utf8":vt.default_utf8=1).</dd>
	<dt class="omit">{此处省略的各种字符集请按需选择}</dt>
</dl></dd>
<dt>Distributed Lock Manager (DLM)<br>CONFIG_DLM</dt><dd>通用的分布式锁管理器(<a href="http://en.wikipedia.org/wiki/Distributed_lock_manager">DLM</a>).用于为各种分布式文件系统提供通用的锁定支持.集群强烈依赖于这个驱动.</dd>
<dd><dl>
	<dt>DLM debugging<br>CONFIG_DLM_DEBUG</dt><dd>仅供开发与调试使用</dd>
</dl></dd>
</dl>






<h2>Kernel hacking<br />内核hack选项</h2>
<dl>
<dt>Show timing information on printks<br>CONFIG_PRINTK_TIME</dt><dd>在控制台和syslog()系统调用的输出中包含printk()消息的时间戳,以便于直接显示内核启动过程中各步骤所用的时间.注意:无论此项是否开启,时间戳总会被记录在/dev/kmsg中,开启此项仅相当于使用"printk.time=1"内核引导参数.</dd>
<dt>Default message log level (1-7)<br>CONFIG_DEFAULT_MESSAGE_LOGLEVEL</dt><dd>printk()内核消息日志的默认级别,取值范围是[1,7].任何由printk显示的字符串通常记录在/var/log/messages文件里.数值越大显示的消息就越详细:1=ALERT,2=CRIT,3=ERR,4=WARNING,5=NOTICE,6=INFO,7=DEBUG.</dd>
<dt>Enable __deprecated logic<br>CONFIG_ENABLE_WARN_DEPRECATED</dt><dd>编译时开启"反对使用"逻辑检查,关闭此项将不会显示类似"warning: 'foo' is deprecated (declared at kernel/power/somefile.c:1234)"这样的警告消息.</dd>
<dt>Enable __must_check logic<br>CONFIG_ENABLE_MUST_CHECK</dt><dd>编译时开启"必须检查"逻辑检查,关闭此项将不会显示类似"warning: ignoring return value of 'foo', declared with attribute warn_unused_result"这样的警告消息.</dd>
<dt>Warn for stack frames larger than (needs gcc 4.4)<br>CONFIG_FRAME_WARN</dt><dd>堆栈帧大小警告阈值,设置过小会导致编译时警告太多,设为"0"可以关闭警告,需要GCC-4.4或更高版本</dd>
<dt>Strip assembler-generated symbols during link<br>CONFIG_STRIP_ASM_SYMS</dt><dd>连接时剥离汇编器产生的内部符号(类似'.Lxxx'),这样可以净化get_wchan()之类的输出,同时还可以减小内核尺寸.建议开启.</dd>
<dt>Magic SysRq key<br>CONFIG_MAGIC_SYSRQ</dt><dd>开启"<a href="http://www.docin.com/p-188851857.html">魔法键</a>"(<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sysrq/">SysRq</a>,允许用户按下Alt+PrintScreen后发送给内核特殊的命令)支持(可以通过"echo 0 > /proc/sys/kernel/sysrq"关闭).由于SysRq会带来安全隐患(允许未经登录的操作),所以你应该仅在确实需要的场合开启.更多详情参见"<a href="https://www.kernel.org/doc/Documentation/sysrq.txt">Documentation/sysrq.txt</a>"文档</dd>
<dd><dl>
	<dt>Enable magic SysRq key functions by default<br>CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE</dt><dd>设置默认开启哪些魔法键.设为"1"表示开启所有魔法键,设为"0"表示禁用所有魔法键.或者按照"<a href="https://www.kernel.org/doc/Documentation/sysrq.txt">Documentation/sysrq.txt</a>"文档的指引设置特定的码位.</dd>
</dl></dd>
<dt>Generate readable assembler code<br>CONFIG_READABLE_ASM</dt><dd>生成人类易读的汇编输出,以方便内核调试.这会禁用一些编译优化措施,也会降低内核的运行速度.</dd>
<dt>Enable unused/obsolete exported symbols<br>CONFIG_UNUSED_SYMBOLS</dt><dd>导出无用和废弃的符号,这将使内核不必要的增大.建议关闭.</dd>
<dt>Debug Filesystem<br>CONFIG_DEBUG_FS</dt><dd>debugfs是内核开发者用来存储调试信息的虚拟文件系统.不搞内核开发就别选</dd>
<dt>Run 'make headers_check' when building vmlinux<br>CONFIG_HEADERS_CHECK</dt><dd>在编译内核时运行'make headers_check'命令检查内核头文件的正确性,当你修改了与用户空间相关的内核头文件后应该启用该选项</dd>
<dt>Enable full Section mismatch analysis<br>CONFIG_DEBUG_SECTION_MISMATCH</dt><dd>在编译时检查无效的引用.仅供内核开发者使用</dd>
<dt>Make section mismatch errors non-fatal<br>CONFIG_SECTION_MISMATCH_WARN_ONLY</dt><dd>若选"N",那么一旦出现"section mismatch",将会直接导致编译失败(而不是仅仅抛出警告).建议选"N".</dd>
<dt>Kernel debugging<br>CONFIG_DEBUG_KERNEL</dt><dd>仅供内核开发者使用.[提示]如果你开启了CONFIG_EXPERT,此项会被强制选中,如果这不是你想要的,可以到内核源码树的根目录下使用"sed -i '/select DEBUG_KERNEL/d' usr/src/linux/init/Kconfig"命令去掉这个依赖.</dd>
<dt>Panic on Oops<br>CONFIG_PANIC_ON_OOPS</dt><dd>当内核<a href="http://www.cnblogs.com/wwang/archive/2010/11/14/1876735.html">oops</a>时,直接<a href="http://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E9%94%99%E8%AF%AF">panic</a>掉(相当于Windows蓝屏死机),这样可以确保内核停止工作,避免导致无法预料的后果.等价于使用"oops=panic"内核引导参数.不确定的选"Y".</dd>
<dd><dl>
	<dt>panic timeout<br>CONFIG_PANIC_TIMEOUT</dt><dd>如何处理内核崩溃(panic):(1)若设为"0"则表示无限等待,不做任何处理;(2)若设为正整数则表示等待设定的秒数之后重启;(3)若设为负整数则表示立即重启.</dd>
</dl></dd>
<dt>Enable extra timekeeping sanity checking<br>CONFIG_DEBUG_TIMEKEEPING</dt><dd>仅供内核开发者使用</dd>
<dt>Detect Hung Tasks<br>CONFIG_DETECT_HUNG_TASK</dt><dd>探测挂起的任务(进程被锁住或者冻结了,处于不可中断的"D"状态).由于仅能检测,不能做进一步的处理,所以仅用于帮助内核调试.</dd>
<dt>Collect scheduler debugging info<br>CONFIG_SCHED_DEBUG</dt><dd>提供一个"/proc/sched_debug"文件以帮助调试调度程序.仅供内核开发以及调试调度程序使用.</dd>
<dt>Collect scheduler statistics<br>CONFIG_SCHEDSTATS</dt><dd>收集调度程序的统计信息,并展示在"/proc/schedstat"文件中.可以用于调试调度程序,或者调整特定的应用程序.不确定的选"N".</dd>
<dt>Collect kernel timers statistics<br>CONFIG_TIMER_STATS</dt><dd>收集内核计时器的统计信息,并展示在"/proc/timer_stats"文件中.使用"echo 1 > /proc/timer_stats"开启统计,使用"echo 0 > /proc/timer_stats"关闭统计.不确定的选"N".</dd>
<dt>Debug object operations<br>CONFIG_DEBUG_OBJECTS</dt><dd>跟踪各种对象的生命周期(life time),并校验对这些对象的各种操作.仅供内核调试.</dd>
<dt>Debug slab memory allocations<br>CONFIG_DEBUG_SLAB</dt><dd>仅供内核开发者使用</dd>
<dt>SLUB debugging on by default<br>CONFIG_SLUB_DEBUG_ON</dt><dd>默认开启SLUB内存分配器调试功能.仅供调试,切勿用于生产环境.</dd>
<dt>Enable SLUB performance statistics<br>CONFIG_SLUB_STATS</dt><dd>收集SLUB内存分配器的性能统计信息.仅供调试,切勿用于生产环境.</dd>
<dt>Kernel memory leak detector<br>CONFIG_DEBUG_KMEMLEAK</dt><dd>内核内存泄漏检测.仅供内核调试.</dd>
<dt>Debug preemptible kernel<br>CONFIG_DEBUG_PREEMPT</dt><dd>对内核的主动抢占特性进行调试.仅供内核开发者使用</dd>
<dt>RT Mutex debugging, deadlock detection<br>CONFIG_DEBUG_RT_MUTEXES</dt><dd>仅供内核开发者使用</dd>
<dt>Built-in scriptable tester for rt-mutexes<br>CONFIG_RT_MUTEX_TESTER</dt><dd>仅供内核开发者使用</dd>
<dt>Spinlock and rw-lock debugging: basic checks<br>CONFIG_DEBUG_SPINLOCK</dt><dd>仅供内核开发者使用</dd>
<dt>Mutex debugging: basic checks<br>CONFIG_DEBUG_MUTEXES</dt><dd>仅供内核开发者使用</dd>
<dt>Lock debugging: detect incorrect freeing of live locks<br>CONFIG_DEBUG_LOCK_ALLOC</dt><dd>仅供内核开发者使用</dd>
<dt>Lock debugging: prove locking correctness<br>CONFIG_PROVE_LOCKING</dt><dd>仅供内核开发者使用</dd>
<dt>Lock usage statistics<br>CONFIG_LOCK_STAT</dt><dd>仅供内核开发者使用</dd>
<dt>Lock dependency engine debugging<br>CONFIG_DEBUG_LOCKDEP</dt><dd>仅供内核开发者使用</dd>
<dt>Sleep inside atomic section checking<br>CONFIG_DEBUG_ATOMIC_SLEEP</dt><dd>仅供内核开发者使用</dd>
<dt>Locking API boot-time self-tests<br>CONFIG_DEBUG_LOCKING_API_SELFTESTS</dt><dd>在内核启动时运行一个简短的加锁/解锁函数(spinlocks,rwlocks,mutexes,rwsems)自我测试.仅供内核开发者使用</dd>
<dt>Stack utilization instrumentation<br>CONFIG_DEBUG_STACK_USAGE</dt><dd>仅供内核开发者使用</dd>
<dt>kobject debugging<br>CONFIG_DEBUG_KOBJECT</dt><dd>仅供内核开发者使用</dd>
<dt>Verbose BUG() reporting (adds 70K)<br>CONFIG_DEBUG_BUGVERBOSE</dt><dd>在内核panic时让BUG()函数报告更详细的信息.内核将会增大70-100K.</dd>
<dt>Compile the kernel with debug info<br>CONFIG_DEBUG_INFO</dt><dd>以调试方式编译内核(gcc -g).仅供内核开发者使用</dd>
<dt>Debug VM<br>CONFIG_DEBUG_VM</dt><dd>仅供内核开发者使用</dd>
<dt>Debug VM translations<br>CONFIG_DEBUG_VIRTUAL</dt><dd>仅供内核开发者使用</dd>
<dt>Debug filesystem writers count<br>CONFIG_DEBUG_WRITECOUNT</dt><dd>仅供内核开发者使用</dd>
<dt>Debug memory initialisation<br>CONFIG_DEBUG_MEMORY_INIT</dt><dd>在内存初始化时增加额外的合理性检查.不确定的选"Y".</dd>
<dt>Debug linked list manipulation<br>CONFIG_DEBUG_LIST</dt><dd>仅供内核开发者使用</dd>
<dt>Linked list sorting test<br>CONFIG_TEST_LIST_SORT</dt><dd>仅供内核开发者使用</dd>
<dt>Debug SG table operations<br>CONFIG_DEBUG_SG</dt><dd>仅供内核开发者使用</dd>
<dt>Debug notifier call chains<br>CONFIG_DEBUG_NOTIFIERS</dt><dd>仅供内核开发者使用</dd>
<dt>Debug credential management<br>CONFIG_DEBUG_CREDENTIALS</dt><dd>仅供内核开发者使用</dd>
<dt>Compile the kernel with frame pointers<br>CONFIG_FRAME_POINTER</dt><dd>仅供内核开发者使用</dd>
<dt>Delay each boot printk message by N milliseconds<br>CONFIG_BOOT_PRINTK_DELAY</dt><dd>仅供内核开发者使用</dd>
<dt>Stack backtrace support<br>CONFIG_STACKTRACE</dt><dd>仅供内核开发者使用.</dd>
<dt>RCU Debugging</dt><dd>仅供内核开发者使用.建议所有子项全选"N".</dd>
<dt>Kprobes sanity tests<br>CONFIG_KPROBES_SANITY_TEST</dt><dd>仅供内核开发者使用</dd>
<dt>Self test for the backtrace code<br>CONFIG_BACKTRACE_SELF_TEST</dt><dd>仅供内核开发者使用</dd>
<dt>Force extended block device numbers and spread them<br>CONFIG_DEBUG_BLOCK_EXT_DEVT</dt><dd>仅供内核开发者使用</dd>
<dt>Force weak per-cpu definitions<br>CONFIG_DEBUG_FORCE_WEAK_PER_CPU</dt><dd>仅供内核开发者使用</dd>
<dt>Debug access to per_cpu maps<br>CONFIG_DEBUG_PER_CPU_MAPS</dt><dd>仅供内核开发者使用</dd>
<dt>Linux Kernel Dump Test Tool Module<br>CONFIG_LKDTM</dt><dd>仅供内核开发者使用</dd>
<dt>Notifier error injection<br>CONFIG_NOTIFIER_ERROR_INJECTION</dt><dd>仅供内核开发者使用</dd>
<dt>Fault-injection framework<br>CONFIG_FAULT_INJECTION</dt><dd>仅供内核开发者使用</dd>
<dt>Latency measuring infrastructure<br>CONFIG_LATENCYTOP</dt><dd>仅供内核开发者使用</dd>
<dt>Strict user copy size checks<br>CONFIG_DEBUG_STRICT_USER_COPY_CHECKS</dt><dd>仅供内核开发者使用</dd>
<dt>Debug page memory allocations<br>CONFIG_DEBUG_PAGEALLOC</dt><dd>仅供内核开发者使用</dd>
<dt>Tracers<br>CONFIG_FTRACE</dt><dd>仅供内核开发者使用.建议选"N".</dd>
<dt>Runtime Testing</dt><dd>运行时自我检查.建议子项全选"N".</dd>
<dt>Red-Black tree test<br>CONFIG_RBTREE_TEST</dt><dd>仅供内核开发者使用</dd>
<dt>Interval tree test<br>CONFIG_INTERVAL_TREE_TEST</dt><dd>仅供内核开发者使用</dd>
<dt>Remote debugging over FireWire early on boot<br>CONFIG_PROVIDE_OHCI1394_DMA_INIT</dt><dd>仅供内核开发者使用</dd>
<dt>Remote debugging over FireWire with firewire-ohci<br>CONFIG_FIREWIRE_OHCI_REMOTE_DMA</dt><dd>仅供内核开发者使用</dd>
<dt>Build targets in Documentation/ tree<br>CONFIG_BUILD_DOCSRC</dt><dd>编译内核源码树下"Documentation"目录中的目标.不确定的选"N".</dd>
<dt>Enable dynamic printk() support<br>CONFIG_DYNAMIC_DEBUG</dt><dd>仅供内核开发者使用</dd>
<dt>Enable debugging of DMA-API usage<br>CONFIG_DMA_API_DEBUG</dt><dd>仅供内核开发者使用</dd>
<dt>Perform an atomic64_t self-test at boot<br>CONFIG_ATOMIC64_SELFTEST</dt><dd>仅供内核开发者使用</dd>
<dt>Self test for hardware accelerated raid6 recovery<br>CONFIG_ASYNC_RAID6_TEST</dt><dd>仅供内核开发者使用</dd>
<dt>Sample kernel code<br>CONFIG_SAMPLES</dt><dd>内核示例代码.仅供内核开发者使用</dd>
<dt>KGDB: kernel debugger<br>CONFIG_KGDB</dt><dd>仅供内核开发者使用</dd>
<dt>kmemcheck: trap use of uninitialized memory<br>CONFIG_KMEMCHECK</dt><dd>仅供内核开发者使用</dd>
<dt>Test functions located in the string_helpers module at runtime<br>CONFIG_TEST_STRING_HELPERS</dt><dd>仅供内核开发者使用</dd>
<dt>Test kstrto*() family of functions at runtime<br>CONFIG_TEST_KSTRTOX</dt><dd>仅供内核开发者使用</dd>
<dt>Filter access to /dev/mem<br>CONFIG_STRICT_DEVMEM</dt><dd>如果选"N",那么用户空间的root用户将可以通过<a href="http://blog.csdn.net/skyflying2012/article/details/47611399">/dev/mem</a>访问所有内存空间(包括用户空间与内核空间),以方便调试内核.如果选"Y",那么内核空间除了PCI和BIOS部分以及数据区之外,都禁止访问,以保护系统安全.不确定的选"Y".</dd>
<dt>Enable verbose x86 bootup info messages<br>CONFIG_X86_VERBOSE_BOOTUP</dt><dd>在启动时显示额外bzimage解压消息,显示详细的内核引导信息.建议选"N"使引导过程更安静(依然会显示错误信息).</dd>
<dt>Early printk<br>CONFIG_EARLY_PRINTK</dt><dd>将内核日志直接输出到VGA缓冲或串口.这有助于调试那些在控制台尚未完成初始化之前就造成系统崩溃的bug.</dd>
<dd><dl>
	<dt>Early printk via EHCI debug port<br>CONFIG_EARLY_PRINTK_DBGP</dt><dd>支持将内核日志直接通过EHCI调试端口输出.选"N",除非你想调试内核.</dd>
</dl></dd>
<dt>Dump the EFI pagetable<br>CONFIG_EFI_PGT_DUMP</dt><dd>仅供内核开发者使用</dd>
<dt>Check for stack overflows<br>CONFIG_DEBUG_STACKOVERFLOW</dt><dd>仅供内核开发者使用</dd>
<dt>Export kernel pagetable layout to userspace via debugfs<br>CONFIG_X86_PTDUMP</dt><dd>仅供内核开发者使用</dd>
<dt>Write protect kernel read-only data structures<br>CONFIG_DEBUG_RODATA</dt><dd>仅供内核开发者使用</dd>
<dt>Set loadable kernel module data as NX and text as RO<br>CONFIG_DEBUG_SET_MODULE_RONX</dt><dd>将内核模块的数据区标记为NX(不可执行),文本段标记为RO(只读),以防止不良模块(例如被植入病毒的模块)对系统的破坏,也能预防某些类型的内核入侵.这需要CPU支持<a href="http://zh.wikipedia.org/wiki/NX%E4%BD%8D%E5%85%83">NX位</a>(CPU flags中要含有"nx"标志).但是这也有副作用:会与运行时代码补丁冲突,还会导致动态内核跟踪失效.建议选"Y",除非你需要调试内核,或者需要为运行中的模块打补丁.</dd>
<dt>Testcase for the NX non-executable stack feature<br>CONFIG_DEBUG_NX_TEST</dt><dd>对处理器的NX的测试用例.仅供内核开发者使用</dd>
<dt>Set upper limit of TLB entries to flush one-by-one<br>CONFIG_DEBUG_TLBFLUSH</dt><dd>仅供内核开发者使用</dd>
<dt>Enable doublefault exception handler<br>CONFIG_DOUBLEFAULT</dt><dd>仅供内核开发者使用</dd>
<dt>Enable IOMMU debugging<br>CONFIG_IOMMU_DEBUG</dt><dd>仅供内核开发者使用</dd>
<dt>Enable IOMMU stress-test mode<br>CONFIG_IOMMU_STRESS</dt><dd>仅供内核开发者使用</dd>
<dt>IOMMU leak tracing<br>CONFIG_IOMMU_LEAK</dt><dd>仅供内核开发者使用</dd>
<dt>x86 instruction decoder selftest<br>CONFIG_X86_DECODER_SELFTEST</dt><dd>仅供内核开发者使用</dd>
<dt>IO delay type</dt><dd>IO延迟方式</dd>
<dd><dl>
	<dt>port 0x80 based port-IO delay<br>CONFIG_IO_DELAY_0X80</dt><dd>传统的Linux IO延迟方式,久经考验,也是最安全的默认值.</dd>
	<dt>port 0xed based port-IO delay<br>CONFIG_IO_DELAY_0XED</dt><dd>基于0xed端口的IO延迟方式,主要是为了避免和基于0x80端口的<a href="http://baike.baidu.com/view/288235.htm">主板诊断卡</a>冲突.绝大多数人都没有主板诊断卡,除非那些专门维修主板的硬件工程师.</dd>
	<dt>udelay based port-IO delay<br>CONFIG_IO_DELAY_UDELAY</dt><dd>使用内核端udelay()函数作为延迟方法(简单的延迟2微秒).可以不占用任何IO端口空间.</dd>
	<dt>no port-IO delay<br>CONFIG_IO_DELAY_NONE</dt><dd>不使用任何port-IO延迟机制.只要你的机器不是老古董,建议选择此项.</dd>
</dl></dd>
<dt>Debug boot parameters<br>CONFIG_DEBUG_BOOT_PARAMS</dt><dd>仅供内核开发者使用</dd>
<dt>CPA self-test code<br>CONFIG_CPA_DEBUG</dt><dd>仅供内核开发者使用</dd>
<dt>Allow gcc to uninline functions marked 'inline'<br>CONFIG_OPTIMIZE_INLINING</dt><dd>允许GCC将标记为内联(inline)的函数变成非内联(uninline).选"Y"后将完全无视代码中的"inline"标记,完全由GCC自行决定是否应该将函数内联.由于GCC4.x系列更新了判断函数是否应该内联的算法,选"Y"后,编译出的内核体积会减小(但运行速度未必提升).建议选"Y".</dd>
<dt>NMI Selftest<br>CONFIG_DEBUG_NMI_SELFTEST</dt><dd>对不可屏蔽中断(Non Maskable Interrupt)进行自检,仅供内核开发者使用</dd>
<dt>ATOM Punit debug driver<br>CONFIG_PUNIT_ATOM_DEBUG</dt><dd>仅供内核开发者使用</dd>
</dl>






<h2>Security options<br />安全选项<br /><span class="little_head">这里的选项不明白的建议不要选,否则有可能弄巧成拙.</span></h2>
<dl>
<dt>Enable access key retention support<br>CONFIG_KEYS</dt><dd>在内核中保留认证令牌(<a href="http://en.wikipedia.org/wiki/Security_token">authentication token</a>)和访问密钥(access key).eCryptfs(CONFIG_ECRYPT_FS)与Docker依赖于它.不确定的选"N".</dd>
<dd><dl>
	<dt>TRUSTED KEYS<br>CONFIG_TRUSTED_KEYS</dt><dd>"TRUSTED KEY"的意思是由<a href="http://security.ctocio.com.cn/wpsummary/141/8692641.shtml">TPM</a>(<a href="http://baike.baidu.com/view/1130324.htm">可信赖平台模块</a>)用<a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA算法</a>封装的一对随机数.开启此项后,内核将可以为创建/封装/解封"TRUSTED KEY"提供支持.如果引导PCR(平台配置寄存器)和各种条件都匹配,那么TPM只解封密钥.用户空间永远只能看到加密过后的二进制内容.不确定的选"N".</dd>
	<dt>ENCRYPTED KEYS<br>CONFIG_ENCRYPTED_KEYS</dt><dd>"ENCRYPTED KEY"的意思是由内核封装的一对随机数,该对随机数可以用一个"主密钥"使用对称加密算法进行加密和解密.开启此项后,内核将可以为创建/加密/解密"ENCRYPTED KEY"提供支持."主密钥"既可以是"TRUSTED KEY"也可以是"user-key"(用户选择的密钥).用户空间永远只能看到/存储加密过后的二进制内容.不确定的选"N".</dd>
	<dt>Enable the /proc/keys file by which keys may be viewed<br>CONFIG_KEYS_DEBUG_PROC_KEYS</dt><dd>开启"/proc/keys"文件支持,该文件中保存了系统上所有可见的密钥.注意,<a href="http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/">LSM</a>(Linux安全模块)安全检查仍然是必须的.不确定的选"N".</dd>
</dl></dd>
<dt>Restrict unprivileged access to the kernel syslog<br>CONFIG_SECURITY_DMESG_RESTRICT</dt><dd>禁止非特权用户访问内核日志(<a href="http://baike.baidu.com/view/712946.htm">dmesg</a>),相当于"echo 1 &gt; /proc/sys/kernel/dmesg_restrict".不确定的选"N".</dd>
<dt>Enable different security models<br>CONFIG_SECURITY</dt><dd>允许内核选择不同的<a href="http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/">LSM</a>(<a href="https://linux.cn/article-2198-1.html">Linux安全模块</a>),如果未选中则内核将使用默认的安全模块("Default security module").不确定的选"N".</dd>
<dt>Enable the securityfs filesystem<br>CONFIG_SECURITYFS</dt><dd>securityfs安全文件系统支持.当前仅被TPM bios字符设备驱动以及IMA(完整性提供者)使用.它与SELinux或SMACK之类没有关系.不确定的选"N".</dd>
<dt>Socket and Networking Security Hooks<br>CONFIG_SECURITY_NETWORK</dt><dd>允许安全模块通过Security Hook对Socket与Networking进行访问控制.不确定的选"N".</dd>
<dd><dl>
	<dt>XFRM (IPSec) Networking Security Hooks<br>CONFIG_SECURITY_NETWORK_XFRM</dt><dd>为XFRM(IPSec)启用安全Hook.这样安全模块可以通过这些hook,根据IPSec策略标签,实现针对每个网络包的访问控制.非IPSec通信则被当做"无标签"处理,仅允许那些被明确批准可以不使用策略标签的socket才能不通过IPSec进行通信.不确定的选"N".</dd>
</dl></dd>
<dt>Security hooks for pathname based access control<br>CONFIG_SECURITY_PATH</dt><dd>此安全钩子程序可以让各种安全模块实现基于路径的访问控制.不确定的选"N".</dd>
<dt>Enable Intel(R) Trusted Execution Technology (Intel(R) TXT)<br>CONFIG_INTEL_TXT</dt><dd>支持使用<a href="http://blog.csdn.net/trustbo/article/details/9292011">可信引导</a>(<a href="http://wenku.baidu.com/view/8bccb8335a8102d276a22faf.html">Trusted Boot</a>)技术引导内核(需要使用<a href="http://tboot.sourceforge.net">tboot</a>模块).这将使用英特尔<a href="http://baike.baidu.com/view/4060870.htm">TXT</a>(<a href="http://baike.baidu.com/view/1553859.htm">可信任执行技术</a>)来引导内核.在不支持<a href="http://www.intel.com/content/www/us/en/architecture-and-technology/trusted-execution-technology/malware-reduction-general-technology.html">TXT</a>的平台上开启此项没有效果.详见"<a href="https://www.kernel.org/doc/Documentation/intel_txt.txt">Documentation/intel_txt.txt</a>"文档.不确定的选"N".</dd>
<dt>Low address space for LSM to protect from user allocation<br>CONFIG_LSM_MMAP_MIN_ADDR</dt><dd>禁止用户空间分配的低位内存范围.禁止用户写入低位内存有助于降低内核NULL指针漏洞造成的破坏(参见CONFIG_DEFAULT_MMAP_MIN_ADDR选项).建议保持默认值"65536".</dd>
<dt>NSA SELinux Support<br>CONFIG_SECURITY_SELINUX</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-secure-linux-ru/index.html">SELinux</a>(安全增强Linux)是美国国家安全局(NSA)开发的<a href="http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/index.html">Linux安全模块</a>,它拥有一个灵活而强制性的访问控制结构,可防御未知攻击,相当于B1级的军事安全性能(比微软所谓的C2等高得多).应用SELinux后,可以减轻恶意攻击或恶意软件带来的灾难,对机密性和完整性有很高要求的信息,亦可提供很高的安全保障.但另一方面,如果不深入<a href="http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?site_id=10&contentarea_by=Linux&sort_by=Date&sort_order=2&topic_by=-1&type_by=所有类别&show_abstract=true&search_by=SELinux">了解SELinux知识</a>而盲目使用,则会弄巧成拙.不确定的选"N".</dd>
<dd><dl>
	<dt>NSA SELinux boot parameter<br>CONFIG_SECURITY_SELINUX_BOOTPARAM</dt><dd>添加"selinux"内核引导参数.以允许在引导时使用'selinux=0'禁用SELinux或'selinux=1'启用SELinux.</dd>
	<dd><dl>
		<dt>NSA SELinux boot parameter default value<br>CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE</dt><dd>"selinux"内核引导参数的默认值.</dd>
	</dl></dd>
	<dt>NSA SELinux runtime disable<br>CONFIG_SECURITY_SELINUX_DISABLE</dt><dd>允许在运行时禁用SELinux.建议选"N".</dd>
	<dt>NSA SELinux Development Support<br>CONFIG_SECURITY_SELINUX_DEVELOP</dt><dd>SELinux开发支持.开启此项后,除非明确使用"enforcing=1"引导参数让内核以"强制模式"运行,否则内核将以"许可模式"运行(记录所有事件,同时允许所有操作).主要用于测试SELinux以及策略开发.此外,开启此项后,还可以在运行时通过"/selinux/enforce"让内核在"强制模式"与"许可模式"之间切换.</dd>
	<dt>NSA SELinux AVC Statistics<br>CONFIG_SECURITY_SELINUX_AVC_STATS</dt><dd>搜集访问向量缓存(access vector cache)的统计信息并在/selinux/avc/cache_stats中显示出来.这些信息可以用avcstat之类的工具查看.</dd>
	<dt>NSA SELinux checkreqprot default value<br>CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE</dt><dd>内核引导参数"checkreqprot"的默认值.设为"0"表示默认检查内核要求执行的保护策略,设为"1"表示默认检查应用程序要求执行的保护策略.此值还可以在运行时通过/selinux/checkreqprot修改.不确定的选"1".</dd>
	<dt>NSA SELinux maximum supported policy format version<br>CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX</dt><dd>将支持的策略格式的最高版本设置为一个特定的数值.该数值将通过/selinux/policyvers向用户空间报告,并在加载策略时被使用.不确定的选"N".</dd>
	<dd><dl>
		<dt>NSA SELinux maximum supported policy format version value<br></dt><dd>支持策略格式的最高版本的数值.可以通过"checkpolicy -V"命令检查当前工具链支持的版本数值.</dd>
	</dl></dd>
</dl></dd>
<dt>Simplified Mandatory Access Control Kernel Support<br>CONFIG_SECURITY_SMACK</dt><dd><a href="http://en.wikipedia.org/wiki/Smack">Smack</a>(简化的强制访问控制内核)<a href="http://zh.wikipedia.org/wiki/Linux%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B5%84">内核安全模块</a>.<a href="http://blog.csdn.net/wangzhicheng1983/article/details/9221359">Smack</a>是一种简单而有效的强制访问控制机制,它的简单体现在安全策略的配置很简单,它的有效体现在完全使用LSM作为其控制手段.不确定的选"N".</dd>
<dt>TOMOYO Linux Support<br>CONFIG_SECURITY_TOMOYO</dt><dd><a href="http://en.wikipedia.org/wiki/TOMOYO_Linux">TOMOYO Linux</a>是日本NTT数据公司开发的一种Linux安全模块.不确定的选"N".</dd>
<dt>AppArmor support<br>CONFIG_SECURITY_APPARMOR</dt><dd><a href="http://blog.csdn.net/ustc_dylan/article/details/7944955">AppArmor</a>(应用盔甲)是来自Novell的一种Linux安全模块.AppArmor使用文件路径来跟踪程序限制,是最容易配置的安全模块.不确定的选"N".</dd>
<dt>Yama support<br>CONFIG_SECURITY_YAMA</dt><dd>Yama(阎王)是3.4版内核新引入的一种Linux安全模块.不确定的选"N".</dd>
<dt>Digital signature verification using multiple keyrings<br>CONFIG_INTEGRITY_SIGNATURE</dt><dd>允许使用多个<a href="http://book.51cto.com/art/200902/108112.htm">密钥环</a>(keyring)进行数字签名验证,也就允许为多个不同的使用场合(evm,ima,module)分别使用不同的keyring.看不懂的选"N".</dd>
<dd><dl>
	<dt>Enable asymmetric keys support<br>CONFIG_INTEGRITY_ASYMMETRIC_KEYS</dt><dd>允许使用非对称密钥进行数字签名验证.</dd>
</dl></dd>
<dt>Integrity Measurement Architecture(IMA)<br>CONFIG_IMA</dt><dd><a href="http://wiki.gentoo.org/wiki/Integrity_Measurement_Architecture">IMA</a>(完整性度量架构)是一个在<a href="http://www.trustedcomputinggroup.org/cn">TCG</a>(<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97">可信计算</a>工作组)技术规范之上提出的完整性检查技术.IMA维护着一个系统关键文件的哈希值列表,从而可以检测这些关键文件是否被篡改.如果系统上有<a href="http://baike.baidu.com/view/687208.htm">TPM安全芯片</a>,那么IMA还会在TPM芯片内存储哈希值的集合.这样的TPM芯片可以提供给第三方,用于检查系统上的关键文件是否被篡改.不确定的选"N".</dd>
<dd><dl>
	<dt>Enables auditing support<br>CONFIG_IMA_AUDIT</dt><dd>添加"ima_audit"内核引导参数支持.当设为"ima_audit=1"时,将允许显示完整性审计信息.</dd>
	<dt>Appraise integrity measurements<br>CONFIG_IMA_APPRAISE</dt><dd>本地完整性鉴定支持.这样就可以在加载文件时检验它的完整性.这要求系统配置<a href="http://wiki.gentoo.org/wiki/Using_Extended_Verification_Module_in_Gentoo">EVM</a>支持.不确定的选"N".</dd>
</dl></dd>
<dt>EVM support<br>CONFIG_EVM</dt><dd><a href="https://wiki.gentoo.org/wiki/Extended_Verification_Module">EVM</a>通过保护文件的安全扩展属性来对抗完整性攻击.</dd>
<dd><dl>
	<dt>EVM HMAC version<br>CONFIG_EVM_HMAC_VERSION</dt><dd>支持的EVM HMAC版本:"1"表示原始版本,默认值"2"表示添加了文件系统<a href="http://zh.wikipedia.org/wiki/UUID">UUID</a>支持的改进版本.</dd>
</dl></dd>
<dt>Default security module</dt><dd>内核默认的安全模块.[提示]"Unix Discretionary Access Controls"是经典的UNIX基于目录的访问控制安全模型.如果没有开启任何安全模块,这将是默认值.</dd>
</dl>






<h2>Cryptographic API<br />内核加密API支持<br /><span class="little_head">这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选,内核中若有其他部分依赖它,会自动选上.使用内核树外的模块时可能需要手动选择.</span></h2>
<dl>
<dt>FIPS 200 compliance<br>CONFIG_CRYPTO_FIPS</dt><dd>"fips"内核引导参数支持.这是在<a href="http://book.2cto.com/201209/4003.html">FIPS200</a>认证的系统中运行所必须的.选"N",除非你确实知道自己在做什么.</dd>
<dt>RSA algorithm<br>CONFIG_CRYPTO_RSA</dt><dd>"<a href="http://baike.baidu.com/view/10613.htm">RSA</a>"公钥加密算法.能同时用于密钥交换和数字签名.</dd>
<dt>Cryptographic algorithm manager<br>CONFIG_CRYPTO_MANAGER</dt><dd>创建默认的加密模版实例,提供了操作内核的加密特性所需的软件.</dd>
<dt>Userspace cryptographic algorithm configuration<br>CONFIG_CRYPTO_USER</dt><dd>允许用户空间配置内核加密实例.不确定的选"N".</dd>
<dt>Disable run-time self tests<br>CONFIG_CRYPTO_MANAGER_DISABLE_TESTS</dt><dd>禁止在注册算法时进行简单的自我检测.不确定的选"Y".</dd>
<dt>GF(2^128) multiplication functions<br>CONFIG_CRYPTO_GF128MUL</dt><dd>由高效表格驱动的<a href="http://wenku.baidu.com/view/503a96fa770bf78a65295425.html">伽罗瓦域 GF(2^128)乘法器</a>支持.某些加密模式需要它.不确定的选"N".如果有其它模块需要此特性,会被自动选中.</dd>
<dt>Null algorithms<br>CONFIG_CRYPTO_NULL</dt><dd>NULL加密算法(什么也不做),用于IPsec协议的封装安全载荷模块(ESP)</dd>
<dt>Parallel crypto engine<br>CONFIG_CRYPTO_PCRYPT</dt><dd>将任意加密算法转化成并行算法,并在内核线程中执行.</dd>
<dt>Software async crypto daemon<br>CONFIG_CRYPTO_CRYPTD</dt><dd>这是一个通用的软件异步加密守护进程,可将任意的同步软件加密算法转换成在内核线程中执行的异步算法.</dd>
<dt>Software async multi-buffer crypto daemon<br>CONFIG_CRYPTO_MCRYPTD</dt><dd>这是一个通用的软件异步加密守护进程,可将任意的多缓冲加密算法转换成在内核线程中执行的异步多缓冲加密算法.</dd>
<dt>Authenc support<br>CONFIG_CRYPTO_AUTHENC</dt><dd>用于IPSec组合模式的包装器:认证加密并对IPSec提供多重加密.</dd>
<dt>Testing module<br>CONFIG_CRYPTO_TEST</dt><dd>丑陋的加密测试模块.仅供调试使用.</dd>
<dt>CCM support<br>CONFIG_CRYPTO_CCM</dt><dd><a href="http://baike.baidu.com/view/3169861.htm">CBC-MAC</a>计数器.IPsec需要它.</dd>
<dt>GCM/GMAC support<br>CONFIG_CRYPTO_GCM</dt><dd>GCM(<a href="http://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter Mode</a>)与GMAC(Galois Message Authentication Code)支持.IPsec需要它.[注释]GCM是一种对称加密算法的块密码工作模式,使用128位块大小.<a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">块密码工作模式</a>可以分为加密模式,认证模式,认证加密模式.GCM模式为认证模式的一种,提供认证和加密两种功能.</dd>
<dt>Sequence Number IV Generator<br>CONFIG_CRYPTO_SEQIV</dt><dd>序号初始向量(IV)生成器.它基于一个序号与一个盐粒子(salt)的异或值生成一个向量.此算法主要用于块密码的CTR(计数模式).</dd>
<dt>CBC support<br>CONFIG_CRYPTO_CBC</dt><dd><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:密码分组链接(Cipher Block Chaining)模式.IPSec需要它.</dd>
<dt>CTR support<br>CONFIG_CRYPTO_CTR</dt><dd><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:计数器(Counter)模式.IPSec需要它.</dd>
<dt>CTS support<br>CONFIG_CRYPTO_CTS</dt><dd><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:密文窃取(Cipher Text Stealing)模式.Kerberos gss机制支持的AES加密需要它.</dd>
<dt>ECB support<br>CONFIG_CRYPTO_ECB</dt><dd><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>电子密码本(Electronic CodeBook)模式.这是最简单的分组密码算法,只是简单的分别加密每个块.</dd>
<dt>LRW support<br>CONFIG_CRYPTO_LRW</dt><dd><a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F#.E5.85.B6.E5.AE.83.E6.A8.A1.E5.BC.8F.E5.92.8C.E5.AF.86.E7.A0.81.E5.AD.A6.E6.A6.82.E5.BF.B5">块密码工作模式</a>:LRW(Liskov Rivest Wagner)模式.这个模式以三个人名命名.这是一种小数据块加密模式,加密后的数据保持与明文数据同样的长度,专门用于CONFIG_DM_CRYPT模块加密磁盘区块(使用"aes-lrw-benbi"指定).</dd>
<dt>PCBC support<br>CONFIG_CRYPTO_PCBC</dt><dd><a href="http://zh.wikipedia.org/wiki/块密码的工作模式">块密码工作模式</a>:填充密码块链接(Propagating Cipher Block Chaining)模式.CONFIG_AF_RXRPC需要它.</dd>
<dt>XTS support<br>CONFIG_CRYPTO_XTS</dt><dd><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:XTS模式.这是IEEE1619/D16规范制定的一种小数据块加密模式,加密后的数据保持与明文数据同样的长度,专门用于加密磁盘区块(使用"aes-xts-plain"指定).</dd>
<dt>CMAC support<br>CONFIG_CRYPTO_CMAC</dt><dd>NIST(美国国家标准与技术研究所)制定的基于密文的<a href="http://wenku.baidu.com/view/c0bb4078168884868762d6a1.html">消息认证码</a>(<a href="http://www.rfc-editor.org/rfc/rfc4493.txt">Cipher-based Message Authentication Code</a>)</dd>
<dt>HMAC support<br>CONFIG_CRYPTO_HMAC</dt><dd>基于哈希的消息验证代码(<a href="http://blog.chinaunix.net/uid-20356525-id-1700433.html">RFC2104</a>).在发送方和接收方共享机密密钥的前提下,<a href="http://baike.baidu.com/view/1136366.htm">HMAC</a>可用于确定通过不安全信道发送的消息是否被篡改.IPSec需要它.</dd>
<dt>XCBC support<br>CONFIG_CRYPTO_XCBC</dt><dd>基于哈希的加密算法(<a href="http://www.ietf.org/rfc/rfc3566.txt">RFC3566</a>)</dd>
<dt>VMAC support<br>CONFIG_CRYPTO_VMAC</dt><dd><a href="http://fastcrypto.org/vmac">VMAC</a>是一种专用于64位CPU的高速消息认证算法</dd>
<dt>CRC32c CRC algorithm<br>CONFIG_CRYPTO_CRC32C</dt><dd><a href="http://blog.csdn.net/codegame/article/details/6540965">CRC32c</a>摘要算法是常见的CRC32<a href="http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a>的一个变种,仅多项式常数不同,算法完全一样.常用于iSCSI和SCTP数据校验.</dd>
<dt>CRC32c INTEL hardware acceleration<br>CONFIG_CRYPTO_CRC32C_INTEL</dt><dd>利用<a href="http://en.wikipedia.org/wiki/SSE4">SSE4.2</a>指令集中专用的"CRC32"指令,可以提高最少10倍的运算速度.如果你的CPU支持SSE4.2,建议选"Y".</dd>
<dt>CRC32 CRC algorithm<br>CONFIG_CRYPTO_CRC32</dt><dd>经典的CRC32<a href="http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a>算法.</dd>
<dt>CRC32 PCLMULQDQ hardware acceleration<br>CONFIG_CRYPTO_CRC32_PCLMUL</dt><dd>使用处理器的PCLMULQDQ指令(又称<a href="http://en.wikipedia.org/wiki/CLMUL_instruction_set">CLMUL</a>指令集,其实只有一条指令)加速CRC32的运算.PCLMULQDQ是从Intel <a href="http://zh.wikipedia.org/wiki/Intel_Nehalem#Nehalen.E8.A3.BD.E7.A8.8B.E6.94.B9.E9.80.B2.E7.89.88.EF.BC.9AWestmere.E6.9E.B6.E6.A7.8B">Westmere</a>和AMD <a href="http://zh.wikipedia.org/wiki/AMD_Bulldozer">Bulldozer</a>开始引入的指令(隶属于<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>).可以大幅提升CRC32的运算速度.如果你的CPU支持AES指令集(grep aes /proc/cpuinfo),建议选"Y".</dd>
<dt>CRCT10DIF algorithm<br>CONFIG_CRYPTO_CRCT10DIF</dt><dd>CRC T10 DIF(Data Integrity Field)算法可用于保障T10/SCSI设备的端到端的数据完整性.</dd>
<dt>CRCT10DIF PCLMULQDQ hardware acceleration<br>CONFIG_CRYPTO_CRCT10DIF_PCLMUL</dt><dd>使用处理器的PCLMULQDQ指令(又称<a href="http://en.wikipedia.org/wiki/CLMUL_instruction_set">CLMUL</a>指令集,其实只有一条指令)加速CRC T10 DIF的运算.PCLMULQDQ是从Intel <a href="http://zh.wikipedia.org/wiki/Intel_Nehalem#Nehalen.E8.A3.BD.E7.A8.8B.E6.94.B9.E9.80.B2.E7.89.88.EF.BC.9AWestmere.E6.9E.B6.E6.A7.8B">Westmere</a>和AMD <a href="http://zh.wikipedia.org/wiki/AMD_Bulldozer">Bulldozer</a>开始引入的指令(隶属于<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>).可以大幅提升CRC T10 DIF的运算速度.如果你的CPU支持AES指令集(grep aes /proc/cpuinfo),建议选"Y".</dd>
<dt>GHASH digest algorithm<br>CONFIG_CRYPTO_GHASH</dt><dd><a href="http://wenku.baidu.com/view/c5d3a56c783e0912a3162a07.html">GHASH</a>是用于GCM(Galois/Counter Mode)的消息摘要算法.</dd>
<dt>MD4 digest algorithm<br>CONFIG_CRYPTO_MD4</dt><dd>老旧的<a href="http://baike.baidu.com/view/444142.htm">MD4</a>(RFC1320)摘要算法,已经被淘汰.</dd>
<dt>MD5 digest algorithm<br>CONFIG_CRYPTO_MD5</dt><dd>广泛使用的<a href="http://zh.wikipedia.org/wiki/MD5">MD5</a>(RFC1321)摘要算法,128位.已经被发现可以快速找到碰撞,正逐渐淘汰中.</dd>
<dt>Michael MIC keyed digest algorithm<br>CONFIG_CRYPTO_MICHAEL_MIC</dt><dd>Michael MIC是仅用于<a href="http://baike.baidu.com/view/755337.htm">TKIP</a>(IEEE 802.11i)的摘要算法.不能用于其它场合,因为它存在一些缺陷.</dd>
<dt>RIPEMD-128 digest algorithm<br>CONFIG_CRYPTO_RMD128</dt><dd>RIPEMD-128(ISO/IEC 10118-3:2004)128位摘要算法.安全性不高,不建议使用.</dd>
<dt>RIPEMD-160 digest algorithm<br>CONFIG_CRYPTO_RMD160</dt><dd><a href="http://baike.baidu.com/view/260854.htm">RIPEMD</a>-160(ISO/IEC 10118-3:2004)160位摘要算法.是替代各种128位摘要算法(RIPEMD-128,MD5,MD4)的首选.其运算速度和SHA1相当,但是目前尚无已知有效的攻击方法.</dd>
<dt>RIPEMD-256 digest algorithm<br>CONFIG_CRYPTO_RMD256</dt><dd>RIPEMD-256在本质上和RIPEMD-128是一样的.因为RIPEMD的设计者们根本就没有真正设计256和320位这两种标准,他们只是在128位和160位的基础上,修改了初始参数和s-box来达到输出为256和320位的目的.所以,256位的强度和128相当,而320位的强度和160位相当.</dd>
<dt>RIPEMD-320 digest algorithm<br>CONFIG_CRYPTO_RMD320</dt><dd>RIPEMD-320在本质上和RIPEMD-160是一样的.因为RIPEMD的设计者们根本就没有真正设计256和320位这两种标准,他们只是在128位和160位的基础上,修改了初始参数和s-box来达到输出为256和320位的目的.所以,256位的强度和128相当,而320位的强度和160位相当.</dd>
<dt>SHA1 digest algorithm<br>CONFIG_CRYPTO_SHA1</dt><dd>目前使用最广泛的SHA-1(FIPS 180-1/DFIPS 180-2)160位摘要算法是<a href="http://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">SHA家族</a>中的一员,在许多安全协议中广为使用(TLS,SSL,PGP,SSH,S/MIME,IPsec等).SHA-1曾被视为是MD5的后继者,但由于出现了针对SHA-1的理论上破解的方法(不等于实践中被破解),有些人已经开始改用其它的替代算法(例如<a href="http://www.oschina.net/translate/keccak-the-new-sha-3-encryption-standard">SHA-3</a>).</dd>
<dt>SHA1 digest algorithm (SSSE3/AVX)<br>CONFIG_CRYPTO_SHA1_SSSE3</dt><dd>使用<a href="http://en.wikipedia.org/wiki/SSSE3">SSSE3</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>指令集加速SHA-1的计算.如果你的CPU支持SSSE3/AVX指令集,建议选"Y".</dd>
<dt>SHA256 digest algorithm (SSSE3/AVX/AVX2)<br>CONFIG_CRYPTO_SHA256_SSSE3</dt><dd>使用<a href="http://en.wikipedia.org/wiki/SSSE3">SSSE3</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a>指令集加速SHA-256的计算.</dd>
<dt>SHA512 digest algorithm (SSSE3/AVX/AVX2)<br>CONFIG_CRYPTO_SHA512_SSSE3</dt><dd>使用<a href="http://en.wikipedia.org/wiki/SSSE3">SSSE3</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a>指令集加速SHA-512的计算.</dd>
<dt>SHA224 and SHA256 digest algorithm<br>CONFIG_CRYPTO_SHA256</dt><dd>SHA-224和SHA-256摘要算法,速度较SHA1稍慢,都属于"SHA-2"系列,目前尚无已知的有效攻击方法.但并未被广泛使用.</dd>
<dt>SHA384 and SHA512 digest algorithms<br>CONFIG_CRYPTO_SHA512</dt><dd>SHA-384和SHA-512摘要算法,速度大约只有SHA1的40-50%,都属于"SHA-2"系列,目前尚无已知的有效攻击方法.但并未被广泛使用.</dd>
<dt>Tiger digest algorithms<br>CONFIG_CRYPTO_TGR192</dt><dd>Tiger号称是最快的哈希算法,专门为64位机器做了优化.</dd>
<dt>Whirlpool digest algorithms<br>CONFIG_CRYPTO_WP512</dt><dd><a href="http://blog.csdn.net/simb/article/details/1266177">Whirlpool</a>是一种512位的摘要算法,利用了已有的AES分组密码算法构造Hash函数,拥有相当高的安全性,已经被列入了ISO标准,目前最新版本为3.0(2003年发布).</dd>
<dt>GHASH digest algorithm (CLMUL-NI accelerated)<br>CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL</dt><dd>使用CPU的<a href="http://en.wikipedia.org/wiki/CLMUL_instruction_set">CLMUL</a>指令集(包含在<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>中)加速GHASH摘要算法.</dd>
<dt>AES cipher algorithms<br>CONFIG_CRYPTO_AES</dt><dd><a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES</a>(FIPS-197)又称"Rijndael",是目前最佳的<a href="http://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E5%8A%A0%E5%AF%86">对称加密</a>算法,快速且节省内存,可以使用128/192/256位密钥,是目前使用最广泛的对称加密算法.</dd>
<dt>AES cipher algorithms (x86_64)<br>CONFIG_CRYPTO_AES_X86_64</dt><dd>针对x86_64架构的AES实现.</dd>
<dt>AES cipher algorithms (AES-NI)<br>CONFIG_CRYPTO_AES_NI_INTEL</dt><dd>使用<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>加速AES的计算.如果你的CPU支持AES指令集(grep aes /proc/cpuinfo),建议选"Y".</dd>
<dt>Anubis cipher algorithm<br>CONFIG_CRYPTO_ANUBIS</dt><dd>Anubis是一种分组密码算法.分组长度为128位,密钥长度可变(最低128位),圈数可变(最低12圈).是欧洲于2000年1月1日启动的<a href="http://wenku.baidu.com/view/23e92c0e7cd184254b3535fb.html">NESSIE计划17个候选分组加密算法</a>之一.</dd>
<dt>ARC4 cipher algorithm<br>CONFIG_CRYPTO_ARC4</dt><dd>一种脆弱的流对称加密算法,仅用于已经被淘汰的<a href="http://baike.baidu.com/view/32853.htm">WEP</a>.</dd>
<dt>Blowfish cipher algorithm<br>CONFIG_CRYPTO_BLOWFISH</dt><dd><a href="http://zh.wikipedia.org/wiki/Blowfish_(%E5%AF%86%E7%A0%81%E5%AD%A6)">Blowfish</a>对称加密算法,一种又老又慢的对称加密算法.</dd>
<dt>Blowfish cipher algorithm (x86_64)<br>CONFIG_CRYPTO_BLOWFISH_X86_64</dt><dd>针对x86_64架构的Blowfish实现</dd>
<dt>Blowfish cipher algorithm (x86_64/AVX2)<br>CONFIG_CRYPTO_BLOWFISH_AVX2_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a>指令集加速Blowfish的计算.</dd>
<dt>Camellia cipher algorithms<br>CONFIG_CRYPTO_CAMELLIA</dt><dd><a href="http://zh.wikipedia.org/wiki/Camellia">Camellia</a>是欧盟NESSIE项目的选定算法,也是日本CRYPTREC项目的推荐算法.可以使用128/192/256位密钥,具有与AES同等级的安全强度及运算速度.</dd>
<dt>Camellia cipher algorithm (x86_64)<br>CONFIG_CRYPTO_CAMELLIA_X86_64</dt><dd>针对x86_64架构的Camellia实现</dd>
<dt>Camellia cipher algorithm (x86_64/AES-NI/AVX)<br>CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速Camellia的计算.</dd>
<dt>Camellia cipher algorithm (x86_64/AES-NI/AVX2)<br>CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2指令集</a>加速Camellia的计算.</dd>
<dt>CAST5 (CAST-128) cipher algorithm<br>CONFIG_CRYPTO_CAST5</dt><dd>老旧的CAST5(CAST-128)对称加密算法</dd>
<dt>CAST5 (CAST-128) cipher algorithm (x86_64/AVX)<br>CONFIG_CRYPTO_CAST5_AVX_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速CAST5的计算.</dd>
<dt>CAST6 (CAST-256) cipher algorithm<br>CONFIG_CRYPTO_CAST6</dt><dd>老旧的CAST6(CAST-256)对称加密算法</dd>
<dt>CAST6 (CAST-256) cipher algorithm (x86_64/AVX)<br>CONFIG_CRYPTO_CAST6_AVX_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速CAST6的计算.</dd>
<dt>DES and Triple DES EDE cipher algorithms<br>CONFIG_CRYPTO_DES</dt><dd>老旧的DES和三重DES对称加密算法.</dd>
<dt>FCrypt cipher algorithm<br>CONFIG_CRYPTO_FCRYPT</dt><dd>FCrypt对称加密算法仅用于CONFIG_AF_RXRPC</dd>
<dt>Khazad cipher algorithm<br>CONFIG_CRYPTO_KHAZAD</dt><dd><a href="http://en.wikipedia.org/wiki/KHAZAD">Khazad</a>是一种最终进入NESSIE决赛的对称加密算法,专为64位CPU设计,支持128位密钥.</dd>
<dt>Salsa20 stream cipher algorithm<br>CONFIG_CRYPTO_SALSA20</dt><dd><a href="http://en.wikipedia.org/wiki/Salsa20">Salsa20</a>是一种<a href="http://wenku.baidu.com/view/a431d1125f0e7cd184253620.html">流密码算法</a>,也是<a href="http://www.ecrypt.eu.org/stream/">eSTREAM</a>工程最终胜选算法之一.</dd>
<dt>Salsa20 stream cipher algorithm (x86_64)<br>CONFIG_CRYPTO_SALSA20_X86_64</dt><dd>针对x86_64架构的Salsa20实现</dd>
<dt>SEED cipher algorithm<br>CONFIG_CRYPTO_SEED</dt><dd>SEED(RFC4269)对称分组加密算法,采用128位密钥,是韩国的国家标准.</dd>
<dt>Serpent cipher algorithm<br>CONFIG_CRYPTO_SERPENT</dt><dd><a href="http://en.wikipedia.org/wiki/Serpent_(cipher)">Serpent</a>对称加密算法曾经是AES的最终5个候选算法之一,因为速度较Rijndael慢而最终得票数次之.目前尚未发现针对Serpent的有效攻击,因此被认为是一种强安全算法(甚至被认为比Rijndael更安全).</dd>
<dt>Serpent cipher algorithm (x86_64/SSE2)<br>CONFIG_CRYPTO_SERPENT_SSE2_X86_64</dt><dd>使用<a href="http://zh.wikipedia.org/wiki/SSE2">SSE2</a>指令集加速Serpent的计算.</dd>
<dt>Serpent cipher algorithm (x86_64/AVX)<br>CONFIG_CRYPTO_SERPENT_AVX_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速Serpent的计算.</dd>
<dt>Serpent cipher algorithm (x86_64/AVX2)<br>CONFIG_CRYPTO_SERPENT_AVX2_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2指令集</a>加速Serpent的计算.</dd>
<dt>TEA, XTEA and XETA cipher algorithms<br>CONFIG_CRYPTO_TEA</dt><dd>较弱的几种对称加密算法</dd>
<dt>Twofish cipher algorithm<br>CONFIG_CRYPTO_TWOFISH</dt><dd><a href="http://zh.wikipedia.org/wiki/%E5%8F%8C%E9%B1%BC%E7%AE%97%E6%B3%95">Twofish</a>是派生自Blowfish的对称加密算法,曾经是AES的最终5个候选算法之一,最终得票数第三.</dd>
<dt>Twofish cipher algorithm (x86_64)<br>CONFIG_CRYPTO_TWOFISH_X86_64</dt><dd>针对x86_64架构的Twofish实现</dd>
<dt>Twofish cipher algorithm (x86_64, 3-way parallel)<br>CONFIG_CRYPTO_TWOFISH_X86_64_3WAY</dt><dd>针对x86_64架构的三路并行Twofish实现.能够充分利用<a href="http://zh.wikipedia.org/wiki/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C">乱序执行</a>CPU的指令周期.</dd>
<dt>Twofish cipher algorithm (x86_64/AVX)<br>CONFIG_CRYPTO_TWOFISH_AVX_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速Twofish的计算.</dd>
<dt>Twofish cipher algorithm (x86_64/AVX2)<br>CONFIG_CRYPTO_TWOFISH_AVX2_X86_64</dt><dd>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2指令集</a>加速Twofish的计算.</dd>
<dt>Deflate compression algorithm<br>CONFIG_CRYPTO_DEFLATE</dt><dd><a href="http://zh.wikipedia.org/wiki/DEFLATE">Deflate</a>(RFC1951)无损数据压缩算法.当在IPSec中使用<a href="http://wenku.baidu.com/view/082419c00c22590102029d2d.html">IPCOMP</a>协议时才需要.</dd>
<dt>Zlib compression algorithm<br>CONFIG_CRYPTO_ZLIB</dt><dd><a href="http://zh.wikipedia.org/wiki/Zlib">zlib</a>无损数据压缩算法是一种事实上的业界标准.被广泛应用.</dd>
<dt>LZO compression algorithm<br>CONFIG_CRYPTO_LZO</dt><dd><a href="http://zh.wikipedia.org/wiki/LZO">LZO</a>是致力于解压速度的一种无损数据压缩算法.</dd>
<dt>Pseudo Random Number Generation for Cryptographic modules<br>CONFIG_CRYPTO_ANSI_CPRNG</dt><dd>符合ANSI(美国国家标准学会)X9.31-1998附录A.2.4所描述的伪随机数发生器(基于3DES).这是一种较老的算法,生成的随机数质量不高.</dd>
<dt>NIST SP800-90A DRBG<br>CONFIG_CRYPTO_DRBG_MENU</dt><dd>符合NIST(美国国家标准技术局)<a href="https://en.wikipedia.org/wiki/NIST_SP_800-90A">SP800-90A</a>标准的伪随机数发生器(DRBG).<a href="https://nakedsecurity.sophos.com/zh/2013/12/22/the-openssl-software-bug-that-saves-you-from-surveillance/">SP800-90A</a>是美国政府<a href="http://baike.baidu.com/view/9738638.htm">FIPS 140-2</a>安全认证强制推广的加密标准,其中包含了生成强随机数的算法.这是一种较新的算法,生成的随机数质量较高.建议选"Y".选中此项后,还需选中至少一个子项.</dd>
<dd><dl>
	<dt>Enable Hash DRBG<br>CONFIG_CRYPTO_DRBG_HASH</dt><dd>符合 NIST SP800-90A 标准的 Hash DRBG 变种算法(基于SHA256).建议选"Y".</dd>
	<dt>Enable CTR DRBG<br>CONFIG_CRYPTO_DRBG_CTR</dt><dd>符合 NIST SP800-90A 标准的 CTR DRBG 变种算法(基于AES).建议选"Y".</dd>
</dl></dd>
<dt>Jitterentropy Non-Deterministic Random Number Generator<br>CONFIG_CRYPTO_JITTERENTROPY</dt><dd>JitterEntropy伪随机数生成器以CPU执行时间的抖动作为熵源,这是一种高质量的熵源,可作为其他随机数生成器(<a href="http://www.tinylab.org/myths-about-urandom/">/dev/urandom</a>)的种子.这样就无需在系统启动时从磁盘上加载已经保存的种子文件了.</dd>
<dt>User-space interface for hash algorithms<br>CONFIG_CRYPTO_USER_API_HASH</dt><dd>哈希算法的用户空间接口.不确定的选"N".</dd>
<dt>User-space interface for symmetric key cipher algorithms<br>CONFIG_CRYPTO_USER_API_SKCIPHER</dt><dd>对称加密算法的用户空间接口.不确定的选"N".</dd>
<dt>User-space interface for random number generator algorithms<br>CONFIG_CRYPTO_USER_API_RNG</dt><dd>随机数发生器算法的用户空间接口.不确定的选"N".</dd>
<dt>User-space interface for AEAD cipher algorithms<br>CONFIG_CRYPTO_USER_API_AEAD</dt><dd><a href="http://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">AEAD</a>(Authenticated-Encryption with Addtional Data)加密算法的用户空间接口.AEAD是当前最好的加密模式.不确定的选"N".</dd>
<dt>Hardware crypto devices<br>CONFIG_CRYPTO_HW</dt><dd>硬件加密设备支持</dd>
<dd><dl>
	<dt>Support for VIA PadLock ACE<br>CONFIG_CRYPTO_DEV_PADLOCK</dt><dd>带有<a href="http://www.viatech.com.cn/cn/initiatives/padlock/index.jsp">PadLock</a>技术的VIA系列处理器支持</dd>
	<dd><dl>
		<dt>PadLock driver for AES algorithm<br>CONFIG_CRYPTO_DEV_PADLOCK_AES</dt><dd>利用PadLock技术<a href="http://www.viatech.com.cn/cn/initiatives/padlock/features.jsp#aes">加速AES运算</a>.VIA C3及以上的CPU都支持.</dd>
		<dt>PadLock driver for SHA1 and SHA256 algorithms<br>CONFIG_CRYPTO_DEV_PADLOCK_SHA</dt><dd>利用PadLock技术<a href="http://www.viatech.com.cn/cn/initiatives/padlock/features.jsp#sha">加速SHA1和SHA256运算</a>.VIA C7及以上的CPU都支持.</dd>
	</dl></dd>
	<dt>Support for AMD Cryptographic Coprocessor<br>CONFIG_CRYPTO_DEV_CCP</dt><dd>AMD密码协处理器支持.</dd>
	<dt>Support for Intel(R) DH895xCC<br>CONFIG_CRYPTO_DEV_QAT_DH895xCC</dt><dd>支持<a href="http://server.it168.com/server/2008-03-26/200803260936276.shtml">QuickAssist技术</a>的Intel DH895xcc芯片.<a href="http://news.mydrivers.com/1/435/435453.htm">Skylake的服务器平台的部分CPU型号支持QuickAssist技术</a>.</dd>
	<dt>Support for Intel(R) DH895xCC Virtual Function<br>CONFIG_CRYPTO_DEV_QAT_DH895xCCVF</dt><dd>支持<a href="http://server.it168.com/server/2008-03-26/200803260936276.shtml">QuickAssist技术</a>的Intel DH895xcc芯片.<a href="http://news.mydrivers.com/1/435/435453.htm">Skylake的服务器平台的部分CPU型号支持QuickAssist技术</a>.</dd>
</dl></dd>
<dt>Asymmetric (public-key cryptographic) key type<br>CONFIG_ASYMMETRIC_KEY_TYPE</dt><dd><a href="http://baike.baidu.com/view/1490349.htm">非对称加密算法</a>(<a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公钥加密算法</a>)</dd>
<dd><dl>
	<dt>Asymmetric public-key crypto algorithm subtype<br>CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE</dt><dd>非对称公钥加密算法子类型.如果需要生成或者校验签名,那就还必须配合哈希算法一起使用.</dd>
	<dd><dl>
		<dt>RSA public-key algorithm<br>CONFIG_PUBLIC_KEY_ALGO_RSA</dt><dd><a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA</a>算法(<a href="http://wenku.baidu.com/view/168e67175f0e7cd18425369a.html">PKCS#1</a>, RFC3447)支持</dd>
		<dt>X.509 certificate parser<br>CONFIG_X509_CERTIFICATE_PARSER</dt><dd><a href="http://baike.baidu.com/view/156016.htm">X.509</a>证书解析支持</dd>
	</dl></dd>
</dl></dd>
<dt>Certificates for signature checking</dt><dd>用于检查签名有效性的证书:(1)用于检查内核模块的签名,(2)用于检查全局密钥环(keyring)中的密钥的可靠性.</dd>
</dl>






<h2>Virtualization<br />虚拟化支持<br /><span class="little_head">仅在将此内核用作宿主机(host)的情况下才需要开启这里的子项</span></h2>
<dl>
<dt>Kernel-based Virtual Machine (KVM) support<br>CONFIG_KVM</dt><dd><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-kvm/index.html">KVM</a>(<a href="http://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA">内核虚拟机</a>)是一种基于Linux内核的<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vt/">全虚拟化技术</a>,需要CPU支持<a href="http://zh.wikipedia.org/wiki/X86%E8%99%9A%E6%8B%9F%E5%8C%96">x86硬件虚拟化技术</a>(Intel VT或AMD-V).开启此项后,将可以通过字符文件"/dev/kvm"使用虚拟机.</dd>
<dd><dl>
	<dt>KVM for Intel processors support<br>CONFIG_KVM_INTEL</dt><dd><a href="http://baike.baidu.com/view/2236017.htm">Intel VT</a>技术支持.也就是cpu-flags中有"vmx"标记.</dd>
	<dt>KVM for AMD processors support<br>CONFIG_KVM_AMD</dt><dd><a href="http://sites.amd.com/cn/business/it-solutions/virtualization/Pages/amd-v.aspx">AMD-V</a>技术支持.也就是cpu-flags中有"svm"标记.</dd>
	<dt>Audit KVM MMU<br>CONFIG_KVM_MMU_AUDIT</dt><dd>添加一个"kvm.mmu_audit"内核参数,用于控制是否允许在运行时对KVM MMU进行审计."0"表示禁止审计,"1"表示允许审计.主要用于调试目的.不确定的选"N".</dd>
	<dt>KVM legacy PCI device assignment support<br>CONFIG_KVM_DEVICE_ASSIGNMENT</dt><dd>通过KVM支持传统的PCI设备分配.内核目前还通过VFIO(CONFIG_VFIO)支持一个全功能的<a href="http://www.linux-kvm.com/content/pci-device-assignment-driver-coming-linux-36-vfio">用户空间设备驱动框架</a>,可以取代这里的功能.不确定的选"N".</dd>
</dl></dd>
<dt>Host kernel accelerator for virtio net<br>CONFIG_VHOST_NET</dt><dd>在宿主机内核中开启此项后,可以加速客户机的网络操作速度(客户机内核需要加载virtio_net模块(CONFIG_VIRTIO_NET)).建议选"Y".</dd>
<dt>VHOST_SCSI TCM fabric driver<br>CONFIG_VHOST_SCSI</dt><dd>Say M here to enable the vhost_scsi TCM fabric module for use with virtio-scsi guests.看不懂的选"N".</dd>
<dt>Cross-endian support for vhost<br>CONFIG_VHOST_CROSS_ENDIAN_LEGACY</dt><dd>允许宿主机支持不同大小端顺序的客户机中老旧的virtio设备.仅在宿主机与客户机的大小端顺序不一致的场合(ppc64/arm64)才有意义.不确定的选"N".</dd>
</dl>






<h2>Library routines<br />库子程序<br /><span class="little_head">子选项可以全不选,内核中若有其他部分依赖它,会自动选上.使用内核树外的模块时可能需要手动选择.</span></h2>
<dl>
<dt>CRC-CCITT functions<br>CONFIG_CRC_CCITT</dt><dd>为内核树外的模块提供<a href="http://djb69.blog.163.com/blog/static/6776323420100158391490/">CRC-CCITT</a>循环验证算法支持.</dd>
<dt>CRC16 functions<br>CONFIG_CRC16</dt><dd>为内核树外的模块提供<a href="http://blog.csdn.net/kwbin/article/details/3323836">CRC16</a>循环验证算法支持.</dd>
<dt>CRC calculation for the T10 Data Integrity Field<br>CONFIG_CRC_T10DIF</dt><dd>为内核树外的模块提供<a href="http://zh.wikipedia.org/zh/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">CRC</a>循环验证算法支持.从而允许内核树外的SCSI模块利用<a href="http://www.ibm.com/developerworks/cn/aix/library/au-T10E2E/">T10/SCSI Data Integrity Field</a>保障<a href="http://alanwu.blog.51cto.com/3652632/1093600">端到端的数据完整性</a>.</dd>
<dt>CRC ITU-T V.41 functions<br>CONFIG_CRC_ITU_T</dt><dd>为内核树外的模块提供CRC ITU-T V.41循环验证算法支持.</dd>
<dt>CRC32/CRC32c functions<br>CONFIG_CRC32</dt><dd>为内核树外的模块提供CRC32/CRC32c循环验证算法支持.</dd>
<dd><dl>
	<dt>CRC32 perform self test on init<br>CONFIG_CRC32_SELFTEST</dt><dd>在CRC32算法初始化的时候进行一个简单的自我测试.不确定的选"N".</dd>
	<dt>CRC32 implementation</dt><dd>选择CRC32算法的实现方式.不确定的请保持默认值"Slice by 8 bytes",除非你知道自己在做什么.</dd>
</dl></dd>
<dt>CRC7 functions<br>CONFIG_CRC7</dt><dd>为内核树外的模块提供CRC7循环验证算法支持.</dd>
<dt>CRC32c (Castagnoli, et al) Cyclic Redundancy-Check<br>CONFIG_LIBCRC32C</dt><dd>为内核树外的模块提供CRC32c循环验证算法支持.</dd>
<dt>CRC8 function<br>CONFIG_CRC8</dt><dd>为内核树外的模块提供CRC8循环验证算法支持.</dd>
<dt>XZ decompression support<br>CONFIG_XZ_DEC</dt><dd>为内核树外的模块提供XZ解压支持.详见"<a href="https://www.kernel.org/doc/Documentation/xz.txt">Documentation/xz.txt</a>"文档.子项是针对不同平台的"BCJ filter decoder".按需选择即可.</dd>
<dt>XZ decompressor tester<br>CONFIG_XZ_DEC_TEST</dt><dd>XZ解压测试程序.不确定的选"N".</dd>
<dt>Averaging functions<br>CONFIG_AVERAGE</dt><dd>为内核树外的模块提供averaging函数支持</dd>
<dt>CORDIC algorithm<br>CONFIG_CORDIC</dt><dd>为内核树外的模块提供<a href="http://en.wikipedia.org/wiki/CORDIC">CORDIC</a>算法支持</dd>
<dt>JEDEC DDR data<br>CONFIG_DDR</dt><dd>为内核树外的DDR SDRAM内存控制器驱动提供获取<a href="http://zh.wikipedia.org/wiki/JEDEC">JEDEC</a>数据支持.</dd>
<dt>Select compiled-in fonts<br>CONFIG_FONTS</dt><dd>选择内嵌到内核中的字体(点阵字库,仅包含<a href="http://images.cnblogs.com/cnblogs_com/skynet/201105/2011050311372042.png">ASCII字符</a>和<a href="http://images.cnblogs.com/cnblogs_com/skynet/201105/201105031137219627.png">扩展ASCII字符</a>,共256个).选"N"表示内嵌自动选择的默认字体,选"Y"表示可以手动选择内嵌的字体.[提示]可到drivers/video/console目录下找到相应的"font_*.c"文件,将其中的"0"全部替换为空格,即可看到点阵字符.</dd>
<dd><dl>
	<dt>VGA 8x8 font<br>CONFIG_FONT_8x8</dt><dd>这是传统上高分辨率(高于80x50)下使用的字体.因为点阵太小,所以显示的字体质量非常低劣.</dd>
	<dt>VGA 8x16 font<br>CONFIG_FONT_8x16</dt><dd>这是传统上的标准字体(用于80x25),也是默认内嵌的字体,最为常见.</dd>
	<dt class="omit">{其它字体省略}</dt>
	<dt>console 16x16 CJK font ( cover BMP )<br>CONFIG_FONT_16x16_CJK</dt><dd><a href="https://github.com/gentoo-zh/linux-cjktty/">CJKTTY</a>开源项目提供的中文字体支持(仅支持UTF-8字符)<a href="https://github.com/gentoo-zh/linux-cjktty/compare/4.4-utf8.diff">补丁</a>.如果你希望能够直接在控制台上显示中文,那么请将此项选"Y",并同时将其他字体选项全部选"N".<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-termi-hanzi/">如何改造 Linux 虚拟终端显示中文</a>一文讲解了此补丁的原理.</dd>
</dl></dd>
</dl>


<hr />

<table align="center" cellspacing="10">
<tr align="center"><th> &lt;Select&gt; </th><th> &lt; Exit &gt; </th><th> &lt; Help &gt; </th><th> &lt; Save &gt; </th><th> &lt; Load &gt; </th></tr>
<tr align="center"><td>确定</td><td>退出</td><td>帮助</td><td>保存配置</td><td>读入配置</td></tr>
</table>

<hr />


</body></html>
