g/regular/s/regular/complex/g    -> g/regular/s//complex/g 
   地址      模式匹配
g：全局命令：意味着所有匹配的行都进行改变                 
g：改变，意味着改变一行上的每次regular的出现，不止一次。

g/regular expressions/s/regular/complex/g 
包含regular expressions的任意行上，用complex替代regular.

g/re/p #grep命令源于ed命令的模式匹配。 全局正则表达式打印。

单引号：阻止shell解释命令中的特殊符号和空格

awk：
没有用大括号{}将过程括起来
没有用单引号''把命令括起来
没有用斜杠//将模式括起来

sed：
如果没有指定地址，那么命令将应用于每一行
如果只有一个地址，那么命令应用于与这个地址匹配的任意行
如果指定了由逗号分隔的两个地址，那么命令应用于匹配第一个地址的第一行和它后面的的行，直到匹配第二个地址的行。
如果地址后面还有感叹号，那么命令就应用于不匹配该地址的所有行。

[address]s/pattern/replacement/flags
n: 1到512之间的一个数字，表示对文本模式中指定模式第n此出现的情况进行替换
g：对模式空间的所有出现的情况进行全局更改
p：打印模式空间的内容
W file：将模式空间的内容写到文件file中

追加[line-address]a\
text
插入[line-address]i\
text
更改[line-address]c\
text

l:用于显示模式空间的内容，非打印的字符显示为两个数字的ASCII代码

转换：[address]y/abc/xyz/
打印：[address]p
打印行号:[address]=
下一步：[address]n  #输出模式空间的内容，然后读取输入的下一行，而不用返回到脚本的顶端。
                    #n命令简单来说就是提前读取下一行，覆盖模型空间前一行（并没有删除，因此依然打印至标准输出），
                    #如果命令未执行成功（并非跳过：前端条件不匹配），则放弃之后的任何命令，并对新读取的内容，重头执行sed。
					
					
读[line-address]r file 写[address]w file
退出[line-address]q

处理了多行模式空间(N,D,P)  -> (n,d,p)
采用保持空间来保存模式空间的内容并使它用于后续的命令(H,h,G,g,x)
编写使用分支和条件指令的脚本来更改控制流(:,b,t)

d是是删除模式空间的内容，D只删除多行模式空间的第一行。
N：# N命令简单来说就是追加下一行到模式空间，同时将两行看做一行，但是两行之间依然含有\n换行符，如果命令未执行成功
   #（并非跳过：前端条件不匹配），则放弃之后任何命令，并对新读取的内容，重头执行sed。

next输出模式空间的内容，然后读取新的输入行。next不创建多行模式空间   

D:   #删除当前模式空间开端至\n的内容（不在传至标准输出），放弃之后的命令，但是对剩余模式空间重新执行sed。

h命令，H命令，g命令，G命令
h命令是将当前模式空间中内容覆盖至保持空间，H命令是将当前模式空间中的内容追加至保持空间
g命令是将当前保持空间中内容覆盖至模式空间，G命令是将当前保持空间中的内容追加至模式空间

x命令是将当前保持空间和模式空间内容互换

