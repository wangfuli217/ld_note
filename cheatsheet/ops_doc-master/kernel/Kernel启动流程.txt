Linux启动的第一阶段（从开机到main.c） 3个任务：

A、启动BIOS，准备实模式下的中断向量表和中断服务程序。

B、从启动盘加载操作系统程序到内存。

C、为执行32的main函数做过渡准备。

内存变化如下：

①　、0xFE000到0xFFFFF是BIOS启动块，其中上电后第一条指令在0xFFFF0。

②　、而后0x00000到0x003FF总共1KB存放中断向量表，而接下去的地址到0x004FF共256B存放BIOS数据，从0x0E05B开始的约8KB的内存中存放中断服务程序。

③　、利用BIOS中断0x19h把硬盘的第一扇区bootsect.s的代码加载到内存中，即0x07c00处，后转到该处执行。

④　、将bootsect.s的代码复制到0x90000处。

⑤　、利用中断0x13h将setup.s程序加载到内存0x90200处。

⑥　、再将剩余的约240个扇区的内容加载到0x10000~0x2EFFF处。

⑦　、开始转到setup.s处执行，第一件事就利用BIOS提供的中断服务程序从设备上获取内核运行的所需系统数据并存在0x90000的地址处，这时将原来bootsect.s的代码覆盖得只剩2Byte的空间。

⑧　、关中断并将系统代码复制到0x00000处，将原来放在这里的中断向量表与BIOS数据区覆盖掉，地址范围是0x00000~0x1EFFF。同时制作两表与两寄存器。

⑨　开地址线A20，寻址空间达到4GB，后对8259重新编程，改变中断号。

⑩　、转到head.s（大小是25K+184B）执行，执行该程序完后是这样的：

0x00000~0x04FFF:页目录与4个页表，每一项是4KB,共20KB；

0x05000~0x05400:共1KB的空间是软盘缓冲区；

0x05401~0x054b8:共184B没用；

0x054b9~0x05cb8：共2KB的空间存中断描述符表；

0x05cb9~0x064b8：共2KB的空间存全局描述符表；

之后就是main函数的代码了！
2

第二阶段、从main.c函数到系统准备完毕阶段。

第一步：创建进程0，并让进程0具备在32位保护模式下载主机中的运算能力。流程是：

复制根设备和硬盘参数表 （main.c中的102、110、111行）        

物理内存规划格局（main.c的112行~126行，其中有

             rd_init函数定义在kernel/ramdisk.c中，此函数用于虚拟盘初始化；而mem_init函数是用于内存管理结构初始化，定义在mem/memory.c中，该函数页面使用虚拟盘设置与初始化次数均设置成100，然后再依据主内存的起始位置和终止位置将处于主内存的所有页面的使 用次数全部清零，系统以后把使用次数为0的页面视为空闲页面。）

内存管理结构mem_map初始化   

异常处理类中断服务程序挂接（在main.c的127行，trap()函数定义

kernel/trap.c，目的是将各种中断与中断描述符表挂接。）

初始化块设备与字符设备请求项结构（在main.c的128、129行，           blk_dev_init()     定义在                                                                       kernel/blk_dev/ll_rw_blk.c，

chr_dev_init()定义在kernel/chr_dev/tty_io.c）

将串口与显示器外设的中断服务程序挂接（在main.c的130行，

                                   tty_init()定义在kernel/chr_dev/tty_io.c）

开启时间设置（在main.c的131行，time_init()定义于main.c函数

                             76行startup_time）

系统开始激活进程0（在main.c的131行，sched_init()定义在kernel/

                                   sched.c函数中，该函数实现进程相关事务设置

依据时钟中断设置，系统调用服务程序挂接。系统调用函数是对用户程序的最基本支持，利用的是进程相关事务初始化设置系统调用软中断，详细见下面的。）

时钟中断设置

系统调用服务程序挂接

初始化缓冲区管理结构（在main.c中133行，                                                        buffer_init(buffer_memory_end)定义                                                           fs/buffer.c）

初始化硬、软盘（main.c中134、135行，hd_init与floppy_init定义                              于kernel/blk_drv/hd.c和kernel/blk_drv/floppy.c）

开中断 （main.c中136行，sti（））
3

第二步：以进程0为母本创建进程1，使进程1不仅仅具备进程0所拥有的能力，而且还能以文件的形式与外设进行数据交互。流程是：

操作系统为进程0创建进程1做准备  main.c中137行，move_to_

user_mode()定义在include/asm/system.h，实现从内核态到用户态。进程0正式开始执行，而后执行main.c的138行的“if(!fork())”，开始创建进程1，此时将执行unisted.h中的syscall0宏函数，得到一个编号，对于fork函数，其值是2，具体在这个程序中的第62行有定义，然后执行软中断

复制进程0的信息之前，先将一些数据压栈      进入系统调用阶段，跳到内核态，执行kernel/system_call.s中的代码，将一些寄存器的值压栈后，通过刚才在unisted.h中给eax赋值。

初步设置进程1管理结构         的2偏移值在系统调用sys_call_table中找到sys_fork函数，跳到该函数执行。进入后首先申请一个空闲位置并获取进程号。

这同样在system_call.s函数中的sys_fork进程0创建进程1的过程中发生时钟中断中的_find_copy_process,再跳到该函数的定义处kernel/fork.c中，后返回到sys_fork中，在从中断返回复制进程信息前，再将一些数据压栈，此时有一个寄存器的值和前面的不一样，那就是eax，此时是1，它从task[64]中

得到的。之后执行copy_process，跳到调整进程1的管理结构定义处kernel/fork.c中，设置进程1的管理结构。假如此时发生时钟中断，系统

会响应并执行kernel/system_call.s函数中的timer_interrupt定义处，先压栈后

设置进程1的线性地址空间及物理页面进入kernel/sched.c的do_timer函数，别忘了此时仍在进程0执行，然后便发现时间片还没完，所以跳出，并返回到ret_from_sys_call。这是继续调整进程1的管理结构 在kernel/system_call.s中定义的，接着直接将刚才的压栈数据出栈，继续完成刚才创建进程1的任务，即在fork.c中继续调整进程1的管理结构，同时设置进程进程0准备切换到进程1    1的线性地址空间及物理页面，直到执行到这条语句“p->state=TASK_

RUNNING；return last_pid;”，标志着系统切换到进程1执行       进程1创建完成。后跳出copy_process.c函数，返回到system_call.s，将压栈的

进程1开始执行        的寄存器值出栈，此时eax是1。后中断返回，进程由从内核态变为用户态，即到了 unisted.h的“if(_res>=0)”这条指令中，

_res的值就是eax的值，一判断成立，就返进程1开始以数据块的形式操作硬盘 回该值。最后回到了main.c的“if(!fork())”中，一判断不成立，跳出执行下一条指令“for（；；）pause();”，同理Pause函数也和fork函数一样，这里就不

将找到的缓冲块与请求项挂接讲了，进入sys_pause()后将进程0置为可中断等待状态，并调用在kernel/sched.c定义的schedule()函数切换进程。

进程切换中断返回后执行了第一条语句将请求项与硬盘处理函数挂接       是“if(_res>=0)”，一判断，刚存的eax值为0，返回到“if(!fork())”

判断为真，执行init（）函数，这在main.c定义。进入init.c后其程序执行流程见附录，进行硬盘读盘前的工作准备各个程序执行目的正如左边写的一样。
4

第三步：

以进程1为母本创建进程2，使进程2在全面具备进程1所拥有的能力和环境的基础上，进一步具备支持”人机交互“的能力，最终实现准备阶段完成。流程如下：

进程1准备创建进程2  与进程0创建进程1一样，创建进程2，复

                     制进程1的管理结构，复制页表、页目录

                     项等，创建进程2后即执行到init/main.c中

复制进程2的管理结构并进行调整  176行与186行，分别是：if(!(pid

                     =fork())中子进程即进程2执行，而父进程（

                     进程1）执行186行的if(pid>0），父进程

调整进程2管理结构中与文件有关的内容   进入wait函数，等待！

                     进入wait函数后还做了一些动作：首先

                     查找自己的子进程，确定是进程2后，判断

进程1执行过程中发生时钟中断  进程2是否处于终止状态或是

                     僵死状态，一判断不是，就将进程1设置为

                     可中断等待状态，继而调用schedule()函数

进程1从时钟中断返回   准备切换到进程2执行   切换到进程2。

                      进入进程2后开始加载shell程序。首先执

                     行init/main.c中180行的“close(0);”，就是

进程1查找它自己的子进程  解除filp[20]与file_table[64]的第一项

                                                关系，这是从进程1继承过来的。然后

                         是“if(open("etc/rc",O_RDONLY,0)）”，

对进程2的状态进行处理   其中是将进程2的管理结构指针表filp

                      [20]的第一项与file_table[64]的第一项建立

                      一个关于资源配置的文件，而后再执行

切换到进程2执行     execve函数，并映射到sys_execve系统调用。

                      再调用do_execve函数，目的便是将参数

                      与环境变量加载到主内存的页面中去，中断

为打开/etc/rc文件做准备  返回，但此时在该函数里已经将EIP的

                     值指向了shell程序的入口地址，所以返回后

                     执行的是shell的第一条指令，但这时却发现

进程2打开”/etc/rc“配置文件  内存中没有这一条指令的映射，

                     所以发生“缺页中断”，然后调用page_fault

                    函数中的do_no_page。

通过压栈为加载shell文件做准备

为参数和环境变量设置做准备

得到shell文件i节点

为加载参数和环境变量做准备

根据i节点，为shell文件进行检测

检测shell文件头

备份文件头并进行分析

对shell文件进行进一步分析

拷贝参数与环境变量

调整进程2的管理结构

继续调整进程2的管理结构

释放进程2继承的页面

检测协处理器

调整shell程序所在的线性地址空间

为shell程序准备参数与环境变量

继续调整进程2的管理结构

调整EIP，使其指向shell程序的入口地址

Shell程序执行发生缺页中断 

缺页中断中shell程序加载前检测 

为即将载入的内容申请页面 

为shell载入新获得的页面

根据shell进程的情况，调整页面内容

将线性地址空间与程序所在的物理页面相对应

                         Shell程序开始执行，执行的内容是/etc/

                        rc里面的命令，其中便有创建update进

Shell进程准备创建update进程 程，该进程是为同步缓冲区与硬盘而

                          设的进程，它会时不时的进入睡眠状

                          态，经过一定的时间再被唤醒然后更新

进程2开始执行/etc/rc文件  缓冲区与硬盘的数据。之后创建完成后

                     Shell进程退出，退出操作当然得释放它占

                     用的资源或者是清除掉，或者是将使用次数

准备加载update进程    减1。然后为进程1找到一个子进程，

                    那就是update进程了，发信号告诉进程1

                    shell进程退出，进程1唤醒执行，重新进入

Shell程序检测“etc/rc”文件  main.c函数中执行180行后面的程序

                     再次创建shell进程，现在进程号是4，同样

                      与之前的一样，但此时稍微有点不同的是

Shell进程退出           open的参数是/dev/tty0，这是一个设备

                   文件，与之前的/etc/rc文件不一样，致使这次

                    创建完毕后并不会退出shell进程了，这段区

Shell进程退出善后处理  别是在以下的附录程序中。这样就是完成

                      了所有准备工作，接下去的除了安装文件

                       系统就没有再别的事了，此时shell

进程1清理shell进程管理结构  程序就等着用户输入命令然后执行，

                      剩下的所有操作就是留给用户自己了，一旦

                      用户执行什么命令，包括在shell中输入，

 系统开始重建shell     以及点击应用程序图标，都通过一定的方

                      式映射到内核中执行