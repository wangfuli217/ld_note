模块 = 接口和实现 -> 一种接口；N种实现。
  接口规定了模板做什么。接口会声明标识符、类型和例程，提供给使用模块的代码。
  实现指明模块如何完成其接口规定的目标。
  客户程序是使用模块的一段代码。客户程序导入接口，实现则导出接口，客户程序只需要看到接口即可。
耦合(couping):客户程序和实现之间的依赖性。
1. 不同的实现可能会提供更好的性能。设计完善的接口会避免对特定机器的依赖，但也可能强制实现依赖于机器，
   因此对用到接口的每种机器，可能都需要一个不同的实现来支持。

C语言
  变量、函数、类型定义和枚举常数   共享一个命名空间
  全局结构、联合和枚举标识符       共享一个命名空间

  无符号数的除法和模运算是有正确定义的
x/y x%y当两个操作数符号不同时，由C语言内建运算符所得出的返回值取决于具体编译器的实现。
  取余运算在计算商值向0方向舍弃小数位
  取模运算在计算商值向负无穷方向舍弃小数位
同时，也可以这样理解：
  取余，遵循尽可能让商大的原则
  取模，遵循尽可能让商小的原则

int arith_min(int x, int y) 返回min(x,y)
int arith_max(int x, int y) 返回max(x,y)
int arith_ceiling(int x, int y) 返回不小于x/y实数商的最小整数。y = 0; 则为未检查的运行时错误。
int arith_floor(int x, int y)   返回不大于x/y实数商的最大整数。y = 0; 则为未检查的运行时错误。
int arith_div(int x, int y); 返回x/y，若有实数z使得z *y = x, 返回值即不大于实数z的最大整数。向负无穷大舍入；
                             arith_div(-13,5)返回-3，y=0; 则为未检查的运行时错误。
int arith_mod(int x, int y);    返回x-y*arith_div(x,y), 
                             arith_div(-13,5)返回2，y=0; 则为未检查的运行时错误。
                             
1. arith_div不超过实数double z=(double)x/(double)y的最大整数
2. arith_mod等于x-y*arith_div(x,y);
因此：x=-13;y=5; x(double)/(double)y=-2.6, 则arith_mod(x,y)=-3
      x-y*arith_div(x,y) = -13 - 5(-3) = -13+15 = 2
bash: printf "%d\n" $[-13/5] # -13/5 = -2
      printf "%d\n" $[-13%5] # -13%5 = -3

在C99中，除法的结果总是向零截取的(-9/7的结果是-1)，i%j值的符号与i的相同(-9%7的结果是-2)。
1. ceiling(x,y)返回不小于x/y的实数商的最小整数 - 只支持小数
double ceil(double x);
float ceilf(float x);
long double ceill(long double x);

2. floor(x,y)  返回不大于x/y的实数商的最大整数 - 只支持小数
double floor(double x);
float floorf(float x);
long double floorl(long double x);

3. 向零舍入                                    - 只支持整数
div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(long long numerator, long long denominator);


抽象数据类型
-------------------
    高级类型是抽象的，其接口隐藏了相关的表示细节，并只规定了对该类型值的合法操作。
理想情况下，这些操作不会暴露类型的表示细节，因为那样可能是客户程序隐含地依赖具体的表示。
C语言
1. _STACK或_STACK_INCLUDED: 标准C将下划线前缀保留给实现者和未来的扩展使用，避免使用下划线前缀。
2. 不透明指针隐藏了表示细节，有助于捕获错误。
3. C语言的用法没有规定的或编译器无法检查的规则，必须在接口中详细说明。客户程序必须遵循这些规则，实现必须执行这些规则
   接口通常会规定未检查的运行时错误(unchecked runtime error), 已检查的运行时错误(checked runtime error)和异常(exception)
   未检查的和已检查的运行时错误是非预期的用户错误：如未能打开一个文件。运行时错误是对客户程序和实现之间契约的破坏，是无法修复的程序bug
   异常是指一些可能的情形，但很少发生。但很少发生。程序也许能从异常恢复。内存消耗就是一个例子。
4. 未检查的运行时错误是对客户程序与实现之间契约的破坏，而实现并不保证能够发现这样的错误。
   如果发生未检查的运行时错误，可能会继续执行，但结果是不可预测的，甚至可能是不可重复的。
   好的程序会在可能的情况下避免未检查的运行错误，但必须规定可能发生的此类错误。 
   arith_虽然可以检查除以零的情形，但却不加处理使之成为未检查的运行时错误，这样接口中的函数就模拟了C语言内建的除法运算的行为。
5. 已检查的运行时错误是对客户程序与实现之间契约的破坏，但是实现保证会发现这种错误。这些错误表明
   客户程序未能遵守契约对它的约束，客户程序有责任避免这类错误。Stack接口规定了三个已检查的运行时错误：
   1. 向该接口中的任何例程传递空的Stack_T类型的指针
   2. 传递给Stack_free的Stack_T指针为NULL指针
   3. 传递给Stack_pop的栈为空。
6. 接口可以规定异常及发异常的条件。未处理的异常(unhandled exception)被当作是已检查的运行时错误。

接口通常会规定
未检查的运行错误 已检查的运行错误 : 是用户非预期的用户错误 是无法恢复的程序bug
和 异常                           : 是指一些可能的情形 但很少发生

#define T stack_t

typedef struct T *T;  // T是不透明的Stack_T

向任何stack函数传递的T值为NULL，则为已检查的运行时错误。
extern T        stack_new(void);    返回一个新的空栈T。
extern int      stack_empty(T stk); 如果stk栈为空返回1，否则返回0
extern ssize_t  stack_length(T stk); 
extern void     stack_free(T *stk);  释放*stk并将其清零。如果stk或*stk为NULL，则为已检查的运行时错误

extern void     stack_push(T stk, void *x); 将x推入stk栈中
extern void    *stack_pop(T stk);           弹出并返回stk的栈顶元素。如果stk为空，则为已检查的运行时错误
extern void    *stack_peek(T stk);

#undef T

接口的设计原则
-------------------
1. 完全屏蔽实现细节
    接口仅规定客户程序可能使用的那些标识符，而尽可能隐藏不相关的表示细节算法。这有助于客户程序
避免依赖特定实现的具体细节。
2. 规范的标识符命名
    在接口中，接口名称表现为每个标识符的前缀，这种约定并不优美，但C语言几乎没有提供其他的备选方案。
所在文件作用域中的标识符，包括变量、函数、类型定义和枚举常数，都共享同一个命名空间。
所有的全局结构、联合和枚举标记则共享另一个命名空间。避免这种"名称碰撞(name collision)"的一个方法是使用前缀，如模块名。
一个大程序很容易有数千全局标识符，但通常只有几百个模块。模块名不仅提供了适当的前缀，还有助于使客户程序代码文档化。
    "接口名称作为标识符前缀"算是一种约定俗成的习惯。
3. 堵住(完善)语言语义漏洞
    大多数编程语言的语义中都包含有漏洞，某些操作的精确含义定义得不明确或根本未定义。C 语言的语义充满了这种漏洞。
设计完善的接口会塞住这些漏洞，将未定义之处定义完善，并对语言标准规定为未定义或由具体实现定义的行为给出明确的
裁决。

抽象数据类型
-------------------
1. 数据类型的内涵
    一个抽象数据类型是一个接口，它定义了一个数据类型和对该类型的值所进行的操作。一个数据类型是一个值的集合。
在C语言中，内建的数据类型包括字符、整数、浮点数等。而结构本身也能定义新的类型，因而可用于建立更高级类型，
如列表、树、查找表等。
    高级类型是抽象的，因为其接口隐藏了相关的表示细节，并只规定了对该类型的合法操作。理想情况下，这些操作
不会暴露类型的表示细节，因为那样可能使客户程序隐含地依赖于具体的表示。
    抽象数据类型时就指出了数据类型的两个本质内容 —— 数据本身(值的集合)与对数据的操作。
2. 不透明的指针类型
    该接口透露了栈是通过指向结构的指针表示的，但并没有给出结构的任何信息。因而 Stack_T 是一个不透明指针类型，
客户端可以自由低操纵这种指针，但无法反引用不透明指针，即无法查看指针所指向结构的内部信息。
    不透明指针隐藏了表示细节，有助于捕获错误。只有 Stack_T 类型值可以传递给上述的函数，试图传递另一种指针，
如指向其他结构的指针，将会产生编译错误。唯一的例外是参数中的一个 void 指针。该参数可以传递任何类型指针。
    「透明」就是在头文件中能看到结构体的成员，而不透明恰好相反。




