程序中会发生三种错误: 用户错误、运行时错误和异常。
1. 用户错误:    是指预期发生的；因为错误的用户输入就可能会导致用户错误，程序必须计划并处理这类错误。
                通常，函数必须处理用户错误并返回错误代码，这些错误是计算过程中很正常的一部分。
2. 运行时错误 : 不是用户错误，根本不在预料中，并且总是提示了程序的漏洞。
                因而程序无法从这种错误恢复过来，必须优雅的结束。可以使用断言来结束运行。
3. 异常: 介于用户错误和程序错误之间的一类错误。异常是很少出现且可能不可预测的错误，但是从异常中恢复是可能的。
         异常并不会经常发生，因此可能会发生异常的函数通常不会返回错误代码。
         一些异常反应了机器的能力，如算术运算上溢或下溢以及栈溢出。
         其他异常表明操作系统检测到的状况，这些状况也许是用户发起的，如按下一个"中断"键或写文件时遇到写入错误。
C语言
  标准库函数setjmp和longjmp形成了结构化异常工具的基础。即setjmp实例化处理程序，而longjmp产生异常。
  异常处理程序处理的是异常的地址。异常必须是全局的或静态的变量，因此它们的地址惟一地标识了它们。
如果把异常声明成一个局部变量或参数就会产生不可检查的运行期错误。
  Except_T结构只有一个字段，它可以初始化为一个描述异常的字符串。当发生一个未处理的异常时，
才会把该字符串打印出来。
  处理程序是由TRY-EXCEPT和TRY-FINALLY语句来实例化的。这两个语句用宏指令实现，可以处理嵌套异常，
也可以管理异常状态的数据。
  RETURN宏用在TRY语句内部，用来替代return语句，直接使用return语句是一个不可检查的运行错误。

setjmp状态
  Except_entered    setjmp的第一次返回将except_flag设置为Except_entered，表示已经进入TRY语句并将一个异常帧压入异常栈
                    Except_entered必须为零，因为第一调用setjmp返回零，此后从setjmp返回时会将该标识设置为Except_raised，表示异常
  Except_raised     
  Except_handled    处理程序将except_flag设置为Except_handled，表示它们已经处理了异常
  Except_finalized  

except宏说明
  TRY将一个新的Except_Frame帧压栈，并调用setjmp。
  RAISE和RERAISE调用Except_raise填充栈顶帧的各字段并出栈，然后调用longjmp。
  EXCEPT检查exception字段，决定应用哪个处理程序。
  FINALLY执行清除代码，并重新产生已弹出的异常帧中存储的异常。
  如果发生了异常却没有执行处理控制就达到了END_TRY，将会重新触发异常。

  
宏指令TRY、EXCEPT、ELSE、FINALLY和END_TRY一起将TRY-EXCEPT语句转化为如下形式：
do {
    create and push an Except_Frame
    if (first return from setjmp) {
        S
    } else if (exception is e1 ) {
        S1
    …
    } else if (exception is en ) {
        Sn
    } else {
        S0
    }
    if (an exception occurred and wasn’t handled)
        RERAISE;
} while (0)   

typedef struct T {char *reason;} T;  -- T 即为Except_T
TRY语句的语法如下，S和e表示语句和异常。ELSE子句是可选的。
TRY S EXCEPT(e1) S1 ... EXCEPT(en) Sn ELSE S0 END_TRY
TRY S FINALLY S1 ED_TRY

void except_raise(const T *e, const char *file, int line)
在源代码位置file和line处引发异常*e。如果e=NULL，则为已检查的运行时错误，未捕获的异常，将导致程序终止。
RAISE(e) 引发异常e
RERAISE  重新引发导致异常处理程序执行的异常
RETURN   
RETURN expression 是用于TRY语句内部的返回语句。在TRY语句内使用C语言的返回语句，属于未检查的运行时错误。


断言
-------------------
    一般标准要求头文件assert.h把assert(e)定义成一个提供诊断信息的宏指令。assert(e)对e求值，
如果e为0，那么在标准错误上写上诊断信息并调用标准库函数abort中断执行。
    assert.h也使用了宏指令NDEBUG，如果定义了宏指令NDEBUG，那么assert(e)与空表达式((void)0)等价。
因此，程序员可以通过定义NDEBUG并重新编译来关掉断言。
    Assert接口定义的assert(e)与标准中的定义类似，不同的是断言失败将触发一个Assert_Failed异常，
而不是终止运行，并且不提供断言e的内容。

assert(0) 是一个很好的方法，用于指明"不可能发生"的情况。
assert(!"ptr==NULL -- can not hanppen") 特很好

#undef assert
#ifdef NDEBUG
#define assert(e) ((void)0)
#else
extern void assert(int e);
#define assert(e) ((void)((e) || \
        (fprintf(stderr, "%s:%d Assertion Failed:%s\n", \
        __FILE__, (int)__LINE__, #e), abort(), 0)))
#endif

assert(e) 如果e为0，则引发assert_failed异常。语法上，assert(e)是一个表达式。
          如果包含assert.h都文件，已经定义了NDEBUG,则断言被禁用。