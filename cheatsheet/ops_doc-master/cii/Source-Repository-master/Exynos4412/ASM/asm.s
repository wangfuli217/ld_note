.global _start @定义了一个全局的符号
_start:        @汇编入口

@汇编文件中主要包括三部分内容：
@	1).指令：编译完成后作为一条指令存储在内存单元当中，CPU执行时能完成一定的操作
@	2).伪指令：在编译时替换成其他ARM能够识别的指令
@	3).伪操作：指导编译器进行编译，编译完成后不生成指令也不占用内存空间


@指令分为六类：
@	1).数据处理指令：对数据进行逻辑、数学等运算与处理
@	2).跳转指令：实现程序的跳转
@	3).Load/Store指令：CPU与内存之间进行数据的存取
@	4).状态寄存器传送指令：对状态寄存器进行读写操作
@	5).协处理器指令：对协处理器进行操作
@	6).异常中断产生指令：产生异常中断

/******************************************************************************/

/*****数据处理指令*****/

@ 数据搬移指令
	@ mov r0, #0xFF
	@ r0 = 0xFF
	@ mov r1, r0
	@ r1 = r0
	@ mvn r2, r1
	@ r2 = ~r1

@ 立即数
	@ 在指令中给立即数留了12位的存储空间，所以立即数只包含了2的12次方个
	@ 一个立即数是由一个八位的数循环右移偶数次得到的
	@ 立即数的本质是包含于指令中的数
	@ mov r0, #0xf0000000
	@ 有效数
	@ 有效数即包括立即数也包括立即数取反得到的数
	@ mov r0, #0xffffff00

@ 加法指令
	@ mov r0, #1
	@ mov r1, #1
	@ add r2, r1, r0
	@ r2 = r1 + r0

@ 数据处理指令的语法：<操作>{<cond>}{S} Rd, Rn, Operand2
@ <操作码><目标寄存器Rd><第一操作寄存器Rn><第二操作数Operand2>

@ 数据操作对CPSR的影响
	@ 默认情况下，数据处理指令不影响条件码标志位，但可以选择通过添加“S”来影响标志位。
	@ mov r0, #5
	@ adds r1, r0, #5
	@ mov r0, #0xFFFFFFFE
	@ adds r1, r0, #5

@ 带进位的加法指令
	@ 两个64位数相加，第一个64位数的低32位放在r0高32位放在r1,第二个64位数的低32位放在r2高32位放在r3
	@ 编写代码实现两个64位数的和，结果的低32位放在r4高32位放在r5
	@ mov r0, #0xfffffffe  @第一个数的低位
	@ mov r1, #1           @第一个数的高位
	@ mov r2, #0x5         @第二个数的低位
	@ mov r3, #1           @第二个数的高位
	@ adds r4, r0, r2
	@ adc  r5, r1, r3
	@ r5 = r1 + r3 + c

@ 减法指令
	@ mov r0, #5
	@ mov r1, #3
	@ sub r2, r0, r1
	@ r2 = r0 - r1

@ 带借位减法指令
	@ mov  r0, #5
	@ mov  r1, #3
	@ subs r2, r1, r0
	@ mov  r0, #5
	@ mov  r1, #3
	@ sbc  r2, r0, r1
	@ r2 = r0 - r1 - !C

@ 逆向减法指令
	@ mov  r0, #3
	@ rsb r1, r0, #5
	@ r1 = 5 - r0

@ 带借位逆向减法指令
	@ rsc r1, r2, r3
	@ r1 = r3 - r2 - !C

@ 乘法指令
	@ mov r0, #3
	@ mov r1, #5
	@ mul r2, r0, r1
	@ r2 = r0 * r1

	@ mla r3, r0, r1, r2
	@ r3 = (r0 * r1) + r2

@ 逻辑与指令
	@ mov r0, #0xf0
	@ mov r1, #0x0f
	@ and r2, r0, r1
	@ r2 = r0 & r1

@ 逻辑或运算
	@ mov r0, #0xf0
	@ mov r1, #0x0f
	@ orr r2, r0, r1
	@ r2 = r0 | r1

@ 逻辑异或运算
	@ mov r0, #0xff
	@ mov r1, #0xff
	@ eor r2, r1, r0
	@ r2 = r1 eor r0

@ 位清零指令
	@ mov r0, #0xff
	@ bic r1, r0, #0xf
	@ 0xf中哪一位是1对应的将r0中的哪一位清零，然后将结果放在r1中

@ 比较指令
	@ mov r0, #2
	@ mov r1, #1
	@ cmp r0, r1
	@ mov r0, #1
	@ mov r1, #1
	@ cmp r0, r1
	@ 实质是进行了减法运算，当减法结果为0时也就是两个数相等时，CPSR中的Z自动置1
	@ 没有目标寄存器

@ 基于相反数的比较指令
	@ mov r0, #-1
	@ mov r1, #1
	@ cmn r0, r1
	@ 实质是进行了加法运算，当两个数互为负数时相加结果为0，这时Z位为1，否则Z位为0

@ 位测试指令
	@ tst r0, #0x1
	@ 实质是进行了与运算  常用于测试某一位是0还是1


@ 相等测试指令
	@ teq r0, r1
	@ 实质是进行了异或运算，常用于测试两个数是否相等，两个数异或后相等为0，所以Z位置1

@ 桶形移位器
	@ mov r0, #0xff
	@ mov r1, r0, lsl #4
	@ 将r0逻辑左移四位放入r1中
	@ 逻辑左移  高位移出  低位补零
	@ mov r1, r0, lsr #4
	@ 逻辑右移  低位移出  高位补零
	@ mov r1, r0, asr #4
	@ 算数右移  低位移出  高位补符号位
	@ mov r1, r0, ror r2
	@ 循环右移  低位移出  高位补低位

/*****跳转指令*****/
/*
	@跳转指令
loop1:
	mov r1, #1
	mov r2, #2
	mov r3, #3
	b loop2
	mov r4, #4
	mov r5, #5

loop2:
	mov r6, #6
	mov r7, #7
	b loop1
	mov r8, #8
*/
	@ 能够跳转到当前指令地址±32M字节的内存空间处的代码
	@ 一条跳转指令中给跳转的目标地址分配了24位的空间来表示跳转的目标地址
	@ ARM指令32位宽度，即指令的存储地址后两位永远是00
	@ 所以B指令中用24位的空间表示了一个26位的数(后两位默认是00)，这样跳转范围为2的26次方即64M

	@跳转的同时将跳转指令下一条指令的地址自动保存到LR寄存器当中
/*
loop1:
	mov r1, #1
	mov r2, #2
	mov r3, #3
	bl loop2
	mov r4, #4
	mov r5, #5

loop2:
	mov r6, #6
	mov r7, #7
	mov r8, #8
	mov pc, lr
*/

@ ARM指令的条件执行

	@ ARM指令可以通过添加适当的条件码前缀来达到条件执行的目的
	@ 实质是判断cpsr中的条件位
	@ mov r1, #2
	@ mov r2, #2
	@ cmp r1, r2
	@ beq loop
	@ 当r1与r2相等时跳转  否则不跳转继续向下执行
	@ mov r3, #3
	@ mov r4, #4

@ loop:
	@ mov r5, #5
	@ mov r6, #6

@ 测试2
/*
loop:
	cmp r0, r1
	beq stop
	subgt r0, r0, r1
	sublt r1, r1, r0
	b loop

/*****Load/Store指令*****/

@ 向内存当中写一个数据
	@ mov r0, #0xaa
	@ mov r1, #0x41000000
	@ str r0, [r1]
	@ 将R0中的数据存储到以R1起始地址的内存单元
	@ strb r0, [r1]
	@ 将r0寄存器中的[7:0]位存储到内存地址为r1的内存单元
	@ strh r0, [r1]
	@ 将r0寄存器中的[15:0]位存储到内存起始地址为r1的内存单元

@ 从内存当中读一个数据到寄存器
	@ ldr r2, [r1]
	@ 将r1指向的内存单元中的数加载到r2寄存器中
	@ ldrb r2, [r1]
	@ 将内存单元R1中的数据加载到R2的低8位
	@ ldrh r2, [r1]
	@ 将内存单元R1为起始地址的数据加载到R2的低16位

@ 单寄存器内存访问的索引方式

	@ 前索引
	@ mov r0, #0xaa
	@ mov r1, #0x41000000
	@ mov r2, #4
	@ str r0, [r1, #4]
	@ 将r0中的数据存储到内存地址为r1+4的内存单元中
	@ strb r0, [r1, r2]
	@ 将r0中的数据存储到内存地址为r1+让的内存单元中
	@ str r0, [r1, r2, lsl #1]
	@ 将r0中的数据存储到内存地址为 r1+(r2 lsl #1)的内存单元中

	@ 后索引
	@ mov r0, #0xaa
	@ mov r1, #0x41000000
	@ mov r2, #4
	@ str r0, [r1], #4
	@ 将r0中的数据存储到r1指向的内存地址当中，然后r1=r1+4
	@ str r0, [r1], r2
	@ 将r0中的数据存储到r1指向的内存地址当中，然后r1=r1+r2

	@ 自动索引
	@ mov r0, #0xaa
	@ mov r1, #0x41000000
	@ str r0, [r1, #4]!
	@ 将r0中的数据存储到r1+4指向的内存地址当中，然后r1=r1+4
    @ str r0, [r1, #8]!
    @ 将r0中的数据存储到r1+8指向的内存地址当中，然后r1=r1+8

@ 批量数据操作
	@ mov r1, #1
	@ mov r2, #2
	@ mov r3, #3
	@ mov r4, #4
	@ mov r5, #5
	@ mov r11,#0x41000000
	@ stm r11, {r1-r5}
	@ 将r1-r5寄存器中的数存储到以r11为起始地址的内存单元当中
	@ stm r11, {r1-r3,r4,r5}
	@ 寄存器编号小的永远放在内存地址小的地址单元
	@ stmia r11, {r1-r5}
	@ 默认方式，先操作后增长
	@ stmda r11, {r1-r5}
	@ 先操作后减小
	@ stmib r11, {r1-r5}
	@ 先增长后操作
	@ stmdb r11, {r1-r5}
	@ 先减小后操作
	@ stm r11!, {r1-r5}
	@ 操作完成后地址自增

	@ ldm r11!, {r6-r10}
	@ 将r11为起始地址的内存单元的数据加载到r6-r10
	@ ldmdb r11!, {r6-r10}

@ 栈的操作
/*
	mov r1, #1
	mov r2, #2
	mov r3, #3
	mov r4, #4
	mov r5, #5
	mov r11,#0x41000000
	stmfd r11!, {r1-r5}
	ldmfd r11!, {r6-r10}
*/
	@ FD满减  FA满增  ED空减  EA空增
	@ 习惯上使用满减栈

@ 子函数调用

	@ mov sp, #0x41000000
	@ 初始化栈顶
/*
MIAN:
	mov r0, #1
	mov r1, #1
	bl FUNC              @ 子函数调用
	add r2, r0, r1
	b stop

FUNC:
	stmfd sp!, {r0,r1}   @ 保护现场  压栈
	mov r0, #2
	mov r1, #4
	sub r2, r1, r0
	ldmfd sp!, {r0,r1}   @ 出栈  恢复现场
	mov pc, lr           @ 子函数返回
*/


@ 信号量操作
	@ swp r0, r1, [r2]
	@ 将r0中的数据放入内存地址是r2的地址空间，同时将r2中的值放入r1寄存器
	@ 单条指令实现数据的交换，过程不会被打断，常用于信号量操作

/*****状态寄存器传送指令*****/

	@ mrs r0, cpsr
	@ 读取CPSR到R0中
	@ bic r0, #0xf
	@ msr cpsr, r0
	@ 将r0中的数据写入到CPSR
	@ 修改CPSR的一般步骤  读-改-写
	@ orr r0, r0, #0x3
	@ msr cpsr, r0
	@ 非特权模式下不能修改模式

	@ bic r0, #0xffffff0f
	@ msr cpsr_f, r0
	@ 将r0的第[31:24]位写入cpsr中的[31:24]位  条件域
	@ msr cpsr_s, r0
	@ 状态域
	@ msr cpsr_x, r0
	@ 预留域
	@ msr cpsr_c, r0
	@ 控制域

/*异常中断产生指令*/
	@ swi #3
	@ 通过该指令可以触发一次软中断

/*协处理器指令*/
 	@MRC
 	@从协处理器寄存器移到ARM 寄存器
 	@MCR
 	@从 ARM 寄存器移到协处理器寄存器


/*****伪指令*****/

	@ ldr r0, =0x12345678
	@ ldr r0, =0xf
	@ 编译阶段进行了替换
	@ ldr r0, =stop
	@ ldr r0, stop

/*****伪操作*****/

	@ .global _start
	@定义了一个全局的符号
	@ _start:
	@ 汇编入口
	@ .end           @汇编程序结束
	@ .word 0x12345678
	@ 在当前地址存放一个4字节的数并对其初始化
	@ .byte 1
	@ .space 100,1
	@ 在当前地址申请一个100字节的空间并初始化为1

/*****C和汇编的混合编程*****/
	@ C调用汇编
	@ 汇编调用C
	@ C内嵌汇编

/*****ATPCS协议*****/
	@ 使用满减栈
	@ r0-r3用于子程序传参
	@ r0用于返回值

/***************************************************************/
/***************************************************************/

/*实验目的：编写裸机程序控制开发板上LED闪烁*/

/*实验步骤*/

	@ 1.通过分析电路图可知，当4412处理器GPX2_7管脚为高电平时LED2点亮，否则熄灭
	@ 2.通过分析可知可以使用GPX2_7的GPIO功能来实现高低电平的控制
CFG:
	ldr r0, =0x11000c40
	@ 将控制寄存器的地址放到R0中
	ldr r1, =0x10000000
	@ 先将设置的值放到r1寄存器中
	str r1, [r0]
	@ 将r1中的数存储到r0指向的内存单元当中即将GPX2_7管脚设置成了输出功能

FUNC:
	bl LED_ON
	bl DELAY
	bl LED_OFF
	bl DELAY
	b  FUNC

LED_OFF:
	ldr r0, =0x11000c44
	@ 将数据寄存器的地址放到R0中
	ldr r1, =0x0
	@ 先将设置的值放到r1寄存器中
	str r1, [r0]
	@ 将r1中的数存储到r0指向的内存单元当中即GPX2_7管脚输出低电平
	mov pc, lr
	@ 调用返回

LED_ON:
	ldr r0, =0x11000c44
	@ 将数据寄存器的地址放到R0中
	ldr r1, =0x80
	@ 先将设置的值放到r1寄存器中
	str r1, [r0]
	@ 将r1中的数存储到r0指向的内存单元当中即GPX2_7管脚输出低电平
	mov pc, lr
	@ 调用返回

DELAY:
	ldr r0, =50000000
T:
	sub r0, r0, #1
	cmp r0, #0
	moveq pc, lr
	b T

stop:
	b stop     @死循环，防止跑飞 while(1)
.end           @汇编程序结束


