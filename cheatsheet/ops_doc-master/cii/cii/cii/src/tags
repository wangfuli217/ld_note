!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ArenaFailedException	arena.c	/^const except_t ArenaFailedException =$/;"	v
ArenaNewFailedException	arena.c	/^const except_t ArenaNewFailedException = $/;"	v
ArithmeticException	except.c	/^const T ArithmeticException         = {"ArithmeticException"};$/;"	v
AssertFailedException	assert.c	/^const except_t AssertFailedException       = {"AssertFailedException"};$/;"	v
BPW	bit.c	9;"	d	file:
Fmt_puts	fmt_assist.c	/^void Fmt_puts(const char *str, int len, in put(int c, void *c1), void *c1, $/;"	f
HTAB_LEN	memchk.c	8;"	d	file:
IOException	except.c	/^const T IOException                 = {"IOException"};$/;"	v
IllegalArgumentException	except.c	/^const T IllegalArgumentException    = {"IllegalArgumentException"};$/;"	v
IndexOutOfBoundsException	except.c	/^const T IndexOutOfBoundsException   = {"IndexOutOfBoundsException"};$/;"	v
MemFailedException	memchk.c	/^const except_t MemFailedException          = {"MemFailedException"};$/;"	v
NALLOC	memchk.c	38;"	d	file:
NDESCRIPTORS	memchk.c	36;"	d	file:
NELEMS	atom.c	60;"	d	file:
NullPointerException	except.c	/^const T NullPointerException        = {"NullPointerException"};$/;"	v
OverflowException	fmt.c	/^const except_t  OverflowException = {"Formatting Overflow"};$/;"	v
RuntimeException	except.c	/^const T RuntimeException            = {"RuntimeException"};$/;"	v
SignalException	except.c	/^const T SignalException             = {"SignalException"};$/;"	v
T	arena.c	/^struct T{$/;"	s	file:
T	arena.c	7;"	d	file:
T	array.c	9;"	d	file:
T	bit.c	/^struct T{$/;"	s	file:
T	bit.c	7;"	d	file:
T	bst.c	/^struct T{$/;"	s	file:
T	bst.c	5;"	d	file:
T	digraph.c	/^struct T{$/;"	s	file:
T	digraph.c	10;"	d	file:
T	dlist.c	7;"	d	file:
T	except.c	8;"	d	file:
T	fmt.c	14;"	d	file:
T	indexminpq.c	/^struct T{$/;"	s	file:
T	indexminpq.c	7;"	d	file:
T	list.c	7;"	d	file:
T	ring.c	/^struct T{$/;"	s	file:
T	ring.c	8;"	d	file:
T	seq.c	/^struct T{$/;"	s	file:
T	seq.c	10;"	d	file:
T	set.c	/^struct T{$/;"	s	file:
T	set.c	8;"	d	file:
T	sparsearray.c	/^struct T{$/;"	s	file:
T	sparsearray.c	9;"	d	file:
T	stack.c	/^struct T{$/;"	s	file:
T	stack.c	6;"	d	file:
T	table.c	/^struct T{$/;"	s	file:
T	table.c	7;"	d	file:
T	text.c	7;"	d	file:
THRESHOLD	arena.c	39;"	d	file:
_access_get	seq.c	/^_access_get(T seq, ssize_t position)$/;"	f	file:
_access_set	seq.c	/^_access_set(T seq, ssize_t position, void *x)$/;"	f	file:
_alloc	text.c	/^static char *_alloc(int len) {$/;"	f	file:
_bit_copy	bit.c	/^_bit_copy(T t)$/;"	f	file:
_bit_in_set	bit.c	/^_bit_in_set(unsigned char *bytes, ssize_t position)$/;"	f	file:
_bst_remove_child	bst.c	/^_bst_remove_child$/;"	f	file:
_bst_replace_child	bst.c	/^_bst_replace_child$/;"	f	file:
_bst_set_key	bst.c	/^_bst_set_key$/;"	f	file:
_cmp_simple	bst.c	/^_cmp_simple$/;"	f	file:
_cmpatom	set.c	/^_cmpatom(const void *x, const void *y)$/;"	f	file:
_cmpatom	table.c	/^_cmpatom(const void *x, const void *y)$/;"	f	file:
_cset	text.c	/^static char _cset[] =$/;"	v	file:
_current	text.c	/^} _head = { NULL, NULL, NULL }, *_current = &_head;$/;"	v	typeref:struct:chunk	file:
_dalloc	memchk.c	/^_dalloc(void *ptr, $/;"	f	file:
_default_except_handler	except.c	/^_default_except_handler(const T *e,$/;"	f	file:
_exch	indexminpq.c	/^_exch(T iminpq, int i, int j)$/;"	f	file:
_expand	seq.c	/^_expand(T seq)$/;"	f	file:
_find	memchk.c	/^_find(const void *ptr)$/;"	f	file:
_greater	indexminpq.c	/^_greater(T iminpq, int i, int j)$/;"	f	file:
_hashatom	set.c	/^_hashatom(const void *x)$/;"	f	file:
_hashatom	table.c	/^_hashatom(const void *key)$/;"	f	file:
_head	text.c	/^} _head = { NULL, NULL, NULL }, *_current = &_head;$/;"	v	typeref:struct:chunk	file:
_list_append_g	list.c	/^_list_append_g(T list, T tail)$/;"	f	file:
_list_list_g	list.c	/^_list_list_g(void *x, ...)$/;"	f	file:
_list_reverse_g	list.c	/^_list_reverse_g(T list)$/;"	f	file:
_relax	digraph.c	/^_relax$/;"	f	file:
_reset_lastget	ring.c	/^_reset_lastget(T ring)$/;"	f	file:
_ring_node	ring.c	/^_ring_node(T ring, ssize_t position)$/;"	f	file:
_ring_node_delete	ring.c	/^_ring_node_delete(T ring, struct node *p)$/;"	f	file:
_set_copy	set.c	/^_set_copy(T t, int hint)$/;"	f	file:
_signal_except_handler	except.c	/^_signal_except_handler(int sig)$/;"	f	file:
_sink	indexminpq.c	/^_sink(T iminpq, int k)$/;"	f	file:
_swim	indexminpq.c	/^_swim(T iminpq, int k)$/;"	f	file:
a	arena.c	/^    union align a;$/;"	m	union:header	typeref:union:header::align	file:
adj	digraph.c	/^struct adj{$/;"	s	file:
adj_seq	digraph.c	/^    seq_t   adj_seq;$/;"	m	struct:T	file:
align	arena.c	/^union align{$/;"	u	file:
align	memchk.c	/^union align{$/;"	u	file:
append	fmt.c	/^static int  append(int c, void *cl)$/;"	f	file:
arena	digraph.c	/^    arena_t     arena;$/;"	m	struct:T	file:
arena_alloc	arena.c	/^arena_alloc(T arena, $/;"	f
arena_calloc	arena.c	/^arena_calloc(T arena,$/;"	f
arena_dispose	arena.c	/^arena_dispose(T *ap)$/;"	f
arena_free	arena.c	/^arena_free(T arena)$/;"	f
arena_new	arena.c	/^arena_new(void)$/;"	f
arith_ceiling	arith.c	/^arith_ceiling(int x, int y)$/;"	f
arith_div	arith.c	/^arith_div(int x, int y)$/;"	f
arith_floor	arith.c	/^arith_floor(int x, int y)$/;"	f
arith_max	arith.c	/^arith_max(int x, int y)$/;"	f
arith_min	arith.c	/^arith_min(int x, int y)$/;"	f
arith_mod	arith.c	/^arith_mod(int x, int y)$/;"	f
array	seq.c	/^    struct array_t array;$/;"	m	struct:T	typeref:struct:T::array_t	file:
array_copy	array.c	/^array_copy(T array, ssize_t length)$/;"	f
array_free	array.c	/^array_free(T *array)$/;"	f
array_get	array.c	/^array_get(T array, ssize_t position)$/;"	f
array_length	array.c	/^array_length(T array)$/;"	f
array_new	array.c	/^array_new(ssize_t length, ssize_t size)$/;"	f
array_put	array.c	/^array_put(T array, ssize_t position, void *element)$/;"	f
array_resize	array.c	/^array_resize(T array, ssize_t length)$/;"	f
array_size	array.c	/^array_size(T array)$/;"	f
arrayrep_init	array.c	/^arrayrep_init(T array,$/;"	f
assert	assert.c	/^void (assert)(int e) {$/;"	f
atom	atom.c	/^static struct atom{$/;"	s	file:
atom_int	atom.c	/^atom_int(long n)$/;"	f
atom_length	atom.c	/^atom_length(const char *str)$/;"	f
atom_new	atom.c	/^atom_new(const char *str, int len)$/;"	f
atom_string	atom.c	/^atom_string(const char *str)$/;"	f
avail	arena.c	/^    char *avail;$/;"	m	struct:T	file:
avail	text.c	/^	char *avail;$/;"	m	struct:chunk	file:
avail	text.c	/^	char *avail;$/;"	m	struct:text_save_t	file:
b	arena.c	/^    struct T b;$/;"	m	union:header	typeref:struct:header::T	file:
binding	table.c	/^    struct binding{$/;"	s	struct:T	file:
bit_clear	bit.c	/^bit_clear   (T bset, ssize_t low, ssize_t high)$/;"	f
bit_count	bit.c	/^bit_count   (T bset)$/;"	f
bit_diff	bit.c	/^bit_diff    (T s, T t)$/;"	f
bit_eq	bit.c	/^bit_eq      (T s, T t)$/;"	f
bit_free	bit.c	/^bit_free    (T *bset)$/;"	f
bit_get	bit.c	/^bit_get     (T bset, ssize_t position)$/;"	f
bit_inter	bit.c	/^bit_inter   (T s, T t)$/;"	f
bit_length	bit.c	/^bit_length  (T bset)$/;"	f
bit_leq	bit.c	/^bit_leq     (T s, T t)$/;"	f
bit_lt	bit.c	/^bit_lt      (T s, T t)$/;"	f
bit_map	bit.c	/^bit_map     (T bset,$/;"	f
bit_minus	bit.c	/^bit_minus   (T s, T t)$/;"	f
bit_new	bit.c	/^bit_new     (ssize_t length)$/;"	f
bit_not	bit.c	/^bit_not     (T bset, ssize_t low, ssize_t high)$/;"	f
bit_put	bit.c	/^bit_put     (T bset, ssize_t position, int bit)$/;"	f
bit_set	bit.c	/^bit_set     (T bset, ssize_t low, ssize_t high)$/;"	f
bit_union	bit.c	/^bit_union   (T s, T t)$/;"	f
bp	fmt.c	/^    char   *bp;$/;"	m	struct:buf	file:
bst_delete	bst.c	/^bst_delete$/;"	f
bst_find	bst.c	/^bst_find$/;"	f
bst_get_key	bst.c	/^bst_get_key$/;"	f
bst_insert	bst.c	/^bst_insert$/;"	f
bst_maximum	bst.c	/^bst_maximum$/;"	f
bst_minimum	bst.c	/^bst_minimum$/;"	f
bst_new	bst.c	/^bst_new$/;"	f
bst_predecessor	bst.c	/^bst_predecessor$/;"	f
bst_successor	bst.c	/^bst_successor$/;"	f
bst_traverse	bst.c	/^bst_traverse$/;"	f
buckets	atom.c	/^}*buckets[2048];$/;"	v	typeref:struct:atom	file:
buckets	set.c	/^    }**buckets;$/;"	m	struct:T	typeref:struct:T::member	file:
buckets	table.c	/^    }**buckets;$/;"	m	struct:T	typeref:struct:T::binding	file:
buf	fmt.c	/^    char   *buf;$/;"	m	struct:buf	file:
buf	fmt.c	/^struct buf{ $/;"	s	file:
bytes	bit.c	/^    unsigned char *bytes;$/;"	m	struct:T	file:
chunk	text.c	/^static struct chunk {$/;"	s	file:
cmp	set.c	/^    int (*cmp) (const void *x, const void *y);$/;"	m	struct:T	file:
cmp	table.c	/^    int (*cmp)(const void *x, const void *y);$/;"	m	struct:T	file:
convert	str.c	24;"	d	file:
convert	text.c	12;"	d	file:
count	indexminpq.c	/^    int     count;$/;"	m	struct:T	file:
count	stack.c	/^    int count;$/;"	m	struct:T	file:
current	text.c	/^	struct chunk *current;$/;"	m	struct:text_save_t	typeref:struct:text_save_t::chunk	file:
cvt	fmt.c	/^static T cvt[256] = {$/;"	v	file:
cvt_c	fmt.c	/^cvt_c(int code, va_list *app,$/;"	f	file:
cvt_d	fmt.c	/^cvt_d(int code, va_list *app,$/;"	f	file:
cvt_f	fmt.c	/^cvt_f(int code, va_list *app,$/;"	f	file:
cvt_o	fmt.c	/^cvt_o(int code, va_list *app,$/;"	f	file:
cvt_p	fmt.c	/^cvt_p(int code, va_list *app,$/;"	f	file:
cvt_s	fmt.c	/^cvt_s(int code, va_list *app,$/;"	f	file:
cvt_s	fmt_assist.c	/^static void cvt_s(int code, va_list *app, int put(int c, void *c1), void *c1,$/;"	f	file:
cvt_u	fmt.c	/^cvt_u(int code, va_list *app,$/;"	f	file:
cvt_x	fmt.c	/^cvt_x(int code, va_list *app,$/;"	f	file:
d	arena.c	/^    double d;$/;"	m	union:align	file:
d	memchk.c	/^    double d;$/;"	m	union:align	file:
descriptor	memchk.c	/^static struct descriptor{$/;"	s	file:
digraph_add	digraph.c	/^digraph_add         $/;"	f
digraph_add_seg	digraph.c	/^digraph_add_seg     $/;"	f
digraph_connect	digraph.c	/^digraph_connect$/;"	f
digraph_count	digraph.c	/^digraph_count$/;"	f
digraph_dijkstra	digraph.c	/^digraph_dijkstra$/;"	f
digraph_free	digraph.c	/^digraph_free$/;"	f
digraph_is_connect	digraph.c	/^digraph_is_connect$/;"	f
digraph_new	digraph.c	/^digraph_new$/;"	f
digraph_path_free	digraph.c	/^digraph_path_free$/;"	f
digraph_path_get	digraph.c	/^digraph_path_get     $/;"	f
digraph_path_length	digraph.c	/^digraph_path_length$/;"	f
digraph_path_t	digraph.c	/^struct digraph_path_t{$/;"	s	file:
digraph_sr_dist	digraph.c	/^digraph_sr_dist$/;"	f
digraph_sr_free	digraph.c	/^digraph_sr_free$/;"	f
digraph_sr_has_path	digraph.c	/^digraph_sr_has_path$/;"	f
digraph_sr_path_to	digraph.c	/^digraph_sr_path_to$/;"	f
digraph_sr_start	digraph.c	/^digraph_sr_start$/;"	f
digraph_sr_t	digraph.c	/^struct digraph_sr_t{$/;"	s	file:
dist_to	digraph.c	/^    double      *dist_to;$/;"	m	struct:digraph_sr_t	file:
dlist_append	dlist.c	/^dlist_append(T dlist, T dtail)$/;"	f
dlist_copy	dlist.c	/^dlist_copy(T dlist)$/;"	f
dlist_free	dlist.c	/^dlist_free(T *dlist)$/;"	f
dlist_length	dlist.c	/^dlist_length(T dlist)$/;"	f
dlist_list	dlist.c	/^dlist_list(void *x, ...)$/;"	f
dlist_map	dlist.c	/^dlist_map(T dlist,$/;"	f
dlist_pop	dlist.c	/^dlist_pop(T dlist, void **x)$/;"	f
dlist_push	dlist.c	/^dlist_push(T dlist, void *x)$/;"	f
dlist_reverse	dlist.c	/^dlist_reverse(T dlist)$/;"	f
dlist_to_array	dlist.c	/^dlist_to_array(T dlist, void *end)$/;"	f
edge_array	digraph.c	/^    struct adj  **edge_array;$/;"	m	struct:digraph_sr_t	typeref:struct:digraph_sr_t::adj	file:
element	stack.c	/^    struct element{$/;"	s	struct:T	file:
equal	text.c	21;"	d	file:
except_ctx	except.c	/^volatile struct except_context except_ctx = {.default_handler = _default_except_handler, $/;"	v	typeref:struct:except_context
except_raise	except.c	/^except_raise(const T *e, $/;"	f
except_set_default_handler	except.c	/^except_set_default_handler(void (*handler)(const T *e,$/;"	f
f	arena.c	/^    float f;$/;"	m	union:align	file:
f	memchk.c	/^    float f;$/;"	m	union:align	file:
file	memchk.c	/^    const char *file;$/;"	m	struct:descriptor	file:
fmt_flags	fmt.c	/^char       *fmt_flags = "-+ 0";$/;"	v
fmt_fmt	fmt.c	/^fmt_fmt(int (*put)(int c, void *cl),$/;"	f
fmt_fprint	fmt.c	/^void fmt_fprint(FILE *stream,  const char *fmt, ...) \/\/fprintf$/;"	f
fmt_print	fmt.c	/^fmt_print(const char *fmt, ...) \/\/printf$/;"	f
fmt_putd	fmt.c	/^fmt_putd(const char *str,$/;"	f
fmt_puts	fmt.c	/^void        fmt_puts(const char *str,$/;"	f
fmt_register	fmt.c	/^fmt_register(int code, T convert)$/;"	f
fmt_sfmt	fmt.c	/^fmt_sfmt(char *buf, $/;"	f
fmt_string	fmt.c	/^fmt_string(const char *fmt, ...)$/;"	f
fmt_vfmt	fmt.c	/^fmt_vfmt(int (*put)(int c, void *cl),$/;"	f
fmt_vsfmt	fmt.c	/^fmt_vsfmt(char *buf,$/;"	f
fmt_vstring	fmt.c	/^fmt_vstring(const char *fmt, va_list ap)$/;"	f
fp	arena.c	/^    void (*fp)(void);$/;"	m	union:align	file:
fp	memchk.c	/^    void (*fp)(void);$/;"	m	union:align	file:
free	memchk.c	/^    struct descriptor *free;$/;"	m	struct:descriptor	typeref:struct:descriptor::descriptor	file:
freechunks	arena.c	/^static T freechunks;$/;"	v	file:
freelist	memchk.c	/^static struct descriptor freelist = {.free = &freelist};$/;"	v	typeref:struct:descriptor	file:
from	digraph.c	/^    int         from;$/;"	m	struct:adj	file:
func	memchk.c	/^    const char *func;$/;"	m	struct:descriptor	file:
get_except_signal	except.c	/^get_except_signal()$/;"	f
hash	memchk.c	41;"	d	file:
hash	set.c	/^    unsigned long (*hash) (const void *x);$/;"	m	struct:T	file:
hash	table.c	/^    unsigned long (*hash)(const void *key);$/;"	m	struct:T	file:
head	ring.c	/^    }*head;$/;"	m	struct:T	typeref:struct:T::node	file:
head	seq.c	/^    ssize_t head;$/;"	m	struct:T	file:
head	stack.c	/^    } *head;$/;"	m	struct:T	typeref:struct:T::element	file:
header	arena.c	/^union header{$/;"	u	file:
htab	memchk.c	/^} *htab[HTAB_LEN];$/;"	v	typeref:struct:descriptor	file:
i	arena.c	/^    int i;$/;"	m	union:align	file:
i	memchk.c	/^    int i;$/;"	m	union:align	file:
idx	str.c	22;"	d	file:
idx	text.c	10;"	d	file:
iminpq_change_key	indexminpq.c	/^iminpq_change_key$/;"	f
iminpq_clean	indexminpq.c	/^iminpq_clean$/;"	f
iminpq_contains	indexminpq.c	/^iminpq_contains    $/;"	f
iminpq_count	indexminpq.c	/^iminpq_count$/;"	f
iminpq_decrease_key	indexminpq.c	/^iminpq_decrease_key$/;"	f
iminpq_delete	indexminpq.c	/^iminpq_delete$/;"	f
iminpq_delete_min	indexminpq.c	/^iminpq_delete_min$/;"	f
iminpq_free	indexminpq.c	/^iminpq_free$/;"	f
iminpq_increase_key	indexminpq.c	/^iminpq_increase_key$/;"	f
iminpq_insert	indexminpq.c	/^iminpq_insert$/;"	f
iminpq_is_empty	indexminpq.c	/^iminpq_is_empty     $/;"	f
iminpq_key_of	indexminpq.c	/^iminpq_key_of       $/;"	f
iminpq_min_index	indexminpq.c	/^iminpq_min_index    $/;"	f
iminpq_min_key	indexminpq.c	/^iminpq_min_key      $/;"	f
iminpq_new	indexminpq.c	/^iminpq_new$/;"	f
iminpq_size	indexminpq.c	/^iminpq_size$/;"	f
insert	fmt.c	/^insert(int c, void *cl)$/;"	f	file:
isatend	text.c	18;"	d	file:
key	bst.c	/^    void *key;$/;"	m	struct:T	file:
key	table.c	/^        const void *key;$/;"	m	struct:T::binding	file:
keys	indexminpq.c	/^    double  *keys;$/;"	m	struct:T	file:
l	arena.c	/^    long l;$/;"	m	union:align	file:
l	memchk.c	/^    long l;$/;"	m	union:align	file:
lastget_node	ring.c	/^    struct node *lastget_node;$/;"	m	struct:T	typeref:struct:T::node	file:
lastget_pos	ring.c	/^    ssize_t     lastget_pos;$/;"	m	struct:T	file:
ld	arena.c	/^    long double ld;$/;"	m	union:align	file:
ld	memchk.c	/^    long double ld;$/;"	m	union:align	file:
left	bst.c	/^    T left,right, parent;$/;"	m	struct:T	file:
len	atom.c	/^    int len;$/;"	m	struct:atom	file:
length	bit.c	/^    ssize_t length;$/;"	m	struct:T	file:
length	ring.c	/^    ssize_t     length;$/;"	m	struct:T	file:
length	seq.c	/^    ssize_t length;$/;"	m	struct:T	file:
length	set.c	/^    int length;$/;"	m	struct:T	file:
length	table.c	/^    int length;$/;"	m	struct:T	file:
limit	arena.c	/^    char *limit;$/;"	m	struct:T	file:
limit	text.c	/^	char *limit;$/;"	m	struct:chunk	file:
line	memchk.c	/^    int line;$/;"	m	struct:descriptor	file:
link	atom.c	/^    struct atom *link;$/;"	m	struct:atom	typeref:struct:atom::atom	file:
link	digraph.c	/^    struct adj  *link;$/;"	m	struct:adj	typeref:struct:adj::adj	file:
link	memchk.c	/^    struct descriptor *link;$/;"	m	struct:descriptor	typeref:struct:descriptor::descriptor	file:
link	set.c	/^        struct member *link;$/;"	m	struct:T::member	typeref:struct:T::member::member	file:
link	stack.c	/^        struct element *link;$/;"	m	struct:T::element	typeref:struct:T::element::element	file:
link	table.c	/^        struct binding *link;$/;"	m	struct:T::binding	typeref:struct:T::binding::binding	file:
link	text.c	/^	struct chunk *link;$/;"	m	struct:chunk	typeref:struct:chunk::chunk	file:
list_append	list.c	/^list_append(T list, T tail)$/;"	f
list_copy	list.c	/^list_copy(T list)$/;"	f
list_free	list.c	/^list_free(T *list)$/;"	f
list_length	list.c	/^list_length(T list)$/;"	f
list_list	list.c	/^list_list(void *x, ...)$/;"	f
list_map	list.c	/^list_map(T list, $/;"	f
list_pop	list.c	/^list_pop(T list, void **x)$/;"	f
list_push	list.c	/^list_push(T list, void *x)$/;"	f
list_reverse	list.c	/^list_reverse(T list)$/;"	f
list_to_array	list.c	/^list_to_array(T list, void *end)$/;"	f
llink	ring.c	/^        struct node *llink, *rlink;$/;"	m	struct:T::node	typeref:struct:T::node::node	file:
lp	arena.c	/^    long *lp;$/;"	m	union:align	file:
lp	memchk.c	/^    long *lp;$/;"	m	union:align	file:
lsbmask	bit.c	/^static unsigned char lsbmask[] = {$/;"	v	file:
mem_alloc	mem.c	/^mem_alloc(ssize_t len, $/;"	f
mem_alloc	memchk.c	/^mem_alloc(ssize_t len, $/;"	f
mem_calloc	mem.c	/^mem_calloc(ssize_t count,$/;"	f
mem_calloc	memchk.c	/^mem_calloc(ssize_t count,$/;"	f
mem_free	mem.c	/^mem_free(void *ptr,$/;"	f
mem_free	memchk.c	/^mem_free(void *ptr,$/;"	f
mem_leak	memchk.c	/^mem_leak(void (*apply)(const void *ptr,$/;"	f
mem_resize	mem.c	/^mem_resize(ssize_t len,$/;"	f
mem_resize	memchk.c	/^mem_resize(ssize_t len,$/;"	f
member	set.c	/^        const void *member;$/;"	m	struct:T::member	file:
member	set.c	/^    struct member{$/;"	s	struct:T	file:
msbmask	bit.c	/^static unsigned char msbmask[] = {$/;"	v	file:
nbytes	bit.c	13;"	d	file:
nfree	arena.c	/^static int nfree;$/;"	v	file:
node	ring.c	/^    struct node{$/;"	s	struct:T	file:
node_seq	digraph.c	/^    seq_t   node_seq;$/;"	m	struct:digraph_path_t	file:
nwords	bit.c	11;"	d	file:
outc	fmt.c	/^static int  outc(int c, void *cl)$/;"	f	file:
p	arena.c	/^    void *p;$/;"	m	union:align	file:
p	memchk.c	/^    void *p;$/;"	m	union:align	file:
pad	fmt.c	23;"	d	file:
pad	fmt_assist.c	54;"	d	file:
parent	bst.c	/^    T left,right, parent;$/;"	m	struct:T	file:
pq	indexminpq.c	/^    int     *pq;$/;"	m	struct:T	file:
prev	arena.c	/^    T prev;$/;"	m	struct:T	file:
ptr	memchk.c	/^    const void *ptr;$/;"	m	struct:descriptor	file:
qp	indexminpq.c	/^    int     *qp;$/;"	m	struct:T	file:
right	bst.c	/^    T left,right, parent;$/;"	m	struct:T	file:
ring	sparsearray.c	/^    ring_t ring;$/;"	m	struct:T	file:
ring_add	ring.c	/^ring_add(T ring, ssize_t position, void *x)$/;"	f
ring_add_high	ring.c	/^ring_add_high(T ring, void *x)$/;"	f
ring_add_low	ring.c	/^ring_add_low(T ring, void *x)$/;"	f
ring_free	ring.c	/^ring_free(T *ring)$/;"	f
ring_get	ring.c	/^ring_get(T ring, ssize_t position)$/;"	f
ring_length	ring.c	/^ring_length(T ring)$/;"	f
ring_new	ring.c	/^ring_new(void)$/;"	f
ring_put	ring.c	/^ring_put(T ring, ssize_t position, void *x)$/;"	f
ring_remove	ring.c	/^ring_remove(T ring, ssize_t position)$/;"	f
ring_remove_high	ring.c	/^ring_remove_high(T ring)$/;"	f
ring_remove_low	ring.c	/^ring_remove_low(T ring)$/;"	f
ring_ring	ring.c	/^ring_ring(void *x, ...)$/;"	f
ring_rotate	ring.c	/^ring_rotate(T ring, ssize_t n)$/;"	f
rlink	ring.c	/^        struct node *llink, *rlink;$/;"	m	struct:T::node	typeref:struct:T::node::	file:
scatter	atom.c	/^static unsigned long scatter[] = {$/;"	v	file:
seq_add_high	seq.c	/^seq_add_high(T seq, void *x)$/;"	f
seq_add_low	seq.c	/^seq_add_low(T seq, void *x)$/;"	f
seq_free	seq.c	/^seq_free(T *seq)$/;"	f
seq_get	seq.c	/^seq_get(T seq, ssize_t position)$/;"	f
seq_length	seq.c	/^seq_length(T seq)$/;"	f
seq_new	seq.c	/^seq_new(ssize_t hint)$/;"	f
seq_put	seq.c	/^seq_put(T seq, ssize_t position, void *x)$/;"	f
seq_remove_high	seq.c	/^seq_remove_high(T seq)$/;"	f
seq_remove_low	seq.c	/^seq_remove_low(T seq)$/;"	f
seq_seq	seq.c	/^seq_seq(void *x, ...)$/;"	f
set_diff	set.c	/^set_diff(T s, T t)$/;"	f
set_free	set.c	/^set_free(T *set)$/;"	f
set_inter	set.c	/^set_inter(T s, T t)$/;"	f
set_length	set.c	/^set_length(T set)$/;"	f
set_map	set.c	/^set_map(T set,$/;"	f
set_member	set.c	/^set_member(T set, const void *member)$/;"	f
set_minus	set.c	/^set_minus(T s, T t)$/;"	f
set_new	set.c	/^set_new(int hint,$/;"	f
set_put	set.c	/^set_put(T set, const void *member)$/;"	f
set_remove	set.c	/^set_remove(T set, const void *member)$/;"	f
set_signal_except	except.c	/^set_signal_except(int sig)$/;"	f
set_to_array	set.c	/^set_to_array(T set, void *end)$/;"	f
set_union	set.c	/^set_union(T s, T t)$/;"	f
setop	bit.c	15;"	d	file:
size	digraph.c	/^    int size;$/;"	m	struct:digraph_sr_t	file:
size	fmt.c	/^    ssize_t size;$/;"	m	struct:buf	file:
size	indexminpq.c	/^    int     size;$/;"	m	struct:T	file:
size	memchk.c	/^    ssize_t size;$/;"	m	struct:descriptor	file:
size	set.c	/^    int size;$/;"	m	struct:T	file:
size	table.c	/^    int size;$/;"	m	struct:T	file:
sparsearray_free	sparsearray.c	/^sparsearray_free(T *sarray)$/;"	f
sparsearray_get	sparsearray.c	/^sparsearray_get(T sarray, ssize_t key)$/;"	f
sparsearray_get_at	sparsearray.c	/^sparsearray_get_at(T sarray, ssize_t index)$/;"	f
sparsearray_index_of_key	sparsearray.c	/^sparsearray_index_of_key(T sarray, ssize_t key)$/;"	f
sparsearray_key_at	sparsearray.c	/^sparsearray_key_at(T sarray, ssize_t index)$/;"	f
sparsearray_length	sparsearray.c	/^sparsearray_length(T sarray)$/;"	f
sparsearray_new	sparsearray.c	/^sparsearray_new(ssize_t hint)$/;"	f
sparsearray_put	sparsearray.c	/^sparsearray_put(T sarray, ssize_t key, void *value)$/;"	f
sparsearray_put_at	sparsearray.c	/^sparsearray_put_at(T sarray, ssize_t index, void *value)$/;"	f
sparsearray_remove	sparsearray.c	/^sparsearray_remove(T sarray, ssize_t key)$/;"	f
sparsearray_remove_at	sparsearray.c	/^sparsearray_remove_at(T sarray, ssize_t index)$/;"	f
stack_empty	stack.c	/^stack_empty(T stk)$/;"	f
stack_free	stack.c	/^stack_free(T *stk)$/;"	f
stack_length	stack.c	/^stack_length(T stk)$/;"	f
stack_new	stack.c	/^stack_new(void)$/;"	f
stack_peek	stack.c	/^stack_peek(T stk)$/;"	f
stack_pop	stack.c	/^stack_pop(T stk)$/;"	f
stack_push	stack.c	/^stack_push(T stk, void *x)$/;"	f
start	digraph.c	/^    int     start;$/;"	m	struct:digraph_path_t	file:
start	digraph.c	/^    int start;$/;"	m	struct:digraph_sr_t	file:
str	atom.c	/^    char str[];$/;"	m	struct:atom	file:
str_any	str.c	/^str_any$/;"	f
str_cat	str.c	/^char *str_cat(const char *s1, ssize_t i1, ssize_t j1,$/;"	f
str_cat_v	str.c	/^char *str_cat_v(const char *s,...){$/;"	f
str_chr	str.c	/^str_chr$/;"	f
str_cmp	str.c	/^str_cmp$/;"	f
str_dup	str.c	/^char *str_dup(const char *s, ssize_t i, ssize_t j, ssize_t n){$/;"	f
str_find	str.c	/^str_find$/;"	f
str_len	str.c	/^str_len$/;"	f
str_many	str.c	/^str_many$/;"	f
str_map	str.c	/^char *str_map(const char *s, ssize_t i, ssize_t j,$/;"	f
str_match	str.c	/^str_match$/;"	f
str_pos	str.c	/^str_pos$/;"	f
str_rchr	str.c	/^str_rchr$/;"	f
str_reverse	str.c	/^char *str_reverse(const char *s, ssize_t i, ssize_t j){$/;"	f
str_rfind	str.c	/^str_rfind$/;"	f
str_rmany	str.c	/^str_rmany$/;"	f
str_rmatch	str.c	/^str_rmatch$/;"	f
str_rupto	str.c	/^str_rupto$/;"	f
str_sub	str.c	/^char *str_sub (const char *s, ssize_t i, ssize_t j){$/;"	f
str_upto	str.c	/^str_upto$/;"	f
table	sparsearray.c	/^    table_t table;$/;"	m	struct:T	file:
table_free	table.c	/^table_free(T *table)$/;"	f
table_get	table.c	/^table_get(T table, const void *key)$/;"	f
table_length	table.c	/^table_length(T table)$/;"	f
table_map	table.c	/^table_map(T table,$/;"	f
table_new	table.c	/^table_new(int hint,$/;"	f
table_put	table.c	/^table_put(T table, const void *key, void *value)$/;"	f
table_remove	table.c	/^table_remove(T table, const void *key)$/;"	f
table_to_array	table.c	/^table_to_array(T table, void *end)$/;"	f
text_any	text.c	/^text_any$/;"	f
text_ascii	text.c	/^const T text_ascii  = {127, _cset};$/;"	v
text_box	text.c	/^text_box$/;"	f
text_cat	text.c	/^text_cat$/;"	f
text_chr	text.c	/^text_chr$/;"	f
text_cmp	text.c	/^text_cmp$/;"	f
text_cset	text.c	/^const T text_cset   = {256, _cset};$/;"	v
text_digits	text.c	/^const T text_digits = {10,  _cset + '0'};$/;"	v
text_dup	text.c	/^text_dup$/;"	f
text_find	text.c	/^text_find$/;"	f
text_get	text.c	/^text_get$/;"	f
text_lcase	text.c	/^const T text_lcase  = {26,  _cset + 'a'};$/;"	v
text_many	text.c	/^text_many$/;"	f
text_map	text.c	/^text_map$/;"	f
text_match	text.c	/^text_match$/;"	f
text_null	text.c	/^const T text_null   = {0,   _cset};$/;"	v
text_pos	text.c	/^text_pos(T text, ssize_t i)$/;"	f
text_put	text.c	/^text_put$/;"	f
text_rchr	text.c	/^text_rchr$/;"	f
text_restore	text.c	/^text_restore(text_save_t *save)$/;"	f
text_reverse	text.c	/^text_reverse$/;"	f
text_rfind	text.c	/^text_rfind$/;"	f
text_rmany	text.c	/^text_rmany$/;"	f
text_rmatch	text.c	/^text_rmatch$/;"	f
text_rupto	text.c	/^text_rupto$/;"	f
text_save	text.c	/^text_save()$/;"	f
text_save_t	text.c	/^struct text_save_t {$/;"	s	file:
text_sub	text.c	/^text_sub$/;"	f
text_ucase	text.c	/^const T text_ucase  = {26,  _cset + 'A'};$/;"	v
text_upto	text.c	/^text_upto$/;"	f
timestamp	set.c	/^    unsigned long timestamp;$/;"	m	struct:T	file:
timestamp	table.c	/^    unsigned long timestamp;$/;"	m	struct:T	file:
to	digraph.c	/^    int         to;$/;"	m	struct:adj	file:
value	ring.c	/^        void *value;$/;"	m	struct:T::node	file:
value	table.c	/^        void *value;$/;"	m	struct:T::binding	file:
weight	digraph.c	/^    double      weight;$/;"	m	struct:adj	file:
words	bit.c	/^    unsigned long *words;$/;"	m	struct:T	file:
x	stack.c	/^        void *x;$/;"	m	struct:T::element	file:
