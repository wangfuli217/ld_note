.\" This manpage has been automatically generated by docbook2man-spec
.\" from a DocBook document.  docbook2man-spec can be found at:
.\" <http://shell.ipoline.com/~elmert/hacks/docbook2X/> 
.\" Please send any bug reports, improvements, comments, patches, 
.\" etc. to Steve Cheng <steve@ggi-project.org>.
.TH "FMT" "3" "20 March 2002" "" ""
.SH NAME
fmt_print, fmt_eprint, fmt_fprint, fmt_sfmt, fmt_vsfmt, fmt_string, fmt_vstring, fmt_start, fmt_starts, fmt_build, fmt_finalize, fmt_register \- Replacement for *printf with extension semantics.
.SH SYNOPSIS
\fB#include <format/fmt.h>
.sp
void
fmt_print
(const char * \fIformat\fB,
\&...);
.sp
void
fmt_eprint
(const char * \fIformat\fB,
\&...);
.sp
void
fmt_fprint
(FILE * \fIfp\fB,
const char * \fIformat\fB,
\&...);
.sp
int
fmt_sfmt
(char * \fIbuf\fB,
int \fIsize\fB,
const char * \fIformat\fB,
\&...);
.sp
int
fmt_vsfmt
(char * \fIbuf\fB,
int \fIsize\fB,
const char * \fIformat\fB,
va_list \fIap\fB);
.sp
char *
fmt_string
( const char * \fIformat\fB,
\&...);
.sp
char *
fmt_vstring
( const char * \fIformat\fB,
va_list \fIap\fB);
.sp
stringvec_t *
fmt_start
(size_t \fIlen\fB);
.sp
stringvec_t *
fmt_starts
(stringvec_t * \fIvec\fB,
size_t \fIlen\fB);
.sp
void
fmt_build
(stringvec_t \fIvec\fB,
int \fIlen\fB,
char * \fIfmt\fB,
\&... );
.sp
char *
fmt_finalize
(stringvec_t \fIvec\fB,
size_t * \fIlen\fB);
.sp
fmt_handler_info_t
fmt_register
(int \fIcode\fB,
fmt_t \fIcvt\fB);
\fR.SH "DESCRIPTION"
.PP
The fmt library provides an extensible replacement to *printf(). Fmt
is portable (it will behave the same way on every platform it is compiled
on) and provides extensions such as quadword formatting (%Lx). Most
importantly, fmt allows callbacks to be registered for format specifiers,
for instance mapping IP address formatting to %i. For the most part,
the fmt interface is so similar to that of *printf that fmt can be
swapped in with a series of #defines.
.SS "PRINTF EQUIVALENCES"
.TP 0.2i
\(bu
\fBfmt_print\fR is \fBprintf\fR
.TP 0.2i
\(bu
\fBfmt_eprint\fR is \fBfprintf(stderr, ...)\fR
.TP 0.2i
\(bu
\fBfmt_fprint\fR is \fBfprintf\fR
.TP 0.2i
\(bu
\fBfmt_sfmt\fR is \fBsnprintf\fR
.TP 0.2i
\(bu
\fBfmt_vsfmt\fR is \fBvsnprintf\fR
.TP 0.2i
\(bu
\fBfmt_string\fR is \fBasprintf\fR
.TP 0.2i
\(bu
\fBfmt_vstring\fR is \fBvasprintf\fR
.SS "INCREMENTAL STRING CONSTRUCTION"
.PP
A string can be built up from multiple calls to snprintf by 
observing the return values of the snprintf calls, and keeping
an incrementing pointer into a buffer. This has two obvious 
problems: first, it is tedious to write and maintain this code,
and second, the string must be marshalled into a fixed size
buffer.
.PP
The \fBfmt_build\fR function allows strings to 
be built incrementally without regard for bookkeeping details. 
\fBfmt_build\fR maintains a dynamic array (with
vector-like resizing) behind the scenes; repeated calls to 
\fBfmt_build\fR add more text to the end of this
array. 
.PP
\fBfmt_build\fR operates on \fBstringvec_t\fR
objects. These are opaque types; obtain them from \fBfmt_start\fR
(to allocate one from malloc) or \fBfmt_starts\fR (to allocate
one on the stack). When the string is completely built, a call to
\fBfmt_finalize\fR returns the string. Both the
string, and the \fBstringvec_t\fR (if it was
obtained from \fBfmt_start\fR) must be free()'d.
.SS "ADDING FORMAT EXTENSIONS"
.PP
New extensions are mapped to format codes by calling \fBfmt_register\fR. fmt_register takes a callback as its
second argument; this callback takes a \fBfmt_code_info_t\fR
as its only argument. This structure is defined as:
.sp
.nf
       typedef struct {
	int                 code;
	void               *cl;
	va_list            *app;
	putfunc_t           put;
	void               *put_cl;
	int                 width;
	int                 prec;
	const char         *arg;
	size_t              arg_len;
	struct cvt_array_t *cvt;
	unsigned char       flags[256];
       };
} fmt_code_info_t;
.sp
.fi
.PP
The most important of these arguments is "app", which provides
a varargs pointer to the data passed in as the argument to this
function. Fmt callbacks use the \fBfmt_puts\fR
to output strings. For instance, a callback that prints resolved
IP addresses on encountering a %D:
.sp
.nf

void
fmt_domainname(fmt_code_info_t *cvt) {
	char buf[500];
        char *str = va_arg(*cvt->app, char *);   // Retrieve argument
        struct hostent *hp = gethostbyname(str);
        if(hp) {
               fmt_sfmt(buf, sizeof buf, "%i", hp->h_addr);
        } else 
               fmt_sfmt(buf, sizeof buf, "unresolved IP");
      
	fmt_puts(buf, strlen(buf), cvt);
}

fmt_register('D', fmt_domainname);
.sp
.fi
.SH "SEE ALSO"
.PP
printf(3)
.SH "AUTHOR"
.PP
Original code: David Hanson <drh@microsoft.com>
.PP
Interface and Extensions: Thomas H. Ptacek <tqbf@arbor.net>
