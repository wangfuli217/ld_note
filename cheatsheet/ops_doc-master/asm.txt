吴wu		汇编和C的关系
求伯君		一个人使写了10万行汇编指令开发WPS软件

AT&T汇编	bell实验室开发的汇编语言,主要用在linux环境
ARM汇编		ARM板子上用
MS汇编		微软的汇编语言,基本不用

汇编语言执行速度快,相对其他语言来说程序体积最小,但是可读性差不好理解,而且完全没有可移植(跨平台portable)性,由于以上原因汇编语言不是开发的主力工具.

反汇编工具 objdump -dS t			man objdump
-d
-S
readelf								见20120814session16.txt,第257行
gcc -Wall -S t.c -o t.s				生成的汇编文件没有地址信息,所以基本不用此命令

gcc -Wall t.c -o t -g
objdump -dS t > t.ass				这两条命令可以得到有C语言对应的汇编文件

----------------------------------------------------------------------------------------
#include <stdio.h>
int sum_arr(int a[], int n)
{
        int i, sum;
        for(i = 0, sum = 0; i < n; i++)
                sum = sum + a[i];
        return sum;
}
int main()
{
        int a[] = {1,2,3,4,5}, c = 0;
        c = sum_arr(a, 5);
        return 0;
}
yk@ubuntu:~/test$ gcc -Wall t.c -o t -g
yk@ubuntu:~/test$ objdump -dS t > t.txt
yk@ubuntu:~/test$ vi t.txt 
?????????????????????????????????需要修改???????????????????????????????????????????????
080483b4 <add>:
#include <stdio.h>
int add(int x, int y)
{
 80483b4:	55                   	push   %ebp
#push把数据压到栈帧的指令,esp向下移动4字节,空出来的4字节保存ebp的地址
 80483b5:	89 e5                	mov    %esp,%ebp
#mov赋值指令,把%esp的值赋给%ebp,%ebp的值改变
	return x + y;
 80483b7:	8b 45 0c             	mov    0xc(%ebp),%eax
#寄存器%ebp向上偏移0xc个字节的内存空间的值赋值给%eax
 80483ba:	8b 55 08             	mov    0x8(%ebp),%edx
#寄存器%ebp向上偏移0x8个字节的内存空间的值赋值给%eax
 80483bd:	8d 04 02             	lea    (%edx,%eax,1),%eax
#lea寻址指令,(%edx,%eax,1)表示%edx + %eax * 1的地址赋值给%eax
}
 80483c0:	5d                   	pop    %ebp
#pop把数据从栈帧中取出的指令,先取值,然后esp向上移动4字节
 80483c1:	c3                   	ret    
#ret函数返回,取得返回地址,返回

080483c2 <main>:
int main()
{	
#16进制表示的指令地址	指令对应的二进制机器码	汇编指令
 80483c2:	55                   	push   %ebp
#push把数据压到栈帧的指令,esp向下移动4字节,空出来的4字节保存ebp(此时ebp存的是启动历程的栈基地址)
 80483c3:	89 e5                	mov    %esp,%ebp
#mov赋值指令,把%esp的值赋给%ebp,%ebp的值改变
 80483c5:	83 ec 18             	sub    $0x18,%esp
#sub减法指令,此句表示%esp的地址向下偏移$0x18个字节,也就是给main函数分配24个(4*6,每行4个字节一共6行)字节的存储空间
	int a = 100, b = 200, c;
 80483c8:	c7 45 fc 64 00 00 00 	movl   $0x64,-0x4(%ebp)
#movl赋值指令,把$0x64赋值给寄存器%ebp向下偏移0x4个字节的内存空间
 80483cf:	c7 45 f8 c8 00 00 00 	movl   $0xc8,-0x8(%ebp)
#movl赋值指令,把$0xc8赋值给寄存器%ebp向下偏移0x8个字节的内存空间
	c = add(a, b);
 80483d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
#寄存器%esp向下偏移0x8个字节的内存空间的值赋值给%eax
 80483d9:	89 44 24 04          	mov    %eax,0x4(%esp)
#寄存器%eax的值赋值给寄存器%esp向上偏移0x4个字节的内存空间
 80483dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
#寄存器%esp向下偏移0x4个字节的内存空间的值赋值给%eax
 80483e0:	89 04 24             	mov    %eax,(%esp)
#寄存器%eax的值赋值给寄存器%esp向上偏移0x0个字节的内存空间
 80483e3:	e8 cc ff ff ff       	call   80483b4 <add>
#call函数调用指令,调用内存中入口地址为80483b4的函数
 80483e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
#寄存器%eax的值赋值给寄存器%ebp向下偏移0xc个字节的内存空间
	return 0;
 80483eb:	b8 00 00 00 00       	mov    $0x0,%eax
#mov赋值指令,把$0x0赋值给寄存器%eax
}
 80483f0:	c9                   	leave  
#leave指令,相当于mov %ebp, %esp和pop %ebp两条指令的作用
 80483f1:	c3                   	ret   
#ret函数返回,取得返回地址,返回
 80483f2:	90                   	nop
#nop,空指令

??????????????????????????????????????????????????????????????????????????????????????
汇编指令	作用
push	%ebp	把数据压到栈帧的指令,esp向下移动4字节,空出来的4字节保存ebp
pop	%ebp	把数据从栈帧中取出的指令,先取值,然后esp向上移动4字节

call		函数调用指令,格式:call 函数入口地址.call指令先将esp向下移动4字节用于保存返回地址			(call下一条指令的地址),再执行跳转.
		call和jmp的区别:call调用完成后,会跳转回原程序继续执行.
ret		函数返回指令,先取得返回地址(call下一条指令的地址),然后esp向上移动4字节,然后跳转到
		返回地址(call下一条指令的地址),继续执行代码.

leave		相当于mov %ebp, %esp和pop %ebp两条指令的作用
nop		空指令

mov		赋值指令,把第一个操作数的常量赋值给第二个操作数,如:
lea		寻址指令,把第一个操作数的地址赋值给第二个操作数,如:(%edx,%eax,1),%eax

shl		左移位指令,每左移一位相当于作乘法2
shr		右移位指令,每右移一位相当于作除于2
and		位与操作,两个操作数做位与运算,目的是把数据长短对齐,如下面一行.
and	$0xfffffff0, %esp

add		加法指令,两个操作数相加
sub		减法指令,后减前
inc		自加指令
dec		自减指令

jmp		单向无条件跳转,跳转到指定地址
cmpl		两个操作数相减,后减前.两数相等结果为0,eflags的ZF位置1.
je		常和cmpl指令配合使用,根据前一条指令得出的eflags的ZF位的值来判断是否做跳转,eflags			的ZF位为1发生跳转,为0不跳转继续执行下一条指令.
jle		和cmpl指令配合,如果不大于则跳转(l代表low,jle和jge对应).
jge		和cmpl指令配合,如果不小于则跳转

mov的3个后缀
movl	表示数据对象是4字节
movw	表示数据对象是2字节
movb	表示数据对象是1字节
movsbl	字节转换命令,s表示转换,b表示1字节,l表示4字节


汇编指令后一般跟1-3个操作数
以$符号开头的是立即数(常量),如$0x80.汇编中立即数就是常量,常量就是立即数
以%符号开头是的寄存器,如%eax,寄存器直接被CPU使用
%esp和(%esp)的区别,不加括号表示寄存器,加()括号表示取寄存器指向的地址

-----------------------栈帧的调用过程-----------------------------------------------
括号前是正号为上移,是负号为下移.上移或下移,都是指向内存块的下角.
-0xc(%ebp),0x4(%esp),表示的是同一块内存区域

			|-----------|			高地址
			|    ebp    |
	 ebp---→|-----------|←---esp+16
			|    	    |			每行代表4个字节
   ebp-4---→|-----------|←---esp+12
			|           |
   ebp-8---→|-----------|←---esp+8
			|***********|
  ebp-12---→|-----------|←---esp+4
			|	        |
  ebp-16---→|-----------|←---esp		低地址
				
				上图为main函数的栈帧图
----------------------------------------------------------------------------------------

寄存器价格非常昂贵,i386有8个,arm有16个
i386的8个寄存器简介
通用寄存器	eax	ebx	ecx	edx,可以随意使用	P186有些情况也不能随意使用
下标寄存器	edi(d表示目的,i表示index下标)	esi(s表示源)
栈帧寄存器	ebp(基址,p表示指针)	esp(栈顶)

特殊寄存器
eip		程序计数器
eflags		保存计算过程中产生的标志位

标志位包括进位标志 CF,溢出标志 OF,零标志 ZF,负数标志 SF

寄存器在CPU中,被CPU直接调用,CPU从内存中调用马上要使用的数据存储在寄存器中.
磁盘,内存,寄存器的关系就像仓库,厨房,案板的关系一样,菜就代表数据

CPU调用内存数据分为2个步骤
1.寻址		走地址总线
2.数据传送	走数据总线

CPU和内存有2条物理线路连接
地址总线	平常说的32或64位机,指的是地址总线长度,指针的宽度由地址总线宽度决定
数据总线

毫秒	10的-3次方
微秒	10的-6次方
纳秒	10的-9次方	
寄存器的访问速度是纳秒级别的
内存的访问速度是100纳秒级别的
磁盘的访问速度是毫秒级别的
网络的访问速度是分钟级别的

汇编预言中2中传参方式
1.通过寄存器传参,是内核函数特有的传参方式,因为内核函数有自己的栈帧
2.通过栈帧来传参,是用户编写的函数和标准库函数的传参方式.

#			汇编语言的单行注释

----------------------------------------------------------------------------------------
i386是Intel规定的一套CPU体系结构,x86是一系列芯片的总称.
i386体系结构规定了,汇编指令集和寻址方式.
AMD和Intel公司生产的CPU使用的都是i386体系结构.
CISC(complex instruction set computer)复杂指令集计算机

i386体系结构的芯片有
4004			芯片名
8008			芯片名
8086			芯片名		1978年推出的8086是16位处理器
三年后8086芯片被IBM选用于个人计算机的平台.
80188			芯片名
80286			芯片名
80386			芯片名		直到1985年的80386芯片才是32位处理器
80486			芯片名
在美国,由于数字不能作为注册商标,因此Intel及其竞争者在新一代处理器使用可注册的名称,如Pentium.
奔腾(586)		芯片名
奔腾2代(686)	芯片名
奔腾3代(686)	芯片名
奔腾4代			芯片名
赛扬			芯片名
酷睿			芯片名

i386 i486 i586 i686
i686是i386体系结构的一个子集,支持的cpu从Pentium 2 (686)开始,之前的芯片不支持.


Intel规定的一套体系结构,在国外的名字是
IA-32		对应i386体系结构
IA-64
IA-pro		工作站上用


RISC(Reduced Instruction-Set Computer)精简指令集计算机
ARM（Advanced RISC Machines）是微处理器行业的一家知名企业(英国)，设计了大量高性能、廉价、耗能低的RISC处理器.
ARM是ARM公司规定的一套CPU体系结构,是一系列芯片的总称.
CPU体系结构规定了,汇编指令集(32位/16位)和寻址方式.

ARM6		ARM CPU体系结构的具体版本
ARM7		ARM CPU体系结构的具体版本,ARM7之前的基本没人用
ARM8		ARM CPU体系结构的具体版本
ARM9		ARM CPU体系结构的具体版本
ARM10		ARM CPU体系结构的具体版本
ARM11		ARM CPU体系结构的具体版本
core-tex	ARM CPU体系结构的具体版本,最新

S3C2410		ARM9的芯片名
S3C2440		ARM9的芯片名


汇编基础					P183
----------------------------------hello.s--------------------------------------------------
#%eax holds the system call number
#%ebx holds the return status

.section .data			#.section指示器把代码划分成若干段,.data段保存程序的数据,是可读可写的,相当C程序的全局变量

.section .text			#.text段保存代码,是只读和可执行的
.globl _start			#.globl指示器声明后面的符号会被链接器用到,没有用.globl声明的符号,不会被链接器用到. _start是一个符号,代表一个地址
_start:				#链接器在链接时会查找目标文件中_start符号代表的地址,把它设置成整个程序的入口地址,每个汇编程序都要提供一个_start符号并且用.globl声明
        movl    $1, %eax	#mov的l代表long,$1表示CPU产生立即数1,%eax表示寄存器eax
        movl    $4, %ebx
        int     $0x80	#int是软中断指令,$0x80是一个参数,异常处理程序要根据参数决定如何处理

反编译得到的汇编文件和写的汇编文件 多杀有点不一样.
------------------------------------------------------------------------------------------
yk@ubuntu:~/test$ as hello.s -o hello.o			用汇编器把汇编程序翻译成机器指令
yk@ubuntu:~/test$ ld hello.o -o hello			用链接器把目标文件链接成可执行文件
yk@ubuntu:~/test$ ./hello 
yk@ubuntu:~/test$ echo $?				显示上一条命令的退出状态
4							显示结果


助记符也叫指示器,以.开头.如.section
符号在汇编程序中代表地址.如_start

C语言中的3种遍历(travel)
数组遍历
字符串遍历				最好以'\0'位结束条件
链表遍历

CPU分为用户模式和特权模式

函数的本质是一段完成某项工作的代码.
函数名的本质是函数的入口地址,也是函数第一条指令的地址.

-------------------------------------------------------------------------------------------
栈帧
栈帧是在函数调用的时候系统开辟的一块内存空间,用于存放函数的局部变量和临时值.
每个函数都会在内存中分配自己的栈帧,函数的参数也是通过栈帧来传递的.

内核函数有自己的栈帧,它是通过寄存器来和其他函数传参的.

配合38行,画栈帧使用过程图.

栈帧的要点				见20120814session16.txt,第1行

----------------------------------寻址方式-----------------------------------------------------
data_items(,%edi,4)			P188,返回值为指针,第edi个元素的地址是data_items+edi*4
movl data_items(,%edi,4), %eax		表示把地址data_items(,%edi,4)指向的内容,赋值给%eax

data_items(,%edi,4)可以解释以下问题		
1.为什么数组元素下标要从0开始
2.为什么访问每个数组元素的时间都相等