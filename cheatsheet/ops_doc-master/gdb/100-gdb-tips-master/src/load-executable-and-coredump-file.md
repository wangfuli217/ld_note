# 加载可执行程序和core dump文件 

## 例子

	#include <stdio.h>

	int main(void) {
	        int *p = NULL;
	        printf("hello world\n");
	        *p = 0;
	        return 0;
	}



## 技巧

例子程序访问了一个空指针，所以程序会crash并产生core dump文件。用gdb调试core dump文件，通常用这个命令形式：“gdb path/to/the/executable path/to/the/coredump”，然后gdb会显示程序crash的位置：

	bash-3.2# gdb -q /data/nan/a /var/core/core.a.22268.1402638140
	Reading symbols from /data/nan/a...done.
	[New LWP 1]
	[Thread debugging using libthread_db enabled]
	[New Thread 1 (LWP 1)]
	Core was generated by `./a'.
	Program terminated with signal 11, Segmentation fault.
	#0  0x0000000000400cdb in main () at a.c:6
	6               *p = 0;

有时我们想在gdb启动后，动态加载可执行程序和core dump文件，这时可以用“file”和“core”（core-file命令缩写）命令。“file”命令用来读取可执行文件的符号表信息，而“core”命令则是指定core dump文件的位置：

	bash-3.2# gdb -q
	(gdb) file /data/nan/a
	Reading symbols from /data/nan/a...done.
	(gdb) core /var/core/core.a.22268.1402638140
	[New LWP 1]
	[Thread debugging using libthread_db enabled]
	[New Thread 1 (LWP 1)]
	Core was generated by `./a'.
	Program terminated with signal 11, Segmentation fault.
	#0  0x0000000000400cdb in main () at a.c:6
	6               *p = 0;



可以看到gdb同样显示程序crash的位置。 

这两个命令可参见[gdb手册](https://sourceware.org/gdb/onlinedocs/gdb/Files.html#index-core-dump-file)

## 贡献者

nanxiao



