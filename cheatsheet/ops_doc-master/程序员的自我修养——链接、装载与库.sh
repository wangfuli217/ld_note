book(简介){
北桥——高速：CPU、内存、PCI总线
南桥——低速：硬盘、外设、ISA总线

南北桥的区别    低速、高速    
}

book(温故而知新){
2    程序运算速度并不一定与CPU数量成正比，因为程序并不能都分解成若干个完全不相干的子问题    CPU越多，程序运算速度越快吗？    不一定，因为程序并不能都分解成若干个完全不相干的子问题        
3    计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决    计算机系统软件设计的核心是什么    分层        
4    运行库使用操作系统提供的系统调用接口，往往以软件中断的方式来实现，Linux采用0x80号，Windows采用0x2E    系统调用的实现方式    软中断        
5    操作系统的主要功能，一个是提供抽象的接口，一个是管理硬件资源    操作系统的主要功能    提供抽象的接口、管理硬件资源        
6    多道程序设计（监控）——分时系统（协作）——多任务(进程)——抢占式    操作系统的发展    多道程序设计——分时系统——多任务——抢占式        
7    物理内存的问题：
    1、地址空间不隔离——一个任务的失败会影响其它任务
    2、内存使用率低——运行新程序时内存不够，需要保存旧程序的运行环境到磁盘，载入新程序。大量数据IO造成效率低下。
    3、程序运行地址不确定——每次运行都要重新分配地址
8    隔离——普通程序需要独立的地址空间，自己的CPU（时间）    什么是隔离    普通程序需要独立的地址空间，自己的CPU（时间）        
9    分段——不同的程序映射到独立的地址空间，没有重叠不需要重定位    什么是分段    不同的程序映射到独立的地址空间，没有重叠不需要重定位        
10    分段的问题：内存映射程序为单位，大量的磁盘访问，做法粗糙、粒度大    分段的问题    内存映射程序为单位，大量的磁盘访问，做法粗糙、粒度大        
11    程序的局部性原理：正在运行的程序，某个时间段内只是频繁的用到了一小部分数据    什么是程序的局部性原理    正在运行的程序，某个时间段内只是频繁的用到了一小部分数据        
12    虚拟空间的有些页被映射到同一个物理页，实现内存共享    共享内存的实现原理    虚拟空间的有些页被映射到同一个物理页        
13    内存页的保护：每个页设置权限属性，保护自己和进程    内存页的保护    每个页设置权限属性，保护自己和进程        
14    一个标准的线程由线程ID、当前指令指针PC、寄存器集合和堆栈组成    的组成    线程ID、当前指令指针PC、寄存器集合和堆栈        
15    线程共享：内存空间（代码段、数据段和堆）和资源（打开文件、信号）    线程共享什么    内存空间（代码段、数据段和堆）和资源（打开文件、信号）        
16    多线程的优点：有效利用等待时间    多线程的优点    有效利用等待时间        
17    线程私有：栈、寄存器    线程私有什么    栈、寄存器        
18    当线程数量小于等于处理器数量时，线程真正并发运行    为什么线程数量大于CPU数量，就不是真正的并发运行    至少有一个CPU会运行多个线程        
19    在处理器上切换不同线程的行为，叫做线程调度    什么叫线程调度    在处理器上切换不同线程的行为        
20    线程的运行状态    
        线程时间片用尽——就绪态
        等待的事情发生——就绪态
        开始等待某事件——等待态        
21    IO密集型与CPU密集型    
        频繁等待的线程——IO密集型
        很少等待的线程——CPU密集型
22    IO密集型总是比CPU密集型线程更容易得到优先级提升    哪种更容易得到优先级提升    IO密集型        
23    线程饿死：低优先级线程始终无法执行    什么是线程饿死    低优先级线程始终无法执行        
24    调度系统会逐步提升等待过程时间得不到运行的线程的优先级，一个线程只要等待了足够长的时间，优先级就一定能提高到足够让它运行的程度    怎么防止线程饿死    调度系统逐步提升等待过程时间得不到运行的线程的优先级，线程只要等待了足够长的时间，优先级就一定能提高到足够让它运行的程度        
25    线程优先级改变的三种方式：
        用户指定
        根据等待的频繁程度改变
        长时间得不到运行而被提升        
26    线程用尽时间片被强制剥夺而进入就绪态的过程，叫做抢占    什么叫抢占    线程用尽时间片被强制剥夺而进入就绪态的过程        
27    不可抢占的系统，线程调度时机确定    不可抢占的系统，线程调度特点    线程调度时机确定        
28    fork：复制当前进程，不复制原任务内存空间，和新任务共享写时复制    fork    复制当前进程，不复制原任务内存空间，和新任务共享写时复制        
29    写时复制：两个任务可以同时自由读取内存，当然任意一个任务试图对内存进行修改时，会复制一份内存给修改方单独使用，以免影响到其它的任务使用    什么是写时复制    两个任务可以同时自由读取内存，当然任意一个任务试图对内存进行修改时，会复制一份内存给修改方单独使用，以免影响到其它的任务使用        
30    exec：用新的可执行映像替换当前的可执行映像    exec    用新的可执行映像替换当前的可执行映像        
31    clone：从指定位置开始运行新任务，可共享当前的进程空间和资源    clone    从指定位置开始运行新任务，可共享当前的进程空间和资源        
32    单指令的操作成为原子的    什么是原子操作    单指令的操作        
33    同步：一个线程访问数据未结束时，其它线程不得对同一个数据进行访问    什么是线程同步    一个线程访问数据未结束时，其它线程不得对同一个数据进行访问        
34    二元信号量：只能被唯一一个线程独占     二元信号量    只能被唯一一个线程独占        
35    信号量：可以被任意线程获取和释放    信号量    可以被任意线程获取和释放        
36    互斥量：获取互斥量的线程负责释放锁    互斥量    获取互斥量的线程负责释放锁        
37    临界区：作用范围只限于本进程    临界区    作用范围只限于本进程        
38    读写锁：独占和共享    读写锁的两种方式    独占和共享        
39    条件变量的两种操作：等待和唤醒    条件变量的两种操作    等待和唤醒        
40    函数重入：没有执行完，又一次进入执行    什么是函数重入    没有执行完，又一次进入执行        
41    函数重入的两种情况：
    1、多个线程同时执行
    2、自身调用自身        
42    volatile关键值防止过度优化的做法：
    1、阻止编译器缓存变量到寄存器而不写回
    2、阻止编译器调整变量指令的执行顺序    
43    barrier指令会阻止CPU把指令之前的指令交换到其后面    barrier指令作用    会阻止CPU把指令之前的指令交换到其后面        
44    用户态线程不一定在内核中对应同等数量的内核线程    用户态线程在内核中对应同等数量的内核线程吗    不一定，因为程序并不能都分解成若干个完全不相干的子问题        
45    一对一模型：真正的并发，多处理器表现好    
    一对一模型的优点    真正的并发，多处理器表现好        
46    一对一模型：用户线程数量受限，上下文切换开销大    
    一对一模型的缺点    用户线程数量受限，上下文切换开销
47    多对一模型：切换快，用户线程数量不限    
    多对一模型的优点    切换快，用户线程数量不限        
48    多对一模型：一个用户线程阻塞所有的用户线程，因为内核线程会阻塞    
    多对一模型的缺点    一个用户线程阻塞所有的用户线程，因为内核线程会阻塞
}

book(静态链接){
49    编译和链接合并到一起的过程称为构建（build）    什么是build？    编译和链接   
}

book(编译和链接){
50    编译成可执行文件的4步：
        预处理（prepressing）
        编译（compilation）
        汇编（assembly）
        链接（linking）        
51    预编译主要处理#开头的预编译指令：
    1、展开宏定义
    2、处理条件编译
    3、处理文件包含
    4、删除注释
    5、添加行号和文件名标识(为输出结果用)
    6、保留#pragma编译器指令
52    编译包括词法分析、语法分析、语义分析和优化后生成汇编代码    编译的过程？ gcc  -S  .c/.i  -o  .s    法分析、语法分析、语义分析和优化后生成汇编代码    2012-3-6    
53    汇编是将汇编代码一一翻译成机器代码的过程    汇编的过程？ gcc  -c  .c/.s  -o  .o    汇编代码翻译成机器代码        
54    词法分析yacc：源代码字符序列->scanner(有限状态机)->记号(token)    词法分析的内容？    源代码字符序列->scanner(有限状态机)->记号(token)        
55    语法分析：记号(token)->语法分析器(上下文无关语法、下推自动机)->语法树(Syntax Tree)    语法分析的内容？    记号(token)->语法分析器(上下文无关语法、下推自动机)->语法树(Syntax Tree)        
56    语法树：以表达式为节点的树    什么是语法树？    以表达式为节点的树        
57    符号和数字是最小的表达式，通常作为语法树的叶节点    通常作为语法树的叶节点的是什么表达式？    符号和数字        
58    编译器所能分析的语义是静态语义，在编译期就可以确定的语义，通常包括声明、类型匹配与转换    语义分析的是哪种语义？包含什么过程？    静态语义，通常包括声明、类型匹配与转换    2012-3-7    
59    语义分析由语义分析器(Semantic Analyzer)来完成，语法树的表达式都被标识了类型    语义分析对语法树有什么改变？    语法树的表达式都被标识了类型        
60    代码优化包括 
        前端：源代码优化->中间语言生成（Source Code Optimizer）
        后端：目标代码优化->机器代码生成（Target Code Optimizer）            
61    在linux中的中间代码被称为RTL(Register Transfer Language)，通常是平台无关的，这个过程也被称为编译前端。编译后端对RTL树进行裁减，优化，得到在目标机上可执行的汇编代码。    linux下gcc的中间代码是什么格式？    RTL(Register Transfer Language)        
62    中间代码使得编译器可以分为前端和后端。前端负责产生机器无关的中间代码（三地址码、P-Code），后端将中间代码进行剪裁和优化，生成机器代码。这样对于一些跨平台的编译器，可以针对不同的平台使用同一个前端和多个后端生成不同的目标代码    编译器优化是怎样分段的？各自特点？    中间代码使得编译器可以分为前端和后端。前端负责产生机器无关的中间代码（三地址码、P-Code），后端将中间代码进行剪裁和优化，生成机器代码。这样对于一些跨平台的编译器，可以针对不同的平台使用同一个前端和多个后端生成不同的目标代码        
63    重新计算目标地址的过程叫做重定位（relocation）    什么是重定位？    重新计算目标地址的过程    2012-3-11    
64    符号（symbol）的概念随着汇编语言而普及，表示一个地址    程序里的符号（symbol）指什么？    地址        
65    模块之间如何组合的问题可以归结为模块之间的通信问题，静态语言（C/C++）的模块之间的通信有两种方式，模块间的函数调用和变量访问。函数调用需要知道目标函数的地址，变量访问也要目标变量的地址，这两种方式都可以归结为一种方式——模块间的符号引用    静态语言的模块间通讯方式，它们的实质是什么？    函数调用和变量访问，模块间的符号引用        
66    链接的过程包括了地址和空间分配（allocation）、符号决议（symbol resolution）、重定位（relocation）    链接的过程？    地址和空间分配（allocation）、符号决议（symbol resolution）、重定位（relocation）        
67    每个被修正的起始地址叫做重定位入口（Entry）    什么是重定位入口（Entry）？    每个被修正的起始地址          
}

book(目标文件里有什么){
68    windows下的PE和linux下来的ELF都是COFF格式的变种    ELF与COFF的关系？    从属        
69    动态链接库（.dll/.so）和静态链接库（.lib/.a）都按照可执行文件的格式存储    动态链接库和静态链接库的存储格式？    可执行文件        
70    静态链接库是把多个目标文件捆绑起来加上索引生成的    静态链接库的内容？    多个目标文件捆绑起来加上索        
71    ELF文件的4类：
    可重定位文件(Relocatable)
    可执行文件（Executable）
    共享目标文件（Shared object file）
    核心转储文件（Core Dump File）        
72    可重定位文件.o/.a(Relocatable)：包含代码和数据，用来链接成可执行文件或共享目标文件    什么是可重定位文件，有哪些类型？    包含代码和数据，用来链接成可执行文件或共享目标文件，.o/.a        
73    可执行文件（Executable）：包含可执行的程序                
74    共享目标文件.so（Shared object file）：包含代码和数据，用来链接产生新的目标文件或与可执行文件动态链接作为进程映像的一部分运行    什么是共享目标文件，有哪些类型?    包含代码和数据，用来链接产生新的目标文件或与可执行文件动态链接作为进程映像的一部分运行,.so        
75    核心转储文件core dump（Core Dump File）：进程意外终止时，系统将进程地址空间的内容及终止时的一些其它信息转储到该文件中    什么是核心转储文件？    进程意外终止时，系统将进程地址空间的内容及终止时的一些其它信息转储到该文件中        
76    COFF的主要贡献是在目标文件里引入了段机制，并且定义了调试数据格式    COFF的主要特点    段机制，调试数据格式    2012-3-12    
77    源代码编译后的机器指令存放在代码段(.code/.text)，已初始化的全局变量和局部静态变量存放在数据段(.data)，未初始化的全局变量和局部静态变量存放在BSS段(.bss)->全局变量的符号类型为COMMON    代码段、数据段和BSS段分别存放什么？    机器指令、已初始化的全局变量和局部静态变量、未初始化的全局变量和局部静态变量        
78    BSS段（Block Started by Symbol）只是为未初始化的全局变量和局部静态变量预留位置，并没有内容，所以不占空间    BSS段的作用，大小？    为未初始化的全局变量和局部静态变量预留位置，并没有内容，所以不占空间        
79    程序指令和数据分段存放的原因：
    1、程序装载后，数据和指令分别被映射到两个内存区域，数据区为可读写，程序区为只读，防止程序指令被改写。
    2、现代CPU缓存一般被设计成数据缓存和指令缓存分离，指令区和数据区分离有利于提高程序的局部性，提高CPU的命中率。
    3、当系统中运行多个程序的副本时，指令都是一样的，所以内存中可以共享指令与各种资源    
80    ELF文件中以.开头的段，如.rodata，是系统保留的    .bss的.是什么意思？    系统保留的段    2012-6-4    
81    同名段可以有多个    段可以重名吗？    可以        
82    链接器在处理目标文件时，需要对目标文件的某些部分进行重定位，即代码段和数据段中对绝对地址的引用位置，如程序中的printf。                
83    每个需重定位的代码段或数据段，都有一个重定位表                
84    字符串表在ELF文件中也以段的形式保存                
85    不同的编译器采用不同的名字修饰方法，导致生成的目标文件无法相互链接    为什么不同的编译器生成的目标文件无法连接？    不同的编译器采用不同的名字修饰方法        
86    函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号            2012-6-5    
87    强引用：链接时未定义报错，弱引用：未定义不报错   
}

book(静态链接){
88    链接器为目标文件分配空间——相似段合并    链接器为目标文件分配空间的方法？    相似段合并        
89    分配空间的两层含义：1、输出的可执行文件中的空间 2、装载后的虚拟地址空间                
90    对于有实际数据的段(.text .data)，两个空间都要分配。对于不含实际数据的段(.bss)，只在虚拟空间中分配                
91    两步链接：空间与地址分配（全局符号表）、符号解析与重定位    两步链接的内容？    空间与地址分配（全局符号表）、符号解析与重定位    2012-6-6    
92    链接前目标文件中所有段的VMA都是0，链接后才分配虚拟空间    链接前后目标文件的虚拟地址空间有何不同？    链接前目标文件中所有段的VMA都是0，链接后才分配虚拟空间        
93    在Linux下，ELF可执行文件默认地址从0x08048000开始分配    在Linux下，ELF可执行文件默认地址分配起点？    0x08048000        
94    ld a.0 b.o -e main -o ab
        -e main 程序入口为main， ld默认入口为_start
        -o ab 链接输出文件名为ab          
95    弱符号定义在COMMON块，不同目标文件需要的COMMON块空间大小不一致时，以最大的为准    两个同名弱符号的链接处理？    以需要空间最大的为准    2012-6-11    
96    直接导致需要COMMON块原因是链接器运行不同类型的弱符号存在，本质原因是链接器不支持符号类型，无法判断各个符号类型是否一致。    为什么能存在不同类型的同名弱符号？    本质原因是链接器不支持符号类型，无法判断各个符号类型是否一致        
97    使未初始化的全局变量不以COMMON块的形式处理，gcc"-fno-common"或__attribute__((nocommon)),相当于一个强符号                
98    C++需编译器和链接器支持的语言特性：重复代码消除，全局构造与析构                
99    当模板在一个编译单元被实例化时，并不知道在别的编译单元是否被实例化，当一个模板在多个编译单元实例化成相同类型时必然生成重复代码    为什么模板会生成重复代码？        2012-6-12    
100    将每个模板的实例代码单独存放在一个段里，链接时区分这些段，合并入最后的代码段    编译器怎么消除模板生成的重复代码？            
101    由于不同编译单元使用不同的编译器版本或者优化选项，导致同一个函数编译出来的实际代码不同，编译器随意选择其中一个作为输入，同时提供警告信息。    消除重复代码会产生什么问题？            
102    Linux下一般程序的入口为_start,这是Glibc的一部分。初始化在.init段，里面保存可执行指令，包括全局对象的构造函数，初始化完成后调用main函数执行程序主体，main执行完成以后返回.fini段执行清理工作，包括全局对象的析构            2012-6-13    
103    C++二进制兼容标准——C++ ABI    什么是ABI？    二进制兼容标准    2012-6-18    
104    静态库是一组目标文件的集合，ar将它们压缩打包，进行编号和索引。ar -t查看库里的目标文件    什么是静态库？            
150    ld链接器会自动寻找所有需要的符号以及目标文件，将目标文件解压并链接成一个可执行文件。    ld的作用？    自动寻找所有需要的符号以及目标文件，将目标文件解压并链接成一个可执行文件。        
151    控制链接的三种方法：1)ld的命令行参数 2)将链接指令放到目标文件中 3)连接控制脚本    控制链接过程的方法？    1)ld的命令行参数 2)将链接指令放到目标文件中 3)连接控制脚本    2012-6-19    
152    使用自己的链接脚本 ld -T xxxx                
153    一般程序入口在库的_start，由库负责初始化后调用main函数来执行程序的主体部分    一般程序的初始化执行过程？            
154    main程序中的return将退出状态返回给系统库，由系统库将状态值传递给EXIT系统调用，这样父进程就可以接收到子进程的退出码。    一般程序的退出过程？ 
}

book(可执行文件的装载与进程){
155    程序，静态，进程，动态，程序运行过程            2012-6-25    
156    指针大小与虚拟空间位数相同                
157    动态装载的基本原理，程序运行的局部性                
158    覆盖装入：一个模块被调用时，调用路径上的所有模块都必须在内存中，不允许跨树调用                
159    ELF文件装载时，相同权限的段，合并到一起当做一个段映射                
160    从链接的角度看，ELF文件是按Section进行存储的；从装载的角度看，ELF文件是按Segment装载进内存的                
161    系统是按照segment来映射可执行文件的                
167    操作系统通过使用VMA来对进程地址空间进行管理，堆栈等空间在进程的虚拟空间中也以VMA的形式存在，cat /proc/pid/maps    操作系统怎么管理进程的地址空间，如堆栈等？    通过使用VMA来对进程地址空间进行管理    2012-9-5    
168    特殊的VMA：vdso，位于内核空间的内核模块，进程用来与内核通讯    vdso是什么空间？    位于内核空间的内核模块，进程用来与内核通讯        
169    可执行文件的装载运行，是通过虚拟内存的页映射机制完成的，即在一段物理内存和进程虚拟地址空间之间建立映射关系    可执行文件的装载运行？    虚拟内存的页映射机制完成的，即在一段物理内存和进程虚拟地址空间之间建立映射关系        
170    进程运行环境的初始化：系统环境变量和进行的运行参数，操作系统在进程启动前将信息保存到进行的虚拟空间的栈中。进程启动后程序的库部分会把堆栈里的初始信息传递给main()函数    进程怎么启动和传参的？            
171    内核装载ELF文件的过程：
    1、fork：创建一个新进程
    2、execve：执行新的ELF文件（unistd.h），内核真正的装载工作
        2.1、sys_execve()：参数复制检查
        2.2、do_execve()：查找文件，读取前128字节来判断文件格式
        2.3、search_binary_handle()：匹配可执行文件对应的处理程序
        2.3.1、load_aout_binary()：a.out可执行文件处理
        2.3.2、load_script()：可执行脚本
        2.3.3、load_elf_binary()：ELF文件装载（fs/Binfmt_elf.c）
        2.3.3.1、检查ELF文件格式的有效性
        2.3.3.2、寻找动态链接器所在的“.interp”段
        2.3.3.3、根据文件表头映射各个段
        2.3.3.4、初始化ELF进程的运行环境，如CPU各寄存器内容
        2.3.3.5、修改系统调用的返回地址为ELF文件的入口
                 对静态链接的ELF程序，入口地址为文件头e_entry所指
                 对动态链接的ELF程序，入口点为动态链接器
    3、从系统调用sys_execve返回，进入ELF程序开始执行
}

book(动态链接){
172    动态共享对象（DSO），ELF动态链接文件，.so    什么是DSO？            
173    动态链接器将动态链接库装载的进程的地址空间，对未决议的符号进行重定位    动态库的装载过程            
174    动态库保留了完整的符号信息，链接时可以解析符号判断是静态符号还是动态符号                
175    动态链接器与普通共享对象一样被映射到了进程地址空间，在系统开始运行进程前，首先会把控制权交给动态链接器，完成链接工作，然后开始执行进程    动态链接的工作过程            
176    共享对象能在任意地址装载，是因为动态链接库在链接时对所有绝对地址的引用不作重定位，而是推迟到装载时完成，当模块装载地址确定，系统对程序中所有绝对地址引用进行重定位，即Load Time Relocation    为什么共享对象能在任意地址装载？        2012-9-24    
177    Load Time Relocation无法使指令在多个程序间共享，使用PIC（地址无关编码）技术将指令中需要被修改的部分分离出来和数据放在一起，才能共享指令，即-fPIC                
178     -fPIC产生的代码大，-fpic产生的代码相对较小，而且快。但PIC代码都是与硬件平台相关，-fpic在平台上会有限制，所以一般不用     -fpic与 -fPIC的区别            
179    如何区分一个DSO是否为PIC？ 
        Readelf -s xxx.so|grep TEXTREL
    有输出则不是，因为PIC的DSO不包含任何代码段重定位表，TEXTREL表示代码段重定位表地址。"                
180    动态库全局变量对不同进程间和同一进程的不同线程间的影响：
    （1）对不同进程没有区别，因为每个进程有自己的地址空间
    （2）对于同一进程的不同线程，由于进程内部是共享地址空间的，所以这个变量对所有线程都可见"        
181    地址无关代码与装载重定位代码的区别：
    （1）装载重定位代码无法多进程共享，所以无法节省内存，但运行速度快。
    （2）地址无关代码，每次访问全局数据和函数都需要进行地址重定位，来计算当前地址以及间接寻址的过程。
182    ELF文件的加载：
    （1）读取文件头
    （2）映射各个段到虚拟内存
    （3）加载动态链接器
    （4）执行动态链接过程
    （5）控制权转交到可执行文件入口，程序开始正式执行            
183    .interp段保存动态链接器的路径，readelf -l |grep inerpreter查看                
184    动态链接器是glibc的一部分，版本号与其一致                
185    .dynamic段保存动态链接所需的信息，用readelf -d 和ldd 查看                
186    linux-gate.so.1是一个内核虚拟共享对象Kernel virtual DSO，在地址的末端，                
187    动态链接过程：动态链接器自举、加载共享对象、重定位和初始化    动态链接过程？            
188    动态链接器本身不依赖于其它对象，其全局变量和静态变量的重定位由自己完成，动态链接器的入口即自举代码的入口。                
189    链接器装载共享对象的过程一般采用广度优先的算法，先加载所有的共享对象，再解析依赖关系                
190    全局符号介入：当一个符号需要被加入全局符号表时，如果同名符号已存在，则后加入的符号被忽略    当两个被同时动态链接的共享库中有同名全局函数时会怎么处理？            
191    链接器会初始化动态库的.init和.fini，而可执行文件的这两个段由程序初始化代码执行    动态库的.init和.fini段是怎么初始化的？            
192    动态链接器/lib/ld-linux.so.2不仅是个共享对象，还是个可执行程序，它是glibc的一部分                
193    动态链接器本身是静态链接的，不依赖其它对象，其是PIC的                
194    运行时加载的API位于/lib/libld.so                
195    dlopen()查找动态库的顺序：
    (1) LD_LIBRARY_PATH
    (2) /etc/ld.so.cache指定的路径
    (3) /lib、/usr/lib    dlopen()查找动态库的顺序? 
}