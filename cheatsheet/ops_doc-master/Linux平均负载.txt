1. uptime、w、top、glances、tload、 /proc/loadavg
当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。

2. 运行队列中的平均进程数
    Load Average是 CPU 的Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 
CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。
    系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数。
如果一个满足以下条件则其就会位于运行队列中：
  它没有在等待I/O操作的结果
  它没有主动进入等待状态(也就是没有调用'wait')
  没有被停止(例如：等待终止)

3. 平均活跃进程数
    简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，
也就是平均活跃进程数，它和 CPU 利用率并没有直接关系。
3.1 可运行状态
    所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 
ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。
3.2 不可中断状态
    不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，
比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态
（Uninterruptible Sleep，也称为 Disk Sleep）的进程。
所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

uptime(){
ubuntu@localhost:~$ uptime
21:41:11 up 57 min,  1 user,  load average: 0.28, 0.09, 0.24

一般来说只要每个 CPU 的当前活动进程数不大于3那么系统的性能就是良好的，如果每个 CPU 的任务数大于5，
那么就表示这台机器的性能有严重问题。
grep 'model name' /proc/cpuinfo | wc -l
1
可知该系统此时只有一个 CPU ，则表示其系统性能是良好的。
}

4. 理解系统平均负载和CPU核心数目的关系
4.1 多处理器 Vs 多核处理器
  多处理器 —— 一个计算机系统中集成两个或多个物理 CPU
  多核处理器 —— 单个物理 CPU 有两个或多个单独的核并行工作(也叫处理单元)。双核意味着有两个处理单元，4核有4个处理单元，以此类推。

  此外，Intel 引入了超线程技术用来提高并行计算能力。
  通过超线程技术，在操作系统中，单个物理 CPU 表现的和两个逻辑 CPU 一样(实际在硬件上只有一个 CPU)。

  注意，单个 CPU 核同一时间只能执行一个任务，于是产生了多 CPU/处理器、多核 CPU，以及多线程技术。
多 CPU 时，多个程序可以同时执行。如今的 Intel CPU 使用了多核心和超线程技术。
可以使用 nproc 或 lscpu 命令查看系统中的处理器单元数量。

CPU的核数
nproc # 4
grep 'model name' /proc/cpuinfo | wc -l # 

4.1.1 负载 23:16:49 up  10:49,  5 user,  load average: 1.00, 0.40, 3.35
在单核系统中意味着：
CPU 被充分利用（100%）；最近的 1 分钟有 1 个进程在运行。
CPU 有 60% 处于空闲状态；在最近的 5 分钟没有进程等待 CPU 时间。
CPU 平均过载了 235%；最近的 15 分钟平均有 2.35 个进程在等待 CPU 时间。

在双核系统中意味着：
有一个 CPU 处于完全空闲状态，另一个 CPU 被使用；最近的 1 分钟没有进程等待 CPU 时间。
CPU 平均 160% 处于空闲状态；最近的 5 分钟没有进程等待 CPU 时间。
CPU 平均过载了 135%；最近的 15 分钟有 1.35 个进程等待 CPU 时间。

4.2 Load average 的算法
文件: include/linux/sched.h:
#define CALC_LOAD(load,exp,n) ...
文件: kernel/timer.c:
static inline void calc_load(unsigned long ticks)
文件: fs/proc/proc_misc.c:
static int proc_calc_metrics(char *page, char **start, off_t off,
                 int count, int *eof, int len)
static int loadavg_read_proc(char *page, char **start, off_t off,
                 int count, int *eof, void *data)
                 
5. 平均负载的意义
既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。
比如当平均负载为 2 时，意味着什么呢？
  在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
  在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。
  而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。

  如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。
  但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。
  反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，
也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着
系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。


6. 平均负载与CPU使用率
平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：
  CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
  I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。


apt install stress sysstat
场景一：CPU 密集型进程
uptime
stress --cpu 1 --timeout 600 # %usr
uptime              # 查看平均负载的变化情况
mpstat -P ALL 5     # -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据
pidstat -u 5 1      # 间隔 5 秒后输出一组数据
                    # stress 进程的 CPU 使用率为 99.60%，接近100%。
                    
                    
场景二：I/O 密集型进程
uptime
stress -i 1 --hdd 1 --timeout 600 # --hdd表示读写临时文件 %iowait
uptime              # 查看平均负载的变化情况
watch -d uptime
mpstat -P ALL 5 1   # 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据
                    # iowait 高达 87.44%
pidstat -u 5 1      # 间隔 5 秒后输出一组数据，-u 表示 CPU 指标

场景三：大量进程的场景
stress -c 8 --timeout 600 # %usr
watch -d uptime
pidstat -u 5 1      # 间隔 5 秒后输出一组数据 %wait

文章总结
1. 什么是平均负载
• 正确定义：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。
• 错误定义：单位时间内的cpu使用率。
• 可运行状态的进程：正在使用cpu或者正在等待cpu的进程，即ps aux命令下STAT处于R状态的进程
• 不可中断状态的进程：处于内核态关键流程中的进程，且不可被打断，如等待硬件设备IO响应，ps命令D状态的进程
• 理想状态：每个cpu上都有一个活跃进程，即平均负载数等于cpu数
• 过载经验值：平均负载高于cpu数量70%的时候

2. 相关命令
• cpu核数: lscpu、 grep ‘model name’ /proc/cpuinfo | wc -l
• 显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势
• watch -d uptime: -d会高亮显示变化的区域
• strees: 压测命令，–cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，–timeout 执行时间
• mpstat: 多核cpu性能分析工具，-P ALL监视所有cpu
• pidstat: 进程性能分析工具，-u 显示cpu利用率

3. 平均负载与cpu使用率的区别
CPU使用率：单位时间内cpu繁忙情况的统计
• 情况1：CPU密集型进程，CPU使用率和平均负载基本一致
• 情况2：IO密集型进程，平均负载升高，CPU使用率不一定升高
• 情况3：大量等待CPU的进程调度，平均负载升高，CPU使用率也升高

4. 平均负载过高时调优
工具：stress、sysstat

5. CPU密集型进程case
• mpstat -P ALL 5：-P ALL表示监控所有CPU，5表示每5秒刷新一次数据，观察是否有某个cpu的%usr会很高，但iowait应很低
• pidstat -u 5 1：每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低，极有可能就是这个进程导致cpu飚高

6. IO密集型进程case
• mpstat -P ALL 5：观察是否有某个cpu的%iowait很高，同时%usr也较高
• pidstat -u 5 1：观察哪个进程%wait较高，同时%CPU也较高

7. 大量进程case
• pidstat -u 5 1：观察那些%wait较高的进程是否有很多
