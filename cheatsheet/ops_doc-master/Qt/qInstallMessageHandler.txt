https://blog.csdn.net/liang19890820/article/details/51838096  输出详细日志
https://blog.csdn.net/liang19890820/article/details/51838379  重定向至文件


1. 简述
    安装之前已定义的消息处理程序，返回一个指向前一个消息处理程序。
    消息处理程序是一个函数，用于打印调试信息、警告信息、严重错误和致命的错误的消息。
  Qt库（debug模式）包含成百上千的警告信息打印，当发生内部错误时（通常是无效的函数参数）。
  Qt在release模式下构建还包含这些警告，除非在编译时设置QT_NO_WARNING_OUTPUT和/或QT_NO_DEBUG_OUTPUT。
  如果你实现自己的消息处理程序，就可以完全控制这些消息。
  
    缺省的消息处理程序向标准输出打印消息。如果是一个致命的消息，应用程序就会立即中止。
    仅可以定义一个消息处理程序，因为这通常是在应用范围的基础上进行的，以控制调试输出。
    调用qInstallMessageHandler(0)可以恢复消息处理程序。

2. 调试级别
Q包含用于警告和调试文本的全局宏：
    qDebug()    调试消息
    qInfo()     信息消息
    qWarning()  警告消息和可恢复的错误
    qCritical() 关键错误和系统错误
    qFatal()    致命错误

如果包含头文件<QDebug>，就可以将所述qDebug()宏用作一个输出流。
例如
qDebug() << "Widget" << widget << "at position" << widget->pos();
Windows中，如果是一个控制台应用程序，文本将被发送到控制台；否则，被发送到调试器。
    
3. 正常使用
一般情况下，在调试程序的时候，我们会输出一些调试信息，便于程序跟踪。
例如：
int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    // 打印信息
    qDebug("This is a debug message.");
    qWarning("This is a warning message.");
    qCritical("This is a critical message.");
    qFatal("This is a fatal message.");

    ...
    return app.exec();
}
输出如下：
    This is a debug message.
    This is a warning message.
    This is a critical message.
    This is a fatal message.
    
4. 自定义消息处理
一般情况下，一个大型项目会出现很多这样类似的调试信息，很不利于查找，因为我们根本不清楚输出信息所在的文件、函数、行号等信息。
下面，我们来根据需要自定义消息处理程序。
#include <QApplication>
#include <stdio.h>
#include <stdlib.h>

// 自定义消息处理程序
void myMessageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    QByteArray localMsg = msg.toLocal8Bit();
    switch (type) {
    case QtDebugMsg:
        fprintf(stderr, "Debug: %s (%s:%u, %s)\n", localMsg.constData(), context.file, context.line, context.function);
        break;
    case QtInfoMsg:
        fprintf(stderr, "Info: %s (%s:%u, %s)\n", localMsg.constData(), context.file, context.line, context.function);
        break;
    case QtWarningMsg:
        fprintf(stderr, "Warning: %s (%s:%u, %s)\n", localMsg.constData(), context.file, context.line, context.function);
        break;
    case QtCriticalMsg:
        fprintf(stderr, "Critical: %s (%s:%u, %s)\n", localMsg.constData(), context.file, context.line, context.function);
        break;
    case QtFatalMsg:
        fprintf(stderr, "Fatal: %s (%s:%u, %s)\n", localMsg.constData(), context.file, context.line, context.function);
        abort();
    }
}

int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    // 安装消息处理程序
    qInstallMessageHandler(myMessageOutput);

    // 打印信息
    qDebug("This is a debug message.");
    qWarning("This is a warning message.");
    qCritical("This is a critical message.");
    qFatal("This is a fatal message.");

    ...
    return app.exec();
}
这时，我们不仅可以输出调试信息，而且可以很直观、很方便的得到输出代码所在的文件、函数、行号等信息。
输出如下：

    Debug: This is a debug message. (..\MessageOutput\main.cpp:90, int __cdecl main(int,char *[]))
    Warning: This is a warning message. (..\MessageOutput\main.cpp:91, int __cdecl main(int,char *[]))
    Critical: This is a critical message. (..\MessageOutput\main.cpp:92, int __cdecl main(int,char *[]))
    Fatal: This is a fatal message. (..\MessageOutput\main.cpp:93, int __cdecl main(int,char *[]))
    
5. 重定向至文件
void myMessageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    // 加锁
    static QMutex mutex;
    mutex.lock();

    QByteArray localMsg = msg.toLocal8Bit();

    QString strMsg("");
    switch(type)
    {
    case QtDebugMsg:
        strMsg = QString("Debug:");
        break;
    case QtWarningMsg:
        strMsg = QString("Warning:");
        break;
    case QtCriticalMsg:
        strMsg = QString("Critical:");
        break;
    case QtFatalMsg:
        strMsg = QString("Fatal:");
        break;
    }

    // 设置输出信息格式
    QString strDateTime = QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss ddd");
    QString strMessage = QString("Message:%1 File:%2  Line:%3  Function:%4  DateTime:%5")
            .arg(localMsg.constData()).arg(context.file).arg(context.line).arg(context.function).arg(strDateTime);

    // 输出信息至文件中（读写、追加形式）
    QFile file("log.txt");
    file.open(QIODevice::ReadWrite | QIODevice::Append);
    QTextStream stream(&file);
    stream << strMessage << "\r\n";
    file.flush();
    file.close();

    // 解锁
    mutex.unlock();
}

int main(int argc, char **argv)
{
    // 安装消息处理程序
    qInstallMessageHandler(myMessageOutput);

    QApplication app(argc, argv);

    // 打印信息
    qDebug("This is a debug message.");
    qWarning("This is a warning message.");
    qCritical("This is a critical message.");
    qFatal("This is a fatal message.");

    ...
    return app.exec();
}

这里，使用QMutex进行加锁、解锁操作，便于我们可以安全的在多线程操作中使用。QFile打开模式为QIODevice::ReadWrite | QIODevice::Append（读写、追加模式），保证了输出信息可以以追加的形式写入文件。
 
    
    