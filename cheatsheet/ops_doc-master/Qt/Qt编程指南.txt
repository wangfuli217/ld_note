
1.2 Qt下载
================================================================================
Qt百度网盘下载
    http://pan.baidu.com/s/1nuk5Lbz 
    qt-opensource-windows-x86-mingw491_opengl-5.4.0.exe，这是 Windows 操作系统的安装包，编译 套件是 MinGW 工具集。
    qt-opensource-mac-x64-clang-5.4.0.dmg，这是苹果操作系统的安装包，编译套件是 Clang。
    qt-opensource-linux-x86-5.4.0.run，这是 32 位 Linux 操作体统安装包，Linux 系统默认编译工具集是 GNU 套件。
    qt-opensource-linux-x64-5.4.0.run，这是 64 位 Linux 操作系统安装包，也默认是 GNU 套件。
    qt-everywhere-opensource-src-5.4.0.7z，这个不是安装包，是单纯的源代码压缩包，里面没有可执行文件，也没有开发环境。通常上面四个开发环境安装包自带源代码，在安装时选中即可，所以一般不需要手动下载这个源代码包。
Qt资源下载网站
    镜像网站：
    中国科学技术大学 http://mirrors.ustc.edu.cn/qtproject/
    清华大学： https://mirrors.tuna.tsinghua.edu.cn/qt/
    北京理工大学 http://mirror.bit.edu.cn/qtproject/
Qt 镜像网站里面的目录结构
    archive：各种Qt开发工具安装包，新旧都有（可以下载Qt开发环境和源代码）
    community_releases：社区定制的Qt库，Tizen版Qt以及Qt附加源码包
    development_releases：开发版，有新的和旧的不稳定版本，在Qt开发过程中的非正式版本
    learning：有学习Qt的文档教程和示范视频
    ministro：迷你版，目前是针对Android的版本
    official_releases：正式发布版，是与开发版相对的稳定版Qt库和开发工具（可以下载Qt开发环境和源代码）
    online：Qt在线安装源
    snapshots：预览版，最新的开发测试中的Qt库和开发工具
archive 和 official_releases 两个目录都有最新的 Qt 开发环境安装包
archive 
    vsaddin/ ，这是 Qt 针对 Visual Studio 集成的插件，本教程基本不使用 Visual Studio ，所以不需要插件。
    qtcreator/，这是 Qt 官方的集成开发工具，但是 qtcreator 本身是个空壳，它没有编译套件和 Qt 开发库。
    qt/，这是 Qt 开发环境的下载目录，我们刚说的 Qt 5 的大安装包就在这里面。
    online_installers/，在线安装器，国内用户不建议使用，在线安装是龟速，还经常断线。我们教程采用的全部是离线的大安装包。
qt
    qt/ 目录包含了所有的 Qt 版本，从 1.0 到目前的 5.5
        5.4.0 是完整的 Qt 库版本号，第一个数字 5 是大版本号（major），第二个数字 4 是小版本号（minor），第三个数字 0 是补丁号（patch）。
    只要前面两个数字相同，Qt 库的特性就是一致的，最后的数字是对该版本的补丁更新。也就是说本教程对 5.4.* 系列 Qt 库都是通用的
Qt最新版本下载
    http://download.qt.io/ 下载
http://download.qt.io/official_releases/qt/5.13/5.13.2/
    submodules/ 目录存放 Qt 各个分模块的源代码。
    single/ 目录存放 Qt 源代码的合集打包。
    qt-opensource-windows-x86-pdb-files-uwp-5.11.1.7z  是 VC 开发 UWP 应用调试信息库，不用管。
    qt-opensource-windows-x86-pdb-files-desktop-5.11.1.7z 是 VC 开发普通 Windows 桌面程序的调试信息库，也不用管。
    qt-opensource-windows-x86-5.11.1.exe 是 Windows 系统下的 Qt 安装包，这很简略，MinGW 和 VC 版本全部集成到一块了。
    qt-opensource-mac-x64-5.11.1.dmg 是苹果操作系统的安装包。
    qt-opensource-linux-x64-5.11.1.run 是 Linux 系统的安装包。
    md5sums.txt 保存了以上文件的 MD5 校验和，可以检查下载软件包的完整性。
https://wiki.qt.io/Main
    Qt 维基网站会显示最新的正式版、LTS 版、正在开发中的版本等等



1.3 Qt在Windows下安装
================================================================================
http://pan.baidu.com/s/1nuyQHzb
https://lug.ustc.edu.cn/sites/qtguide/extradoc/Qt-VS2015.7z 

Qt 命令行脚本
    “Qt Creator (Community)”就是集成开发环境
    “Assistant” （Qt助手）是帮助文档查看工具，
    “Designer” （Qt设计师）是图形界面可视化编辑工具，
    “Linguist”（Qt语言家）是多国语言翻译支持工具
    Qt 5.4 for Desktop (MinGW 4.9 32bit)” 就是 Qt 开发命令行，配置好了 Qt 开发需要的环境变量，打开它我们就可以从命令行编译 Qt 程序。
Qt 静态库下载配置
    Qt 环境里面自带了发布工具 windeployqt ，其使用教程参考文档：https://qtguide.ustclug.org/extradoc/windeployqt.doc.7z 
    Realfan 大神主页：http://www.qtcn.org/bbs/u/123401
    下面的网盘链接也分享了他打包的 Qt 静态库：https://pan.baidu.com/s/1sOFrkti69SCIb-hAZEfOXw
    
“工具”--> “选项”  https://qtguide.ustclug.org/ch01-03.htm
    构建&运行: Qt Version
               构建套件


1.4 Qt在Linux下安装
================================================================================
安装前准备工作
    如果是 Debian/Ubuntu/Deepin (apt-get) 系列操作系统，执行命令：
    sudo apt-get install build-essential libgl1-mesa-dev

    如果是 Fedora/RHEL/CentOS (yum) 系列操作系统，执行命令：
    sudo yum groupinstall "C Development Tools and Libraries"
    sudo yum install mesa-libGL-devel

    如果是 openSUSE (zypper) 系列操作系统，执行命令：
    sudo zypper install -t pattern devel_basis 
安装Qt开发环境
    32位Linux安装包为 qt-opensource-linux-x86-5.4.0.run， chmod +x /文件夹路径/qt-opensource-linux-x86-5.4.0.run
    64位Linux安装包为 qt-opensource-linux-x64-5.4.0.run。 chmod +x /文件夹路径/qt-opensource-linux-x64-5.4.0.run
中文输入法问题
    安装软件包 fcitx-qt5 ， 然后复制 .so 文件：/usr/lib64/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so 
    (64位系统是/usr/lib64/... ，32位系统是/usr/lib/...)，
    粘贴一份到目录：
    Qt安装目录/Tools/QtCreator/bin/plugins/platforminputcontexts/
    再粘贴一份到目录：
    Qt安装目录/5.4/gcc_64/plugins/platforminputcontexts/
Qt开发环境目录结构
Qt开发环境脚本 (qt5env.sh)
  KDE 
    export QTDIR=~/Qt5.4.0/5.4/gcc_64
    export PATH=~/Qt5.4.0/5.4/gcc_64/bin:$PATH
    export LD_LIBRARY_PATH=~/Qt5.4.0/5.4/gcc_64/lib:$LD_LIBRARY_PATH
    cd ~
    konsole
  GNOME 
    export QTDIR=~/Qt5.4.0/5.4/gcc_64
    export PATH=~/Qt5.4.0/5.4/gcc_64/bin:$PATH
    export LD_LIBRARY_PATH=~/Qt5.4.0/5.4/gcc_64/lib:$LD_LIBRARY_PATH
    cd ~
    gnome-terminal
  KDE 桌面里用 konsole 启动命令行， GNOME 桌面里用 gnome-terminal 启动命令行




1.5 认识开发工具
================================================================================
GNU 工具集
    gcc     GNU C 语言编译器。
    g++     GNU C++ 语言编译器。
    ld      GNU 链接器，将目标文件和库文件链接起来，创建可执行程序和动态链接库。
    ar      生成静态库 .a ，可以编辑和管理静态链接库。
    make    生成器，可以根据 makefile 文件自动编译链接生成可执行程序或库文件。
    gdb     调试器，用于调试可执行程序。
    ldd     查看可执行文件依赖的共享库（扩展名 .so，也叫动态链接库）。
MinGW(Minimalist GNU for Windows)  利用 MinGW 就可以生成 Windows 里面的 exe 程序和 dll 链接库
MinGW 与 Linux/Unix 系统里 GNU 工具集的有些区别：
    MinGW 里面工具带有扩展名 .exe， Linux/Unix 系统里工具通常都是没有扩展名的。
    MinGW 里面的生成器文件名为 mingw32-make.exe，Linux/Unix 系统里就叫 make。
    MinGW 在链接时是链接到 *.a 库引用文件，生成的可执行程序运行时依赖 *.dll，而 Linux/Unix 系统里链接时和运行时都是使用 *.so 。
Windows 里面动态库扩展名为 .dll，MinGW 可以通过 dlltool 来生成用于创建和使用动态链接库需要的文件，如 .def 和 .lib。
MinGW 本身主要就是编译链接等工具和头文件、库文件，并不包含系统管理、文件操作之类的 Shell 环境
MinGW 官方又推出了 MSYS(Minimal SYStem)，相当于是一个部署在 Windows 系统里面的小型 Unix 系统环境

CMake (Cross platform Make)
    CMake 自己不编译程序， 它相当于用自己的构建脚本 CMakeLists.txt，叫各种编译工具集去生成可执行程序或链接库。
    Qt 官方的 qmake 工具生成 makefile 文件，没有用 CMake
    跨平台的程序/库如 Boost C++ Libraries、OpenCV、LLVM、Clang 等也都是用 CMake 脚本构建的。

Qt工具集
    qmake   核心的项目构建工具，可以生成跨平台的 .pro 项目文件，并能依据不同操作系统和编译工具生成相应的 Makefile，
            用于构建可执行程序或链接库。
    uic     User Interface Compiler，用户界面编译器，Qt 使用 XML 语法格式的 .ui 文件定义用户界面，uic 根据 .ui 文件
            生成用于创建用户界面的 C++ 代码头文件，比如 ui_*****.h 。
    moc     Meta-Object Compiler，元对象编译器，moc 处理 C++ 头文件的类定义里面的 Q_OBJECT 宏，它会生成源代码文件，
            比如 moc_*****.cpp ，其中包含相应类的元对象代码，元对象代码主要用于实现 Qt 信号/槽机制、运行时类型定义、动态属性系统。
    rcc     Resource Compiler，资源文件编译器，负责在项目构建过程中编译 .qrc 资源文件，将资源嵌入到最终的 Qt 程序里。
    qtcreator   集成开发环境，包含项目生成管理、代码编辑、图形界面可视化编辑、 编译生成、程序调试、上下文帮助、
                版本控制系统集成等众多功能， 还支持手机和嵌入式设备的程序生成部署。
    assistant   Qt 助手，帮助文档浏览查询工具，Qt 库所有模块和开发工具的帮助文档、示例代码等都可以检索到，是 Qt 开发必备神器，
                也可用于自学 Qt。
    designer    Qt 设计师，专门用于可视化编辑图形用户界面（所见即所得），生成 .ui 文件用于 Qt 项目。
    linguist    Qt 语言家，代码里用 tr() 宏包裹的就是可翻译的字符串，开发人员可用 lupdate 命令生成项目的待翻译字符串文件
                .ts，用 linguist 翻译多国语言 .ts ，翻译完成后用 lrelease 命令生成 .qm 文件，然后就可用于多国语言界面显示。
    qmlscene    在 Qt 4.x 里是用 qmlviewer 进行 QML 程序的原型设计和测试，Qt 5 用 qmlscene 取代了旧的 qmlviewer。新的 
                qmlscene 另外还支持 Qt 5 中的新特性 scenegraph 。


1.6 常见的名词术语
================================================================================
C++11 标准： 
    CONFIG += c++11
    gcc:CXXFLAGS += -std=c++0x
Debug 和 Release：
    Debug ：     libQt5Guid.a/Qt5Guid.dll
    Release：    libQt5Gui.a/Qt5Gui.dll
Dynamic Link 和 Static Link：
    Dynamic Link: 链接到如 *.dll 或 *.so 文件
    Static Link： Linux/Unix 系统里静态库扩展名一般是 .a.   Windows 系统里 VC 编译器用的静态库扩展名一般是 .lib
    MinGW 使用的静态库扩展名为 .a ，而其动态库扩展名则为 .dll.  .a 仅在生成目标程序过程中使用，.dll 则是在目标程序运行时使用。
Explicit Linking 和 Implicit Linking：
    Explicit Linking：Linux 里比如用 dlopen 函数打开并加载动态库，Windows 里一般用 LoadLibrary 打开并加载动态库
    Implicit Linking： 在 .exe 程序运行前系统会检查依赖的 .dll
    MinGW 是将动态库的导出函数声明放在了 .a 文件里，程序运行依赖的动态库也是 .dll 。
Makefile： 让程序员只需要去关注如何编写代码， 而生成程序过程中的脏活累活都交给 make 程序。
    现在 Makefile 通常都有工具自动生成，如 qmake 工具
Project： 即项目(或叫工程)
    Qt 使用 .pro 文件管理项目， VC++ 则使用 .vcproj 作为项目文件。集成开发环境通常都是依据项目文件（.pro/.vcproj）管理和构建项目。
    
    
2.1 Hello World
================================================================================
    g++ helloworld.cpp -o helloworld                  # 单文件helloworld.cpp
    g++ helloworld.cpp -static -o hellostatic         # 单文件helloworld.cpp
    g++ helloworld.cpp -g -static -o hellodebug       # 单文件helloworld.cpp
                                                        
    g++ -c rect.cpp -o rect.o                         # 多文件 rect.cpp 和 hellorect.cpp
    g++ -c hellorect.cpp -o hellorect.o               # 多文件 rect.cpp 和 hellorect.cpp
    g++ rect.o hellorect.o -lm -static -o hellorect   # 多文件 rect.cpp 和 hellorect.cpp
    
给 Hello Rect 编写简单的 Makefile
    # Makefile for building: hellorect
CC          = gcc
CXX         = g++
LINKER      = g++
LFLAGS      = -lm -static

OBJECTS     = rect.o hellorect.o
DSTTARGET   = hellorect

# Default rule
all: $(DSTTARGET)
$(DSTTARGET): $(OBJECTS)
	$(LINKER)  $(LFLAGS)  -o $@  $(OBJECTS)
hellorect.o: hellorect.cpp
	$(CXX) -c  -o  $@  $<  
rect.o: rect.cpp
	$(CXX) -c  -o  $@  $<  
clean:
	rm  $(OBJECTS)  hellorect.exe

$@ 是上一行冒号左边的目标，$< 是上一行冒号右边第一个依赖文件。

mingw32-make
mingw32-make clean

2.2 Hello Qt
================================================================================
    g++ helloqt.cpp  -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include"  -L"C:\Qt\Qt5.4.0\5.4\mingw491_32\lib" -lQt5Core -lQt5Gui -lQt5Widgets  -o helloqt
    g++ helloqt.cpp -std=c++0x -I"C:\Qt\Qt5.7.0\5.7\mingw53_32\include" -L"C:\Qt\Qt5.7.0\5.7\mingw53_32\lib" -lQt5Core -lQt5Gui -lQt5Widgets -o hellqt 
    
Hello Widget
    moc hellowidget.h -o moc_hellowidget.cpp 
    g++ -c moc_hellowidget.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -o moc_hellowidget.o
    g++ -c hellowidget.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -o hellowidget.o
    g++ -c main.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -o main.o
    g++ moc_hellowidget.o hellowidget.o main.o -L"C:\Qt\Qt5.4.0\5.4\mingw491_32\lib" -lQt5Core -lQt5Gui -lQt5Widgets -o hellowidget
    
使用 qmake
    qmake 工具有两种工作模式，它首先根据项目文件夹的头文件、源文件、图形界面文件、资源文件等，生成标准的 .pro 项目文件。
    然后使用第二种工作模式， qmake 可以根据 .pro 文件自动生成 Makefile 文件
    
    qmake -project "QT+=widgets"  # qmake 的选项 -project 就是指定第一种工作模式
    qmake                         # 用 qmake 生成 Makefile
    qmake -o Makefile hello.pro   # 用 qmake 生成 Makefile
    qmake -t vcapp -o hello.dsp hello.pro # qmake也可以生成“.dsp”文件
    
    mingw32-make # 调用 make 工具生成可执行程序
    mingw32-make debug
    mingw32-make release
    mingw32-make all
    
hellowidget.pro
######################################################################
# Automatically generated by qmake (3.0) ??? ?? 17 20:31:15 2015
######################################################################
QT+=widgets
TEMPLATE = app
TARGET = hellowidget
INCLUDEPATH += .

# Input
HEADERS += hellowidget.h
SOURCES += hellowidget.cpp main.cpp
    pro 文件可以通过 qmake 生成，或者手动编写 pro 文件也行。 qmake 又可以按照 pro 文件的内容生成 Makefile
pro 文件是非常关键的项目管理和控制项目生成的文件，集成开发环境 QtCreator 就是采用 pro 文件管理和生成项目的


2.3 Hello Designer
================================================================================
Qt 设计师编辑 UI
  UI 类型
    Dialog: 按钮居底部、按钮居右边和不带按钮
    "Main Window"，即主窗口界面，主窗口功能最为丰富，有菜单栏、工具栏、状态栏、中央部件，并且可以添加停靠/浮动窗口。
    通用“Widget”界面
  UI 编辑
    ①编辑窗口部件：为窗口拖拽控件(即部件)，编辑控件布局等。
    ②编辑信号/槽：用户在图形界面的一些动作会触发窗口或控件的信号，信号对应的处理函数就是槽函数，这种模式实现二者的关联关系。
    ③编辑伙伴：最常见的就是将标签控件设置为其他控件(如编辑框)的伙伴，标签控件文本就可以指明关联控件的名称/功能/用途，并且能方便地设置快捷 键。
    ④编辑 Tab 顺序：在窗口中，用户可以按 Tab 键依次选择进入各个控件，这个模式就是编辑各个控件被选择的顺序。
  UI 编辑
    对象查看器是记录当前窗体里面有哪些控件， 每个控件对象的名称和类名都会列出来
    
    属性编辑器，用于编辑窗体或控件的属性，比如对象名称、窗口标题、窗口大小等等。
      objectName：对象名称，ui 文件里的对象名称全是指针变量名，因为它们全都是用 new 创建的。
      geometry：控件显示占据的几何图形，就是显示的矩形区域. X、Y、宽度、高度，设置这四个数值，可以控制控件显示的位置和控件的大小。
      text：显示的文本
      
      资源浏览器    : 
      动作编辑器    : 
      信号/槽编辑器 : 
“窗体”-->“预览(P)...”， 或者按快捷键 Ctrl+R，
“文件”-->“保存(S)”，或者按快捷键 Ctrl+S

UI 直接使用法—— Hello Designer    == ui_hello.h + main.cpp
====================================
    uic hello.ui -o ui_hello.h
  setupUi 函数，这个是最关键的生成图形界面的函数，它接收一个 QWidget 对象的指针，然后为这个 QWidget 对象设置窗口界面和控件。
  retranslateUi 函数，是专门用于支持多国语言翻译的，主窗口和标签控件的字符串都在这重新翻译一下，
  
  // main.cpp
  #include "ui_hello.h"
  QWidget *hw = new QWidget();    //main GUI window
  Ui::Form createUi;      //createUi is not a real window
  createUi.setupUi(hw);   //createUi is a tool for creating the GUI
  hw->show();             //hw is the real window
  
  g++ main.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -L"C:\Qt\Qt5.4.0\5.4\mingw491_32\lib" -lQt5Core -lQt5Gui -lQt5Widgets -o hellodesigner 
  
# 将图形界面设计和后台功能代码相分离，是现代 GUI 程序设计的通用思路，学会一种图形界面编程方法，其他的都可以触类旁通。
  
UI 多重继承使用法—— Hello UIWidget   == ui_hello.h + main.cpp + hellouiwidget.h + hellouiwidget.cpp
====================================
//hellouiwidget.h
#include <QtWidgets/QWidget>
#include <QtWidgets/QLabel>
#include "ui_hello.h"

class HelloUIWidget : public QWidget, public Ui::Form
{
    Q_OBJECT
public:
    explicit HelloUIWidget(QWidget *parent = 0);
    ~HelloUIWidget();

protected:
    void AdjustLabel();
};


//hellouiwidget.cpp
#include "hellouiwidget.h"

HelloUIWidget::HelloUIWidget(QWidget *parent) : QWidget(parent)
{
    setupUi(this);  //Must call setupUi first!
    //Then do other things.
    AdjustLabel();
}

HelloUIWidget::~HelloUIWidget()
{
    //Do not need to delete labels/widgets manually.
    //They will be deleted by Qt automatically.
}

void HelloUIWidget::AdjustLabel()
{
    label->setText(tr("<h1>Hello UIWidget!</h1>"));
    label->setStyleSheet(tr("color: red; background-color: rgb(0, 255, 255)"));
}

//main.cpp
#include <QtWidgets/QApplication>
#include "hellouiwidget.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    HelloUIWidget *huiw = new HelloUIWidget();
    huiw->show();
    return a.exec();
}

uic hello.ui -o ui_hello.h                    # 用 uic 生成 ui_hello.h
moc hellouiwidget.h -o moc_hellouiwidget.cpp  # 用 moc 生成元对象系统代码
g++ -c moc_hellouiwidget.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -o moc_hellouiwidget.o  # 编译 cpp 源代码文件
g++ -c hellouiwidget.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -o hellouiwidget.o          # 编译 cpp 源代码文件
g++ -c main.cpp -I"C:\Qt\Qt5.4.0\5.4\mingw491_32\include" -o main.o                            # 编译 cpp 源代码文件
g++ moc_hellouiwidget.o hellouiwidget.o main.o -L"C:\Qt\Qt5.4.0\5.4\mingw491_32\lib" -lQt5Core -lQt5Gui -lQt5Widgets -o hellouiwidget # 链接生成目标程序

2.4 Hello Creator
================================================================================
新建项目对话框里有五类项目模板：
    Application：Qt 应用程序，包括普通窗体程序和 QtQuick 程序。
    Library：可以创建动态库、静态库以及 QtQuick 扩展插件、QtCreator 自身插件。
    其他项目：可以创建单元测试项目、Qt4 设计师自定义控件、子目录项目等。
    非 Qt 项目：可以创建纯 C 或 纯 C++ 项目。
    导入项目：从版本控制系统管理的软件项目导入旧的项目。

Application。在 Qt 应用程序里有四个子模板：
    Qt Widgets Application：普通窗体模板，传统基于部件的窗体界面程序。
    Qt Quick Application：使用 QtQuick 设计界面的应用程序，编译得到二进制可执行程序。
    Qt 控制台应用：因为 Qt 主要用于图形界面设计，这个控制台项目模板基本不用的。
    Qt Quick UI：使用 QtQuick 设计的界面文件 *.qml ，项目不需要编译，而是使用 qmlscene 工具预览界面

基类的选择，目前是三种基类：
    QMainWindow：基于主窗口类的程序，一般用于较为复杂的应用程序，除了中央客户区界面，还可以包括菜单栏、工具栏、状态栏以及多个可停靠的工具对话框等等。
    QWidget：最简单最基本的窗体程序，里面可以放置多个控件实现程序功能。
    QDialog：基于对话框的程序，对话框一般用于弹窗，也可以用于主界面显示。对话框是从 QWidget 继承而来的，并丰富了一些功能，如模态显示和返回值等。

UI 模板生成 widget.h(widget.ui) + widget.cpp + widget.h + main.cpp


3.1 字符编码方式 (字符编码那点事：快速理解ASCII、Unicode、GBK和UTF-8 -- 阮一峰)
================================================================================
ANSI多字节编码
    大陆制定了国标码 GB2312，台港澳地区则使用了大五码 Big5
    微软针对这些本地化字符编码采用的就是用 ANSI（American National Standards Institute，美国国家标准学会）多字节编码方式
系统里的英文和符号就使用单字节的 ASCII（0x00~0x7f），而对于汉字之类的本地化字符编码，就采用 0x80~0xFF 范围内的多个字节来表示，
这样既能兼容 ASCII ，又能正常使用本地化语言文字。
  GB2312：1980年发布         汉字是双字节编码。
  GBK：1995年发布            汉字是双字节编码。
  GB18030-2000：2000年发布   汉字分为双字节编码部分和四字节编码部分。
  GB18030-2005：2005年发布   汉字分为双字节编码部分和四字节编码部分。
新的国标码标准通常是兼容旧的编码方式的。
微软针对各种本地化语言的页面有自己的编号方式，GBK 对应的代码页编号是 936，
                                              GB18030 对应的代码页编号是 54936，
                                              Big5 对应的代码页编号是 950。
# GB2312 编码方案
    GB2312 编码方案把这7445个字符分成了94个区，每个区有94个位置，然后把这些字符一个个放到这些位置上来表示。
比如汉字‘啊’的编号就是在16区01位。
    两个字节分别加32得到国标码，继续加128得到内码，这个内码就可以被操作系统解析了。
举个例子，比如‘啊’的区位码是（16, 01），
                  国标码是（16+32, 01+32）=（48, 33），
                  内码是（48+128, 33+128）=（B0, A1），
                  最终这个（B0, A1）就可以被操作系统解析了。
我们在 Windows 上用记事本保存一个‘啊’字，然后用16进制显示可以看到内码确实是（B0, A1）



Unicode系列编码
    ANSI 多字节编码解决了各种语言文字的本地化使用问题，也有它自己的缺陷：各地制定的编码标准只对自己的语言文字有效，
而不同语言文字的编码都是冲突的，因为大家都用 0x80~0xFF 范围字节表示自己的语言文字，而不考虑别的语言文字如何编码，
冲突在所难免。
    Unicode 编码系统，可分为编码方式和实现方式两个层次。对于国际组织发布的 Unicode 编码标准，对应的就是编码方式，
      UCS-2（Universal Character Set 2），采用两字节编码一个字符。
      四字节编码方式 UCS-4
    这个仅仅是标准，而不是实现，在编码实现的过程中，有些考虑兼容旧的单字节 ASCII 编码，有些不考虑兼容性；
有些考虑双字节中哪个字节放在前面，哪个字节放在后面的问题，即 BOM（Byte Order Mark，字节顺序标记）的作用。

诞生了多种国际码的实现方式，统称为 Unicode 转换格式（Unicode Transformation Format，UTF）
  UTF-8：灵活的变长编码，对于 ASCII 使用一个字节编码
  UTF-16：兼容 UCS-2，一般都是两字节表示一个字符，使用一对两字节来表示。
    UTF-16LE（Little Endian，小端字节序）和UTF-16BE（Big Endian，大端字节序）
    微软所说的 Unicode 默认就是 UTF-16LE。
  UTF-32：同 UCS-4，因为用四个字节表示一个字符，所以不需要考虑扩展了。
    在存储时也分为 UTF-32BE 和 UTF-32LE

C++使用的字符串
    使用 char 表示单字节的字符，使用 wchar_t 表示宽字符，对国际码提供一定程度的支持。
    char * 字符串有专门的封装类 std::string 来处理，标准输入输出流是 std::cin 和 std::cout 。
    wchar_t * 字符串，其封装类是 std::wstring，标准输入输出流是 wcin 和 wcout。
    宽字符是占用几个字节
      Windows 系统里的宽字符是两个字节，就是 UTF-16
      Unix/Linux 系统里为了更全面的国际码支持，其宽字符是四个字节，即 UTF-32 编码
    MFC 一般用自家的 TCHAR 和 CString 类支持国际化，当没有定义 _UNICODE 宏时，TCHAR = char，
当定义了 _UNICODE宏 时，TCHAR = wchar_t，CString 内部也是类似的。
    Qt 则用 QChar 和 QString 类（内部恒定为 UTF-16），一般的图形开发库都用自家的字符串类库。

    Windows 命令行默认的输入输出格式是 ANSI 的。在 Linux 系统里统统都是 UTF-8
    
源文件字符编码测试
    char theStr[] = "1234打印汉字";
    cout<<"str length: "<<strlen(theStr)<<endl;
    cout<<theStr;
                         Windows                   Linux
GBK.cpp、UTF-8.cpp、UTF-16.cpp                     
g++ GBK.cpp -o GBK       # 编译正常；输出正常      编译正常；输出不正常
g++ UTF-8.cpp -o UTF-8   # 编译正常；输出不正常    编译正常；输出正常
g++ UTF-16.cpp -o UTF-16 # 编译根本不成功          编译根本不成功

那么 UTF-16 的源代码谁能正常编译呢？答案就是微软出的 Visual Studio，微软自家用的 Unicode 还得靠 MSVC 编译器来编译：
cl UTF-16.cpp /EHsc      # 编译正常；输出正常
cl GBK.cpp /EHsc         # 编译正常；输出正常
cl UTF-8.cpp /EHsc       # 编译正常；输出正常


①g++ 编译器不会对源文件里的字符串做转码。
②MSVC 编译器会根据不同的源文件编码格式进行转码

UTF-8 编码的源文件是 Qt5 官方规定的源文件格式

%% GBK.cpp UTF-8.cpp UTF-16.cpp 编码方式和QtCreator

3.1 Qt程序字符编码
================================================================================
UTF-8 编码的源文件是 Qt5 官方规定的源文件格式。 GBK方式编码会输出"错误"内容。

乱码纠正——不推荐的方式
QString strText = QString::fromLocal8Bit("1234打印汉字"); # QString::​fromLocal8Bit 函数代替 tr 函数来实现转码

乱码纠正——应该用的方式
按编码保存 : GBK -> UTF-8.

运行时QString与多种编码格式转换
转入函数        转出函数        描述
fromLocal8Bit   toLocal8Bit     与操作系统及本地化语言相关，Linux 一般是 UTF-8 字符串，Windows 一般是 ANSI 多字节编码字符串。
fromUtf8        toUtf8          与 UTF-8 编码的字符串相互转换。
fromUtf16       utf16 和unicode 与 UTF-16（UCS2）编码的字符串互相转换，utf16 函数与 unicode 函数功能一样， 注意没有 to 前缀，因为 QString 运行时的内码就是 UTF-16，字符的双字节采用主机字节序。
fromUcs4        toUcs4          与 UTF-32（UCS4）编码的字符串互相转换，一个字符用四个字节编码，占空间多，应用较少。
fromStdString   toStdString     与 std::string 对象互相转换，因为 C++11 规定标准字符串 std::string 使用 UTF-8 编码，这对函数功能与上面 **Utf8 转码函数相同。
fromStdWString  toStdWString    与 std::wstring 对象相互转换，在 Linux 系统里宽字符是四字节的 UTF-32，在 Windows 系统里宽字符是两字节的 UTF-16。因为不同平台有歧义，不建议使用。

# cout
与 Windows 命令行进行输入输出沟通时，应该使用 fromLocal8Bit （获取命令行输入）和 toLocal8Bit（输出到命令行）。
    Windows 系统里的 API 通常有两套同名的，比如 LoadLibrary 函数，这个名字只是一个宏定义，在 VC++ 环境，
对于 ANSI 多字节程序，它真实函数是 LoadLibraryA，
对于 Unicode 程序，它真实函数是 LoadLibraryW。
    如果读者以后遇到需要和 Windows API 函数打交道时，对于输入输出有乱码的，可以类似的测试一下 QString 的转码函数，
对于 ANSI 多字节程序的 API，一般可以用 fromLocal8Bit 和 toLocal8Bit 函数进行沟通；
对于 Unicode 程序的 API，可以用 fromUtf16 和 utf16 进行沟通，多试试就可以了。

对 Unix/Linux 系统就没那么多事，因为默认都是 UTF-8 的字符串。

# qDebug()
qDebug 可以正确显示 Utf8 、StdString 编码的字符串，当然还能智能打印 QString 对象的内容，会用双引号包起来。

%% qtcodec QTextCodec编码器
%% qtmess  乱码问题

3.2 使用 QString
================================================================================
C++ 基本类型和 QString 的互相转换、QString 涉及的运算符、QString 子串查询和操作、利用 QTextStream 对 QString 做输入输出操作等

tr 函数就是将 UTF-8 变长编码的字符串转成 QString 运行时的内码。
tr 函数不仅可以用于支持国际化翻译，并且能自动将字符串的存储交换格式 UTF-8 转换成运行时的 UTF-16 内码，返回转换过后得到的 QString 对象。
QString 内码是 UTF-16，而标准 C++ 的字符串是 UTF-8 编码的，Qt 针对标准 C++ 字符串也提供了 QByteArray 类，用于操作 UTF-8 编码以及其他本地化字符串、字节数组等
一是 long 和 ulong 长度是根据操作系统和编译器确定的，32 位编程就是 32 位，64 位编程就是 64 位；二是实数 qreal 默认情况下都是对应 double ，

   QString::QString(const char * str)
   QString::QString(const QByteArray & ba)
使用QByteArray或者str创建一个QString, QByteArray和str通过 QString::fromUtf8(const char * str, int size = -1)创建QString
   QString strAll = baAll.toHex();

基本类型与字符串互相转换
  QString toLower() const   
  QString arg(......) const
  toShort toUShort toInt toUInt toLong toULong toLongLong toULongLong toFloat toDouble
  
  'e'：科学计数法，小写 e，如 [-]9.9e[±]999。
  'E'：科学计数法，大写 E，如 [-]9.9E[±]999。
  'f'：定点数显示，[-]9.9。
  'g'：自动选择用科学计数法或定点数显示，哪种方式最简洁就用哪个，科学计数法的 e 小写。
  'G'：自动选择用科学计数法或定点数显示，哪种方式最简洁就用哪个，科学计数法的 E 大写。

字符串运算符
  = += > >= < <= == != []  + 

子串查询与操作
  QString &    append | prepend | insert | remove | replace 
  bool    startsWith | endsWith | contains
  int     count | indexOf | lastIndexOf
  QStringList    split
  QString    section | left | right | mid | fill | repeated | trimmed(前后) | simplified(前中后)
  QString    toLower() | toUpper()
  void    truncate(int position) | clear() | 从末尾删除：void chop(int n) | void swap(QString &other)
  
  Unicode 系列
    QString & setUnicode(const QChar *unicode, int size)            
    QString & setUtf16(const ushort *unicode, int size)             
    QString fromLatin1(const char *str, int size = -1)              QByteArray 	toLatin1() const
    QString fromLocal8Bit(const char *str, int size = -1)           QByteArray 	toLocal8Bit() const
    QString fromUcs4(const uint *unicode, int size = -1)            QVector<uint> 	toUcs4() const
    QString fromUcs4(const char32_t *str, int size = -1)            QVector<uint> 	toUcs4() const
    QString fromUtf8(const char *str, int size = -1)                QByteArray 	toUtf8() const
    QString fromUtf16(const ushort *unicode, int size = -1)         const ushort *QString::utf16() const
    QString fromWCharArray(const wchar_t *string, int size = -1)    int QString::toWCharArray(wchar_t *array) const
    
    QString fromStdString(const std::string &str)                   std::string 	toStdString() const
    QString fromStdU16String(const std::u16string &str)             std::u16string 	toStdU16String() const
    QString fromStdU32String(const std::u32string &str)             std::u32string 	toStdU32String() const
    QString fromStdWString(const std::wstring &str)                 std::wstring 	toStdWString() const

QTextStream配合字符串使用
  内存输出流
  QString strOut;
  QTextStream streamOut(&strOut);

%% testqstring

3.4 使用 QByteArray 
================================================================================
QByteArray和char

QByteArray作为字符串使用
    一般用 QString 来处理文本字符串，QByteArray 类没有 section 函数，所以字符串处理时优先用　QString　类。
    
QByteArray作为字节数组使用=
  QDataStream dsIn(baIn);                               # baIn(QByteArray)
  QDataStream dsOut(&baResult, QIODevice::ReadWrite);   # baResult(QByteArray)

%% testqbytearray

4.1 元对象系统 
================================================================================
是什么?
    元对象系统是 Qt 类库独有的功能，是Qt对标准 C++ 的扩展，并且元对象系统本身也是由纯C++语言写成的，所以学好C++是必须的。
完成功能?
    元对象系统最主要的一个功能就是实现信号和槽，窗体和控件对象之间的沟通一般都使用信号和槽，这是非常核心的东西
    Qt 元对象系统实现了对象之间通信机制 -- 信号和槽，并提供了运行时类型信息和动态属性系统。
使用元对象系统的前提?
    直接或间接地以 QObject 为基类，这样才能利用元对象系统的功能，Qt 的窗体和控件最顶层的基类都是 QObject。
    将 Q_OBJECT 放在类声明的私有段落，以启用元对象特性，如动态属性、信号和槽等。
    元对象编译器(Meta-Object Compiler，moc)为每个 QObject 的子类提供必要的代码以实现元对象特性。
元对象系统提供的特性?
    QObject::metaObject() 函数返回当前类对象关联的元对象(meta-object)。
    QMetaObject::className() 函数返回当前对象的类名称字符串，而不需要 C++ 编译器原生的运行时类型信息支持
    QObject::inherits() 函数判断当前对象是否从某个基类派生，判断某个基类是否位于从 QObject 到对象当前类的继承树上。
    QObject::tr() 和 QObject::trUtf8() 函数负责翻译国际化字符串
    QObject::setProperty() 和 QObject::property() 函数用于动态设置和获取属性，都通过属性名称字符串来 操作。
    QMetaObject::newInstance() 构建一个当前类的新实例对象。
    元对象系统还提供了 qobject_cast() 函数，可以对基于 QObject 的类对象进行转换，qobject_cast() 函数功能类似标准 C++ 的 dynamic_cast()。
    

private slots:
void Widget::on_hungryButton_clicked() 槽函数
void 类名称::on_实例名称_信号名称()    槽函数
void 类名称::on_<object name>_<signal name>(<signal parameters>);

%% 按钮弹窗手动关联          hungry
%% 按钮弹窗自动关联          autoconn
 
4.2 使用原有的信号和槽 
================================================================================
QMetaObject::connectSlotsByName(Widget);
    connectSlotsByName 就是完成自动关联的函数，这是元对象系统包含的功能，根据对象名、信号名与 
on_<object name>_<signal name>(<signal parameters>) 槽函数进行自动匹配关联，可以给程序员提供便利，
省了许多 connect 函数调用的代码。
    自动关联一般用于一个窗体之内的控件关联，其他很多情况都是需要手动编写 connect 函数的.
# 注意不要对同样的信号和槽重复调用 connect 函数，那样会生成多个不同的连接对象，导致一次信号会触发多次同样的槽函数。
                        函数指针                     函数指针
connect(ui->pushButton, &QPushButton::clicked, this, &Widget::FoodIsComing);           //新式语法
connect(ui->pushButton, SIGNAL(clicked()),     this, SLOT(FoodIsComing()));            //旧式语法
                        字符串                       字符串

0. 文本同步
connect(ui->lineEdit, SIGNAL(textEdited(QString)), ui->label, SLOT(setText(QString)));

1. 一关联多
connect(ui->lineEdit, SIGNAL(textEdited(QString)), ui->label, SLOT(setText(QString)));         # QLineEdit 信号 -> QLabel 槽
connect(ui->lineEdit, SIGNAL(textEdited(QString)), ui->textBrowser, SLOT(setText(QString)));   # QLineEdit 信号 -> QTextBrowser 槽
connect(ui->lineEdit, SIGNAL(textEdited(QString)), this, SLOT(PrintText(QString)));            # QLineEdit 信号 -> Widget 自定义PrintText函数

2. 多关联一
connect(ui->pushButtonAnderson, SIGNAL(clicked()), this, SLOT(FoodIsComing()));
connect(ui->pushButtonBruce, SIGNAL(clicked()), this, SLOT(FoodIsComing()));
connect(ui->pushButtonCastiel, SIGNAL(clicked()), this, SLOT(FoodIsComing()));

QString strObjectSrc = this->sender()->objectName(); # "pushButtonAnderson" "pushButtonBruce" "pushButtonCastiel"

QObject * QObject::​sender() const
    并且它是个 [protected] 保护类型的函数，在该类及其派生类之外是不能访问的。该函数返回通用基类 QObject * 指针，
可以通过 QObject 类对象的 objectName() 函数获取该对象的名称。

3. 解除关联示例
   connect(ui->lineEdit, SIGNAL(textEdited(QString)), ui->label, SLOT(setText(QString)));
disconnect(ui->lineEdit, SIGNAL(textEdited(QString)), ui->label, SLOT(setText(QString)));

%% 文本同步    textshow
%% 一对多关联  textmulti
%% 多对一关联  multiconsumer

4.3 自定义信号和槽 
================================================================================
通过信号和槽机制通信，通信的源头和接收端之间是松耦合的：
    源头只需要顾自己发信号就行，不用管谁会接收信号；
    接收端只需要关联自己感兴趣的信号，其他的信号都不管；
    只要源头发了信号，关联该信号的接收端全都会收到该信号，并执行相应的槽函数。

# 通过自定义信号和槽沟通 -- 已定义信号 -> 自定义槽函数(自定义信号函数) -> 自定义槽函数
1. 信号 -> 槽函数 (转发)
Widget w;   //①主窗体对象，内部会发送 SendMsg 信号
ShowMsg s;  //②接收端对象，有槽函数 RecvMsg
QObject::connect(&w, SIGNAL(SendMsg(QString)), &s, SLOT(RecvMsg(QString))); //③关联，信号里的字符串参数会自动传递给槽函数

2. 信号 -> 槽函数 (发起)
connect(ui->pushButton, SIGNAL(clicked()), this, SLOT(ButtonClicked())); // 关联
void Widget::ButtonClicked(){                    // 接收来自 Button 点击的 槽处理函数
    emit SendMsg( tr("This is the message!") );  // 用 emit 发信号
}

<Widget>          (emit 槽函数发送信号)
signals:    //添加自定义的信号
    void SendMsg(QString str);  //信号只需要声明，不要给信号写实体代码

<ShowMsg>
public slots:     (接收来自QWidget的信号)
    void RecvMsg(QString str);  //接收 SendMsg 信号的槽函数

    
# 信号关联到信号示例 -- 已定义信号 -> 自定义信号函数 -> 自定义槽函数
1. 信号 -> 新信号
connect(ui->pushButton, SIGNAL(clicked()), this, SIGNAL(SendVoid()));

2. 信号 -> 槽函数
Widget w;                                                       //①源头对象，内部发送信号 SendVoid()
ShowVoid s;                                                     //②接收对象，有对应槽函数　RecvVoid()
QObject::connect(&w, SIGNAL(SendVoid()), &s, SLOT(RecvVoid())); //③关联源头的信号和接收端的槽函数

3. 槽处理函数
void ShowVoid::RecvVoid(){
    QMessageBox::information(NULL, tr("Show"), tr("Just void."));
}

%% 自定义信号和槽沟通   qobjcom
%% 信号关联到信号       signalsconn

4.4 属性系统 
可以获得类字符串名称 QMetaObject; QObject::metaObject();
可以获得实例字符串名称 QObject::objectName(); 继承关系QObject::inherits();
可以获得和修改类成员变量值 QObject::setProperty()和 QObject::property()  动态属性 w.dynamicPropertyNames();
可以获得Q_CLASSINFO类信息 QMetaObject::classInfoCount();  QMetaObject::classInfo(i);  QMetaClassInfo::name() QMetaClassInfo::value()
================================================================================
# 普通属性示例 
set 函数可以作为槽函数，方便接收相关对象的信号以实现自动调整，
set 函数会导致成员变量数值变化，为了通知相关对象，set 函数里通常会 emit 该成员变量发生变化的信号。

Q_PROPERTY(type name
           READ getFunction
           [WRITE setFunction]
           [RESET resetFunction]
           [NOTIFY notifySignal] )
Q_PROPERTY()宏就是属性的声明：
  type 是指属性的类型，可以是 C++ 标准类型、类名、结构体、枚举等，name 就是属性的名字。
  READ 标出该属性的读函数 getFunction，Qt 属性的读函数通常省略 get 三个字母。
  WRITE 标出该属性的写函数 setFunction，
  RESET 标出该属性的重置函数 resetFunction，
  NOTIFY 标出该属性变化时发出的通知信号 notifySignal，

    对于属性用到的数值会存在一个真正的私有成员变量里面，私有成员变量、读函数、写函数、
信号等需要另外编写这些声明，对于函数还需要编写实体代码。

Q_PROPERTY(type name                 // 接口变量名 -> Q_PROPERTY是类内私有成员变量的接口声明宏。是读写、重置和通知通用机制的声明方式
           MEMBER memberName         // 类内私有成员变量名
           [READ getFunction]        // 省略不写，moc系统自动生成
           [WRITE setFunction]       // 省略不写，moc系统自动生成 (可以作为槽函数) -- moc自动生成写函数不能作为槽函数
           [RESET resetFunction]     // 自己声明，并编写相关代码
           [NOTIFY notifySignal] )   // 自己声明，并编写相关代码 (在setFunction被调用时，可能会触发notifySignal信号)
这里的 MEMBER 标出属性使用的成员变量 memberName

    在明确标出属性使用的成员变量的情况下，属性的读写函数可以省略不写，Qt 的 moc 工具会
自动为成员变量生成读写代码；而重置函数、信号等需要自己声明，并编写必须的代码；
    如果声明了属性值变化的通知信号，那么 moc 工具生成的写属性代码会自动触发该通知信号。

//不直接标出成员变量的形式
Q_PROPERTY(QString nickName READ nickName WRITE setNickName NOTIFY nickNameChanged)
//直接标出成员变量的形式
Q_PROPERTY(int count MEMBER m_count READ count WRITE setCount NOTIFY countChanged)
//标出成员变量，可以省略读写函数
Q_PROPERTY(double value MEMBER m_value NOTIFY valueChanged)

# 对 Q_PROPERTY(double value MEMBER m_value NOTIFY valueChanged) 的说明 
   moc 工具自动生成的读写代码仅仅是代码片段，没有函数的，自然没有相关的槽函数，
所以如果希望把写函数作为槽函数来用，就得用类似 count 属性的声明，并自己编读写函数的实体代码。

属性通用的函数：setProperty() 写属性，property() 读属性，都是通过属性的名称来寻找特定属性实现读写。
注意由于上面的 value 属性没有声明读写函数，所以对它的读写只能靠 setProperty() 和 property() 函数，这对通用的属性读写函数的声明如下：
bool QObject::​setProperty(const char * name, const QVariant & value)
QVariant QObject::​property(const char * name) const

# 动态属性示例
    不仅在源代码里面添加属性声明，程序运行时也可以通过 setProperty() 函数为当前类对象添加动态属性，
获取动态属性的值也是用 property() 函数。获取全部的动态属性名称列表可以通过 ​dynamicPropertyNames 函数：
QList<QByteArray> QObject::​dynamicPropertyNames() const
​dynamicPropertyNames 返回当前所有动态属性名称字符串的列表。

Widget w;
//如果动态属性不存在，QVariant 对象的 isValid() 函数返回 false，变量不可用
qDebug()<<w.property("myValue").isValid();    // false

//添加属性 myValue
w.setProperty("myValue", 2.3456);
//获取并打印
qDebug()<<w.property("myValue").toDouble();   // 2.3456 

//添加属性 myName
w.setProperty("myName", "Wid");
//获取并打印
qDebug()<<w.property("myName").toString();   // "Wid"

//获取所有动态属性名称，打印名称列表
qDebug()<<w.dynamicPropertyNames();          // ("myValue", "myName") 


# 类的附加信息
    Qt 程序运行时可以查询当前对象的名称。运行时还可以查询类的信息，主要包括两种类信息，
一种是基本的类信息，Qt 类会自动生成这些信息，包括当前类名、继承树上的基类名称等；
另一类是程序员手动添加的类附加信息，通过 Q_CLASSINFO() 宏，在类的声明里添加类附加信息.
    Q_CLASSINFO("Version", "1.0.0")
附加信息也是成对的“名称-值”，不过注意 名称和值 都是普通字符串。

2. 附加信息 -- 依赖 Q_CLASSINFO("Version", "1.0.0")
const QMetaObject * QObject::​metaObject() const               [virtual]
QMetaClassInfo QMetaObject::​classInfo(int index) const

Widget w;
//获取类的附加信息
const QMetaObject *pMO = w.metaObject();
//附加信息个数
int nInfoCount = pMO->classInfoCount();
//打印所有的附加信息
for(int i=0; i<nInfoCount; i++)
{
    QMetaClassInfo info = pMO->classInfo(i);
    qDebug()<<info.name()<<"\t"<<info.value();
}

1. 基本信息 -- 类名，实例名，继承关系
const char * QMetaObject::​className() const
bool QObject::​inherits(const char * className) const

//基本信息
qDebug()<<"Class Name: "<<pMO->className();
qDebug()<<"Object Name: "<<w.objectName();
//判断是否为基类
qDebug()<<w.inherits("QWidget");
qDebug()<<w.inherits("nothing");

%% 普通属性      normalpros
%% 动态属性      dynamicpros
%% 类的附加信息  classInfo
%% QWidgetDemo\battery 

4.5 扩展阅读：ui_*.h
================================================================================
# QMetaObject类
    每个QObject派生类都有一个QMetaObject实例，保存该派生类的元信息，可以通过QObject::metaObject()获取元对象。
  className() 返回类的名称字符串。
  superClass() 返回基类的元对象。
  method() 和 methodCount() 提供类的元方法的信息(元方法包括信号、槽和其他 invokable 成员函数)。
  enumerator() 和 enumeratorCount() 提供类里定义的枚举类型信息。
  propertyCount() 和 property() 提供类的属性信息。
  constructor() 和 constructorCount() 提供类的元构造函数信息。
    另外还有多个索引函数，能根据字符串名称检索元构造函数、元方法、枚举类型、属性等，函数名为： 
indexOfConstructor(), indexOfMethod(), indexOfEnumerator() 和 indexOfProperty() 。

# ui_*.h 代码 
编辑窗口部件、编辑信号/槽、编辑伙伴、编辑 Tab 顺序。

retranslateUi(Widget);
重新翻译界面，如果做了多国语言翻译，这个函数可以将界面翻译成其他语言显示。

%%  元对象系统   npcomplete

4.6 扩展阅读：moc_*.cpp代码
================================================================================
Q_OBJECT    Q_EMIT      Q_SLOTS      Q_SIGNALS

“Follow Symbol Under Cursor”


1. qt_meta_stringdata_Widget 静态字符串数据
2. qt_meta_data_Widget 数组
C:\Qt\Qt5.4.0\5.4\Src\qtbase\src\corelib\kernel\qmetaobject_p.h
  目录数据条目
  元方法数据条目
  属性条目
3. Widget::staticMetaObject 类的静态元对象
C:\Qt\Qt5.4.0\5.4\mingw491_32\include\QtCore\qobjectdefs.h
4. C:\Qt\Qt5.4.0\5.4\Src\qtbase\src\corelib\kernel\qobject.cpp
QMetaObject::Connection    connect(const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection)

QObject::connect(&w, SIGNAL(countChanged(int)), &s, SLOT(RecvCount(int)));
# define SLOT(a)     "1"#a
# define SIGNAL(a)   "2"#a
QObject::connect(&w, "2countChanged(int)", &s, "1RecvCount(int)");
    "1" 和 "2" ，称为方法类型代号，是用来区分信号和槽函数名称的，必须确保发送端一定是信号函数的名称字符串。
接收端既可以是信号，也可以是槽函数，要求相对宽松一些。


# normalizedSignature
QString retVal;
QByteArray normalizedSignature = QMetaObject::normalizedSignature("compute(QString, int, double)");
int methodIndex = obj->metaObject()->indexOfMethod(normalizedSignature);
QMetaMethod method = obj->metaObject()->method(methodIndex);
method.invoke(obj,
              Qt::DirectConnection,
              Q_RETURN_ARG(QString, retVal),
              Q_ARG(QString, "sqrt"),
              Q_ARG(int, 42),
              Q_ARG(double, 9.7));

其中，要使用QMetaObject::normalizedSignature()来规范化函数签名，确保方法签名是invoke()所期望的。

# connect(...) 调用过程
（1）判断输入参数 sender、receiver、signal、method，如果有一个为空，那么返回空连接。
（2）检查 sender 和 signal，把 signal 打头的字符解析为方法类型代号，比如 "2" 转成数值 2，如果是信号类型就继续，否则返 回空连接。
（3）跳过 signal 打头的数字字符，根据源头元对象 smeta、信号名、信号参数个数、信号参数类型等计算源头信号的相对序号（函数为 QMetaObjectPrivate::indexOfSignalRelative，返回序号保存到 signal_index）。
（4）如果信号相对序号是负数，说明没找到，那么把 signal 信号名做一下规范化（QMetaObject::normalizedSignature）， 去除多余空格等，然后
再用 QMetaObjectPrivate::indexOfSignalRelative 查一次信号的相对序号 signal_index。
（5）如果上面两次查询结果都是负数，没找到序号，打印警告，返回空连接；如果相对序号正确则继续。
（6）对相对序号 signal_index 做处理，如果是克隆信号就改为使用原始信号序号，否则就用前面的相对序号。
（7）把相对序号 signal_index 加上所有基类信号计数，变成新的绝对序号，后面 signal_index 就是信号的绝对序号。

（8）提取 method 打头的数字字符转成方法类型代号，比如 "1" 转成 1，"2" 转成 2，只要是槽代号或信号代号，那就继续，否则返回空连 接。
（9）跳过 method 打头的数字字符，根据接收函数的类型：
如果 method 是槽函数类型，使用 QMetaObjectPrivate::indexOfSlotRelative 函数计算槽函数相对序号 method_index_relative；
如果 method 是信号类型，那么使用 QMetaObjectPrivate::indexOfSignalRelative 函数计算信号的相对序号 method_index_relative。
（10）判断相对序号 method_index_relative 是否为负数，如果为负数，那么把接收函数名称做 规范化（QMetaObject::normalizedSignature），去除多余空格等，然后对规范化的接收函数名称：
如果是槽函数类型，那么使用 QMetaObjectPrivate::indexOfSlotRelative 函数计算槽函数相对序号 method_index_relative；
如果是信号类型，那么使用 QMetaObjectPrivate::indexOfSignalRelative 函数计算信号的相对序号 method_index_relative。
（11）如果上面计算的相对序号 method_index_relative 还是负数，说明没找到接收端的信号或槽函数，返回空连接；如果相对序号是正确的，那么继续。
（12）使用 QMetaObjectPrivate::checkConnectArgs 函数检查信号函数参数个数、类型与接收函数的参数个数、类型是否 能兼容，如果不兼容返回空连接，如果兼容就继续往下走。
（13）如果连接类型 type == Qt::QueuedConnection，那么使用 queuedConnectionTypes 函数计算入队关联需要的额外类型指针 types。
（14）如果没定义不能调试的宏 QT_NO_DEBUG，那么按下面三步再次检查源头信号和接受端函数：
①QMetaObjectPrivate::signal 函数根据源头元对象smeta和信号相对序号 signal_index，得到信号元方法 smethod；
②计算 method_index_relative + rmeta->methodOffset() ，也就是接收端的元方法绝对序号，然后通过 rmeta->method 函数得到接收端元方法 rmethod；
③检查源头元对象 smeta、元方法 smethod 、接收端元对象 rmeta、元方法 rmethod 是不是具有 QMetaMethod::Compatibility 特性。
（15）前面全都是参数判断和查询序号，最后才是关键的一步，进行实际的连接操作：
QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
    sender, signal_index, smeta, receiver, method_index_relative, rmeta ,type, types));
return handle;
真正的连接操作由 QMetaObjectPrivate::connect 函数完成，然后返回新的连接 handle 。

# connect 自动关联
void on_<object name>_<signal name>(<signal parameters>);
<object name> 是子控件名字，<signal name> 就是子控件的信号名。

5.1 按钮类的控件  (QGroupBox)
================================================================================
（1）按压按钮 QPushButton              text()   icon()   ​clicked()
（2）工具按钮 QToolButton              QButtonGroup 或者 QToolBar (快捷按钮)
%% /widgets/widgets/movie
QHBoxLayout + QToolButton(openButton, playButton, pauseButton, stopButton, quitButton)
  openButton->setIcon(style()->standardIcon(QStyle::SP_DialogOpenButton));
  openButton->setIconSize(iconSize);
  openButton->setToolTip(tr("Open File"));
  connect(openButton, SIGNAL(clicked()), this, SLOT(open()));
    
%% /widgets/widgets/calculator 计数器 
1. Button 继承自 QToolButton。 Button 和 QGridLayout 构成了计数器按钮布局
2. Button *clickedButton = qobject_cast<Button *>(sender()); # qobject_cast的使用
   int digitValue = clickedButton->text().toInt()
   QString clickedOperator = clickedButton->text();
   
%% widgets/graphicsview/diagramscene  QButtonGroup QToolBox
1. QAction 和 QMenu 关联关系 createMenus()
2. QAction 和 QToolBar 关联关系 createToolbars()
3. QToolButton 和 setPopupMode 产生菜单按钮 createToolbars() 有两个信号函数，一个是QToolButton按下，另一个是QAction被选中。功能一样
   fontColorToolButton  
   fillColorToolButton  
   lineColorToolButton  
4. QToolButton 按钮菜单 
   pointerButton
   linePointerButton
5. QToolBar   addWidget(QWidget * widget) 可以添加 QToolButton QComboBox
              addAction(QAction * action) 
%% MainWindowToolBar (跟小豆君学Qt) QToolBar 
QMenuBar 和 QToolBar 更像容器，QMenuBar可以添加QMenu和QAction; QMenu可以进一步添加QAction(形成菜单项)
                              QMenu可以添加QMenu和QAction; QMenu可以进一步添加QAction(形成菜单项)
在QMainWindow中通过 menuBar() 函数获得QMenuBar; 一个 QMenuBar 实例。
在QMainWindow中通过 addToolBar(tr("Edit")); 函数获得QToolBar; 多个 QToolBar 实例。
                               QToolBar 可以添加QWidget和QAction; QAction可以与菜单关联；QWidget是QToolButton QComboBox QFontComboBox 等等
6. QToolBox  %% widgets/dialogs/standarddialogs 
QToolBox管理多个QWidget，QWidget与之关联的QHBoxLayout，QHBoxLayout与多个控件关联
7. QButtonGroup + QToolButton 互斥按钮组 和 非互斥按钮


（3）单选按钮 QRadioButton             text()   isChecked()  setChecked(bool) + QButtonGroup + toggled(bool checked)
    connect(m_pGenderGroup, SIGNAL(buttonClicked(int)), this, SLOT(RecvGenderID(int)));
    connect(m_pStatusGroup, SIGNAL(buttonClicked(int)), this, SLOT(RecvStatusID(int)));
                void QButtonGroup::​buttonClicked(int id)
方法1: 将QButtonGroup和QRadioButton关系编码到初始化中       手动设计   QButtonGroup的信号函数  checkedId();

方法2: 将QButtonGroup和QRadioButton关系编码到ui_widget.h中  界面设计   QRadioButton的信号函数  isChecked()
QButtonGroup switch  分支策略
QRadioButton if-else 分支策略

（4）复选框 QCheckBox     二选按钮     isChecked()  setChecked(bool)  toggled(bool checked)  
                          三选开关     [setTristate(bool y = true) + bool isTristate()] ​
                          三选按钮     checkState() ​setCheckState(Qt::CheckState state) stateChanged(int state)
（5）命令链接按钮 QCommandLinkButton   description() setDescription(const QString & description)
                  QSring -> QUrl -> QDesktopServices::openUrl (QCommandLinkButton)
                                       bool QDesktopServices::​openUrl(const QUrl & url)
                                       QUrl::​QUrl(const QString & url, ParsingMode parsingMode = TolerantMode)
                                       QDesktopServices::openUrl( QUrl("file:///D:/QtProjects") );
                                       QDesktopServices::openUrl( QUrl("https://lug.ustc.edu.cn/sites/qtguide/") );

                                       
QCommandLinkButton 一般意味着进入下一个窗体或弹出网页浏览器访问网页链接。
QUrl 是用于描述网页链接或本地文件链接的类
QDesktopServices 不仅可以打开本地浏览器，而且还可以打开本地文件(夹)等，可以获取桌面、我的文档、Home等目录
# 获取桌面、我的文档、Home等目录的路径
  QString desktop_path = QDesktopServices::storageLocation(QDesktopServices::DesktopLocation);
  QString document_path = QDesktopServices::storageLocation(QDesktopServices::DocumentsLocation);
  QString home_path = QDesktopServices::storageLocation(QDesktopServices::HomeLocation);
  QString application_path = QDesktopServices::storageLocatio(QDesktopServices::ApplicationsLocation);
  QString temp_path = QDesktopServices::storageLocation(QDesktopServices::TempLocation);
%% fsbrowser
%% /widgets/dialogs/findfiles


（6）标准按钮盒 QDialogButtonBox 
%% widgets/draganddrop/dropsite 
%% /network/loopback
1. 用户自定义QPushButton
buttonBox->addButton(clearButton, QDialogButtonBox::ActionRole);
buttonBox->addButton(quitButton, QDialogButtonBox::RejectRole);

connect(quitButton, SIGNAL(pressed()), this, SLOT(close()));
connect(clearButton, SIGNAL(pressed()), dropArea, SLOT(clear()));
    
2. 构造函数自定义 QPushButton
buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok
                                 | QDialogButtonBox::Cancel);
connect(buttonBox, SIGNAL(accepted()), this, SLOT(accept()));
connect(buttonBox, SIGNAL(rejected()), this, SLOT(reject()));
以上Cancel按钮能成功响应slotButtonB()，Apply按钮无响应

Constant                            ValueDescription
QDialogButtonBox::InvalidRole       -1      The button is invalid.
QDialogButtonBox::AcceptRole        0       Clicking the button causes the dialog to be accepted (e.g. OK).
QDialogButtonBox::RejectRole        1       Clicking the button causes the dialog to be rejected (e.g. Cancel).
QDialogButtonBox::DestructiveRole   2       Clicking the button causes a destructive change (e.g. for Discarding Changes) and closes the dialog.
QDialogButtonBox::ActionRole        3       Clicking the button causes changes to the elements within the dialog.
QDialogButtonBox::HelpRole          4       The button can be clicked to request help.
QDialogButtonBox::YesRole           5       The button is a "Yes"-like button.
QDialogButtonBox::NoRole            6       The button is a "No"-like button.
QDialogButtonBox::ApplyRole         8       The button applies current changes.
QDialogButtonBox::ResetRole         7       The button resets the dialog's fields to default values.

%% widgets/dialogs/extension    扩展部分，通过QWidget的hide()  QWidget的setVisible()
    垂直按钮盒 buttonBox = new QDialogButtonBox(Qt::Vertical); 自定义 findButton 和 moreButton 按钮
    
    
%% widgets/dialogs/tabdialog


%% QRadioButton 和 QButtonGroup       singleselection
%% QCheckBox    和 QCommandLinkButton multiselection
%% widgets/widgets/groupbox           QPushButton 按钮(普通按钮, 有状态按钮, 平铺按钮, 按钮菜单)
                                      QCheckBox 复选框(两状态, 三状态)
                                      QRadioButton 单选 ( 互斥单选按钮组 )
QGroupBox ( setCheckable(true);提供复选框 setChecked(false);复选功能为false )

%% widgets/graphicsview/diagramscene  QToolButton 和 QButtonGroup 

QRadioButton 和 QCheckBox的触发是有状态的，通过 isChecked()检查状态   setChecked(bool)设置状态
                                           通过 checkState()检查状态  setCheckState(state)设置状态
QPushButton  和 QCommandLinkButton 的触发是无状态的，正常情况下，触发后恢复到触发前状态

%% widgets/layouts/basiclayouts      QGroupBox QHBoxLayout QPushButton       平铺按钮组
                                     QGroupBox QGridLayout QLabel+QLineEdit  输入对话框
                                     QGroupBox QFormLayout QLabel+QLineEdit
                                                           QLabel+QComboBox
                                                           QLabel+QSpinBox

如果在Qt中，则会分别发出一个clicked()信号和toggled()信号。按钮被按下时会发出pressed()信号，按钮松开时会发出released()信号。

5.2 单行编辑控件 
================================================================================
QLineEdit 类       text() maxLength() textEdited(const QString & text) editingFinished()  selectedText() const
                   widget/widget/lineedits  EchoMode Validator Alignment InputMask ReadOnly
                   login void setEchoMode(EchoMode) + QByteArray QCryptographicHash::​hash(const QByteArray & data, Algorithm method) 散列保存
                   netparas                                           setInputMask(const QString & inputMask)
                   netparas                      QIntValidator(int minimum, int maximum, QObject * parent = 0) + void QIntValidator::​setRange(int bottom, int top)
                   netparas                      QDoubleValidator(double bottom, double top, int decimals, QObject * parent = 0) + setRange(double minimum, double maximum, int decimals = 0)
                   netparas                      QRegExpValidator(const QRegExp & rx, QObject * parent = 0) + QRegExp(const QString & pattern, Qt::CaseSensitivity cs = Qt::CaseSensitive, PatternSyntax syntax = RegExp)
                   netparas                      

形神兼备: 形: EchoMode Validator Alignment InputMask ReadOnly 
          形: 函数参数多为bool值，枚举值，模式匹配(或者设定范围)
          神: text()  setText()  textEdited(QString &)  editingFinished()  selectedText()
          神: 值的变化会产生各种类型的信号，并且值内容可以通过界面修改
          形会限制神的内容，形也会限制神的显示。
          
%% widget/widget/lineedits 密码模式 数据验证器 居座中右功能 掩码功能 只读功能
%% widgets/widgets/calculator(计数器)   QLineEdit 和 QFont

%% 密码登录框              login
%% 数据验证器和伙伴快捷键  netparas
%% 单词补全                completer
QCompleter(QAbstractItemModel * model, QObject * parent = 0)
QCompleter(const QStringList & list, QObject * parent = 0)
void setCaseSensitivity(Qt::CaseSensitivity caseSensitivity)
void setCompletionMode(CompletionMode mode) 

5.3 丰富文本编辑控件
================================================================================
# QTextEdit
void setHtml(const QString & text)
void setPlainText(const QString & text)
void setText(const QString & text)

QTextEdit对象的光标所在的位置字体改变时，会发射currentCharFormatChanged()信号
void QTextEdit::​currentCharFormatChanged(const QTextCharFormat & f)


%% 简易文本编辑器 simpleeditor
//设置二态按钮
ui->pushButtonBold->setCheckable(true);     //粗体

# void Widget::on_textEdit_currentCharFormatChanged(const QTextCharFormat &format)
<QIntValidator> 包含整数验证器类，用于限定字号的范围。
<QFont> 包含综合字体格式类，用于感知或设置文本格式。
<QColorDialog> 包含颜色设置对话框，提供给用户选取文字前景色或者背景色。
<QBrush> 包含画刷类，在进行颜色感知时，需要通过前景色画刷和背景色画刷来感知。

函数参数里的 format 就是光标当前指向的位置或选中的文本片段的格式信息。
通过 format.fontWeight() 来判断字体格式是否为粗体 QFont::Bold，如果是粗体就同步设置 "粗体" 按钮的状态为 true，否则为 false。
通过 format.fontItalic() 来判断斜体状态，同步设置 "斜体" 按钮的状态。
通过 format.fontUnderline() 来判断是否有下划线，同步设置 "下划线" 按钮的状态。


# QTextBrowser 
virtual void setSource(const QUrl & name) 
void sourceChanged(const QUrl & src) 
%% 简易 HTML 查看器  simplebrower

5.4 其他输入控件
================================================================================
（1）组合框 QComboBox (可被编辑|不可被编辑) (槽处理函数参数为字符串|为数值)
void addItem(const QIcon & icon, const QString & text, const QVariant & userData = QVariant())
                   可选          必选                  可选(序号和字符串关联的数据)

QComboBox->setValidator 也有验证器
QFontComboBox && QFontDialog QFont 包括字体大小，加粗，倾斜，下划线

# (槽处理函数参数为字符串|为数值)
int currentIndex() const
void setCurrentIndex(int index)
选中的序号变化后发送信号：
void currentIndexChanged(int index)
void currentIndexChanged(const QString & text)

QString currentText() const
void setCurrentText(const QString & text)
当组合框内部包含的单行编辑器的文本发生改变时触发信号：
void currentTextChanged(const QString & text)

# (可被编辑|不可被编辑)
bool isEditable() const
void setEditable(bool editable)

# (下拉可见item最大值)
int maxVisibleItems() const
void setMaxVisibleItems(int maxItems)

# index -> QIcon QString userData
void setItemData(int index, const QVariant & value, int role = Qt::UserRole)
QVariant itemData(int index, int role = Qt::UserRole) const
QIcon   itemIcon(int index) const
QString itemText(int index) const

# QString -> index
QComboBox.findText('dsfds') #返回 内容为dsfds的索引
%%  /widgets/dialogs/findfiles


%% 卖盒饭示例  snacks QComboBox 盒饭
形神兼备: 形: 可被编辑|不可被编辑  下拉可见item最大值  icon(显示扩展)  userData(关联用户数据)
          神: currentIndex()及信号 currentText()及信号 activated(int)信号

# 用户手动编辑的内容，一般不在下拉列表里，就不触发序号改变的信号，而只会触发当前文本属性变化的信号 currentTextChanged(QString)。
    对于可编辑的组合框，用户完全可以手动输入下拉列表之外的文本，然后可以用信号 
currentTextChanged(QString) 或者用 currentText() 获取当前文本。
    editable 属性为 true 时，不仅仅能允许用户自定义内部编辑框里的内容，如果用户
手动输入了下拉列表之外的内容，并且在内部编辑框里面按下 Enter 回车键，那么用户
新编辑的文本条目会自动添加到组合框的下拉列表里面。也就是说，程序运行时，用户可以
手动新增条目到下拉列表里，所需操作就是输入新条目并按回车键。

%% 个人信息收集   infogather   -- 可编辑setEditable(true); 和 不可以编辑的(默认是不可以编辑的)
%% widget/widget/lineedits 密码模式选择 数据验证器选择 居座中右功能选择 掩码功能选择 只读功能选择
        QComboBox::addItem 调用顺序决定 echoChanged(int index) 槽处理函数中参数 index 的值，从0开始累计
QComboBox 也是有状态的，通过 setCurrentIndex(int index) 和 setCurrentText(const QString & text) 修改当前状态
                        通过 currentIndex() 和 currentText() 获得当前状态
                        activated(int)
                        currentIndexChanged(const QString & text)

1.函数说明
QComboBox的activated与currentIndexChanged两个Signal都是改变选择时触发的信号,它们分别有两个重载版本，
void activated ( int index )
void activated ( const QString & text )
void currentIndexChanged ( int index )
void currentIndexChanged ( const QString & text )
int类型代表了下拉框被选中项的索引，QString类型代表了下拉框被选中项的内容。
2.信号差异
activated与currentIndexChanged之间有细微的差别:
信号activated           只要单击下拉框，即使所选内容前后没有变化也会触发此信号；
信号currentIndexChanged 是在单击下拉框且当所选内容发生变化时才会触发此信号。


（2）字体组合框 QFontComboBox
%% widgets/graphicsview/diagramscene
%% widgets/richtext/textedit

（3）计数器 QSpinBox -> 直接编辑数值还是通过上下箭头调整数值
Enter a value between -20 and 20          整数值 可以正负区间
Enter a zoom value between 0 and 1000%    整数值 可以有后缀
Enter a price between 0 and $99           整数值 可以有前缀

int value() const        值
void setValue(int val)   槽函数
void valueChanged(int i) 信号函数
void setSingleStep()

%%  widgets/widgets/spinboxes             整数值 createSpinBoxes
（4）浮点计数器 QDoubleSpinBox -> 直接编辑数值还是通过上下箭头调整数值 
Enter a value between -20 and 20           浮点数 可以正负区间
Enter a scale factor between 0 and 1000    浮点数 可以有后缀
Enter a price between between 0 and 1000   浮点数 可以有前缀

int value() const        值
void setValue(double  val)   槽函数
void valueChanged(int i) 信号函数

数值的精度 
int decimals() const
void setDecimals(int prec)

除了数值的范围，通常需要使用setSpecialValueText()给用户一个特殊（默认）的选择
scaleSpinBox->setSpecialValueText(tr("No scaling"));

%%  widgets/widgets/spinboxes             整数值 createDoubleSpinBoxes

（5）时间编辑器 QTimeEdit
（6）日期编辑器 QDateEdit
（7）日期时间编辑器 QDateTimeEdit
(5) QTimeEdit  QTime::currentTime()
           QTime(9, 0, 0, 0)                 timeEdit->minimumTime().toString(Qt::ISODate)
           存在minimumTime()和maximumTime()  QTimeEdit->QTime->QString
           setTimeRange(QTimeMin, QTimeMax) 
           
void timeChanged(const QTime & time)  信号函数
void setTime(const QTime & time)      槽函数

%%  widgets/widgets/spinboxes             整数值 createDateTimeEdits
(6) QDateEdit  QDate::currentDate()
           QDate(2005, 1, 1)                 dateEdit->minimumDate().toString(Qt::ISODate)
           存在minimumDate()和maximumDate()  QDateEdit->QDate->QString
           setDateRange(QDateMin, QDateMax) 
void dateChanged(const QDate & date)  信号函数
void setDate(const QDate & date)      槽函数

bool calendarPopup() const
void setCalendarPopup(bool enable)

# QDateTime 转换为 QString
QDateTime time = QDateTime::currentDateTime();  
QString strBuffer = time.toString("yyyy-MM-dd hh:mm:ss");  
# QString 转换为 QDateTime
QString strBuffer = "2010-07-02 17:35:00";  
QDateTime time = QDateTime::fromString(strBuffer, "yyyy-MM-dd hh:mm:ss");  

# date
d     1 to 31
dd    01 to 31
ddd   'Mon' to 'Sun'
dddd  'Monday' to 'Qt::Sunday'

M     1-12
MM    01-12
MMM   'Jan' to 'Dec'
MMMM  'January' to 'December'

yy    00-99
yyyy  0000-9999

# Time
h     0 to 23
hh    00 to 23
m     0 to 59
mm    00 to 59
s     0 to 59
ss    00 to 59
z     0 to 999
zzz   000 to 999
AP    "AM" or "PM"
ap    "am" or "pm"

%% 个人信息收集   infogather  中有 ui->dateEdit->setCalendarPopup(true); 设置日期编辑器在编辑时自动弹出日历

%%  widgets/widgets/spinboxes             整数值 createDateTimeEdits
(7) QDateTimeEdit   ==== QDateTime::currentDateTime();
QComboBox->addItem();
               "yyyy-MM-dd hh:mm:ss (zzz 'ms')"
               "hh:mm:ss MM/dd/yyyy"
               "hh:mm:ss dd/MM/yyyy"
               "hh:mm:ss"
               "hh:mm ap"
connect(formatComboBox, SIGNAL(activated(QString)), this, SLOT(setFormatString(QString)));
meetingEdit->setDisplayFormat(formatString); formatString就是setFormatString(QString)中指定的字符串

Sections displayedSections() const; Date显示掩码 或者 Time显示掩码
    DateSections_Mask = DaySection|MonthSection|YearSection
    TimeSections_Mask = AmPmSection|MSecSection|SecondSection|MinuteSection|HourSection,

meetingEdit->setDateRange(QDate(2004, 11, 1), QDate(2005, 11, 30));
meetingEdit->setTimeRange(QTime(0, 7, 20, 0), QTime(21, 0, 0, 0));
meetingEdit->minimumDate().toString(Qt::ISODate)
meetingEdit->maximumDate().toString(Qt::ISODate)
meetingEdit->minimumTime().toString(Qt::ISODate)
meetingEdit->maximumTime().toString(Qt::ISODate)

void setDateTime(const QDateTime & dateTime)      信号函数
void dateTimeChanged(const QDateTime & datetime)  槽函数

QDateTime ->date(QDate) + time(QTime)
QDate     ->year() month() day()
QTime     ->hour() minute() second() msec()

%%  widgets/widgets/spinboxes             整数值 createDateTimeEdits
================================================================================
父类 : QAbstractSlider
子类 : QDial, QScrollBar, and QSlider
QAbstractSlider的数值属性 value 访问函数是 value() ，设置函数是 setValue(int)，数值改变的信号是  valueChanged(int) 。
下限设置函数为  setMinimum() ，上限设置函数为  setMaximum()，
步进设置函数为 setSingleStep()， 单击左或右小箭头时，滑块变化的长度
大步进设置函数为  setPageStep()
QAbstractSlider::sliderReleased()  放开信号

公有槽函数
void setOrientation(Qt::Orientation)//代码创建的默认为竖直向的，需要横向的可设置这个，枚举值在下方  
void setRange(int min, int max)//设置值在变化范围，与setMinimun与setMaxmun两函数效果相同  
void setValue(int)

信号函数：
void    actionTriggered(int action)  
void    rangeChanged(int min, int max)  
void    sliderMoved(int value)  
void    sliderPressed()  
void    sliderReleased()  
void    valueChanged(int value)//一般使用这个

（8）转盘 QDial
QDial同Qslider类似，也多了个notch(刻痕)的概念

1. 刻痕
qreal   notchTarget() const 
bool notchesVisible() const 
void setNotchTarget(double target)//notch target指两刻度之间的像素距离，默认3.7px
2. 回绕
bool wrapping() const
void setWrapping(bool on)

（9）滚动条 QScrollBar
QScrollBar的公有函数只有构造函数：

void setOrientation(Qt::Orientation)      水平方向为 Qt::Horizontal，垂直方向为 Qt::Vertical

# Qt 有专门的类 QScrollArea ，它既有水平滚动条，也有垂直滚动条，如果确实需要自己添加滚动条，
scrollArea = new QScrollArea;
characterWidget = new CharacterWidget;
scrollArea->setWidget(characterWidget);

%% widgets/widgets/imageviewer
%% widgets/widgets/charactermap 

（10）滑动条 QSlider
QSlider相比QScrollBar而言，多出了tick（记号，翻译成刻度比较好），它在中心线的两端加了刻度用于标记值。
刻度位置的枚举值enum QSlider::TickPosition
QSlider::NoTicks            0           无刻度，默认
QSlider::TicksBothSides     3           中线两端绘制
QSlider::TicksAbove         1           绘制线的上方
QSlider::TicksBelow         2           线下方
QSlider::TicksLeft          TicksAbove  线左方
QSlider::TicksRight         TicksBelow  线右方

int tickInterval() const
void setTickInterval(int ti)
tickInterval 默认值为 0，如果 tickPosition 确定要画刻度，那么刻度间距的数值自动从小步进 singleStep 和大步进 pageStep 之间挑。

（11）快捷键编辑器 QKeySequenceEdit

%% 卖盒饭示例 snacks
%% widgets/layouts/dynamiclayouts   QSpinBox QSlider QDial QProgressBar 都有valueChanged和setValue  信号和槽处理函数
%% widgets/widgets/sliders          QSlider  QScrollBar QDial 
形神兼备 形: QSlider  QScrollBar QDial 
         形: 水平|垂直方向， 回绕  刻痕
         神: valueChanged(int) 信号 setValue(int) 槽 value() 值
         
         

5.5 显示类的控件
父类 QFrame
子类 QAbstractScrollArea, QLabel, QLCDNumber, QSplitter, QStackedWidget, and QToolBox.

父类 QAbstractScrollArea
子类  QColumnView, QHeaderView, QListView, QTableView, and QTreeView.
================================================================================
(1) 标签控件 QLabel # 显示丰富文本，利用 Qt Style Sheet 设置前景色、背景色，为伙伴控件设置快捷键
                    # 图片既可以是静态的 BMP、JPG、PNG 等，也可以是动态图格式如 GIF、MNG
1. QPixmap
    m_pPixMap = new QPixmap();
    m_pPixMap->load(strFileName)
    ui->labelShow->setPixmap(*m_pPixMap);
2. RichText
    setText(mimeData->html());
    setTextFormat(Qt::RichText);
3. PlainText
    setText(mimeData->text());    
    setTextFormat(Qt::PlainText);
4. QMovie
    m_pMovie = new QMovie(strFileName);
    ui->labelShow->setMovie(m_pMovie);

    //动态图的总帧数
    int nCount = m_pMovie->frameCount(); //如果动态图格式不支持计数，那么会返回 0
    m_pMovie->jumpToFrame(0)
    ui->labelShow->setGeometry( m_pMovie->frameRect()
     
    //播放出错信号
    connect(m_pMovie, SIGNAL(error(QImageReader::ImageReaderError)),this, SLOT(RecvPlayError(QImageReader::ImageReaderError)));
    //播放的帧号变化信号
    connect(m_pMovie, SIGNAL(frameChanged(int)),this, SLOT(RecvFrameNumber(int)));
    
%% 图片浏览示例 imgshow
%% /widgets/widgets/movie  QToolButton(拥有icon的独立按钮，可以放在QGroupBox和QHBoxLayout)
                           QLabel + QString(Text)
                           QLabel + QMovie
connect(movie, SIGNAL(frameChanged(int)), this, SLOT(updateFrameSlider()));             # QMovie -> QSlider
connect(movie, SIGNAL(stateChanged(QMovie::MovieState)), this, SLOT(updateButtons()));  # QMovie -> QToolButton(playButton,pauseButton,stopButton,quitButton)
connect(fitCheckBox, SIGNAL(clicked()), this, SLOT(fitToWindow()));                     # QCheckBox(fitCheckBox) -> QMovie(setScaledContents)
connect(frameSlider, SIGNAL(valueChanged(int)), this, SLOT(goToFrame(int)));            # QSlider *frameSlider -> QMovie(jumpToFrame)
connect(speedSpinBox, SIGNAL(valueChanged(int)), movie, SLOT(setSpeed(int)));           # QSpinBox *speedSpinBox; -> QMovie(setSpeed)

https://zhuanlan.zhihu.com/p/29250898
%% E:\Qt\journey of qt\lesson-6\DisplayWidget  QLabel各种属性配置

(2) 丰富文本浏览控件 QTextBrowser
%% widgets/richtext/calendar  QTextBrowser -> QTextCursor + QTextTableFormat.setColumnWidthConstraints(QVector<QTextLength>) 
                                              QTextCursor.insertTable(1, 7, tableFormat);
                                              QTextFrame
                                              QTextFrameFormat
                                              QTextCharFormat
                                              QTextTableCell
%% widgets/layouts/borderlayout
QTextBrowser *centralWidget = new QTextBrowser;
centralWidget->setPlainText(tr("Central widget"));

(3) 图形视图 QGraphicsView
(4) 日历控件 QCalendarWidget
%% widgets/widgets/calendarwidget  主控件由于属性变化影响子控件；子控件由于属性编码影响主控件
connect(calendar, SIGNAL(currentPageChanged(int,int)), this, SLOT(reformatCalendarPage())); 月页跳转

connect(localeCombo, SIGNAL(currentIndexChanged(int)),this, SLOT(localeChanged(int)));
connect(firstDayCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(firstDayChanged(int)));
connect(selectionModeCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(selectionModeChanged(int)));
connect(gridCheckBox, SIGNAL(toggled(bool)), calendar, SLOT(setGridVisible(bool)));
connect(navigationCheckBox, SIGNAL(toggled(bool)), calendar, SLOT(setNavigationBarVisible(bool)));
connect(horizontalHeaderCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(horizontalHeaderChanged(int)));
connect(verticalHeaderCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(verticalHeaderChanged(int)));

(5) LCD 数字显示 QLCDNumber
%% 电子钟示例 timeshow
1. QTimer 周期定时器
%% widgets/widgets/digitalclock   QTimer QLCDNumber
1. QTimer 周期定时器

# QTimer 
widgets/widgets/analogclock 

(6) 进度条 QProgressBar
%% widgets/widgets/styles           widgetgallery.c createProgressBar()
%% widgets/layouts/dynamiclayouts   QSpinBox QSlider QDial QProgressBar
%% /widgets/dialogs/findfiles        QProgressDialog ( findFiles函数 )


(7) 线条 Line
(8) OpenGL 三维绘图控件 QOpenGLWidget
(9) 网页浏览视图 QWebView

5.6 Qt 资源文件
================================================================================
资源编译器 rcc 的使用，以及图片和 *.qrc 文件是如何集成到应用程序里

# Qt 资源系统
1. *.qrc 和 *.rcc 的差别？
    一般超过 4 MB 的图片、音视频、压缩包等文件就不建议放进资源文件 *.qrc 里面，
可以放在操作系统的文件夹里或者编译成独立的二进制资源文件 *.rcc.
2. qmake rcc QFile 和 虚拟文件系统？
    Qt 资源系统基于 qmake、rcc(Qt's resource compiler) 和 QFile 三方面紧密协作，
让资源文件的使用与普通操作系统里的文件使用方式很相似，Qt 应用程序内部的资源文件有
一套自己的虚拟文件系统，文件路径类似 ":/pic.png" ，冒号打头的就是代表目标程序内嵌
的资源文件，注意目标程序里所有内嵌的资源文件都是只读的.
    Qt 的资源系统通过 *.qrc 文件描述，是程序源代码的一部分，
                      *.qrc 文件通常放在与项目源代码一样的文件夹里。
                      *.qrc 文件与 *.ui 文件有相似的地方，都是 XML 格式的文本。
3. QFile 虚拟文件系统 文件别名？
程序使用资源文件的过程分两阶段，
    第一阶段是在编写程序代码之前用 *.qrc 表述程序需要用到的图片、文档等资源，
    第二阶段是如何在代码中引用 widget.qrc 里面描述的图片、文档等文件，Qt 资源系统
有自己的一套虚拟文件系统，对于刚才的 images/copy.png 图片，使用目标程序里对应的
内嵌资源文件，就以路径 ":/images/copy.png" 访问，加了冒号和右斜杠打头，代表虚拟文件系统的路径。
对于 QFile 等访问文件的类，就可以将 ":/images/copy.png" 作为路径文件名打开该图片了。
    QFile("qrc:///images/copy.png") 等同于 QFile(":/images/copy.png")
使用哪种形式，要看控件类的函数是接收文件路径形式还是 URL 路径形式。

<qresource prefix="/myresources">
    <file alias="cut-img.png">images/cut.png</file>
</qresource>
这三句同时用了别名和前缀，对应的文件虚拟路径为：
":/myresources/cut-img.png"  和 ":/myresources/images/cut.png" 。
    
# rcc 工具
    Qt 自带的开发工具集里有专门的 rcc 工具，用于将 *.qrc 里面描述的图片、文档等编译成对应的源代码文件 qrc_*.cpp 
或者独立的二进制资源文件 *.rcc。
1. 生成独立的二进制资源文件 *.rcc
rcc -binary myresource.qrc -o myresource.rcc
    rcc 会把 myresource.qrc 里面描述的所有图片、视频等文件，都压缩打包，生成一个二进制的 myresource.rcc 文件，

那么代码中如何使用 myresource.rcc 呢？
    需要在 main 函数开始的位置注册这个独立的二进制资源文件：
    QResource::registerResource("/path/to/myresource.rcc");
然后也是使用之前类似的虚拟文件路径，比如 ":/images/copy.png" 、":/images/cat.gif" 。
二进制资源文件 *.rcc 是用于外挂的，其实应用程序里面更常见的是内嵌资源，接下来介绍内嵌使用方式。

2. 应用程序内嵌资源
一个资源描述文件 application.qrc 在程序编译时内嵌到目标程序里，需要在 *.pro 文件里加一句话：
    RESOURCES += application.qrc
qmake 会自动根据这句话，为 application.qrc 添加编译脚本，
    application.qrc (引用: image/copy.png image/cut.png image/new.png )
    rcc application.qrc    -> application.cpp  # rcc -name application  application.qrc -o qrc_application.cpp
    g++ -c application.cpp -> application.o
    g++ application.o ... other.o -o application
    
    如果出现使用了正确的文件路径 ":/images/copy.png" 却找不到资源里图片文件的情况，
那么需要在使用该资源的类声明里或者在 main 函数里打头的位置加入一句手动初始化：
    Q_INIT_RESOURCE(resources);
resources 是指 resources.qrc 的简短名字形式，不需要扩展名。
    
3. QIcon、QImage、QPixmap
    对于配合按钮、组合框、菜单项、工具条等图标的加载，使用 QIcon 类读取资源文件里的图片，
因为按钮的尺寸比较小，这类图标图片也比较小，比如 16*16 或者 24*24、32*32 。
    QImage 倾向于图片文件本身内容的加载，与桌面系统和显示器无关，并且尊重图片原本的格式和颜色深度，
不会自动修改图片内容格式，一般用于图像处理。
    QPixmap 侧重屏幕显示，与桌面系统和显示器是有关的，通常会自动把加载的图片转成桌面系统设置的
真彩色像素图，QPixmap 像素点的颜色深度一般是固定的，比如 32 位真彩色，QPixmap 专门用于配合控件的显示用途。
QLabel 控件就是使用 QPixmap 像素图显示图片.

QIcon
# QCombobox
void addItem(const QIcon & icon, const QString & text, const QVariant & userData = QVariant())
#  QCheckBox, QPushButton, QRadioButton
QIcon icon() const
void  setIcon(const QIcon & icon)
# QToolButton
openButton->setIcon(style()->standardIcon(QStyle::SP_DialogOpenButton));  返回Icon
openButton->setIconSize(iconSize);

# QCheckBox
QIcon icon;
icon.addFile(QStringLiteral(":/images/man.png"), QSize(), QIcon::Normal, QIcon::Off);
radioButtonMan->setIcon(icon);

%% 图标使用示例 helloqrc 

4. QSplashScreen 
闪屏就是在程序进入主窗体之前，在桌面中央位置显示一个无边框的图片窗口，并且在图片下面还可以显示提示信息，比如 "加载中" 。

构造函数?
QSplashScreen(const QPixmap & pixmap = QPixmap(), Qt::WindowFlags f = 0)
QSplashScreen(QWidget * parent, const QPixmap & pixmap = QPixmap(), Qt::WindowFlags f = 0)
pixmap 是闪屏显示的像素图，f 是窗口风格标志位，一般不用设置标志位，使用默认的就行。

设定图像和显示消息文本?
除了可以在构造函数指定像素图，也可以通过函数设置：
void setPixmap(const QPixmap &pixmap)
闪屏界面显示消息文本的函数为：
void showMessage(const QString & message, int alignment = Qt::AlignLeft, const QColor & color = Qt::black)
message 就是消息文本，alignment 是文本对齐方式，color 是文本颜色。

闪屏会出现在主窗口之前，这时候还没有事件处理循环，如果希望闪屏界面能处理事件、信号、槽，那么需要手动调用 
QApplication::processEvents() 函数，例如：
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QPixmap pixmap(":/splash.png");
    QSplashScreen splash(pixmap);
    splash.show();
    app.processEvents();
    ...
    QMainWindow window;
    window.show();
    splash.finish(&window);
    return app.exec();
}
显示了主窗体之后，就可以结束闪屏进入主窗体，即调用如下函数：
void QSplashScreen::​finish(QWidget * mainWin)
该函数参数里的主窗体 mainWin 显示完成之后，闪屏就自动关闭了。

%% 闪屏和应用程序 splash

6.1 传统窗口调整技术 
================================================================================
# 限定窗口大小 xy wh                             # 移动窗口左上角坐标 xy     # 改变窗口的尺寸大小 wh
void setGeometry(int x, int y, int w, int h)     void move(int x, int y)     void resize(int w, int h)
void setGeometry(const QRect &)                  void move(const QPoint &)   void resize(const QSize &)

# 虚函数 resizeEvent()
void QWidget::​resizeEvent(QResizeEvent * event)    //virtual protected
    注意一般不要在 ​resizeEvent() 函数内部调用 setGeometry() 或者 resize() 改变窗口尺寸，
那样容易导致 ​resizeEvent() 函数循环触发，进入死循环。

# 限定窗口的尺寸范围                                       # 固定大小的窗口
void setMinimumSize(const QSize &)        //最小尺寸       void setFixedSize(const QSize & s)
void setMinimumSize(int minw, int minh)   //最小尺寸       void setFixedSize(int w, int h)
void setMaximumSize(const QSize &)        //最大尺寸       void setFixedWidth(int w)    //单独设置固定宽度
void setMaximumSize(int maxw, int maxh)   //最大尺寸       void setFixedHeight(int h)   //单独设置固定高度

# 控件 UI设计工具
"大小限定" ，然后看到 6 个子菜单项，解释一下：
① "设定最小宽度"，就是将现在看到的窗体宽度设置为该窗体的最小宽度。
② "设定最小高度"，就是将现在看到的窗体高度设置为该窗体的最小高度。
③ "设定最小大小"，就是将现在看到的窗体尺寸设置为该窗体的最小尺寸。
④ "设定最大宽度"，就是将现在看到的窗体宽度设置为该窗体的最大宽度。
⑤ "设定最大高度"，就是将现在看到的窗体高度设置为该窗体的最大高度。
⑥ "设定最大大小"，就是将现在看到的窗体尺寸设置为该窗体的最大尺寸。

%% timeshowfixed   固定大小
%% imgshowdynamic  动态调整控件位置

当窗口大小改变时，我们需要重载主窗体基类的事件函数：
void QWidget::​resizeEvent(QResizeEvent * event)

参数 event 是 QResizeEvent 类型，除了构造函数，这个 QResizeEvent 只有两个自己的公有函数：
const QSize & QResizeEvent::​oldSize() const    # oldSize() 用于获取窗体的旧尺寸，就是变化前的尺寸。
const QSize & QResizeEvent::​size() const       # size() 用于获取窗体当前的新尺寸，就是变化后的尺寸。

"Refactor" 有个子菜单项 "Rename Symbol Under Cursor" ，快捷键 Ctrl+Shift+R，就是重命名鼠标指向的名称的意思。

# 计算文本显示宽度
    Qt 控件的基类 QWidget 原本有能让控件根据显示内容自动调整大小的函数：
    void QWidget::​adjustSize()

    QWidget 类有获取当前字体的函数：
    const QFont & QWidget::font() const

    还有获取 QFontMetrics 对象的函数QFontMetrics 对象专门用于根据文本字符串计算文本宽度：
    QFontMetrics QWidget::​fontMetrics() const
    确定某一段文本的显示宽度：
    int QFontMetrics::​width(const QString & text, int len = -1) const
    int QFontMetrics::​width(QChar ch) const
    int QFontMetrics::​height() const
    
    QFontMetrics 有一个 size() 函数可以计算多行文本的总宽度和总高度，
    QSize QFontMetrics::​size(int flags, const QString & text, int tabStops = 0, int * tabArray = 0) const
第一个参数 flags 可以是如下几个标志位进行位或 | 后的数值：
    Qt::TextSingleLine 代表忽略换行符，把所有文本作为一行来计算。
    Qt::TextExpandTabs 代表展开 '\t' 制表符，用空白区域填充制表符。
    Qt::TextShowMnemonic 是指将 "&x" 替换为 x 来计算，这在伙伴快捷键里常用到。

QFontMetrics fm = pWidget->fontMetrics();
QSize szMulti = fm.size(0, "ABC\n123\nXYZ");
%% textwidth

6.2 水平和垂直布局器 
================================================================================
1. 垂直布局器 QVBoxLayout：将内部的控件按照垂直方向排布，一行一个。
2. 水平布局器 QHBoxLayout：将内部的控件按照水平方向排布，一列一个。
3. 网格布局器 QGridLayout：按照多行、多列的网格排布内部控件，单个控件可以占一个格子或者占据连续多个格子。
4. 表单布局器 QFormLayout：窗体布局器.
   这个布局器就是对应网页设计的表单，通常用于接收用户输入。
   该布局器就如它的图标一样，就是固定的两列控件，第一列通常是标签，第二列是输入控件或含有输入控件的布局器。
5. 堆栈布局器 QStackedLayout：通常用于容纳多个子窗口布局，每次只显示其中一个。
   这个布局器隐含在堆栈部件 QStackedWidget 内部，一般直接用 QStackedWidget 就行了，不需要专门设置堆栈布局器。

# 弹簧条
Horizontal Spacer 水平空白条
Vertical   Spacer 垂直空白条

对界面进行布局有两种方式
1. 第一种方式是预先设计好整体布局，先拖入布局器，后拖入功能控件到布局器里面
2. 第二种方式先把所有功能控件拖入主界面，然后根据设置好的功能控件来决定如何进行布局。

# 布局器下扩展功能
① 将选中控件添加到水平布局器排列。
② 将选中控件添加到垂直布局器排列。
③ 将选中控件添加到水平分裂器排列。
④ 将选中控件添加到垂直分裂器排列。
⑤ 将选中控件添加到网格布局器排布，行列的数目不限。
⑥ 将选中控件添加到表单布局器排布，该布局器固定为两列控件。
⑦ 打破布局，即保留布局器内部的控件和子布局，消除当前选中的布局器。
⑧ 根据需要显示的内容，自动调整控件或窗体的尺寸，相当于调用一次 adjustSize() 函数。

    基类都是 QWidget ，都可以单独存在，有 show() 之类的显示函数。
    分裂器具有布局功能，但分裂器的基类是 QFrame，分裂器是一个实体控件，分裂器不同于布局器，

# QBoxLayout
水平布局器 QHBoxLayout 和垂直布局器 QVBoxLayout 的基类都是 QBoxLayout，只是二者排列方向不同。
QBoxLayout(Direction dir, QWidget * parent = 0)
void setDirection(Direction direction)

枚举常量                    数值      描述
QBoxLayout::LeftToRight     0       水平布局，从左到右排列
QBoxLayout::RightToLeft     1       水平布局，从右到左排列
QBoxLayout::TopToBottom     2       垂直布局，从上到下排列
QBoxLayout::BottomToTop     3       垂直布局，从下到上排列

水平布局器 QHBoxLayout 和垂直布局器 QVBoxLayout 默认是其中的两种：QBoxLayout::LeftToRight 和 QBoxLayout::TopToBottom

# 添加控件
布局器是一定要往里面添加控件才有用，添加控件的函数如下：
void addWidget(QWidget * widget, int stretch = 0, Qt::Alignment alignment = 0)
void insertWidget(int index, QWidget * widget, int stretch = 0, Qt::Alignment alignment = 0)
widget 就是要添加的控件指针，stretch 是伸展因子。

# 添加其他布局
void addLayout(QLayout * layout, int stretch = 0)
void insertLayout(int index, QLayout * layout, int stretch = 0)

# 控件之间默认的间距
void setSpacing(int spacing)
spacing 就是间隔的像素点数目。

# QBoxLayout、QHBoxLayout 、QVBoxLayout 布局器不需要手动新建空白条对象，自带相关函数：
void QBoxLayout::​addSpacing(int size)                          //添加 size 固定尺寸空白条到布局器
void QBoxLayout::​addStretch(int stretch = 0)                   //添加自动拉伸的空白条到布局器
void QBoxLayout::​insertSpacing(int index, int size)            //插入 size 固定尺寸空白条到布局器
void QBoxLayout::​insertStretch(int index, int stretch = 0)     //插入自动拉伸的空白条到布局器

# 计算布局器里面的条目计数：
virtual int count() const
如果要获得布局器中某个序号的条目：
virtual QLayoutItem * itemAt(int index) const
如果要删除布局器中某个序号的条目：
virtual QLayoutItem * takeAt(int index)

%% 网络参数示例的布局            netparasnew 
%% 简易 HTML 查看器示例的布局    simplebrowsernew

# ui_*.h 文件中布局器的内幕代码

%% widgets\widgets\spinboxes      QHBoxLayout[ 3*QGroupBox [ 3*QVBoxLayout ] ]
%% widgets\widgets\sliders        QHBoxLayout[ QGroupBox[QGridLayout] QStackedWidget ] 
%% widgets/dialogs/configdialog   QVBoxLayout[ QHBoxLayout[QListWidget QStackedWidget] QHBoxLayout[QPushButton] ]


6.3 网格布局器 
================================================================================
网格布局器的行、列尺寸可以均匀分布，也可以非均匀分布，通常由尺寸调整的伸展策略和伸展因子灵活控制

# QGridLayout 类
QGridLayout 类既有控制行的函数，也有对应控制列的函数。
    对于列来说，有设置每列的最小宽度的函数：
    void setColumnMinimumWidth(int column, int minSize)
    
    如果要设置各个列在窗口变化时拉伸比例不同，可以用如下函数：
    void setColumnStretch(int column, int stretch)
    
    每列控件之间可以设置布局的水平间隙：
    void setHorizontalSpacing(int spacing)
    
    对于行，也都有类似的函数，只是把英文单词换一下：
    void setRowMinimumHeight(int row, int minSize) //设置行最小高度
    void setRowStretch(int row, int stretch)       //设置行的伸展因子
    void setHorizontalSpacing(int spacing)         //设置行的垂直间隙
    
如果要添加控件或其他布局器、自定义布局条目，使用如下函数：
void addWidget(QWidget * widget, int row, int column, Qt::Alignment alignment = 0)
void addWidget(QWidget * widget, int fromRow, int fromColumn, int rowSpan, int columnSpan, Qt::Alignment alignment = 0)
void addLayout(QLayout * layout, int row, int column, Qt::Alignment alignment = 0)
void addLayout(QLayout * layout, int row, int column, int rowSpan, int columnSpan, Qt::Alignment alignment = 0)
void addItem(QLayoutItem * item, int row, int column, int rowSpan = 1, int columnSpan = 1, Qt::Alignment alignment = 0)

如果没有指定 rowSpan 和 columnSpan 那么就是 1*1 的唯一单元格，
指定了 rowSpan 和 columnSpan 就会占据 rowSpan * columnSpan 的小矩形，占据连续多行多列单元格。

# 获知网格有多少行、有多少列
int rowCount() const      //行计数
int columnCount() const   //列计数

# 获取某个单元格的布局条目
QLayoutItem * itemAtPosition(int row, int column) const
注意，如果某个格子是全空的，也没有手动添加空白条，那么 itemAtPosition() 返回 NULL 指针。因此使用这个函数必须判断返回值是否为空。

用 add* 函数添加控件或子布局时，每个控件或子布局都对应一个序号，这个序号与网格坐标是无关的，是由 add* 函数添加顺序决定的。

# QGridLayout 提供了根据控件或子布局序号查询单元格位置、分布的函数(但没有反查序号的函数)：
void getItemPosition(int index, int * row, int * column, int * rowSpan, int * columnSpan) const
getItemPosition() 函数会填充参数里的四个指针指向的变量，四个指针指向的变量就是 add* 函数里面指定的单元格坐标和分布。

# 根据控件或子布局的序号获取布局条目的函数为：
virtual QLayoutItem * itemAt(int index) const
根据控件序号可以从 QGridLayout 中移除布局条目：
virtual QLayoutItem * takeAt(int index)
凡是函数返回值为指针的都要判断是否为空指针，因为上面函数的序号如果超出范围，也会返回空指针。

得到非空的 QLayoutItem 对象指针之后，就可以从 QLayoutItem 对象里提取实际的控件或布局器、空白条：
QWidget * QLayoutItem::​widget()
QLayout * QLayoutItem::​layout()
QSpacerItem * QLayoutItem::​spacerItem()
另外如果是自己定制的 QLayoutItem 派生类对象，可以把获取的基类对象指针 QLayoutItem * ，通过 dynamic_cast 转成派生类对象指针试试。

%% infogathergrid 个人信息收集示例网格布局
%% complexgrid    分布不均匀的网格布

%% widgets\widgets\lineedits  QGridLayout

6.4 表单布局器 QFormLayout 
================================================================================
在窗体布局中布局 = 表单布局器 = 双列表格布局器
    通常是每行一个标签用于提示信息、一个输入控件接收用户输入， QFormLayout 就是对
这种每行两列的控件分布进行建模并简化界面的构建过程。
    表单布局器的规律性、限制性比网格布局器更强，是严格的两列布局，通常第一列固定是
标签，第二列是输入控件或者输入控件组合成的布局器。

# QFormLayout
    网格布局器的基本单元是单元格，而表单布局器的基本单元是行。表单布局器是高度建模并封装的，
它没有 addWidget() 和 addLayout() 之类的函数，它只有 addRow() 函数。

表单布局器的第一列称为标签，角色为 QFormLayout::LabelRole；
表单布局器的第二列称为域，或叫字段，角色为 QFormLayout::FieldRole。
    如果表单布局器某一行的两列空间全部由单独一个控件或子布局器占据，那么这个控件或
子布局器的角色就称为 QFormLayout::SpanningRole，可以叫跨越角色。

# 添加现有的标签控件和域控件或子布局：
void addRow(QWidget * label, QWidget * field)
void addRow(QWidget * label, QLayout * field)
void insertRow(int row, QWidget * label, QWidget * field)
void insertRow(int row, QWidget * label, QLayout * field)
添加函数不仅能把标签和控件/布局器添加到表单的行，并且能将每行的 label 和 field 自动设置为伙伴，而不需要自己调用 setBuddy() 函数。

# 表单布局可以根据文本自动建立内部的标签控件
void addRow(const QString & labelText, QWidget * field)
void addRow(const QString & labelText, QLayout * field)
void insertRow(int row, const QString & labelText, QWidget * field)
void insertRow(int row, const QString & labelText, QLayout * field)

# QFormLayout::SpanningRole
void addRow(QWidget * widget)
void addRow(QLayout * layout)
void insertRow(int row, QWidget * widget)
void insertRow(int row, QLayout * layout)

# 访问和修改行的函数
void setWidget(int row, ItemRole role, QWidget * widget)
void setLayout(int row, ItemRole role, QLayout * layout)
void setItem(int row, ItemRole role, QLayoutItem * item)
setWidget() 是把指定的第 row 行的 role 角色的格子内容设置为新的 widget。

    role 角色就是之前说的三种，第一列就是 QFormLayout::LabelRole，第二列是 QFormLayout::FieldRole。
如果把角色设置为跨越角色 QFormLayout::SpanningRole，那么这一个控件会占据该行全部 的两列。

表单布局器当前的行计数使用如下函数：
int rowCount() const
如果要查询某行、某角色的布局条目，可以用如下函数：
QLayoutItem * itemAt(int row, ItemRole role) const
    如果返回的指针非空，那就可以使用 QLayoutItem 的 widget()、layout()、spacerItem() 
等函数获取该格子里的控件或布局器，当然也要注意判断返回的指针是否为空。

### 基于控件序号的访问、删除等操作
获取表单布局器中的控件或子布局器等计数的函数为：
virtual int count() const

如果要根据序号查询布局条目，使用如下函数：
virtual QLayoutItem * itemAt(int index) const

如果要查询某个序号的控件或布局器对应的行号和角色，使用如下函数：
void getItemPosition(int index, int * rowPtr, ItemRole * rolePtr) const
查询到的数值会存到 rowPtr 和 rolePtr 指向的变量。如果查不到，那么 rowPtr 指向的数值就是 -1。

如果要删除某个序号的控件，使用下面的函数：
virtual QLayoutItem * takeAt(int index)

### 设置行的显示格式、对齐格式
# 设置大行内部是否自动换行的函数为：
void setRowWrapPolicy(RowWrapPolicy policy)
QFormLayout::​RowWrapPolicy 有三种在大行内部的自动换行策略：
● QFormLayout::DontWrapRows，就是始终不换行，标签和域显示在同一水平行里。
● QFormLayout::WrapLongRows，对于特别长的行自动换行，比如标签文本特别长，那么拆成两小行，上面是标签，下面是域。
● QFormLayout::WrapAllRows，所有的行都拆成两小行，上面小行显示标签，下面小行显示域。
这里的rowWrapPolicy 仅仅决定显示的时候是否自动换行，它对表单布局里原本的大行划分没有影响，从布局管理上，两小行的标签和域还是原来的一大行。

# 表单布局器可以设置表单整体的对齐方式
void setFormAlignment(Qt::Alignment alignment)

# 标签也有专门的对齐方式设置函数：
void setLabelAlignment(Qt::Alignment alignment)

### 伸展策略和布局间隙
# 设置域的伸展策略函数：
void setFieldGrowthPolicy(FieldGrowthPolicy policy)
QFormLayout::​FieldGrowthPolicy 枚举常量有三个，对应不同的拉伸策略，这个策略影响所有行的域拉伸：
  QFormLayout::FieldsStayAtSizeHint，拉伸到最佳大小就保持不变了，苹果系统风格默认是这样的。
  QFormLayout::ExpandingFieldsGrow，根据域里面的控件而定，里面控件自己的策略如果是 Expanding 或 MinimumExpanding 就增长，其他的不增长。Qt 的 Plastique 风格（KDE 桌面）默认是这样。
  QFormLayout::AllNonFixedFieldsGrow，根据域内部控件的策略而定，控件的策略允许增长就增长，控件的策略不增长那就不变。大部分的情况 默 认都是这种伸展策略。

# 表单布局器的布局间隙设置和网格布局器类似，用下面函数设置即可：
void setHorizontalSpacing(int spacing)  //控件之间水平间隙
void setVerticalSpacing(int spacing)    //行 与行之间的垂直间隙

%% 个人信息收集示例表单布局 infogatherform
%% 分布不均匀的表单布局     complexform


6.5 控件尺寸调整策略
================================================================================
布局器的原理和布局器里控件尺寸调整策略。
调整控件的 sizePolicy 属性，设置不同的尺寸调整策略来实现想要的拉伸效果。

    基于 QWidget 的控件都会继承 sizePolicy 属性(QSizePolicy 类型)，这个属性包括两个大的方面内容：
伸展因子(Stretch Factor)和 伸展策略(Policy)，这些都会影响到界面最终的布局显示。

# 布局器工作原理
① 最小尺寸和最大尺寸，控件尺寸会限定在最小尺寸和最大尺寸之间。
② 建议尺寸 QWidget::sizeHint()，这个建议尺寸是后续尺寸调整的基础，在布局时会先给控件分配建议尺寸的空间。
③ 伸展因子（stretch factors），根据伸展因子的比例分配新增的空闲空间给各个控件。
④ 尺寸策略 QWidget::sizePolicy()，在上述处理之后，那么再根据各个控件的尺寸调整策略决定控件应该尽可能拉伸还是尽量不拉伸。
    这些规律对水平布局器、垂直布局器、网格布局器都是通用的。比较例外的是表单布局器，
表单布局器在垂直方向不拉伸，第一列的标签也不拉伸，受尺寸调整策略影响的只 有第二列的
域在水平方向的拉伸行为。

//获取旧的尺寸策略作为底板，修改需要变动的伸展因子
    QSizePolicy sp = ui->pushButton1->sizePolicy();
    sp.setHorizontalStretch(2); //水平伸展因子
    sp.setVerticalStretch(0);   //垂直伸展因子
//把新策略设置给按钮1
    ui->pushButton1->setSizePolicy(sp);

void QSizePolicy::​setHorizontalStretch(int stretchFactor)  # 设置水平伸展因子
void QSizePolicy::​setVerticalStretch(int stretchFactor)    # 设置垂直伸展因子
注意 stretchFactor 的取值范围是 0 到 255，负数就当做 0，大于 255 就当做 255。

    如果布局器和内部直属的控件都设置了伸展因子，那么布局器的设置会覆盖直属 控件的伸展因子。
因此不建议直接设置控件自己的伸展因子属性，而是 通过布局器来设置各个子控件或子布局器的伸展因子。

布局器: 可以控制多个控件，所以常常设置布局器的延展因子和尺寸策略。

水平和垂直布局器的伸展因子设置
QHBoxLayout 和 QVBoxLayout 都是通过基类 QBoxLayout 的函数设置内部直属的各个控件和子布局的伸展因子，对应的设置函数为：
void setStretch(int index, int stretch)
bool setStretchFactor(QWidget * widget, int stretch)
bool setStretchFactor(QLayout * layout, int stretch)
如果要获取某个序号的控件或子布局器的伸展因子是多少，可以用如下函数：
int stretch(int index) const


layoutRowStretch 就是各个行对应的伸展因子；
layoutColumnStretch 就是各个列对应的伸展因子；
layoutRowMinimumHeight 是各个行对应的最小高度；
layoutColumnMinimumWidth 是各个列对应的最小宽度。

对于伸展因子和伸展策略的运用，我们这里建议一个大致的分工原则：
在实际布局中，如果要控制某个布局器直属的子布局器、控件之间的拉伸比例，就通过布局器的伸展因子来设置；
如果要控制功能控件是尽量拉伸还是尽量固定，那么通过控件自己的伸展策略属性来设置。


（1）策略的基本标志位
由 QSizePolicy::​PolicyFlag 类型枚举，包括四个基本标志位：

枚举标志位                   数值   描述
QSizePolicy::GrowFlag       1       可增长标志，如果有必要的话，可以在建议尺寸之外继续增长。
QSizePolicy::ExpandFlag     2       尽量扩展标志，能占多大空间就占多大。
QSizePolicy::ShrinkFlag     4       可收缩标志，如果有必要的话，可以在缩小到建议尺寸之后继续缩小。
QSizePolicy::IgnoreFlag     8       忽略建议尺寸，这个增长方式最野蛮，能占多大空间就占多大空间 
建议尺寸就是通过控件的 sizeHint() 函数获取的尺寸，这个尺寸通常由 Qt 类库自己根据要显示的内容计算。

布局器实例
================================================================================

%% widgets/layouts/basiclayouts QVBoxLayout[ QGroupBox[QHBoxLayout[3*QPushButton]] 
                                             QGroupBox[QGridLayout[3*(QLabel+QLineEdit) ]] 
                                             QGroupBox[QFormLayout] 
                                             QTextEdit
                                             QDialogButtonBox ]
%% widgets/layouts/borderlayout QLayout扩展
widgets/layouts/flowlayout      QLayout扩展
%% widgets/layouts/dynamiclayouts QGridLayout[ QGroupBox[QGridLayout[QWidget]] 
                                               QGroupBox[QGridLayout[QLabel+QComboBox]]
                                               QDialogButtonBox
                                               ]
rotateWidgetsButton = buttonBox->addButton(tr("Rotate &Widgets"), QDialogButtonBox::ActionRole);

%% widgets/dialogs/extension    扩展部分，通过QWidget的hide()  QWidget的setVisible()
    垂直按钮盒 buttonBox = new QDialogButtonBox(Qt::Vertical); 自定义 findButton 和 moreButton 按钮


6.6 分裂器
================================================================================
    分裂器是将每个控件的大小调整都交给用户手动控制，用户能在程序运行时自由调整分裂器
内各个控件的大小， 并能自动隐藏缩到很窄或很扁的控件，为其他控件腾出显示空间。
    注意分裂器内部不能直接放置布局器，只能放置 QWidget 对象或其派生类对象(可以用 
QWidget 对象封装布局器，然后添加到分裂器)。
    在分裂器内部间接添加布局器的例子.
     QWidget -> QFrame -> QSplitter 

QSplitter 可以独立存在，可以作为父窗口容纳多个子控件，分裂器会完全拥有内部的子控件。

    水平分裂器和垂直分裂器的类都是 QSplitter，只是 orientation 属性不一样，水平方向是 Qt::Horizontal
垂直方向是 Qt::Vertical。QSplitter 的构造函数和 orientation 设置函数都可以指定排布方向：
QSplitter(Qt::Orientation orientation, QWidget * parent = 0)
void setOrientation(Qt::Orientation)

向分裂器内添加控件可以通过如下函数：
void addWidget(QWidget * widget)
void insertWidget(int index, QWidget * widget)

注意分裂器只有添加控件的函数，不能直接添加任何布局器。

控件总个数和从index到控件 从控件到index? 
添加了控件之后，可以通过如下函数统计有几个直属控件：
int count() const
如果要获知刚才添加的某个控件 widget 在分裂器内部的序号：
int indexOf(QWidget * widget) const
如果要根据分裂器的序号查询是哪个控件，用如下函数：
QWidget * widget(int index) const


################################################################################
(1) sizeHint 推荐大小提示
如果设置布局，那就返回推荐大小。

(2) Qt针对不同的控件，根据它们所具有的功能，默认使用了不同的大小策略。
    QWidget，QFrame等容器控件在垂直和水平方向都使用Preferred，这意味着窗口在两个
方向可以自由调整大小，但更趋向于sizeHint()的返回值。
    QLabel, QPushButton，QLineEdit类似于长条形状的控件的大小策略是，可以水平拉伸，
垂直固定。
    QToolButton通常是正方形的，所以允许双向的增长。
    支持不同方向的控件(如QSlider、QScrollBar或QHeader)只在各自的方向上指定拉伸。
    可以提供滚动条的控件(通常是QScrollArea的子类)倾向于指定它们可以使用扩展的空间。

(3) 针对不同的需求，Qt为此定下了不同的大小策略类型。
以下可同时适用于水平和垂直方向
    Fixed：sizeHint()是唯一可以接受的选择，窗口不能增长或缩小(例如按钮的垂直方向)。
    Minimum：sizeHint()是最小的，窗口可以被扩展，但是扩展后并不美观(例如按钮的水平方向，
最小是文字像素，如果随着父窗口的扩展而扩展，就会显得不美观)。
    Maximum：sizeHint()是最大的。如果其他控件需要空间(例如分隔线)，该控件可以收缩。
    Preferred：sizeHint()是最好的，控件可以缩小，也可以扩展(QWidge默认的t策略)。
    Expanding：sizeHint()是一个合理的大小，但是控件可以缩小。最重要的，控件当它的父窗口变大时，
它应该得到尽可能多的空间(例如水平滑块的水平方向)。
    MinimumExpanding：同Expanding，但不能再缩小。
    Ignored：sizeHint()将被忽略。控件将获得尽可能多的空间。

3 QLayout::SizeConstraint：大小约束条件，该属性属于QLayout。
当窗口改变大小时，布局本身也会跟着变化，本属性就描述了布局变化时的大小限制，其实就是计算方式的限制。
以下的主窗口指的是，布局所在的窗口。
    SetDefaultConstraint：主窗口最小值设置为minimumSize()，除非已经具有最小值。
    SetNoConstraint：窗口不受最大最小限制SetMinimumSize：主窗口最小值设置为minimumSize()，无法再缩小。
    SetFixedSize：主窗口大小被设置为sizeHint()，大小不能再改变。
    SetMaximumSize：主窗口最大值设置为maximumSize()，无法再变大。
    SetMinAndMaxSize：主窗口的最小值设置为minimumSize()，最大值设置为maximumSize()。

7.1 文件系统概览  
================================================================================
QDir 可以用来获取Qt资源系统的文件信息 %% fsbrowser
QDir 类使用相对或绝对文件路径来指向一个文件/目录。  readlink
QDir 负责且切换目录、枚举文件和文件夹
QFileInfo 负责获取单个文件或者文件夹的详细信息 readlink && stat
QDir::dirves() 获取多个文件系统的根    C:\ ，D:\
QDir::dirves() 返回唯一的根              /

对比项         Windows                        Unix/Linux                    Qt类或函数
路径分隔符     '\'                            '/'                           QDir::​separator() 获取该分隔符
文件系统根     多个根，C:\，D:\ 等等          唯一的 /                      QDir::​drives() 枚举文件系统根
目录操作       命令行 cd 切换目录，dir 枚举   命令行 cd 切换目录，ls 枚举   QDir 负责切换目录，枚举文件夹和文件
文件信息       命令行 dir 文件名              命令行 ls 文件名              QFileInfo 负责查询单个文件夹或文件详细信息 

# 路径字符串
QDir自己的路径可以通过setPath()设置并且通过path()获得
可以使用QDir类的方法isRelative()或者是isAbsolute()来判断QDir指向的路径是相对路径还是绝对路径
如果是相对路径，可使用方法makeAbsolute()将相对路径转换为绝对路径。

QDir <-> QFileInfo <-> QFile 通过QString可以更好的关联到一起。

QDir -> QFileInfoList
QFileInfoList entryInfoList(const QStringList & nameFilters, Filters filters = NoFilter, SortFlags sort = NoSort) const
QFileInfoList entryInfoList(Filters filters = NoFilter, SortFlags sort = NoSort) const
QFileInfoList drives()
间接方式
QStringList entryList(const QStringList & nameFilters, Filters filters = NoFilter, SortFlags sort = NoSort) const
QStringList entryList(Filters filters = NoFilter, SortFlags sort = NoSort) const

QDir -> QDir
QDir current()
QDir home()
QDir root()
QDir temp()

QFileInfo -> QDir
QDir absoluteDir() const
QDir dir() const

QFile 
bool QFile::open(OpenMode mode) 
bool QFile::open(FILE * fh, OpenMode mode, FileHandleFlags handleFlags = DontCloseHandle)
bool QFile::open(int fd, OpenMode mode, FileHandleFlags handleFlags = DontCloseHandle)

    Ctrl+F：在当前编辑窗口查询关键字，可以选择大小写相关，全词匹配，正则表达式匹配，而且在查找之后，还可以进行替换操作。
    Ctrl+Shift+F：全局查找，不只局限在当前文件。注意可能会和输入法快捷键冲突，使用时要关闭中文输入法。
    Ctrl+Shift+V：剪切板历史列表，你可以通过它选择你之前粘贴过的文字，非常好用。
    Ctrl+L：输入数字n，可以快速定位到当前文件的第n行。
    Alt+←：后退。
    Alt+→：前进。
    Ctrl+Home：跳到当前文件开头。
    Ctrl+End：跳到当前文件末尾。
    Ctrl+Tab：在当前所打开的文件之间切换。
    Ctrl+B：编译项目。
    Ctrl+R：编译并运行项目。
    将鼠标放在某个类上面，然后按Ctrl，这时鼠标会变成小手形状，点击鼠标，这会跳到类的声明处，这是最常用的快捷方式，试着按这样的方法，把鼠标移动到函数上，变量上等等，看看都有什么效果。
    F2：移动到定义处。
    F4：在头文件和源文件之间切换。
    Ctrl+/：注释当前鼠标所在行，如果鼠标选择了多行，则注释多行。
    Ctrl+i：选中文本块，Ctrl+i可格式化代码块。
    Shift+home|end|←|→：可选中文本。
    将鼠标移动到某变量上，右键选择Find Usages（查找引用），这可以查找到这个变量所有被引用的地方，这是个非常好用的功能，一定要牢记。快捷键为Ctrl+Shift+U。
    将鼠标移动到某变量上，右键选择Refactor（重构），这个可以帮助你重命名所有引用到的变量，函数。
    将鼠标点到某个类上，按F1键，在侧边栏可显示这个类的帮助文档，如果是移动到函数上点击F1键，可显示此函数的帮助信息。再按一次F1，会跳到帮助文档大页面
    
    
    总结：如果不指定构造函数，则派生类会调用基类的默认构造函数 
          派生类构造函数的初始化列表只能初始化派生类成员，不能直接初始化继承成员，
          如果想要调用基类的有参构造函数，则可以在派生类的初始化列表中显示指定。

以上总结，也告诉我们，当定义一个类时，最好为该类定义默认构造函数。


================================================================================
%% E:\Qt\journey of qt\lesson-5\ContainerWidget2

QToolBox 
count用来记录分组item的个数，currentIndex记录当前展开的item页。并且索引也都是从0开始。

QWidgetBox 
count const int
1. 需要一个count属性来标识总共有count个标签。
currentIndex int
2. 需要一个属性来记录当前标签页。
    标签的索引从左至右或从上到下，从0开始。
documentMode
3. documentMode可见区域是否以文档模式显示。
    当为true时，文档模式会去掉QTabWidget周边的框架。
elideMode
4. 当标签文字很长时，对于标签文字显示应该采用的省略策略，elideMode。
    Qt::ElideLeft：省略号在左边。
    Qt::ElideRight：省略号在右边。
    Qt::ElideMiddle：省略号在中间。
    Qt::ElideNone：显示全部文字。
iconSize QSize
5. 每个标签都可以有个图标，所以需要图标大小iconSize。图标的大小还可以通过样式表来设置，
moveable bool
6. 每个标签可以和其它标签交换前后顺序，moveable是否可交换。
tabBarAutoHide bool
7. 当只有一个标签时，该标签可以自动隐藏，tabBarAutoHide。
tabPosition TabPosition
8. 标签不仅仅可以放在可见区域上方，还可以放在下方，左方，右方，tabPosition。
QTabWidget::North：（北）上方。
QTabWidget::South：（南）下方。
QTabWidget::West：（西）左方。
QTabWidget::East：（东）右方。

9. 标签也可以有不同的形状，tabShape。
    QTabWidget::Rounded：默认矩形。
    QTabWidget::Triangular：三角形。
10. 标签也可以关闭，tabsClosable。
    这里要注意，虽然标签上显示了关闭按钮，但点击后标签并不关闭，而是会发出tabCloseRequested(int)信号，
    你需要连接该信号再调用removeTab槽来关闭标签。
11. 如果标签多了，也可以使用滚动按钮，usesScrollButtons。

QTabWidget QGroupBox


QTranslator
================================================================================
TRANSLATIONS += translation_zh_cn.ts

点击 工具——外部——Qt语言家——更新翻译（lupdate）
打开 Qt 安装目录下的 linguist
翻译 “you are my eyes”为“你是我的眼”，编译出 translation_zh_cn.qm 文件

QTranslator translator;
translator.load("translation_zh_cn.qm");
a.installTranslator(&translator);


# 行数不受限
QListWidget -> QlistWidgetItem QString QIcon QList<class item中显示内容> index Checkable
            -> 按行显示  平铺显示 (像文件系统一样 : 查看下拉菜单)
%% widgets\dialogs\configdialog
%% widgets\dialogs\tabdialog
%% 游戏装备列表 ch08/dotaitems
%% 歌曲列表示例 ch08/musiclist

# 行列受限
QTableWidget  
%% widgets/widgets/icons  createImagesGroupBox()
%% /tools/settingseditor

QTreeWidget


https://github.com/ligang-chn/Gravel_Spreader_Monitoring_System
https://github.com/tinmarino/wiki
https://github.com/tinmarino/wiki/so
https://github.com/tinmarino/wiki/cheat
E:\Qt\app\Practice-master.zip
E:\Qt\app\ProgramLanguage-31c459537251086bc6531e8c45a8c73bc8e34393.zip

================================================================================
QDataStream (udppack和dsedit 都是添加删除影响QListWidget; 保存加载影响QListWidget或存储文件)
             udppack类似于深拷贝，而dsedit类似于浅拷贝。
%% udppack UDPPacker结构体 转换成QByteArray结构体, 在QListWidget中按照hex码(QString)显示， 又可以转回QByteArray
                                                   在QDataStream中写入本地文件，使用QDataStream从本地文件中加载到QListWidget
牵涉到 UDPPacker结构体 如何序列化和反序列化? QByteArray如何转换成Hex类型QString和Hex类型QString转换成QByteArray?
QDataStream & operator>> 和 QDataStream & operator<< 既可以支持QByteArray，也可以支持QFile

UDPPacker结构体 <-> QListWidget(Hex字符串) <-> File(存储数据和加载数据)
            pushButtonAddUDP->           pushButtonSave->
          <-currentRowChanged          <-pushButtonLoad

Hex数据处理
  QByteArray QByteArray::toHex() const ->
  <- QByteArray QByteArray::fromHex(const QByteArray & hexEncoded) 

QByteArray <-> QString
  QString QString::fromUtf8(const QByteArray & str)->
  <- QString::toUtf8();

QByteArray <-> char*
    char * data()
    const char * data() const
    const char * constData() const
    QByteArray & setRawData(const char *data, uint size)
    [static]QByteArray fromRawData(const char *data, int size)
  
QString::QString(const char * str)
QString::QString(const QByteArray & ba)
使用QByteArray或者str创建一个QString, QByteArray和str通过 QString::fromUtf8(const char * str, int size = -1)创建QString


同时又有QDataStream 与 QByteArray QFile之间的关联关系? 
%% dsedit  QString到int double间相互类型转化；QString通过QTextStream将多个QString，int，double类型转换
           QFile通过QDataStream进行数据序列化和数据反序列化(数据保存和数据加载)
           QDataStream将内存类型转换成二进制类型，包括把QByteArray类型写入文件和协议数据缓冲区
           QTextStream将内存类型转换成QString类型，能实现QString到QString int double等类型值转换

udppack 是以Hex格式在QListWidget中显示； dsedit 是以字符串格式在QListWidget中显示

%% tableedit 
1. QString|qint32|double          <--> QString
   tsLine<<QString<<qint32<<double   QTextStream(QString) tsLine即QTextStream    pushButtonAdd
   tsLine>>QString>>qint32>>double   QTextStream(QString) tsLine即QTextStream    currentRowChanged
                                     pushButtonSaveDS
                                     pushButtonLoadDS
流版本信息        Qt_4_8
DS字符内容        'D' 'S'
1.0版本文件格式   0x0100
行计数            nCount
[ strCurName>>nCurAge>>dblCurWeight ] * nCount

# QTextStream (格式化和逆格式化)  --- 文本处理
    explicit QTextStream(QIODevice *device);
    explicit QTextStream(FILE *fileHandle, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(QByteArray *array, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(const QByteArray &array, QIODevice::OpenMode openMode = QIODevice::ReadOnly);
注意后两个构造函数，
如果传递 QByteArray 对象给构造函数，那么这个 QByteArray 对象是只读的。
如果传递 QByteArray 指针给构造函数，那么默认是可读可写的。

# QDataStream (序列化和反序列化)  --- 数据存储和通信
    explicit QDataStream(QIODevice *);
    QDataStream(QByteArray *, QIODevice::OpenMode flags);
    QDataStream(const QByteArray &);

QDataStream强调的是sizeof类型大小和read|write函数(序列化)，QTextStream强调的是printf格式化和scanf扫描格式
QDataStream 就是将内存数据转换为存储数据 以及 将存储数据转化为 内存数据。内存数据强调类型，体现随机，存储数据强调大小，强调依赖关系。

QFile 可以关联到QTextStream 可以关联到QDataStream 
QByteArray 关联到QTextStream时，QByteArray作为char*类型字符看待，QByteArray 关联到QDataStream时，QByteArray按二进制看待

文本文件中空行、注释是需要关注的特殊情况。数据文件中，版本和数据长度是需要特别关注的情况。
文本文件的文本行和QListWidget显示文本除编码外，几近相同。

QTextStream 和 QString关联时，QString主要使用QTextStream提供的 格式化 和 逆格式化方法。
QTextStream 和 QFile关联时，QString主要使用QTextStream提供的 格式化 和 逆格式化方法。


对比项                      QTextStream                                                     QDataStream
用途                        处理文本流，如 QIODevice、FILE句柄、QString、QByteArray，这里的 QByteArray 是作为字符串用途，以 '\0' 为终止符
                            处理二进制数据流，如 QIODevice 、QByteArray ，这里的 QByteArray 作为字节数组，是纯数据，不区分字节数值是否为 0
<<和>>涵盖的数据类型    C++基本类型和 QChar、QString、QByteArray（字符串）   C++基本类型和 Qt 库中几乎所有用于表示数据的类
流操作子                很多格式化操作子，程序员可以控制格式                                没有操作子，打包格式内定，程序员不能控制                   
流的版本号              没有版本号                                                          可以设置从 Qt_1_0 到最新的版本号，不同版本号的串行化打包是有区别的                 
流的游标                pos() 获取游标，seek() 移动游标，atEnd() 判断末尾，可以随机化读写   没有游标，只能用 atEnd() 判断是否到末尾，不能随机化读写，必须按写入时相同的顺序和类型来读取
流的工作状态            QTextStream::Status 四种状态                                         QDataStream::?Status 四种状态  

# QTextStream QDataStream的<< >> 和 QFile的read和write
QTextStream和QDataStream操作后，通过dsIn.status()判断读写错误和是否到达文件尾部; atEnd() 判断末尾
QFile 依赖操作返回值判断

# 文件结尾判断
流的游标: pos() 获取游标，seek() 移动游标，atEnd() 判断末尾，可以随机化读写
流的工作状态: QTextStream::Status 四种状态, Ok ReadPastEnd ReadCorruptData WriteFailed

================================================================================
# QFile
1. 文本接口 -- QTextStream
qint64 QIODevice::​readLine(char * data, qint64 maxSize)
QByteArray QIODevice::​readLine(qint64 maxSize = 0)
第一个 ​readLine() 是程序员手动分配缓冲区，第二个不需要手动分配缓冲区。

QByteArray QIODevice::​readAll()
readAll() 函数看名字就知道，把文件的全部内容直接读取到 QByteArray 对象然后返回。

2. 二进制接口 -- QDataStream
qint64 QIODevice::​read(char * data, qint64 maxSize)
QByteArray QIODevice::​read(qint64 maxSize)
第一个 ​read() 是程序员手动分配缓冲区，第二个不需要手动分配缓冲区。

3. 写函数
qint64 QIODevice::​write(const char * data, qint64 maxSize)
qint64 QIODevice::​write(const char * data)
qint64 QIODevice::​write(const QByteArray & byteArray)

QByteArray -> QString
QString::fromLocal8Bit() fromLatin1() fromUtf8() 这些函数既支持char *类型，又支持 QByteArray类型

QFile将FILE的 文本读取写入方式 和 fd的 二进制读取写入方式进行了综合

%%unixconfig  处理文本文件: 有读处理和写处理
              pushButtonBrowseSrc + pushButtonLoad 中间增加了 lineEditSrcFile数据获取和设置两个步骤，其实可以去掉
              pushButtonBrowseDst + pushButtonSave 中间增加了 lineEditDstFile数据获取和设置两个步骤，其实可以去掉
在没有使用QTextStream的情况下，使用了 QString::fromLocal8Bit( optionValue ); 和 [QString]strHostName.toLocal8Bit()

%% bmpheader   处理二进制数据文件: 只有读处理
              pushButtonBrowse -> pushButtonShowPic 通过QLabel显示图片
                               -> pushButtonReadHeader 通过结构体 BMPFileHeader 和 BMPInfoHeader 解析文件，后使用QTextBrowser显示
%% /widgets/dialogs/findfiles QTableWiget显示文件的名称和大小，显示列明，隐藏行名。
                              setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver) 设置ComboBox的水平和垂直方向拉伸策略
                              directoryComboBox->findText(directory) ComboBox 通过字符串反向查找 index
                              QProgressDialog 过程对话框
                              
                              
================================================================================

%%paths       环境路径 current() home() root() temp() 绝对路径 和 文件名解析
%%fsbrowers   QFileInfoList QListWidget type QDesktopServices::openUrl(QUrl::fromLocalFile(strFilePath))
              enum ITypes{ IDriver = 1999, IFolder = 2000, IFile = 2001 }
              isReadable()  isWritable()  isExecutable() size() suffix()  created() lastModified()
              
QDir 管理内置路径 path() setPath(const QString & path) 获取设置
        绝对路径:  makeAbsolute()  isAbsolute() absolutePath() ​绝对
        相对路径:  isAbsolute() isRelative() isRoot()          相对
        文件路径管理: dirName() 目录名   absFilePath(文件的绝对路径名称) absPath(绝对路径)
        文件路径: filePath(目录中一个文件的路径名称) absoluteFilePath() ​canonicalFilePath()来获得QDir中指定文件的路径名
        目录常量: currentPath() homePath() rootPath() tempParh() current() home() root() temp() 
     管理系统目录
        浏览和验证: exists(const QString & name) ​exists()  cd(const QString & dirName) ​cdUp()
        目录管理  : mkdir(const QString & dirName) 
                    rename(const QString & oldName, const QString & newName) 
                    rmdir(const QString & dirName) const  删除指定目录
                    mkpath(const QString & dirPath) 递归创建
                    rmpath(const QString & dirPath) 递归删除
                    remove(const QString & fileName) 删除指定文件
        目录属性:   exists(const QString & name) isReadable()  isWritable()  isExecutable() size()
                    refresh()
        枚举子目录和文件: count()
    QStringList QDir::​entryList(Filters filters = NoFilter, SortFlags sort = NoSort) const
    QStringList QDir::​entryList(const QStringList & nameFilters, Filters filters = NoFilter, SortFlags sort = NoSort) const
    QFileInfoList QDir::​entryInfoList(Filters filters = NoFilter, SortFlags sort = NoSort) const
    QFileInfoList QDir::​entryInfoList(const QStringList & nameFilters, Filters filters = NoFilter, SortFlags sort = NoSort) const
QDir中的Filter枚举变量
QDir中的SortFlag枚举变量

=========================== QFile QTextStream QDataStream - read|write =========
# QFile 字节移动游标
qint64 QIODevice::​read(char *data, qint64 maxSize)
data 手动分配的缓冲区，
maxSize 就是最多读取的字节数目，手动分配的缓冲区大小，
返回值一般就是正确读取的字节数目，如果小于maxSize，则有几个字节读几个字节。
如果 read() 函数在读取之前就到了文件末尾或者读取错误，那么返回值是-1。

QByteArray QIODevice::​read(qint64 maxSize)
QByteArray::​size()函数判断读了多少字节，如果文件后面没字节可读或读取错误，那么 QByteArray 尺寸就是 0 。

QByteArray QIODevice::​readAll() 把文件的全部内容直接读取到 QByteArray 对象然后返回。

qint64 QIODevice::​readLine(char * data, qint64 maxSize)
从文件或设备里面读取一行 ASCII 字符，最多读取 maxSize-1 字节，因为最后一个字节预留给字符串结尾NULL字符 。
总会在实际读取的字符串末尾会自动添加一个字符串终结符 0 。
函数返回值是真实读取的字节数目，如果读取出错或无数据可读就返回 -1。
QByteArray QIODevice::​readLine(qint64 maxSize = 0)

qint64 QIODevice::​write(const char * data, qint64 maxSize)
qint64 QIODevice::​write(const char * data)
qint64 QIODevice::write(const QByteArray & byteArray)

char* 和 QByteArray: 获取数据的两种方式，char*系统编程接口方式；QByteArray Qt编程接口方式
read(readAll) 和 readLine: 前者强调指定数据长度，即尽力返回指定长度的数据；后者强调NULL结尾字符串，即在指定长度内优先返回NULL结尾字符串。

readLine() 会一直读取数据直到如下三个条件之一满足：
1. 第一个 '\n' 字符读取到缓冲区。
2. maxSize - 1 字节数已读取，最后一个字节预留给 0 。
3. 文件或设备读取已经到末尾。

# QTextStream 文本流游标 -- 为读写QString提供方便接口 (强调数据的读写)  words, lines numbers 实现编解码功能 - QTextCodec::codecForLocale() 
QString QTextStream::​read(qint64 maxlen)
最多读取的字符数目，如果文本流里的数据不够，返回的字符串就是剩余的字符数。

QString QTextStream::​readAll() 读取文本流中所有内容.
QString QTextStream::​readLine(qint64 maxlen = 0)
读取一行文本的时候，返回字符串末尾剔除了换行符（"\n"  或 "\r\n"）

将QString作为函数返回值。
read(readAll) 和 readLine: 前者强调指定数据长度，即尽力返回指定长度的数据；后者强调NULL结尾字符串，即在指定长度内优先返回NULL结尾字符串。

1. Chunk by chunk          readLine() or readAll().
2. Word by word            QStrings, QByteArrays and char* buffers
                           QTextStream & QTextStream::​operator>>(QString & str)
                           QTextStream & QTextStream::​operator>>(QByteArray & array)
3. Character by character  QChar 
                           QTextStream & QTextStream::​operator>>(char * c)

    空白字符包括空格、制表符、换行符等等。
当文本流用 >> 读取逐个字符到 QChar 或 char 变量里面时，可以用
void QTextStream::​skipWhiteSpace()
跳过空白字符，如果不跳过空白字符，那么 QChar 和 char 也会接收到空白字符，如空格、制表符、换行符等等。

%% tableedit  tableedit没有将 行 作为处理单元，而是直接通过忽略空白的形式 读取 名称-年龄-体重 序列。 skipWhiteSpace()是要点
%% unixconfig tableedit是按照序列的方式存储 "名称-年龄-体重", unixconfig是按照 "key=value"方式存储 "ip = 192.168.1.1"等的。
              tableedit作为序列，以空白分割 "名称-年龄-体重", "名称"与"年龄","年龄"与"体重"之间使用空白分割。"体重"和"名称"也使用空白分割。
              unixconfig作为"k-v"对，以行作为"k-v"对象，k和v之间通过"="将k和v分隔开。

              unixconfig IP地址验证器
              
# QDataStream
QDataStream & QDataStream::​writeBytes(const char * s, uint len) //变量 len 也会写入数据流
QDataStream & QDataStream::​readBytes(char *& s, uint & l)       // l 数值是从数据流里读出来的，就是上面的 len
               len长度内容  + 缓冲区内容
写入数据内容 = sizeof(uint) + length(char*)    
读取数据内容 = sizeof(uint) + len长度内容      

QDataStream & QDataStream::​operator<<(const char * s)
QDataStream & QDataStream::​operator>>(char *& s)
               len长度内容  + 缓冲区内容
写入数据内容 = sizeof(uint) + strlen(char*)   
读取数据内容 = sizeof(uint) + len长度内容     

int QDataStream::​writeRawData(const char * s, int len)
int QDataStream::​readRawData(char * s, int len)
               缓冲区内容
写入数据内容 = length(char*)   
读取数据内容 = len长度内容     

writeBytes和​readBytes强调len; >>和<< 强调NULL结尾; ​writeRawData和readRawData强调len
writeBytes和​readBytes; >>和<< ; 输入输出内容中携带数据长度。writeRawData和readRawData 输入输出内容不携带数据长度。

QDataStream 和 QTextStream 实现若干基本类型的整合；扩展类型序列化udppack 基本数据类型 dsedit
                                                   分隔符: 空白分割单词 dsedit 换行分割行 tableedit 
差异化: 大方向 QDataStream实现序列化和反序列化 QTextStream实现格式化printf 逆格式化scanf
差异化: 小方向 QString QByteArray char *str字符串 的处理上，QTextStream倾向回车分割，QDataStream倾向 length+字符串内容 方式
外加关注点: QString QByteArray char* str字符串之间的转换
共同点: 游标，atEnd() 读写错误处理

哪些情况槽函数直接返回?
哪些情况槽函数通过QMessageBox提示之后返回?


=========================== QFile QTextStream QDataStream - 游标====== =========


