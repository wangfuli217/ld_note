QPixmap 类代表图像，实现在 QtGui 共享库中。

1. 构造
以下构造函数生成的 QPixmap 对象为空图像：
QPixmap();     // 构造一个大小为 0 的空图像
以下构造函数生成大小的 QPixmap 对象，但图像数据未初始化：
QPixmap(const QSize &size);     // 构造大小为 size 的图像，图像数据未初始化
QPixmap(int width, int height);    // 等价于 QPixmap(QSize(width, height));

以下构造函数能够从指定的文件中加载图像并生成 QPixmap 对象：
QPixmap(const QString &filename, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
其各个参数的含义解释如下。
  1) filename： 文件名。
  2) format： 字符串，表示图像文件的格式，如果为 0，将进行自动识别。
  3) flags：表示颜色的转换模式。
    如果图像文件加载失败则产生空图像，这里 flags 参数有以下取值。
    1) Qt::AutoColor：由系统自动决定。
    2) Qt::ColorOnly：彩色模式。
    3) Qt::MonoOnly：单色模式。

2. 图像参数
以下成员函数可以获得 QPixmap 对象所表示的图像的相关信息：
int depth() const;     // 颜色深度，既每像素所占的比特数
int width() const;     // 图像宽度，单位是像素
int height() const;    // 图像高度，单位是像素
QSize size() cosnt;    // 图像的大小，即 QSize(width(), height());
QRect rect() const;    // 图像的矩形区域，即 QRect(QPoint(0,0),size());

3. 加载和保存图像
用下面的成员函数可以从文件加载图像：
bool load(const QString &filename, const char *fornat = 0, Qt::ImageCoversionFlags flags = Qt::AutoColor);
    这里各个参数的含义与构造函数中一样，返回值为 true 表示加载成功，false 表示加载失败。相反的操作是将 Qpixmap
代表的图像保存到文件，可用以下成员函数：

bool save(const QString &filename, const char *format = 0, int quality = -1) const;
其各个参数及返回值的含义解释如下。
1) filename：文件名。
2) format：字符串，表示图像文件的格式，如果为 0，将根据文件名的后缀自动确定文件格式。
3) quality：对于有损压缩的文件格式来说，它表示图像保存的质量，质量越低压缩率越大。取值范围为 0～100，-1 表示采用默认值。
4) 返回值：true 表示保存成功，false 表示保存失败。


4. 判断
以下成员函数可以判断 QPixmap 对象是否为空图像：
bool isNull() const;     // 判断是否为空图像









QPixmap与QImage的区别:
QPixmap依赖于硬件，QImage不依赖于硬件。
QPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I/O、图片访问和像素修改而设计的。

    当图片小的情况下，直接用QPixmap进行加载，画图时无所谓，当图片大的时候如果直接用QPixmap进行加载，会占很大的内存，
一般一张几十K的图片，用QPixmap加载进来会放大很多倍，所以一般图片大的情况下，用QImage进行加载，然后转乘QPixmap用户绘制。
QPixmap绘制效果是最好的。

Qpixmap用法:(转自http://blog.csdn.net/caihuisinx/article/details/7343916)
我想qt 中QPixmap这个类大家都很熟悉，它可以很简单的在标签上贴图；例如：
QPixmap p;
p.load("1.png")；
label->setPixmap(p);
就这么简单，但是我今天突然发现个问题，就是：
QPixmap p;
p.load("1.png")；
label->setPixmap(p);
p.load("2.png");
label->setPixmap(p);
p.load("1.png")；
label->setPixmap(p);
当用同一个p，即全局变量时，你加载图片1，显示图片1；再加载图片2，显示图片2；可当你再想变回图片一时，
你再加载图片一，不好使了，变不回来了，还是显示图片二，你在加载个图片三，好使，再想变回图片二，不好使了。。。。。。

这是为神马呢？？？
原来，p.load（）是将图片加载到缓冲区中：QPixmapCache，当你加载图片二是，图片一并没有被覆盖，此时缓冲区内有图片一和图片二，
当你再次加载图片一时，以为缓冲区里应经有了，所以p.load()，直接返回true；但是图片仍是图片二，所以不能显示回图片一！

解决办法很简单，有三种办法：
1. 直接定义局部变量，这样每次都是新的缓冲区；
2. 当再次加载图片时，先将缓冲区清空，    QPixmapCache::clear();然后再加载；
3. 在初始化函数里写：QPixmapCache::setCacheLimit(1);设置缓冲区内只能放一张图片，这样就会替换原来的图片，就可以加载新的图片了！


