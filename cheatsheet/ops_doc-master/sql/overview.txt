https://github.com/hhe0/blog_md

sql(SQL相关的概念){
    数据库：保存有组织的数据的容器（通常是一个文件或一组文件）；
    表：某种特定类型数据的结构化清单；
    模式：关于数据库和表的布局及特性的信息；
    列：表中的一个字段。所有表都是由一个或多个列组成；
    数据类型：所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据；
    行：表中的一个记录；
    主键：一列（或一组列），其值能够唯一表示表中的每个行；
    SQL：一种专门用来和数据库进行通信的结构化查询语言；
    聚集函数：运行在行组上，计算和返回单个值的函数；
    视图：虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询；
    事务处理：用来维护数据库的完整性，它保证成批的SQL操作要么完全执行，要么完全不执行。

作为主键的条件
    任意两行都不具有相同的主键值；
    每个行都必须具有一个主键值（主键列不允许NULL值）；
    主键列中的值不允许修改或更新；
    主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。
}

sql(检索数据){
介绍如何使用SELECT语句从表中检索一个或多个数据列。
注意
    未经过显示排序查询得到的结果的顺序不具有特殊意义。可能是数据被添加到表中的顺序，也可能不是；
    SQL语句不区分大小写，但是表名、列名可能区分大小写；
    通过通配符来检索数据可能会因为检索不需要的列而降低查询的性能。

排序检索数据
    介绍如何使用SELECT的ORDER BY子句，根据需要排序检索出的数据。
注意
    对多个列进行排序时，除非显示指定该列为DESC，否则都为ASC；
    不推荐根据列位置进行排序；
    该子句必须为SELECT语句的最后一条子句。

过滤数据
    介绍如何使用SELECT语句的WHERE子句指定搜索条件。
注意
    通常应考虑在SQL中过滤数据而不是在应用层过滤；
    空值的判断是IS NULL而不是= NULL；
    空值NULL与字段包含0、空字符串或仅仅包含空格不同；
    BETWEEN操作费可以用来检索指定数值或者日期之间的数据。

高级数据过滤
    介绍如何组合WHERE子句以建立功能更强、更高级的搜索条件，以及如何使用NOT和IN操作符。

使用IN操作符的好处
    在使用长的合法选项清单时，IN操作符的语法更清楚且更直观；
    在使用IN时，计算的次序更容易管理（因为使用的操作符更少）；
    IN操作符一般比OR操作符清单执行更快；
    IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。

NOT操作符主要用来一些较为复杂的子句，例如NOT EXISTS。
用通配符进行过滤
    介绍什么是通配符、如何使用通配符以及怎样使用LIKE操作符进行通配搜索，以便对数据进行复杂过滤。
注意
    %表示任何字符出现的任意次数；
    _表示只匹配单个字符而不是多个字符；
    []用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符；

使用通配符的技巧
    不要过分使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符；
    在确实需要使用通配符时，除非确实有必要，否则不要把它们用在搜索模式开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的；
    仔细注意通配符的位置。

创建计算字段
    介绍什么是计算字段、如何创建计算字段以及怎样从应用程序中使用别名引用它们。

使用数据处理函数
    介绍什么是函数，DBMS支持何种函数，以及如何使用这些函数。本章还介绍了为什么SQL函数的使用可能会带来问题。

大多数SQL实现支持以下类型的函数
    用于处理文本串的文本函数；
    用于在数值数据上进行算术操作的数值函数；
    用于处理日期和时间值并从这些值中提取特定成分；
    返回DBMS正使用的特殊信息的系统函数。

汇总数据
    介绍什么是SQL的聚集函数以及如何利用它们汇总表的数据。

常用的聚集函数
函数 	说明
AVG() 	返回某列的平均值
COUNT() 	返回某列的行数
MAX() 	返回某列的最大值
MIN() 	返回某列的最小值
SUM() 	返回某列值之和

COUNT()函数有两种使用方式
    使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值(NULL)还是非空值；
    使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。

注意
    AVG()函数忽略列值为NULL的行；
    如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果COUNT()函数中用的是星号(*)，则不忽略；
    MAX()函数忽略列值为NULL的行；
    MAX()函数在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行；
    MIN()函数忽略列值为NULL的行；
    MIN()函数在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面一行；
    SUM()函数忽略列值为NULL的行。

分组数据
    介绍如何使用分组数据，以便能汇总表内容的子表。这涉及两个新SELECT语句子句，分别是：GROUP BY子句和HAVING子句。

GROUP BY语句的一些重要规定
    GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的空值；
    如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定所有列都一起计算（所以不能从个别的列取回数据）；
    GROUP BY子句中列出的每个列都必须是检索列会有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名；
    大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）；
    除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出；
    如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组；
    GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。

HAVING与WHERE的区别
    HAVING过滤分组，WHERE过滤行；
    WEHRE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。

一般在使用GROUP BY子句时，应该也给出ORDRE BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。
使用子查询
    介绍什么是子查询以及如何使用它们。
注意
    作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误；
    使用子查询并不总是执行这种类型的数据检索的最有效的方法。

联结表
    介绍什么是联结，为什么要使用联结，以及编写使用联结的SELECT语句。
创建高级联结

    介绍其他的一些联结类型（包含它们的含义和使用方法），介绍如何对被联结的表使用表别名和聚集函数。
注意
    联结的几种类型：内部联结（等值联结）、自联结、自然联结和外部联结；
    注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的；
    关于确切的联结语法，应该查看具体的文档，看相应的DBMS支持何种语法；
    保证使用正确的联结条件（不管使用何种语法），否则将返回不正确的数据；
    应该总是提供联结条件，否则会得到笛卡尔积；
    在一个联结表中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。

组合查询
    介绍如何使用UNION操作符将多条SELECT语句组合成一个结果集。
有两种基本情况，其中需要使用组合查询
    在单个查询中从不同的表类似返回结构数据；
    对单个表执行多个查询，按单个查询返回数据。
UNION规则

    UNION规则由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔；
    UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）；
    列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型；
    使用UNION ALL，DBMS不取消重复的行。
}

sql(插入数据){
介绍如何利用SQL的INSERT语句将数据插入表中。

插入可以用一下几种方式使用

    插入完整的行；
    插入行的一部分；
    插入某些查询的部分。

注意

    一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化；
    INSERT SELECT与SELECT INTO之间的一个重要差别是前者导出数据，而后者导入表。

更新和删除数据

    介绍如何利用UPDATE和DELETE语句进一步操纵表数据。

注意

    除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句；
    保证每个表都有主键，尽可能像WHERE子句那样使用它；
    在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确；
    使用强制实施引用完整性的数据库，这样DBMS将不允许删除具有与其他表相关联的数据的行；
    有的DBMS允许数据库管理员施加约束，以防止执行不带WHERE子句的UPDATE或DELETE。如果所采用的DBMS支持这个特性，应该使用它。

创建和操纵表

    介绍表的创建、更改和删除的基本知识。

更新表时需要考虑的内容

    一般来说，在表中包含数据时不要对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，以便今后不会对表的结构作大的改动；
    所有DBMS都允许给现有的表增加列，不过对所增加的列的数据类型（以及NULL和DEFAULT的使用）有所限制；
    许多DBMS不允许删除或更改表中的列；
    多数DBMS允许重新命名表中的列；
    许多DBMS对已经填有数据的列的更改有限制，对为填有数据的列几乎没有限制。

使用视图

    介绍视图是什么，它们怎样工作，何时使用它们。

视图的常见使用场景

    重用SQL语句；
    简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节；
    使用表的组成部分而不是整个表；
    保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
    更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。

注意

    因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。

视图的规则和限制

    与表一样，视图必须唯一命名（也不能与表重名）；
    对于可以创建的视图数目没有限制；
    为了创建视图，必须具有足够的访问权限；
    视图可以嵌套；
    许多DBMS禁止在视图查询中使用ORDRE BY子句；
    有的DBMS要求命名返回的所有列，如果列是计算字段，则需要使用别名；
    视图不能索引，也不能有关联的触发器或默认值；
    有的DBMS把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写会底层表；
    有的DBMS允许创建这样的视图，它不允许进行导致不再属于视图的插入或更新。
}

sql(使用存储过程){
    介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法。
为什么要使用存储过程
    通过把处理封装在容易使用的单元中，简化复杂的操作；
    由于不要求反复建立一系列处理步骤，保证了数据的一致性；
    简化对变动的管理；
    因为存储过程通常以编译过的形式存储，所以DBMS为处理命名所做的工作较少。结果是提高了性能；
    存在一些只能用在单个请求中的SQL元素和特定，存储过程可以使用它们来编写功能更强更灵活的代码。
}

sql(管理事务处理){
    介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理实务处理。
事务相关概念
    事务：一组SQL语句；
    回退：撤销指定SQL语句的过程；
    提交：将未存储的SQL语句结果写入数据库表；
    保留表：事务处理中设置的临时占位符，可以对它发布回退（与回退整个事务处理不同）。
}

sql(使用游标){
介绍了什么是游标以及如何使用游标。
游标常见的一些选项和特性
    能够标记游标为只读，使数据能读取，但不能更新和删除；
    能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）；
    能标记某些列为可编辑的，某些列为不可编辑的；
    规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问；
    指定DBMS对检索出的数据（而不是指出表中活动数据）做复制，使在游标打开和访问期间数据不变化。
使用游标的几个步骤
    在能够使用游标前，必须声明（定义）它；
    一旦声明后，必须打开游标以供使用；
    对于填有数据的游标，根据需要去除（检索）各行；
    在结束游标使用时，必须关闭游标，可能的话，释放游标。
}