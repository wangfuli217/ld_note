1、  for i in $(ls *.mp3)
2、  cp $file $target
3、  Filenames with leading dashes
4、  [ $foo = "bar" ]
5、  cd $(dirname "$f")
6、  [ "$foo" = bar && "$bar" = foo ]
7、  [[ $foo > 7 ]]
8、  grep foo bar | while read -r; do ((count++)); done
9、  if [grep foo myfile]
10、 if [bar="$foo"]
11、 if [ [ a = b ] && [ c = d ] ]
12、 read $foo
13、 cat file | sed s/foo/bar/ > file
14、 echo $foo
15、 $foo=bar
16、 foo = bar
17、 echo <<EOF
18、 su -c 'some command'
19、 cd /foo; bar
20、 [ bar == "$foo" ]
21、 for i in {1..10}; do ./something &; done
22、 cmd1 && cmd2 || cmd3
23、 echo "Hello World!"
24、 for arg in $*
25、 function foo()
26、 echo "~"
27、 local varname=$(command)
28、 sed 's/$foo/good bye/'
29、 tr [A-Z] [a-z]
30、 ps ax | grep gedit
31、 printf "$foo"
32、 for i in {1..$n}
33、 if [[ $foo = $bar ]] (depending on intent)
34、 if [[ $foo =~ 'some RE' ]]
35、 [ -n $foo ] or [ -z $foo ]
36、 [[ -e "$broken_symlink" ]] returns 1 even though $broken_symlink exists
37、 ed file <<<"g/d\{0，3\}/s//e/g" fails
38、 expr sub-string fails for "match"
39、 On UTF-8 and Byte-Order Marks (BOM)
40、 $() removes trailing newlines


1. for i in $(ls *.mp3)
  for i in $(ls *.mp3); do    # 错误!
      some command $i         # 错误!
  done
  for i in $(ls)              # 错误!  for i in `ls`

  for i in $(find . -type f)  # 错误!  for i in `find . -type f`
  files=($(find . -type f))   # 错误!
  for i in ${files[@]}        # 错误!
  
使用命令展开时不带引号，其执行结果会使用IFS作为分隔符，拆分成参数传递给for循环处理；
不应该让脚本去解析ls命令的结果；
问题1：WordSplitting
   文件名为"01 - Don't Eat the Yellow Snow.mp3"
   for i in $(ls *.mp3); do echo $i; done # 则
   01
   -
   Don't
   Eat
   the
   Yellow
   Snow.mp3
问题2：glob characters {*?[]}
$ touch "1*.mp3" "1.mp3" "11.mp3" "12.mp3"
$ for i in $(ls *.mp3); do echo $i; done
1*.mp3 1.mp3 11.mp3 12.mp3
1.mp3
11.mp3
12.mp3
1.mp3
11.mp3
12.mp3
不过，在这种场景下，你即使加上引号，也是无济于事的：
$ for i in "$(ls *.mp3)"; do echo --$i--; done
--1*.mp3 1.mp3 11.mp3 12.mp3--
加上引号后，ls执行的结果会被当成一个整体，所以for循环只会执行一次，达不到预期的效果。

问题3：命令替换
正确：

# 正确方法 不递归
for i in ./*.mp3; do
    [ -e "$i" ] || continue # "$i"如果文件名为"-h"会导致错误
    some command "$i"
done
# 正确方法 递归
find . -type f -name '*.mp3' -exec some command {} \;
find . -type f -name '*.mp3' -exec some command {} +

while IFS= read -r -d '' file; do 
    some command "$file" 
done < <(find . -type f -name '*.mp3' -print0)

2. cp $file $target # 问题原因： WordSplitting和pathname expansion.
cp -- "$file" "$target" # 可以防止"$file"为包含空格的文件名；不能防止文件名第一个字符为"-"的错误

3. 文件名中包含短横'-'
    文件名以'-'开头会导致许多问题，*.mp3这种通配符会根据当前的locale展开成一个列表，
但在绝大多数环境下，'-'排序的时候会排在大多数字母前。这个展开的列表传递给有些命令的时候，
会错误的将-filename解析成命令行选项。
cp -- "$file" "$target" # 不要继续对--之后的内容进行命令行参数/选项解析

确保文件名都使用相对或者绝对的路径，以目录开头：
for i in ./*.mp3; do      for i in *.mp3; do 
    cp "$i" /target           cp "./$i" /target
    ...                       ... 
done                      done
这种情况下，即使某个文件以-开头，展开后文件名依然是./-foo.mp3这种形式，完全不会有问题。
for i in "*.mp3"; do -> 一次返回所有符合条件的

4. [ $foo = "bar" ]
如果[中的变量不存在，或者为空，这个时候上面的例子最终解析结果是：
[ = "bar" ] # 错误!

并且执行会出错：unary operator expected，因为=是二元操作符，它需要左右各一个操作数。
如果变量值包含空格，它首先在执行之前进行单词拆分，因此[命令看到的样子可能是这样的：
[ multiple words here = "bar" ];

正确的做法应该是：
# POSIX
[ "$foo" = bar ]
或者
# POSIX | Bourne
[ x"$foo" = xbar ]
[ x$user = "xadmin" ]
[ "x$user" = "xadmin" ]
[ x$user = xadmin ]
[ x$user = x"admin" ]
[ "$user" = "admin" ]
或者
# Bash / Ksh
[[ $foo == bar ]] # 推荐
这里你不需要使用引号，因为在[[里面参数不会进行展开，当然带上引号也不会有错。
[[ "$foo" == bar ]] # $foo不支持glob pattern
[[ $foo == bar ]]   # $foo支持glob pattern
[[ "$foo" =~ bar ]] # $foo不支持regular pattern
[[ $foo =~ bar ]]   # $foo支持regular pattern

5. cd $(dirname "$f") # 问题原因： WordSplitting和pathname expansion
   cd "$(dirname "$f")" # 正确

6. [ "$foo" = bar && "$bar" = foo ]
[ bar = "$foo" ] && [ foo = "$bar" ] # POSIX        推荐
[[ $foo = bar && $bar = foo ]]       # Bash / Ksh   推荐
[ bar = "$foo" -a foo = "$bar" ]                    不推荐

7. [[ $foo > 7 ]]
原文作者认为算术比较不应该用[[，而是用((，我没弄明白是为什么。
((foo > 7))        # 不推荐
[ "$foo" -gt 7 ]   # 推荐
# 判断foo同时判断foo是否大于7
case $foo in
    *[![:digit:]]*)
        printf '$foo expanded to a non-digit: %s\n' "$foo" >&2
        exit 1
        ;;
    *)
        [ $foo -gt 7 ]
esac

8. grep foo bar | while read -r; do ((count++)); done
这种写法初看没有问题，但是你会发现当执行完后，count变量并没有变化。
原因是管道后面的命令是在一个子Shell中执行的。

9. if [grep foo myfile]
    [是一个命令，它同其它常规的命令一样接受参数。if是一个复合命令，它包含其它命令，[并不是if语法中的一部分
if [ false ]; then echo "HELP"; fi  # HELP
if test false; then echo "HELP"; fi # HELP

if语句的语法是：
if COMMANDS
    then <COMMANDS>
elif <COMMANDS> # optional
    then <COMMANDS>
else <COMMANDS> # optional
fi # required

如果你想根据grep命令的结果来做事情，你不需要把grep放到[里面，只需要在if后面紧跟grep即可：
if grep -q fooregex myfile; then
...
fi

10. if [bar="$foo"]; then ...
正如上一个问题中提到的，[是一个命令，它的参数之间必须用空格分隔。
[bar="$foo"]                   # 错误 
[ bar="$foo" ]                 # 错误
if [ bar = "$foo" ]; then ...  # 正确

11. if [ [ a = b ] && [ c = d ] ]; then ...
不要用把[命令看成C语言中if语句的条件一样，它是一个命令。
如果你想表达一个复合的条件表达式，可以这样写：
if [ a = b ] && [ c = d ]; then ...
注意，if后面有两个命令，它们用&&分开。等价于下面的写法：
if test a = b && test c = d; then ...
if [[ a = b && c = d ]]; then ...

12. read $foo
read命令中你不需要在变量名之前使用$。如果你想把读入的数据存放到名为foo的变量中，下面的写法就够了：
read foo
或者，更加安全地方法：
IFS= read -r foo
read $foo会把一行的内容读入到变量中，该变量的名称存储在$foo中。所以两者的含义是完全不一样的。

13. cat file | sed s/foo/bar/ > file
你不应该在一个管道中，从一个文件读的同时，再往相同的文件里面写，这样的后果是未知的。
你可以为此创建一个临时文件，这种做法比较安全可靠：
# sed 's/foo/bar/g' file > tmpfile && mv tmpfile file

14. echo $foo # 会对$foo进行glob pattern匹配 -> printf "%s\n" "$foo"
msg="Please enter a file name of the form *.zip"
echo $msg
这里整句话会被拆分成单词，然后其中的通配符会被展开，例如*.zip。当你的用户看到如下的结果时，他们会怎样想：
Please enter a file name of the form freenfss.zip lw35nfss.zip

再举一个例子（假设当前目录下有以 .zip 结尾的文件）：
var="*.zip"   # var 包括一个星号，一个点号和 zip
echo "$var"   # 输出 *.zip
echo $var     # 输出所有以 .zip 结尾的文件
实际上，这里使用 echo 命令并不是绝对的安全。

完全可靠的打印变量值的方法是使用 printf：
printf "%s\n" "$foo"

17. echo <<EOF
当脚本需要嵌入大段的文本内容时，here document往往是一个非常有用的工具，它将其中的文本作为命令的标准输入。
# This is wrong:
echo <<EOF
Hello world
How's it going?
EOF

正确的方法是，使用 cat 命令来完成：
# This is what you were trying to do:
cat <<EOF
Hello world
How's it going?
EOF

19. cd /foo; bar #  cd /foo && bar
20. [ bar == "$foo" ]
正确的用法:
[ bar = "$foo" ] && echo yes
[[ bar == $foo ]] && echo yes

21. for i in {1..10}; do ./something &; done
你不应该在&后面添加分号，删除它：
for i in {1..10}; do ./something & done
或者改成多行的形式：
for i in {1..10}; do
    ./something &
done
&和分号一样也可以用作命令终止符，所以你不要将两个混用到一起。

22. cmd1 && cmd2 || cmd3
有些人喜欢把&&和||作为if...then...else...fi 的简写语法，在多数情况下，这种写法没有问题。

23. echo "Hello World!"
在交互式的 Shell 环境下，你执行以上命令会遇到下面的错误：
bash: !": event not found
这是因为，在默认的交互式 Shell 环境下，Bash 发现感叹号时会执行历史命令展开。在 Shell 脚本中，这种行为是被禁止的，所以不会发生错误。

24. for arg in $*
for arg in $*
和大多数 Shell 一样，Bash 支持依次读取单个命令行参数的语法。
不过这并是$*或者$@，这两种写法都不正确，它们只能得到完整的参数列表，并非单独的一个个参数。
正确的语法是（没错要加上引号）：
for arg in "$@"
# 或者更简单的写法
for arg

25. function foo()
这种写法不一定能够兼容所有 shell，兼容的写法是：
foo() {
  ...
}

26. echo "~"
波浪号展开（Tilde expansion）仅当~没有引号的时候发生，在上面的例子中，只会向标准输出打印~符号，
而不是当前用户的家目录路径。

27. local varname=$(command)
当在函数中声明局部变量时，local作为一个独立的命令，这种奇特的行为有时候可能会导致困扰。
比如，当你想要捕获命令替换的返回码时，你就不能这样做。local命令的返回码会覆盖它。
这种情况下，你只能分成两行写：
local varname
varname=$(command)
rc=$?

28. export foo=~/bar
    export 与 local 命令一样，并不是赋值语句的一部分。因此，
在有些 Shell 下（比如Bash），export foo=~/bar会展开，但是有些（比如 Dash）却不行。
下面是两种比较健壮的写法：
foo=~/bar; export foo    # Right!
export foo="$HOME/bar"   # Right!

29. sed 's/$foo/good bye/'
单引号内部不会展开 $foo变量，在这里可以换成双引号：
foo="hello"; sed "s/$foo/good bye/"
但是要注意，如果你使用了双引号，就需要考虑更多转义的事情

30. tr [A-Z] [a-z]
LC_COLLATE=C tr A-Z a-z
如果你希望根据实际的语言环境来转换：
tr '[:upper:]' '[:lower:]'

33. for i in {1..$n}
Bash的命令解释器会优先展开大括号，所以这时大括号{}表达式里面看到的是文字上的$n（没有展开）。$n 不是一个数值，
所以这里的大括号{}并不会展开成数字列表。可见，这导致很难使用大括号来展开大小只能在运行时才知道的列表。
可以用下面的方法：
for ((i=1; i<=n; i++)); do
...
done

34. if [[ $foo = $bar ]]
在[[内部，当=号右边的值没有用引号引起来，bash 会将它当作模式来匹配，而不是一个简单的字符串。
所以，在上面的例子中 ，如果 bar 的值是一个*号，执行的结果永远是 true。
所以，如果你想检查两侧的字符串是否相同，等号右侧的值一定要用引号引起来。
if [[ $foo = "$bar" ]]

35. if [[ $foo =~ 'some RE' ]]
同上，如果=~号右侧的值加上引号，它会散失特殊的正则表达式含义，而变成一个普通的字符串。
如果你想使用一个长的或者复杂的正则表达式，避免大量的反斜杠转义，建议把它放在一个变量中：
re='some RE'
if [[ $foo =~ $re ]]

36. [ -n $foo ] or [ -z $foo ]
这个例子中，$foo 没有用引号引起来，当$foo包含空格或者$foo为空时都会出问题：


40. On UTF-8 and Byte-Order Marks (BOM)
多数情况下，UNIX 下 UTF-8 类型的文本不需要使用 BOM，文本的编码是根据当前语言环境，
MIME类型或者其它文件元数据信息确定的。人为阅读时，不会因为在文件开始处加 BOM 标记而腚影响，
但是当文件要被脚本解释执行时，BOM 标记会像 MS-DOS 下的换行符（^M）一样奇怪。

