基本方法

    内存转储，异常复位后，可以把某块 RAM 区域数据或者设备整个的 RAM 数据全部 dump 出来，通过工具加载 ramdump 可以恢复异常现场，用于问题调试
    将准备好的 vmcore 文件，vmlinux 文件一同放到 crash 目录下。 运行命令./crash vmcore vmlinux

Crash工具( Redhat 提供的一个开源工具)非常强大，值得好好学习一下。可以内存搜索，可以显示结构内容，如struct task_struct 0x12243434343, 就会把内存地址强制转换成task_struct显示出来，也可以struct task_struct,这样就是task_struct结构的大小。

    crash 是和 kdump 工具配套使用，用于解析 kdump 生成的 vmcore 文件。vmcore 是内核的映像（实际上是整个内存的映像，一般来说我们会开启过滤功能，只记录内核页）。内核全部的数据结构都在这个映像里面。crash 解析 vmcore 可以让我们看到触发 kdump 时刻系统的各种状态和内容，信息非常丰富，是定位分析内核问题的利器。
    显示内核日志: 内核把日志打印到内核态的日志缓冲区内，用户态 klogd 负责读取并转发给 syslog 记录到磁盘。在内核故障时，可能无法记录到磁盘，但内核日志缓冲区里面一般会有记录。既然 vmcore 是内存映像，那么日志缓冲区也就在里面了。内核最后打印的日志往往是我们分析内核问题的起点。
    启动 crash（ crash /default /default.gz vmcore）--- 显示系统信息（sys） --- 显示执行 KDUMP 的堆栈（bt） --- 显示进程列表（ ps | more）--- 显示进程的内核栈（bt pid） --- 查看内存使用信息（kmem -i） --- 查看数据结构（ps |grep UN） --- 查看全局变量（p variable_name） --- 查看XXX变量 --- 查看某个指令地址对应的代码行(l *0xfffffffaddr) --- 显示指定 pid 打开的文件（files）
        崩溃时间,CPU,内存,panic的原因
        mod命令加载模块debuginfo信息
            未加载模块debuginfo信息,则无法解析模块的数据结构
            mod -S <模块目录> 加载模块
        foreach 针对系统中每个进程显示 command 数据
        堆栈信息 分析
            Oops：表示当前内核故障类型
            002：页面错误码，表示内核试图写一个不存在的页面
                bit 0 == 0: no page found 1: protection fault
                bit 1 == 0: read access 1: write access
                bit 2 == 0: kernel-mode access 1: user-mode access
                bit 3 == 1: use of reserved bit detected
                bit 4 == 1: fault was an instruction fetch
        offset确定执行的代码行 ： l *struct+0xe3
            crash支持gdb常用命令
            l *命令可以分析堆栈的具体代码行
        log 显示 kernel log 信息
        vtop命令查看地址页表
            PUD页表无法正常解析,说明页表可能被踩或者地址错误
            内核的地址区域都有不同的用途的,因此可以分析地址是否正确
        mount 显示已 mount 的文件系统信息
        task 显示指定进程的 task_struct 和 thread_info 信息
        bt 显示 kernel 进程的 backtrace
        dis 用于反汇编指定函数或内存地址
            一般函数的开头部分都先保存寄存器的只到stack中,函数返回前从stack中恢复寄存器的只;
            接着预留函数局部变量的空间 sub $0x18,%rsp
        irq 显示中断数据信息
        kmem 用于显示 kernel 的 memory 信息
            kmem -S > slab.all 解析所有slab内存地址
            从解析文件可以确认某个地址是空闲的,还是被使用的
            解析过程如果发现报错,则说明slab管理数据结构被破坏
            被破坏的原因可能是重复释放或者踩内存
        解析数据结构
            结构体名称+地址 直接解析数据结构 slab ffffaddr
            显示结构体成员偏移 slab -ox
        struct 显示结构体的定义或者显示指定地址的结构体内容
        sym 转换指定符号为其虚拟地址，显示系统中符号信息
        rd 读取 memory 内容
            对于异常的区域无法通过内置命令解析的,需要人工分析
            这个时候需要直接读取内存原始值
        手工分析stack
            寄存器压入栈的顺序同pt_regs成员顺序
            code地址通过查找符号表可以确认是属于哪个函数
            inline 函数 不是inline函数但是只有一个扇入被优化

在线使用 crash 剖析运行中的内核

    前面介绍了 crash 可以从 VMCORE 中解析出内核的数据结构，帮助我们分析内核问题。既然 VMCORE 是内存的映像，那么肯定也可以解析运行中的内核。这个会非常有用处，比如：
    某个进程 D 状态僵死了，系统还 OK，这时候没必要对系统做 KDUMP。而 echo t >/proc/sysrq-trigger 显示的信息又十分有限。而使用 crash 对运行内核做剖析，可以获取进程的方方面面，搞清楚问题所在。
    某些数据结构内核没有通过 proc 导出到外部，不能使用简单命令立即获取到，而这些数据结构对某些问题的分析又十分重要，使用 crash 对运行内核做剖析你可以获取到任何你想要的内容。比如一个 tcp 连接的全部状态信息，而不仅是 / proc/net/tcp 导出的那一点点。
    Hack 内核。你可以 "偷窥" 到内核的数据内容，比如页表。这对分析、学习内核源码会有很大的帮助。而且如果你比较 "邪恶" :) 你可以修改它。进入 crash 输入 help wr 你就知道了。前不久 suse11 内核有一个计数溢出的 BUG，需要 400 天才能重现，用 wr 命令修改了一个基础变量的值，立马就看到问题现象了，比重新编译内核快多了

调试工具参考资料
在几秒钟内根据core文件找到出错源码行

    一般的方法就是根据堆栈对照源码进行反汇编，找到出错源代码行
    既有debug信息发布的程序文件容量又不大
        gdb在打开-g调试开关为程序增加调试信息后，不会改变程序的指令地址及指令执行顺序, 即两者的汇编代码完全一致。
        在编译版本时同时编译包含调试信息的debug版本和不包含调试信息的release版本。并归档源代码。
        同一份代码的debug版本归档；release版本发布；一对一。在需要分析core文件时，使用debug版本进行分析即可。
    每次编译都同时生成debug和release版本: gdb debugfile corefile

常见的内核问题：oops、panic、空指针、踩内存、死锁、MCE(Machine Check Exception) 系统硬件出现异常、内存耗尽，杀死进程、文件系统只读
常见的定位手段：魔术键、串口、Kbox、Crash、objdump
常见的分析思路

    踩堆栈问题
        bt 命令显示出问题进程堆栈, 发现无法解析堆栈
        根据 RSP: ffff8801fddabf20, 读取stack的内存内存, 根据内存内容规律推出代码位置
    踩页表问题
        bt 观察出错的堆栈, 可以发现是一个地址错误;
        观察RIP: ffffffff8108af68的回报指令, 该指令用到(RAX+0x10)的地址
        观察这个地址的页表, 可以发现PMD指向了0, 说明这个地址的页表有问题;
        初步分析出页表被踩后, 接着可以通过被踩内存的内容, 推出可能的模块;
            或者通过crash时间点的附近日志分析可疑模块;
    踩静态变量问题
        通过sym -l命令可以看到内核符号, 先找到被踩静态变量的地址,
        然后观察其附近地址还有哪些静态变量;
        常见的场景是其前面的某个变量, 操作过程中溢出, 造成周围变量都被踩;
    Double free破坏slab管理区问题
        问题现象
            当出现slab管理区被破坏问题, 可以通过kmem -S命令观察是否打印出错误信息; 如果打印出错误信息, 则说明crash工具解析slab管理区的时候, 遇到错误数据;
            观察日志, 如果日志中出现slab计数错误的BUG_ON的时候;
        分析方法
            通过crash工具, 先分析出slab所属的区域名称是什么; 所以在开发代码过程中, 对于频繁使用内存的模块, 最好申请单独的slabp数据结构, 这可以方便定位问题;
            找到slab名称后, 分析代码中所有涉及的malloc和free流程; 观察这些流程在什么情况下会重复释放; 对于易于重现的问题, 可以直接通过增加地址打印, 方便找出重复释放位置;
    硬件DMA踩内存问题
        问题现象：堆栈没有任何规律, 唯一的相同点就是code区域是一样的, 而且数值是有规律的
        分析方法
            由于内核的code区是只读的, 因此通过线性地址无法去修改, 因此可以推出造成这个修改的必然使用物理地址; 硬件DMA有这个可能; 但是目标地址的内容与硬件设备的DMA没有直接联系; 除了硬件DMA之外, BIOS有直接操作物理内存的能力, 因此分析BIOS代码;
            最终发现驱动代码错误, DMA过程踩到BIOS, 造成BOIS运行过程踩到内核内存;
    死锁问题
        分析方法
            死锁问题, 关键点是当时每个CPU的堆栈是什么;
            通过bt -a命令可以打印出系统当时所有CPU运行的堆栈;
            通过解析锁的数据结构, 可以分析出哪个线程持有锁;
        常见死锁类型
            spinlock保护区中执行了非原子性的流程, 如sleep schedule流程;
            spinlock保护区中执行逻辑消耗的时间太长;
            AB-BA死锁;
            AA死锁, 重复上锁;
            环形锁, 在某些复杂架构设计中, 模块间的等待可能出现环形, 这会造成死锁;
            上锁和解锁不对称, 当锁指针运行中会被修改;