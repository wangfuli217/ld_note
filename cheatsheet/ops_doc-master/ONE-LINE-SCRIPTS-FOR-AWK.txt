1、删除偶数行(打印奇数行)
awk '1 == NR%2 { print $0 }' filename           # 在所有文件累计处理行数；在BEGIN模式中为0，在END模式中为累计处理行数。
awk '{ if(0 == NR%2) next; print $0 }' filename # next语句从输入文件中读取一行，然后从头开始执行awk脚本
awk '{ f = !f; if(f) print $0 }' filename       # 未初始化的字符串为空字符串; 未初始化的数值是0.
awk '{ getline tmp; print $0 }' filename        # 将从当前文件中读取的下条记录给variable, 修改了FNR和NR的值

2、删除奇数行(打印偶数行)
awk '0 == NR%2 { print $0 }' filename           # 有模式，有执行
awk '{ if(1 == NR%2) next; print $0 }' filename # 没有模式，只有执行
awk '{ if(f) print $0; f = !f }' filename
awk '{ if(getline tmp > 0) print tmp }' filename
awk '{ if(getline > 0) print $0 }' filename

# 模式，执行，内置变量，自定义变量，内置函数。
# 但凡模式中可以实现的，在执行中都可以实现；而执行中有很多是模式不能实现的。

一、将文本中每一行后面增加一个空行
awk '{ print $0 "\n" }' File        # $0 变量包括换行；
sed 'G' File                        # G函数把保存区域的内容添加到模式空间的内容之后；以前和新的内容用换行分隔。

二、将文本中每一行后面增加一个空行，有且只有一个空行
awk '!/^$/ { printf("%s\n\n", $0) }' File # print 和 printf 之间差异，OFS和ORS在print中有效，在printf中无效。
sed '/^$/d;G' File                        # /^$/ 表示揩油结尾之间无空格，
    print 语句将 ExpressionList 参数指定的每个表达式的值写至标准输出。每个表达式由 OFS 特殊变量的当前值隔开，
且每个记录由 ORS 特殊变量的当前值终止。
    printf 语句将 ExpressionList 参数指定的表达式以 Format 参数指定的格式写至标准输出。除了 c 转换规范(%c)
不同外，printf 语句和 printf 命令起完全相同的作用。

三、删除文本中的所有偶数行
awk '0 != NR%2 { print $0 }' File

sed 'n;d' File  # awk(next语句从输入文件中读取一行，然后从头开始执行awk脚本) 
                # sed(如果不禁止缺省的输出，则将模式空间写到标准输出。它用输入的下一行替换模式空间)
sed -n '1~2p' File

四、将文本中的内容倒序显示，模拟 tac 的功能
awk '{ a[i++] = $0 } END { for(j=i-1; j>=0; --j) print a[j] }' File  # 未初始化的数值数组为空，未初始化的数值是0.
sed '1!G;h;$!d' File # 1!G 判断执行， h; 无条件执行， $!d 判断执行     执行之间使用';' 分割，! 取反， $ 表示最后一行

五、将文本进行左对齐
awk '{ sub(/^[ \t]+/, ""); print $0 }' File # 左对齐，右对齐和居中对齐，就是对空白的处理(何处增加，何处删除，以及增加多少) 空白:'[ \t]' 
sed 's/^[ \t]*//' File                      # 涉及到定位符就是 ^$, 行首或行尾

六、将文本中每行结尾的空白字符、制表符删除
awk '{ sub(/[ \t]+$/; ""); print $0 }' File # 模式上，删除就是将 '[ \t]' 替换为空(不是替换成空白)
sed 's/[ \t]*$//' File

七、将文本中的两行连城一行
awk '{ f = !f; if(f) printf("%s", $0); else printf("%s\n", $0) }' File  # 自定义变量
awk '{ if(1 == NR%2) printf("%s", $0); else printf("%s\n", $0) }' File  # 内置变量
sed '$!N;s/\n//' File   # 若文本总行数为偶数，此种方法效果最好，上面三种方法会在最后一行之后加上'\n'

八、删除文本中所有的空行
sed '/^$/d' File
awk '!/^$/' /etc/monitrc 
awk '{ if(!match($0, /^$/)) print }' File #  match(string, regexp) 返回正则表示在string中的位置, 没有定位返回0

九、将文本中的 aaa 替换为 nnn
awk '{ if(/aaa/) gsub(/aaa/, "nnn"); print }' File  # sub/gsub(regexp, substitution string, [target string]); 
sed '/aaa/s/aaa/nnn/' File                          # 正则的, 就是vi中s/src/dest/ 和s/src/dest/g的区别, 如果[target string]没有输入, 其缺省值是$0.

十、打印匹配模式的上一行
sed -n '/aaa/{g;1!p;};h' File # 用保持空间保存上一行h;当匹配成功之后，用g将保持空间数据拷贝到模式空间输出。
awk '/aaa/{ print a }{ a = $0 }' File # 用临时变量保存上一行数据，条件正确则输出。

十一、删除文本中的重复行，只保留一行
sed '$!N; /^\(.*\)\n\1$/!P; D' File # 删除相邻的重复行；可与 sort 等结合使用
awk '!a[$0]++' File                         # 数据做索引
awk '!/./ || !a[$0]++' File # 不处理空白行？
awk '!NF || !a[$0]++' File # 同上

Latest version of this file (in English) is usually at:
   http://www.pement.org/awk/awk1line.txt

This file will also be available in other languages:
   Chinese  - http://ximix.org/translation/awk1line_zh-CN.txt   

USAGE:

   Unix: awk '/pattern/ {print "$1"}'    # standard Unix shells
DOS/Win: awk '/pattern/ {print "$1"}'    # compiled with DJGPP, Cygwin
         awk "/pattern/ {print \"$1\"}"  # GnuWin32, UnxUtils, Mingw

Note that the DJGPP compilation (for DOS or Windows-32) permits an awk
script to follow Unix quoting syntax '/like/ {"this"}'. HOWEVER, if the
command interpreter is CMD.EXE or COMMAND.COM, single quotes will not
protect the redirection arrows (<, >) nor do they protect pipes (|).
These are special symbols which require "double quotes" to protect them
from interpretation as operating system directives. If the command
interpreter is bash, ksh or another Unix shell, then single and double
quotes will follow the standard Unix usage.

Users of MS-DOS or Microsoft Windows must remember that the percent
sign (%) is used to indicate environment variables, so this symbol must
be doubled (%%) to yield a single percent sign visible to awk.

If a script will not need to be quoted in Unix, DOS, or CMD, then I
normally omit the quote marks. If an example is peculiar to GNU awk,
the command 'gawk' will be used. Please notify me if you find errors or
new commands to add to this list (total length under 65 characters). I
usually try to put the shortest script first. To conserve space, I
normally use '1' instead of '{print}' to print each line. Either one
will work.

FILE SPACING:

# double space a file      # 在每行后追加一个换行
awk '1;{print ""}'         # 数值1表示逻辑true，即模式匹配成功。1;等价于1{print}。后面的{print ""} 表示插入换行
# 等价于 awk '1 { print }; { print "" }'
awk 'BEGIN{ORS="\n\n"};1'  # 设置ORS为"\n\n", 1;等价于1{print}. 由于ORS为"\n\n"，所以输出双换行。

# double space a file which already has blank lines in it. Output file
# should contain no more than one blank line between lines of text.
# NOTE: On Unix systems, DOS lines which have only CRLF (\r\n) are
# often treated as non-blank, and thus 'NF' alone will return TRUE.
awk 'NF{print $0 "\n"}'

# triple space a file      # 在每行后追加两个换行
awk '1;{print "\n"}'
# 等价于 awk '{ print; print "\n" }' 

NUMBERING AND CALCULATIONS:
# precede each line by its line number FOR THAT FILE (left alignment).
# Using a tab (\t) instead of space will preserve margins.
awk '{print FNR "\t" $0}' files*  # 在当前文件累计处理行数；非第一个文件重头开始计算行

# precede each line by its line number FOR ALL FILES TOGETHER, with tab.
awk '{print NR "\t" $0}' files*   # 在所有文件累计处理行数

# number each line of a file (number on left, right-aligned)
# Double the percent signs if typing from the DOS command prompt.
awk '{printf("%5d : %s\n", NR,$0)}'

# number each line of file, but only print numbers if line is not blank
# Remember caveats about Unix treatment of \r (mentioned above)
awk 'NF{$0=++a " :" $0};1'           # 非空行统计
awk '{print (NF? ++a " :" :"") $0}'  # 非空行统计

# count lines (emulates "wc -l")
awk 'END{print NR}' # wc -l

# print the sums of the fields of every line
awk '{s=0; for (i=1; i<=NF; i++) s=s+$i; print s}' # 行所有字段和  for (;;) { ... } C格式

# add all fields in all lines and print the sum
awk '{for (i=1; i<=NF; i++) s=s+$i}; END{print s}' # 所有行所有字段和

# print every line after replacing each field with its absolute value
awk '{for (i=1; i<=NF; i++) if ($i < 0) $i = -$i; print }'     # 所有行所有字段绝对值 if (...) { ... }  C格式
awk '{for (i=1; i<=NF; i++) $i = ($i < 0) ? -$i : $i; print }' # 所有行所有字段绝对值

# print the total number of fields ("words") in all lines
awk '{ total = total + NF }; END {print total}' file # wc -w

# print the total number of lines that contain "Beth"
awk '/Beth/{n++}; END {print n+0}' file # 包含'Beth'行总数

# print the largest first field and the line that contains it
# Intended for finding the longest string in field #1
awk '$1 > max {max=$1; maxline=$0}; END{ print max, maxline}' # 打印$1值最大值的值 以及对应的行

# print the number of fields in each line, followed by the line
awk '{ print NF ":" $0 } '  # 字段数:行内容

# print the last field of each line
awk '{ print $NF }' # 最后一个字段

# print the last field of the last line
awk '{ field = $NF }; END{ print field }' # 最后一行最后一个字段

# print every line with more than 4 fields
awk 'NF > 4'  # 字段个数大于 4 

# print every line where the value of the last field is > 4
awk '$NF > 4' # 最后一个字段大于4

STRING CREATION:

# create a string of a specific length (e.g., generate 513 spaces)
awk 'BEGIN{while (a++<513) s=s " "; print s}' # 空格数代表 字段数

# insert a string of specific length at a certain character position
# Example: insert 49 spaces after column #6 of each input line.
gawk --re-interval 'BEGIN{while(a++<49)s=s " "};{sub(/^.{6}/,"&" s)};1'

ARRAY CREATION:

# These next 2 entries are not one-line scripts, but the technique
# is so handy that it merits inclusion here.

# create an array named "month", indexed by numbers, so that month[1]
# is 'Jan', month[2] is 'Feb', month[3] is 'Mar' and so on.
split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", month, " ")

awk 'BEGIN { split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", month, " ") ; for (i=1;i<=12;i++) print month[i]}'         
awk 'BEGIN { split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", month, " ") ; for (i in month) print month[i]}'  

# create an array named "mdigit", indexed by strings, so that
# mdigit["Jan"] is 1, mdigit["Feb"] is 2, etc. Requires "month" array
for (i=1; i<=12; i++) mdigit[month[i]] = i
awk 'BEGIN { split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", month, " ") ; for (i=1; i<=12; i++) mdigit[month[i]] = i; for (i in month) print mdigit[month[i]]}'

TEXT CONVERSION AND SUBSTITUTION:

# IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format -> dos2unix
awk '{sub(/\r$/,"")};1'   # assumes EACH line ends with Ctrl-M

# IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format -> unix2dos
awk '{sub(/$/,"\r")};1'

# IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format  -> unix2dos
awk 1

# IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
# Cannot be done with DOS versions of awk, other than gawk:
gawk -v BINMODE="w" '1' infile >outfile      # dos2unix

# Use "tr" instead.  # dos2unix
tr -d \r <infile >outfile            # GNU tr version 1.22 or higher

# delete leading whitespace (spaces, tabs) from front of each line
# aligns all text flush left
awk '{sub(/^[ \t]+/, "")};1' # 删除行开头空白

# delete trailing whitespace (spaces, tabs) from end of each line
awk '{sub(/[ \t]+$/, "")};1' # 删除行末尾空白

# delete BOTH leading and trailing whitespace from each line
awk '{gsub(/^[ \t]+|[ \t]+$/,"")};1' # 删除行开头空白 + 删除行末尾空白
awk '{$1=$1};1'           # also removes extra space between fields 

# insert 5 blank spaces at beginning of each line (make page offset)
awk '{sub(/^/, "     ")};1' # 在行首增加空白

# align all text flush right on a 79-column width
awk '{printf "%79s\n", $0}' file*  # 右对齐

# center all text on a 79-character width
awk '{l=length();s=int((79-l)/2); printf "%"(s+l)"s\n",$0}' file* # 中间对齐

# substitute (find and replace) "foo" with "bar" on each line
awk '{sub(/foo/,"bar")}; 1'           # replace only 1st instance
gawk '{$0=gensub(/foo/,"bar",4)}; 1'  # replace only 4th instance
awk '{gsub(/foo/,"bar")}; 1'          # replace ALL instances in a line

# substitute "foo" with "bar" ONLY for lines which contain "baz"
awk '/baz/{gsub(/foo/, "bar")}; 1'

# substitute "foo" with "bar" EXCEPT for lines which contain "baz"
awk '!/baz/{gsub(/foo/, "bar")}; 1'

# change "scarlet" or "ruby" or "puce" to "red"
awk '{gsub(/scarlet|ruby|puce/, "red")}; 1'

# reverse order of lines (emulates "tac") # 逆序输出
awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' file*

# if a line ends with a backslash, append the next line to it (fails if
# there are multiple lines ending with backslash...)
awk '/\\$/ {sub(/\\$/,""); getline t; print $0 t; next}; 1' file* # 

# print and sort the login names of all users
awk -F ":" '{print $1 | "sort" }' /etc/passwd # 按照顺序输出所有可登陆用户

# print the first 2 fields, in opposite order, of every line
awk '{print $2, $1}' file # $1和$2对换位置

# switch the first 2 fields of every line
awk '{temp = $1; $1 = $2; $2 = temp}' file # $1和$2对换位置 

# print every line, deleting the second field of that line
awk '{ $2 = ""; print }' # 删除第2列

# print in reverse order the fields of every line
awk '{for (i=NF; i>0; i--) printf("%s ",$i);print ""}' file # 所有字段逆序

# concatenate every 5 lines of input, using a comma separator
# between fields
awk 'ORS=NR%5?",":"\n"' file

SELECTIVE PRINTING OF CERTAIN LINES:

# print first 10 lines of file (emulates behavior of "head")
awk 'NR < 11'      # 前10行

# print first line of file (emulates "head -1")
awk 'NR>1{exit};1' # 前1行

# print the last 2 lines of a file (emulates "tail -2")
awk '{y=x "\n" $0; x=$0};END{print y}' # 最后两行

# print the last line of a file (emulates "tail -1")
awk 'END{print}' # 最后一行

# print only lines which match regular expression (emulates "grep")
awk '/regex/' # grep

# print only lines which do NOT match regex (emulates "grep -v")
awk '!/regex/' # grep -v

# print any line where field #5 is equal to "abc123"
awk '$5 == "abc123"' # 第5个字段为abc123

# print only those lines where field #5 is NOT equal to "abc123"
# This will also print lines which have less than 5 fields.
awk '$5 != "abc123"'
awk '!($5 == "abc123")'

# matching a field against a regular expression
awk '$7  ~ /^[a-f]/'    # print line if field #7 matches regex
awk '$7 !~ /^[a-f]/'    # print line if field #7 does NOT match regex

# print the line immediately before a regex, but not the line
# containing the regex
awk '/regex/{print x};{x=$0}'
awk '/regex/{print (NR==1 ? "match on line 1" : x)};{x=$0}'

# print the line immediately after a regex, but not the line
# containing the regex
awk '/regex/{getline;print}'

# grep for AAA and BBB and CCC (in any order on the same line)
awk '/AAA/ && /BBB/ && /CCC/'

# grep for AAA and BBB and CCC (in that order)
awk '/AAA.*BBB.*CCC/'

# print only lines of 65 characters or longer
awk 'length > 64'

# print only lines of less than 65 characters
awk 'length < 64'

# print section of file from regular expression to end of file
awk '/regex/,0'
awk '/regex/,EOF'

# print section of file based on line numbers (lines 8-12, inclusive)
awk 'NR==8,NR==12'

# print line number 52
awk 'NR==52'
awk 'NR==52 {print;exit}'          # more efficient on large files

# print section of file between two regular expressions (inclusive)
awk '/Iowa/,/Montana/'             # case sensitive

SELECTIVE DELETION OF CERTAIN LINES:

# delete ALL blank lines from a file (same as "grep '.' ")
awk NF
awk '/./'

# remove duplicate, consecutive lines (emulates "uniq")
awk 'a !~ $0; {a=$0}'

# remove duplicate, nonconsecutive lines
awk '!a[$0]++'                     # most concise script
awk '!($0 in a){a[$0];print}'      # most efficient script

CREDITS AND THANKS:

Special thanks to the late Peter S. Tillier (U.K.) for helping me with
the first release of this FAQ file, and to Daniel Jana, Yisu Dong, and
others for their suggestions and corrections.

For additional syntax instructions, including the way to apply editing
commands from a disk file instead of the command line, consult:

  "sed & awk, 2nd Edition," by Dale Dougherty and Arnold Robbins
  (O'Reilly, 1997)

  "UNIX Text Processing," by Dale Dougherty and Tim O'Reilly (Hayden
  Books, 1987)

  "GAWK: Effective awk Programming," 3d edition, by Arnold D. Robbins
  (O'Reilly, 2003) or at http://www.gnu.org/software/gawk/manual/

To fully exploit the power of awk, one must understand "regular
expressions." For detailed discussion of regular expressions, see
"Mastering Regular Expressions, 3d edition" by Jeffrey Friedl (O'Reilly,
2006).

The info and manual ("man") pages on Unix systems may be helpful (try
"man awk", "man nawk", "man gawk", "man regexp", or the section on
regular expressions in "man ed").

USE OF '\t' IN awk SCRIPTS: For clarity in documentation, I have used
'\t' to indicate a tab character (0x09) in the scripts.  All versions of
awk should recognize this abbreviation.

#---end of file---
