https://htmlpreview.github.io/?https://raw.githubusercontent.com/openwrt/luci/master/documentation/api/modules/luci.ip.html

ip(new){
  + new (address, netmask): Construct a new luci.ip.cidr instance and autodetect the address family.
  * Throws an error if the given strings do not represent a valid address or if the given optional netmask is of a different family.
  
  # address: String containing a valid IPv4 or IPv6 address, optionally with prefix size (CIDR notation) or netmask separated by slash.
  # netmask: String containing a valid IPv4 or IPv6 netmask or number containing a prefix size in bits (0..32 for IPv4, 0..128 for IPv6). 
  # Overrides mask embedded in the first argument if specified. (optional)

  $ A luci.ip.cidr object representing the given address/mask range.
  
  addr = luci.ip.new("10.24.0.1/24")                 -- print(addr) -> 10.24.0.1/24
  addr = luci.ip.new("10.24.0.1/255.255.255.0")      -- print(addr) -> 10.24.0.1/24
  addr = luci.ip.new("10.24.0.1", "255.255.255.0")   -- separate netmask  -- print(addr) -> 10.24.0.1/24
  addr = luci.ip.new("10.24.0.1/24", 16)             -- override netmask  -- print(addr) -> 10.24.0.1/16
  print(type(addr)) -- userdata
  
  addr6 = luci.ip.new("fe80::221:63ff:fe75:aa17/64")                            -- print(addr6) -> fe80::221:63ff:fe75:aa17/64
  addr6 = luci.ip.new("fe80::221:63ff:fe75:aa17/ffff:ffff:ffff:ffff::")         -- print(addr6) -> fe80::221:63ff:fe75:aa17/64
  addr6 = luci.ip.new("fe80::221:63ff:fe75:aa17", "ffff:ffff:ffff:ffff::")      -- print(addr6) -> fe80::221:63ff:fe75:aa17/64
  addr6 = luci.ip.new("fe80::221:63ff:fe75:aa17/64", 128) -- override netmask   -- print(addr6) -> fe80::221:63ff:fe75:aa17
  print(type(addr6)) -- userdata
  
  addr = luci.ip.new("10.24.0.1/33")                -- print(addr) -> nil
  addr = luci.ip.new("10.24.0.1/255.255.256.0")     -- print(addr) -> nil
  addr = luci.ip.new("10.24.0.1", "255.255.256.0")  -- error "Invalid netmask format"
  addr = luci.ip.new("10.256.0.1", "255.255.255.0") -- print(addr) -> nil
  addr = luci.ip.new("10.24.0.1/24", 33)            -- error "Invalid prefix size"
}
ip(IPv4){
  + IPv4 (address, netmask) Construct a new IPv4 luci.ip.cidr instance.
  * Throws an error if the given string does not represent a valid IPv4 address or if the given optional netmask is of a different family.

  # address: String containing a valid IPv4, optionally with prefix size (CIDR notation) or netmask separated by slash.
  # netmask: String containing a valid IPv4 netmask or number containing a prefix size between 0 and 32 bit. Overrides mask embedded in the first argument if specified. (optional)

  $ A luci.ip.cidr object representing the given IPv4 range.
  
  1. 同上
  addr = luci.ip.IPv4("10.24.0.1/24") 
  addr = luci.ip.IPv4("10.24.0.1/255.255.255.0") 
  addr = luci.ip.IPv4("10.24.0.1", "255.255.255.0")        -- separate netmask 
  addr = luci.ip.IPv4("10.24.0.1/24", 16)                  -- override netmask
  2. 同上
  addr = luci.ip.IPv4("10.24.0.1/33")                -- print(addr) -> nil
  addr = luci.ip.IPv4("10.24.0.1/255.255.256.0")     -- print(addr) -> nil
  addr = luci.ip.IPv4("10.24.0.1", "255.255.256.0")  -- error "Invalid netmask format"
  addr = luci.ip.IPv4("10.256.0.1", "255.255.255.0") -- print(addr) -> nil
  addr = luci.ip.IPv4("10.24.0.1/24", 33)            -- error "Invalid prefix size"
}
ip(IPv6){
  + IPv6 (address, netmask): Construct a new IPv6 luci.ip.cidr instance. 
  * Throws an error if the given string does not represent a valid IPv6 address or if the given optional netmask is of a different family.

  # address: String containing a valid IPv6, optionally with prefix size (CIDR notation) or netmask separated by slash.
  # netmask: String containing a valid IPv4 netmask or number containing a prefix size between 0 and 128 bit. 
    Overrides mask embedded in the first argument if specified. (optional)

  $ A luci.ip.cidr object representing the given IPv6 range.
  
  addr6 = luci.ip.IPv6("fe80::221:63ff:fe75:aa17/64") 
  addr6 = luci.ip.IPv6("fe80::221:63ff:fe75:aa17/ffff:ffff:ffff:ffff::") 
  addr6 = luci.ip.IPv6("fe80::221:63ff:fe75:aa17", "ffff:ffff:ffff:ffff::") 
  addr6 = luci.ip.IPv6("fe80::221:63ff:fe75:aa17/64", 128) -- override netmask
}

https://en.wikipedia.org/wiki/MAC_address
ip(MAC){ -- 略
  + MAC (address, netmask)Construct a new MAC luci.ip.cidr instance. 
  * Throws an error if the given string does not represent a valid ethernet MAC address or if the given optional mask is of a different family.

  # address: String containing a valid ethernet MAC address, optionally with prefix size (CIDR notation) or mask separated by slash.
  # netmask: String containing a valid MAC address mask or number containing a prefix size between 0 and 48 bit. 
    Overrides mask embedded in the first argument if specified. (optional)
    
  $ A luci.ip.cidr object representing the given MAC address range.
  
  intel_macs = luci.ip.MAC("C0:B6:F9:00:00:00/24") 
  intel_macs = luci.ip.MAC("C0:B6:F9:00:00:00/FF:FF:FF:0:0:0") 
  intel_macs = luci.ip.MAC("C0:B6:F9:00:00:00", "FF:FF:FF:0:0:0") 
  intel_macs = luci.ip.MAC("C0:B6:F9:00:00:00/24", 48) -- override mask
}
ip(checkip4){ -- 略

}
ip(checkip6){ -- 略

}
ip(checkmac){ -- 略

}
ip(route){ -- 略

}
ip(routes){
  + routes (filter, callback) : Fetch all routes, optionally matching the given criteria.
  
  # filter:
    Table containing one or more of the possible filter critera described below (optional)
    |-----------|------------------------------------
    |Field      | Description
    |-----------|------------------------------------
    |family     | Number describing the address family to return - 4 selects IPv4 routes, 6 IPv6 ones. Any other value selects both.
    |iif        | String containing the incoming route interface to match.
    |oif        | String containing the outgoing route interface to match.
    |type       | Numeric type to match, e.g. 1 for unicast.
    |scope      | Numeric scope to match, e.g. 253 for onlink.
    |proto      | Numeric protocol to match, e.g. 2 for boot.
    |table      | Numeric routing table to match (0..65535).
    |gw         | String containing the gateway address to match. Can be in any notation specified by luci.ip.new(). Prefix matching is performed when comparing the routes, e.g. "192.168.1.0/24" would select routes with gateway addresses 192.168.1.1 .. 192.168.1.255.
    |dest       | String containing the destination to match. Prefix matching is performed.
    |from       | String containing the source address to match. Prefix matching is performed.
    |src        | String containing the preferred source address to match. Prefix matching is performed.
    |dest_exact | String containing the destination to match. Exact matching is performed, e.g. dest = "0.0.0.0/0" would match any IPv4 route while dest_exact = "0.0.0.0/0" will only match the default route.
    |from_exact | String containing the source address to match. Exact matching is performed.
    |-----------|------------------------------------
  # callback: Callback function to invoke for each found route instead of returning one table of route objects (optional)
  
  $ If no callback function is provided, a table of routes as specified by luci.ip.route() is returned. 
  $ If a callback function is given, it is invoked for each route and nothing is returned.
  1. filter && callback
  luci.ip.routes({ dest_exact = "0.0.0.0/0" }, function(rt) 
        print(rt.type, rt.gw, rt.dev) 
  end)
  2. filter && callback
  luci.ip.routes({ from = "2001::/7" }, function(rt) 
        print(rt.from) 
  end)
  3. return table
  routes = luci.ip.routes({ family = 4 }) 
  for _, rt in ipairs(routes) do 
        print(rt.dest, rt.gw, rt.dev) 
  end
   |-------|-----------------------------------------
   |Field  |Description
   |-------|-----------------------------------------
   |type   |Route type with one of the following numeric values:
   |       |   1   RTN_UNICAST - Gateway or direct route
   |       |   2   RTN_LOCAL - Accept locally
   |       |   3   RTN_BROADCAST - Accept locally as broadcast send as broadcast
   |       |   4   RTN_ANYCAST - Accept locally as broadcast but send as unicast
   |       |   5   RTN_MULTICAST - Multicast route
   |family |Number containing the route family, 4 for IPv4 or 6 for IPv6
   |dest   |Destination luci.ip.cidr instance
   |gw     |Gateway luci.ip.cidr instance (optional)
   |from   |Source address luci.ip.cidr instance (optional)
   |src    |Preferred source luci.ip.cidr instance (optional)
   |dev    |String containing the name of the outgoing interface
   |iif    |String containing the name of the incoming interface (optional)
   |table  |Number of the associated routing table (0..65535)
   |proto  |Number of the associated routing protocol
   |scope  |Number describing the scope of the route, most commonly 0 for global or 253 for on-link
   |metric |Number describing the route metric (optional)
   |expires|Number of seconds the prefix is valid (IPv6 only, optional)
   |error  |Route destination error code (optional)
   |-------|-----------------------------------------
}
ip(neighbors){
  + neighbors (filter, callback) : Fetches entries from the IPv4 ARP and IPv6 neighbour kernel table
  # filter: Table containing one or more of the possible filter critera described below (optional)
    |-------|---------------------------------
    |Field  |  Description
    |-------|---------------------------------
    |family |  Number describing the address family to return - 4 selects IPv4 ARP, 6 select IPv6 neighbour entries. Any other value selects both.
    |dev    |  String containing the associated interface to match.
    |dest   |  String containing the associated address to match. Can be in any notation specified by luci.ip.new(). Prefix matching is performed when comparing the addresses, e.g. "192.168.1.0/24" would select ARP entries for 192.168.1.1 .. 192.168.1.255.
    |mac    |  String containing MAC address to match.
    |-------|---------------------------------
  # callback: Callback function to invoke for each found neighbour entry instead of returning one table of neighbour entries (optional)
  $ If no callback function is provided, a table of neighbour entries is returned.
  $ If a callback function is given, it is invoked for each entry and nothing is returned
  
   A neighbour entry is a table containing the following fields:
    |-----------|-----------------------------
    |Field      | Description
    |-----------|-----------------------------
    |family     | Number containing the neighbour entry family, 4 for IPv4 ARP or 6 for IPv6 NDP
    |dev        | String containing the associated device of the neighbour entry
    |dest       | IP address luci.ip.cidr instance
    |mac        | MAC address luci.ip.cidr instance
    |router     | Boolean "true" if the neighbour entry is a router (IPv6, optional)
    |proxy      | Boolean "true" if this is a proxy entry (optional)
    |incomplete | Boolean "true" if the entry is in incomplete state (optional)
    |reachable  | Boolean "true" if the entry is in reachable state (optional)
    |stale      | Boolean "true" if the entry is stale (optional)
    |delay      | Boolean "true" if the entry is delayed (optional)
    |probe      | Boolean "true" if the entry is in probe state (optional)
    |failed     | Boolean "true" if the entry is in failed state (optional)
    |noarp      | Boolean "true" if the entry is not caused by NDP or ARP (optional)
    |permanent  | Boolean "true" if the entry was statically configured from userspace (optional)
    |-----------|-----------------------------
    1. filter && callback
    luci.ip.neighbors({ dest = "192.168.0.0/16" }, function(n) 
         print(n.dest, n.mac) 
    end)
    2. filter && callback
    luci.ip.neighbors({ family = 6, mac = "00:21:63:75:aa:17" }, 
    function(n) 
        print(n.dest) 
    end)
    3. return table
    neighs = luci.ip.neighbors({ })
}
ip(link){
  + link (device):Fetch basic device information
  # device: String containing the network device to query
  $ If the given interface is found, a table containing the fields described below is returned, else an empty table.
    |-------|----------------------------------
    |Field  | Description
    |-------|----------------------------------
    |up     | Boolean indicating whether the device is in IFF_RUNNING state
    |type   | Numeric value indicating the type of the device, e.g. 1 for ethernet.
    |name   | String containing the name of the device
    |master | If queried device is a bridge port, string containing the name of parent bridge device (optional)
    |mtu    | Number containing the current MTU of the device
    |qlen   | Number containing the TX queue length of the device
    |mac    | MAC address luci.ip.cidr instance representing the device ethernet address
    |-------|----------------------------------
    
  print(luci.ip.link("br-lan").name ~= nil) 
  print(luci.ip.link("eth0").mac) 
}

cidr(is4){
  + cidr:is4 (): Checks whether the CIDR instance is an IPv4 address range
  $ true if the CIDR is an IPv4 range, else false
}
cidr(is4rfc1918){
  + cidr:is4rfc1918 () : Checks whether the CIDR instance is within the private RFC1918 address space
  $ true if the entire range of this CIDR lies within one of the ranges 
         10.0.0.0-10.255.255.255, 172.16.0.0-172.31.0.0 or 192.168.0.0-192.168.255.255, else false.
         
  local addr = luci.ip.new("192.168.45.2/24") 
  if addr:is4rfc1918() then 
      print("Is a private address") 
  end
}
cidr(is4linklocal){
  + cidr:is4linklocal () : Checks whether the CIDR instance is an IPv4 link local (Zeroconf) address
  $ true if the entire range of this CIDR lies within the range the range 169.254.0.0-169.254.255.255, else false.
  
  local addr = luci.ip.new("169.254.34.125") 
  if addr:is4linklocal() then 
      print("Is a zeroconf address") 
  end
}
cidr(is6){
  + cidr:is6 () : Checks whether the CIDR instance is an IPv6 address range
  $ true if the CIDR is an IPv6 range, else false
}
cidr(is6linklocal){
  + cidr:is6linklocal () : Checks whether the CIDR instance is an IPv6 link local 
  $ true if the entire range of this CIDR lies within the range the fe80::/10 range, else false.
  
  local addr = luci.ip.new("fe92:53a:3216:af01:221:63ff:fe75:aa17/64") 
  if addr:is6linklocal() then 
      print("Is a linklocal address") 
  end
}
cidr(is6mapped4){
  + cidr:is6mapped4 () : Checks whether the CIDR instance is an IPv6 mapped IPv4 address
  $ true if the address is an IPv6 mapped IPv4 address in the form ::ffff:1.2.3.4.
  
  local addr = luci.ip.new("::ffff:192.168.1.1") 
  if addr:is6mapped4() then 
      print("Is a mapped IPv4 address") 
  end
}
cidr(ismac){

}
cidr(ismaclocal){
  + cidr:ismaclocal () : Checks whether the CIDR instance is a locally administered (LAA) MAC address
  $ true if the MAC address sets the locally administered bit.
  
  // 00 globally unique identification
  // 02 locally administered addresses (LAA)
  local mac = luci.ip.new("02:C0:FF:EE:00:01")  -- "00:C0:FF:EE:00:01"
  if mac:ismaclocal() then 
      print("Is an LAA MAC address") 
  end
}
cidr(ismacmcast){
  + cidr:ismacmcast () : Checks whether the CIDR instance is a multicast MAC address
  $ true if the MAC address sets the multicast bit.
  
  // 00 unicast
  // 01 broadcast
  local mac = luci.ip.new("01:00:5E:7F:00:10") 
  if addr:ismacmcast() then 
      print("Is a multicast MAC address") 
  end
}

cidr(lower){
  + cidr:lower (addr) : Checks whether this CIDR instance is lower than the given argument. The comparisation follows these rules:
    An IPv4 address is always lower than an IPv6 address and IPv6 addresses are considered lower than MAC addresses
    Prefix sizes are ignored
  # addr: A luci.ip.cidr instance or a string convertable by luci.ip.new() to compare against.
  $ true if this CIDR is lower than the given address, else false.
  
  addr = luci.ip.new("192.168.1.1") 
  print(addr:lower(addr))               -- false 
  print(addr:lower('192.168.1.2'))      -- true 
  print(addr:lower('192.168.1.0'))      -- false 
  print(addr:lower("10.10.10.10/24"))   -- false 
  print(addr:lower(luci.ip.new("::1"))) -- true 
  print(addr:lower(luci.ip.new("192.168.200.1"))) -- true 
  print(addr:lower(luci.ip.new("00:14:22:01:23:45"))) -- "bad argument #1 to 'lower' (string expected, got no value)"
}
cidr(higher){
  + cidr:higher (addr) Checks whether this CIDR instance is higher than the given argument. The comparisation follows these rules:
    An IPv4 address is always lower than an IPv6 address and IPv6 addresses are considered lower than MAC addresses
    Prefix sizes are ignored
  # addr: A luci.ip.cidr instance or a string convertable by luci.ip.new() to compare against.
  $ true if this CIDR is higher than the given address, else false.
  略
}
cidr(equal){
  + cidr:equal (addr)Checks whether this CIDR instance is equal to the given argument.
  # addr: A luci.ip.cidr instance or a string convertable by luci.ip.new() to compare against.
  $ true if this CIDR is equal to the given address, else false.
  
  local addr = luci.ip.new("192.168.1.1") 
  print(addr:equal(addr)) -- true 
  print(addr:equal("192.168.1.1")) -- true 
  print(addr:equal(luci.ip.new("::1"))) -- false 
  
  local addr6 = luci.ip.new("::1") 
  print(addr6:equal("0:0:0:0:0:0:0:1/64")) -- true 
  print(addr6:equal(luci.ip.new("fe80::221:63ff:fe75:aa17"))) -- false 
  
  local mac = luci.ip.new("00:14:22:01:23:45") 
  print(mac:equal("0:14:22:1:23:45")) -- true 
  print(mac:equal(luci.ip.new("01:23:45:67:89:AB")) -- false
}
cidr(prefix){
  + cidr:prefix (mask) : Get or set prefix size of CIDR instance. 
    If the optional mask parameter is given, the prefix size of this CIDR is altered else the current prefix size is returned.
  # mask: Either a number containing the number of bits (0..32 for IPv4, 0..128 for IPv6 or 0..48 for MAC addresses) or a string containing a valid netmask (optional)
  $ Bit count of the current prefix size
  
  range = luci.ip.new("192.168.1.1/255.255.255.0") 
  print(range:prefix()) -- 24 
  
  range:prefix(16) 
  print(range:prefix()) -- 16 
  
  range:prefix("255.255.255.255") 
  print(range:prefix()) -- 32
}
cidr(network){
  + cidr:network (mask) Derive network address of CIDR instance. 
    Returns a new CIDR instance representing the network address of this instance with all host parts masked out. 
    The used prefix size can be overridden by the optional mask parameter.
  # mask: Either a number containing the number of bits (0..32 for IPv4, 0..128 for IPv6 or 0..48 for MAC addresses) or a string containing a valid netmask (optional)
  $ CIDR instance representing the network address
  
  range = luci.ip.new("192.168.62.243/255.255.0.0") 
  print(range:network())                -- "192.168.0.0" 
  print(range:network(24))              -- "192.168.62.0" 
  print(range:network("255.255.255.0")) -- "192.168.62.0" 
  
  local range6 = luci.ip.new("fd9b:62b3:9cc5:0:221:63ff:fe75:aa17/64") 
  print(range6:network())               -- "fd9b:62b3:9cc5::"
}
cidr(host){
  + cidr:host () : Derive host address of CIDR instance. 
     This function essentially constructs a copy of this CIDR with the prefix size set to 32 for IPv4, 128 for IPv6 or 48 for MAC addresses.
  # CIDR instance representing the host address
  range = luci.ip.new("172.19.37.45/16") 
  print(range)        -- "172.19.37.45/16" 
  print(range:host()) -- "172.19.37.45"
}
cidr(mask){
  + cidr:mask (mask) Derive netmask of CIDR instance. 
    Constructs a CIDR instance representing the netmask of this instance. 
    The used prefix size can be overridden by the optional mask parameter.
  # mask: Either a number containing the number of bits (0..32 for IPv4, 0..128 for IPv6 or 0..48 for MAC addresses) or a string containing a valid netmask (optional)
  $ CIDR instance representing the netmask
  local range = luci.ip.new("172.19.37.45/16") 
  print(range:mask())            -- "255.255.0.0" 
  print(range:mask(24))          -- "255.255.255.0" 
  print(range:mask("255.0.0.0")) -- "255.0.0.0" 
}
cidr(broadcast){
  + cidr:broadcast (mask) : Derive broadcast address of CIDR instance.
  # mask: Either a number containing the number of bits (0..32 for IPv4) or a string containing a valid netmask (optional)
  $ Return a new CIDR instance representing the broadcast address if this instance is an IPv4 range, else return nothing.
  
    range = luci.ip.new("172.19.37.45/16") 
    print(range:broadcast())            -- "172.19.255.255" 
    print(range:broadcast(24))          -- "172.19.37.255" 
    print(range:broadcast("255.0.0.0")) -- "172.255.255.255"
}
cidr(mapped4){
  cidr:mapped4 () : Derive mapped IPv4 address of CIDR instance
  local addr = luci.ip.new("::ffff:172.16.19.1") 
  print(addr:mapped4()) -- "172.16.19.1"
}
cidr(tomac){
  cidr:tomac () : Derive MAC address of IPv6 link local CIDR instance.
  local addr = luci.ip.new("fe80::6666:b3ff:fe47:e1b9") 
  print(addr:tomac()) -- "64:66:B3:47:E1:B9"
}
cidr(tolinklocal){
  cidr:tolinklocal () : Derive IPv6 link local address from MAC address CIDR instance.
    local mac = luci.ip.new("64:66:B3:47:E1:B9") 
    print(mac:tolinklocal()) -- "fe80::6666:b3ff:fe47:e1b9"  
}
cidr(contains){
  + cidr:contains (addr) : Test whether CIDR contains given range.
  # addr: A luci.ip.cidr instance or a string convertable by luci.ip.new() to test.
  $ true if this instance fully contains the given address else false.
  
  range = luci.ip.new("10.24.0.0/255.255.0.0") 
  print(range:contains("10.24.5.1"))  -- true 
  print(range:contains("::1"))        -- false 
  print(range:contains("10.0.0.0/8")) -- false 
   
  local range6 = luci.ip.new("fe80::/10") 
  print(range6:contains("fe80::221:63f:fe75:aa17/64"))         -- true 
  print(range6:contains("fd9b:6b3:c5:0:221:63f:fe75:aa17/64")) -- false 
   
  local intel_macs = luci.ip.MAC("C0:B6:F9:00:00:00/24") 
  print(intel_macs:contains("C0:B6:F9:A3:C:11"))  -- true 
  print(intel_macs:contains("64:66:B3:47:E1:B9")) -- false
}
cidr(add){
  + cidr:add (amount, inplace) Add given amount to CIDR instance. 
    If the result would overflow the maximum address space, the result is set to the highest possible address.
  # amount: A numeric value between 0 and 0xFFFFFFFF, a luci.ip.cidr instance or a string convertable by luci.ip.new().
  # inplace: If true, modify this instance instead of returning a new derived CIDR instance.
  $ When adding inplace: Return true if the addition succeded or false when the addition overflowed.
  $ When deriving new CIDR: Return new instance representing the value of this instance plus the added amount or the highest possible address 
    if the addition overflowed the available address space.
    
  addr = luci.ip.new("192.168.1.1/24") 
  print(addr:add(250))           -- "192.168.1.251/24" 
  print(addr:add("0.0.99.0"))    -- "192.168.100.1/24" 
   
  addr:add(256, true)            -- true 
  print(addr)                    -- "192.168.2.1/24 
   
  addr:add("255.0.0.0", true)    -- false (overflow) 
  print(addr)                    -- "255.255.255.255/24 
   
  local addr6 = luci.ip.new("fe80::221:63f:fe75:aa17/64") 
  print(addr6:add(256))          -- "fe80::221:63f:fe75:ab17/64" 
  print(addr6:add("::ffff:0"))   -- "fe80::221:640:fe74:aa17/64" 
   
  addr6:add(256, true)           -- true 
  print(addr6)                   -- "fe80::221:63f:fe75:ab17/64 
   
  addr6:add("ffff::", true)      -- false (overflow) 
  print(addr6)                   -- "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/64" 
   
  local mac = luci.ip.new("00:14:22:01:23:45") 
  print(mac:add(256))            -- "00:14:22:01:24:45" 
  print(mac:add("0:0:0:0:FF:0")  -- "00:14:22:02:22:45" 
   
  mac:add(256, true)             -- true 
  print(mac)                     -- "00:14:22:01:24:45" 
   
  mac:add("FF:FF:0:0:0:0", true) -- false (overflow) 
  print(mac)                     -- "FF:FF:FF:FF:FF:FF"
}
cidr(sub){
  + cidr:sub (amount, inplace) Subtract given amount from CIDR instance. If the result would under, the lowest possible address is returned.
  # amount: A numeric value between 0 and 0xFFFFFFFF, a luci.ip.cidr instance or a string convertable by luci.ip.new().
  # inplace: If true, modify this instance instead of returning a new derived CIDR instance.
  $ When subtracting inplace: Return true if the subtraction succeeded or false when the subtraction underflowed.
  $ When deriving new CIDR: Return new instance representing the value of this instance minus the subtracted amount or the lowest address if the subtraction underflowed.
  
  local addr = luci.ip.new("192.168.1.1/24") 
  print(addr:sub(256))         -- "192.168.0.1/24" 
  print(addr:sub("0.168.0.0")) -- "192.0.1.1/24" 
   
  addr:sub(256, true)          -- true 
  print(addr)                  -- "192.168.0.1/24 
   
  addr:sub("255.0.0.0", true)  -- false (underflow) 
  print(addr)                  -- "0.0.0.0/24 
   
  local addr6 = luci.ip.new("fe80::221:63f:fe75:aa17/64") 
  print(addr6:sub(256))        -- "fe80::221:63f:fe75:a917/64" 
  print(addr6:sub("::ffff:0")) -- "fe80::221:63e:fe76:aa17/64" 
   
  addr:sub(256, true)          -- true 
  print(addr)                  -- "fe80::221:63f:fe75:a917/64" 
   
  addr:sub("ffff::", true)     -- false (underflow) 
  print(addr)                  -- "::/64" 
   
  local mac = luci.ip.new("00:14:22:01:23:45") 
  print(mac:sub(256))            -- "00:14:22:01:22:45" 
  print(mac:sub("0:0:0:0:FF:0")  -- "00:14:22:00:24:45" 
   
  mac:sub(256, true)             -- true 
  print(mac)                     -- "00:14:22:01:22:45" 
   
  mac:sub("FF:FF:0:0:0:0", true) -- false (overflow) 
  print(mac)                     -- "00:00:00:00:00:00"
}
cidr(minhost){
  + cidr:minhost () Calculate the lowest possible host address within this CIDR instance.
  $ Returns a new CIDR instance representing the lowest host address within this range.
  local addr = luci.ip.new("192.168.123.56/24") 
  print(addr:minhost())  -- "192.168.123.1" 
   
  local addr6 = luci.ip.new("fd9b:62b3:9cc5:0:221:63ff:fe75:aa17/64") 
  print(addr6:minhost()) -- "fd9b:62b3:9cc5::1" 
   
  local mac = luci.ip.new("00:14:22:01:22:45/32") 
  print(mac:minhost())   -- "00:14:22:01:00:01"
}

cidr(maxhost){
  + cidr:maxhost () Calculate the highest possible host address within this CIDR instance.
  $ Returns a new CIDR instance representing the highest host address within this range
  local addr = luci.ip.new("192.168.123.56/24") 
  print(addr:maxhost())  -- "192.168.123.254" (.255 is broadcast) 
   
  local addr6 = luci.ip.new("fd9b:62b3:9cc5:0:221:63ff:fe75:aa17/64") 
  print(addr6:maxhost()) -- "fd9b:62b3:9cc5:0:ffff:ffff:ffff:ffff" 
   
  local mac = luci.ip.new("00:14:22:01:22:45/32") 
  print(mac:maxhost())   -- "00:14:22:01:FF:FF"
}

cidr(string){
  $ Returns a string representing the range or address of this CIDR instance
}
