make USE_JEMALLOC=yes V=1

Makefile中的变量有以下几点特征：
--------------------------
    1. Makefile中变量和函数的展开（除规则的命令行以外），是在 make 读取 makefile 文件 时进行的，
这里的变量包括了使用"="定义和使用指示符"define"定义的。
    2. 变量可以用来代表一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件
的目录列表、编译输出的目录列表和所有我们能够想到的事物。
    3. 变量名是不包括":"、"#"、"="、前置空白和尾空白的任何字符串。
    4. 变量名是大小写敏感的。变量"foo"、"Foo"和"FOO"指的是三个不同的变量。 Makefile 
传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义的一般变量
(例如目标文件列表 objects)使用小写方式，而对于一些参数列表(例如：编译选项 CFLAGS)
采用大写方式。
    5. 另外有一些变量名只包含了一个或者很少的几个特殊的字符(符号)。称它们为自动化变量。 
像"$<"、"$@"、"$?"、"$*"等。


变量的引用
--------------------------
    当我们定义了一个变量之后，就可以在 Makefile 的很多地方使用这个变量。变量的引用方式是：
使用"$(VARIABLE_NAME)"或者"${VARIABLE_NAME}"来引用一个变量的定义。美元符号"$"在 Makefile 
中有特殊的含义，所有在命令或者文件名中使用"$"时需要用两个美元符号"$$"来表示。

一般在我们书写 Makefile 时，各部分变量引用的格式我们建议如下：
    make 变量(Makefile 中定义的或者是 make 的环境变量)的引用使用"$(VAR)"格式，无论"VAR"是单字符变量名还是多字符变量名。
    出现在规则命令行中 shell 变量(一般为执行命令过程中的临时变量，它不属于 Makefile 变量，而是一个 shell 变量)引用使用 shell 的"$tmp"格式。
    对出现在命令行中的 make 变量我们同样使用"$(CMDVAR)" 格式来引用。

例如：
sample Makefile
... ...
SUBDIRS := src foo
.PHONY : subdir
Subdir :
@for dir in $(SUBDIRS); do \
	$(MAKE) –C $$dir || exit 1; \
	done
	
两种变量定义
--------------------------
两种变量定义的风格区别：1.定义方式；2.展开时机。

递归展开式变量
----------------
第一种风格的变量就是递归方式扩展的变量。这一类型的变量的定义是通过"="或者使用指示符"define"定义的变量。
其优点是：
这种类型变量的定义时，可以引用其它的之前没有定义的变量(可能在后续部分定义，或者是 通过 make 的命令行选项传递的变量)。
其缺点是：
    使用此风格的变量定义，可能会由于出现变量的递归定义而导致 make 陷入到无限的变量 展开过程中，最终使 make 执行失败。
    第二个缺点：这种风格变量的定义中如果使引用了某一个函数，那么函数总会在其被引用 的地方被执行。
    
A=$(B) 
B=$(C) 
C=Hello

直接展开式变量
----------------
在 GNU make 中可以使用另外一种风格的变量，我们将它称为"直接展开"式。这种风格的变量使用":="来定义变量。

变量的替换运用
----------------
    对于一个已经定义的变量，可以使用"替换引用"将其值使用指定的字符(字符串)进行替换。 
格式为"$(VAR:A=B)"(或者"${VAR:A=B}")，意思是，替换变量"VAR"中所有"A"字符 结尾的字为"B"结尾的字。


变量取值
--------------------------
一个变量可以通过以下几种方式来获得值：
    在运行make时通过命令行选项来取代一个已定义的变量值。
    在makefile文件中通过赋值的方式或者使用"define"来为一个变量赋值。
    将变量设置为系统环境变量。所有系统环境变量都可以被make使用。
    自动化变量，在不同的规则中自动化变量会被赋予不同的值。它们每一个都有单一的习惯性用法。
    一些变量具有固定的值(隐含变量)。

系统环境变量
--------------------------
make 在运行时，系统的所有环境变量对它都是可见的。在 Makefile 中，可以引用任何已定义的系统环境变量。
这里我们区分系统环境变量和 make 的环境变量，系统环境变量是这个系统所有用户所拥有的，而 make 的环境变量只是对于 make 的一次执行过程有效.
使用环境变量我们需要注意以下几点：
    在 Makefile 中对一个变量的定义或者以 make 命令行形式对一个变量的定义，都将覆盖同名的环境变量
(注意：它并不改变系统环境变量定义，被修改的环境变量只在 make 执行过程有效)。而 make 使用"-e"参数时，
Makefile 和命令行定义的变量不会覆盖同名的环境变量， make 将使用系统环境变量中这些变量的定义值。
    默认情况下，只有环境变量和通过命令行方式定义的变量才会被传递给子make进程。 在Makefile中定义
的普通变量需要传递给子make时需要使用"export"指示符来对它声明。
    make的执行环境变量"SHELL"的取值不使用同名的系统环境变量定义，而默认使用"/bin/sh"作为它的命令行解释程序
(make执行之前设置它为"/bin/sh")。

目标指定变量
--------------------------
    此特性允许对于相同变量根据目标指定不同的值，有点类似于自动化变量。目标指定的变量值
只在指定它的目标的上下文中有效，对于其他的目标不产生影响。就是说目标指定的变量具有"局部性"。
设置一个目标指定变量的语法为：
TARGET ... : VARIABLE-ASSIGNMENT
一个多目标指定的变量的作用域是所有这些目标的上下文，它包括了和这个目标相关的所有执行过程。


