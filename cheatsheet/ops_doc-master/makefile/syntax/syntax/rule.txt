1. 规则包含了目标和依赖的关系以及更新目标所要求的命令。

TARGET...:PREREQUISTIES...
	COMMAND
	...
	...

TARGET：规则的目标。目标分两类，一类是文件，另一类是伪目标，而伪目标没有任何依赖只有执行动作。
当TARGET是文件时，代表这个规则执行的目的，就是执行这个规则的目标就是要生成/更新这个TARGET文件；
而伪目标更像是一个命令标志，当在shell执行 make TARGET(伪目标) 时候，会执行这个规则里面的COMMAND。

PREREQUISTIES：规则的依赖。当TARGET是文件时候，要生成/更新TARGET时，首先需要保证这些依赖文件必须是最新的，
如果这些PREREQUISTIES不是最新的，需要先更新，然后再执行COMMAND生成/更新最新的TARGET。

COMMAND：规则的命令行。shell命令。

2. 规则的中心思想：目标文件的内容是由依赖文件决定，依赖文件的任何一处改动，将导致目前已经存在的目标文件的内容过期
  Makefile 中对"$"有特殊的含义(表示变量或者函数的引用)，如果我们的规则需要"$"，需要书写两个连续的("$$")
  
文件名使用通配符
--------------------------
Makefile 中通配符可以出现在以下两种场合：
  可以用在规则的目标、依赖中，此时 make 会自动将其展开；
  可出现在规则的命令中，其展开是在 shell 在执行此命令时完成；
  需要借助函数"wildcard"。(这种情况一般用在变量定义)
    之所以要使用wildcard的原因：
    如果 Makefile 有这样一句："objects = *.o"。那么变量"objects"的值就是"*.o"，而不是使用空格分开的所有.o 文件列表。
当objects作为依赖文件时候，如果没有任何.o文件，那么在执行规则时将会得到一个类似于"没有创建*.o 文件的规则"的错误提示，
这当然不是我们所期望的结果，我们期望的是它能够按照.c文件生成对应的.o文件。
    原理/解决方法：
    在规则中，通配符会被自动展开。但在变量的定义和使用函数时，通配符不会被自动的展开。这种情况下需要通配符有效，
要用到函数"wildcard"， 如果需要变量"objects"代表所有的.o 文件，则需要是用函数"wildcard"来实现objects = $(wildcar *.o)


目录搜索（针对依赖文件目录搜索）
--------------------------
一般搜索 & 选择性搜索：
    一般搜索：使用VPATH变量
    选择性搜索：使用vpath关键字
    
    
双冒号规则
--------------------------
双冒号规则就是使用"::"代替普通规则的":"得到的规则。
    双冒号规则中，当依赖文件比目标更新时。规则将会被执行。对于一个没有依赖而只有命令行的双冒号规则，
当引用此目标时，规则的命令将会被无条件执行。而普通规则，当规则的目标文件存在时，此规则的命令永远不会被执行(目标文件永远是最新的)。
    当同一个文件作为多个双冒号规则的目标时。这些不同的规则会被独立的处理， 而不是像普通规则那样合并
所有的依赖到一个目标文件。这就意味着对这些规则的处理就像多个不同的普通规则一样。就是说多个双冒号规则
中的每一个的依赖文件被改变之后，make只执行此规则定义的命令，而其它的以这个文件作为目标的双冒号规则将不会被执行。

一般双冒号规则都需要定义命令，如果一个双冒号规则没有定义命令，在执行规则时将为其目标自动查找隐含规则。
    

隐含规则的使用
--------------------------
    make 会自动根据已存在(或者可以被创建)的源文件类型来启动相应的隐含规则。
    这里说的"可被创建"的文件是指：这个文件在 Makefile 中被作为目标或者依赖明确的提及，或者可以根据已存在的文件使用其它的隐含规则来创建。
    通常，make会对那些没有命令行的规则、双冒号规则寻找一个隐含规则来执行。
作为一个规则的依赖文件，在没有一个规则明确描述它的依赖关系的情况下；make会将其作为一个目标
并为它搜索一个隐含规则，试图重建它。注意：当规则没有命令行的时候，给目标文件指定明确的依赖
文件并不会影响隐含规则的搜索。

我们来看一个例子：
foo.o: foo.p
    这个规则指定了"foo"的依赖文件是"foo.p"。但是如果在工作目录下存在同名.c源文件"foo.c"。
执行make的结果就不是用"pc"编译"foo.p"来生成"foo"，而是用"cc"编译"foo.c"来生 成目标文件。
这是因为在隐含规则列表中对.c文件的隐含规则处于.p文件隐含规则之前。当需要给目标指定明确
的重建规则时，规则描述中就不能省略命令行，这个规则必须提供明确的重建命令来说明目标需要
重建所需要的动作。

为了能够在存在"foo.c"的情况下编译"foo.p"。 规则可以这样写：
foo.o: foo.p
	pc $< -o $@
另外：当我们不想让make为一个没有命令行的规则中的目标搜索隐含规则时，我们需要使用空命令来实现。


模式规则
--------------------------
	模式规则类似于普通规则，只是在模式规则中，目标的定义中需要包含"%"字符(确切地说 是一个)，
包含"%"的目标被用来匹配一个文件名，"%"可以匹配任何非空字符串。规则的依赖 文件中同样可以使用"%"，
依赖中的"%"的取值情况由目标中的"%"来决定。我们可以使用模式规则来定义一个隐含规则。

	需要注意的是："%"的替换是在规则的其他变量和函数引用扩展完成之后进行的，变量和函数的展开
一般发生在make读取Makefile时，而模式规则中的"%"则发生在make的执行过程。

一个模式规则的格式为：
%.o : %.c ; COMMAND...
这个模式规则指定了如何由文件"N.c"来创建文件"N.o"，文件"N.c"应该是已存在的或者可被创建的。
模式规则中依赖文件也可以不包含模式字符"%"。当模式规则的依赖文件名中不包含模式字符"%"时，
它的含义是所有符合目标模式的目标文件都依赖于一个指定的文件。

模式规则介绍
----------------
    模式规则在Makefile中的顺序需要注意，当一个目标文件符合多个模式规则的目标时，make将会按照第一个找到的作为重建它的规则。
    在Makefile中指定的模式规则会覆盖隐含的模式规则。就是说在Makefile中明确指定的会替代隐含的模式规则。
    另外，依赖文件存在或者被提及的规则，优先于那些需要使用隐含规则来创建其依赖文件的规则

模式的匹配
----------------
通常，模式规则中目标模式由前缀、后缀、模式字符"%"组成，这三个部分中可以同时两部分为空。实际的文件名应该是以模式指定的前缀开始、后缀结束的任何文件名。

万用规则
----------------
当一个模式规则的目标为"%"（它可以匹配任何文件名）时，我们称这个规则为万用规则。


重建内嵌隐含规则
----------------
	对隐含规则，我们可以对它进行重建。重建一个隐含规则时，需要使用相同的目标和依赖文件，但是命令可以不同。
这样就替代了有相同目标和依赖的那个make内嵌的规则，替代之后的隐含规则的顺序由它在Makefile中的位置决定。
例如通常我们Makefile中可能会包含这样一个规则：
%.o : %.c
	$(CC) $(CFLAGS) –D__DEBUG__ $< -o $@

这个模式规则替代了编译.c文件的内嵌隐含规则。
也可以取消一个内嵌的隐含规则。
%.o : %.s


缺省规则
----------------
%::
	touch $@
对没有找到的所有的.c文件使用"touch"命令创建一个空的文件。
实现一个缺省规则的方式也可以不使用万用规则来实现， 可以使用伪目标".DEFAULT"。上边的例子也可以这样来书写：
.DEFAULT :
	touch $@
对于没有命令行的伪目标".DEFAULT"，其含义是取消前边所有使用".DEFAULT"指定的缺省执行命令。


