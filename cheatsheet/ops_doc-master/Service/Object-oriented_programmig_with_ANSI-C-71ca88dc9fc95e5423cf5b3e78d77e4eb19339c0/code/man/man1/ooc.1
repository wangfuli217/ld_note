.\"	ooc.1 -- 5.6 Sep 27 16:06:26 1993
.\"	Copyright (c) 1993 Axel T. Schreiner
.\" preprocess with tbl
.TH ooc  1 "local: ats"
.
.ds AC \s-1ANSI\s0 C
.tr `\(ga
.
.SH NAME
ooc \(em preprocessor for object-oriented coding in \*(AC
.SH SYNOPSIS
.B ooc
[option ...] [report ...] description target ...
.SH DESCRIPTION
.I ooc
is an
.I awk
program
which reads class descriptions
and performs the routine coding tasks necessary
to do object-oriented coding in \*(AC.
Code generated by
.I ooc
is controlled by reports which may be changed.
This manual page describes the effects of the standard reports.
.PP
.I description
is a class name.
.I ooc
loads a class description file with the name
.IB description .d
and recursively class description files for all superclasses
back to the root class.
If
.B \(mih
or
.B \(mir
is specified as a
.IR target ,
a C header file for the public interface or the private representation of
.I description
is written to standard output.
If
.IB source .dc
or
.B \(mi
is specified as a
.IR target ,
.B #include
statements for the
.I description
header files are written to standard output
and
.IB source .dc
or standard input
is read,
preprocessed,
and copied to standard output.
If
.B \(midc
is specified as a
.IR target ,
a source skeleton for
.I description
is written to standard output,
which contains all possible methods.
.PP
The output is produced by report generation from standard report files.
If
.IB file .rep
is specified as a
.IR report ,
the standard files are not loaded.
.PP
There are some global
.IR option s
to control
.IR ooc :
.TP
\f3\(miD\f2name\f1[\f3=\f2value\^\f1]
defines
.I value
or an empty string as replacement for
\f3\(ga\f2name\f1.
The
.I name
should be a single word.
.I ooc
predefines
.B \s-1GNUC\s0
with value
.BR 0 .
.TP
.B \(mid
arranges for debugging to follow normal processing.
Debugging commands are read from standard input:
.IB class .d
loads a class description file;
.IB report .rep
loads a report file;
a description, report, class, or method name
produces a dump of the appropriate information;
and
.BR all ,
.BR classes ,
.BR descriptions ,
or
.B reports
dump all information in the respective category.
.TP
.B \(mil
produces
.B #line
stamps as directed by the reports. 
.TP
.B \(miM
produces a
.I makefile
dependency line between each
.I description
and its superclass description files.
.TP
.B \(miR
must be specified if the root class is processed.
Other standard reports are loaded in this case.
.SS Lexical Conventions
All input lines are processed as follows:
first, a comment is removed;
next, lines are glued together as long as they end with a backslash;
finally, trailing white space is removed.
.PP
A comment extends from
.B //
to the end of a line.
It is removed together with preceding white space
before glueing takes place.
.PP
In glueing,
the backslash marks the contact point and is removed.
All white space around the contact point is replaced with a single space.
.PP
Identifiers significant to
.I ooc
follow the conventions of C,
except that they may not use underscore characters.
The underscore is used to avoid clashes between
.IR ooc 's
and the user's code.
.PP
Declarators significant to
.I ooc
are simplified relative to C.
They may start with
.B const
and the type information must precede the name.
The type information may use
.B *
but no parentheses.
In general,
an arbitrary declarator can be adapted for
.I ooc
by introducing a type name with
.BR typedef .
.PP
A line starting with
.B %%
acts as end of file.
.SS Class Description File
The class description file has the following format:
.RS
.nf
.I header
.BI % " meta class " {
.I "\&   components"
.B %
.I "\&   methods with static linkage"
.B %\(mi
.I "\&   methods with dynamic linkage"
.B %+
.I "\&   class methods"
.BI %}
\&...
.fi
.RE
.PP
.I header
is arbitrary information
which is copied to standard output if the interface file is produced.
Information following
.B %prot
is copied to standard output if the representation file is produced.
.PP
.I components
are C structure component declarations with one declarator per line.
They are copied into the
.B struct
generated in the representation file for the class.
They also determine the order of the construction parameters
for the root metaclass.
.PP
The first set of
.I "methods"
has static linkage,
i.e., they are functions with at least one object as a parameter;
the second set has dynamic linkage
and has an object as a parameter for which the method is selected;
the third set are class methods,
i.e., they have a class as a parameter for which the method is selected.
The selection object is always called
.BR self .
The method declarations define C function headers,
selectors,
and information for the metaclass constructor.
.PP
The class header line
.BI % " meta class " {
has one of three forms.
The first form is used to introduce the root class only:
.TP
.BI % " meta  class " {
.I class
is the root class,
indicated by the fact that it has no superclass.
The superclass is then defined to be the root class itself.
.I meta
should be introduced later as the root metaclass,
indicated by the fact that it has itself as metaclass.
.TP
.BI % " meta  class" : " super " {
.I class
is a new class with
.I meta
as its metaclass and
.I super
as its superclass.
This would also be used to introduce the root metaclass,
which has itself as metaclass and the root class as superclass.
If
.I super
is undefined,
.I ooc
will recursively (but only once)
load the class description file
.IB super .d
and then
.I super
and
.I meta
must have been defined so that
.I class
can be defined.
If this form of the class header is used,
only methods with static linkage can be introduced.
.TP
\f3%\f2 meta\f3\^: \f2supermeta  class\f3\^: \f2super\f3 {\f1
This additionally defines
.I meta
as a new metaclass with
.I supermeta
as its superclass.
If
.I super
is undefined,
.I ooc
will recursively (but only once)
load the class description file
.IB super .d
and then
.I super
and
.I supermeta
must have been defined so that
.I meta
and
.I class
can be defined.
.PP
A method declaration line has the following form,
where braces indicate zero or more occurrences and
brackets indicate an optional item:
.TP
[ \f2tag \f3:\f1 ] \f2declarator\f3 ( \f2declarator \f1{ \f3,\f2 declarator\f1 } [ \f3, ...\f1 ] \f3);\f1
The optional
.I tag
is an identifier involved in locating a method with
.BR respondsTo() .
The first
.I declarator
introduces the method name and result type, the remaining
.IR declarator s
introduce parameter names and types.
Exactly one parameter name must be
.B self
to indicate the receiver of the method call.
.PP
A
.I declarator
is a simplified C declarator as described above,
but there are two special cases:
.TP
.BI _ name
introduces
.I name
as the declarator name.
The type is a pointer to an instance of the current class
or to the class for which a dynamically linked method is overwritten.
Such a pointer will be dereferenced by
.B %casts
as
.I name
within a method.
Therefore,
.B self
must be introduced as
.BR _self ,
where
.B self
is the dereferenced object or class for class methods and
.B _self
is the raw pointer.
.TP
.IB class " @ " name
.br
introduces
.I name
as a pointer to an instance of
.IR class .
Such a pointer will not be dereferenced
but it will be checked by
.BR %casts .
.PP
The result type of a method can employ
.IB class " @" .
In this case, the result type is generated as a pointer to a
.B struct
.I class
which is useful when implementing methods,
and which cannot be used other than for assignments to
.B "void *"
in application code.
The result type should be
.B "void *"
for constructors and similar methods to emphasize the generic aspects
of construction.
.SS Preprocessing
Subject to the lexical conventions described above,
an implementation file
.IB source .dc
is copied to standard output.
Lines starting with
.B %
are preprocessed as follows:
.TP
.BI % " class method " {
This is replaced by a C function header for
.IR method ;
the header is declared
.B static
with the name
.IB class _ method,
unless
.I method
has static linkage.
In the latter case,
.I class
is optional.
.I ooc
checks in all cases that the method can be specified for
.IR class .
Function names are remembered as necessary for initialization of the description of
.I class
and the corresponding metaclass if any.
There can be an optional tag preceding
.I class
unless
.I method
has static linkage.
.TP
.BI %casts
This is replaced by definitions of local variables
to securely dereference parameter pointers to objects in the current class.
For statically linked methods this is
followed by checks to verify the parameters pointing to objects
of other classes.
.B %casts
should be used where local variables can be defined;
for statically linked methods it must be the last definition.
Note that null pointers flunk the checks and terminate the calling program.
.TP
.BI %init
This should be near the end of the implementation file.
If the
.I description
introduced a new metaclass,
a constructor for the metaclass,
selectors for the class,
and initializations for the metaclass are generated.
In either case,
an initialization for the class is generated.
.PP
If a method
.I m
does not have static linkage,
there are two selectors:
.I m
with the same parameters as the method
selecting the method defined for
.BR self ,
and
.BI super_ m
with an explicit class description as an additional first parameter.
The second selector is used to pass a method call to
the superclass of the class where the method is defined.
.PP
If a dynamically linked or class method has a variable argument list,
the selector passes
.B va_list * app
to the actual method.
.PP
If a selector recognizes that it cannot be applied to its object,
it calls
.B forward
and passes its object,
a pointer to a result area, or a null pointer,
its own address,
its name as a string,
and its entire argument list.
.B forward
should be a dynamically linked method in the root class;
it can be used to forward a message from one object to another.
.SS Tags
.B respondsTo()
is a method in the root class which
takes an object and a tag, i.e., a C string
containing an identifier,
and returns either a null pointer or a selector
which will accept the object and other parameters
and call the method corresponding to the tag.
.PP
The tag under which a class or dynamically linked method can be found
is defined as follows.
The default is either the method name or
.I tag
in the method header in the class description file:
.RS
[ \f2tag \f3:\f1 ] \f2declarator\f3 ( \f2declarator \f1{ \f3,\f2 declarator\f1 } [ \f3, ...\f1 ] \f3);\f1
.RE
.PP
The method header in the implementation may overwrite the tag:
.RS
.BI % " mtag" : " class method " {
.RE
.PP
The effective tag is
.I mtag
if specified, or
.I tag
if not.
If
.I mtag
or
.I tag
is empty but the colon is specified,
.B respondsTo()
cannot find the method.
.SS Report File
.I ooc
uses report files containing all code fragments
which
.I ooc
will generate.
Names such as
.B app
for an argument list pointer
can be changed in the report file.
Only
.B self
is built into
.I ooc
itself.
.PP
A report file contains one or more reports.
The usual lexical conventions apply.
Each report is preceded by a line starting with
.B %
and containing the report name
which may be enclosed by white space.
The report name is arbitrary text
but it must be unique.
.PP
A report consists of lines of words separated by single blanks or tabs,
called spaces.
An empty word results between any two adjacent spaces
or if a space starts or ends a line.
.PP
An empty word,
not at the beginning of an output line,
is printed as a blank.
In particular,
this means that two successive spaces in a report
represent a single blank to be printed.
Any word not starting with a back quote
.B `
is printed as is.
.PP
A word starting with
.B `%
causes a report to be printed.
The report name is the remainder of the word.
.PP
.B `#line
followed by a word
causes a line stamp to be printed
if option
.B \(mil
is specified;
the phrase is ignored otherwise.
If the word is a class, method, or class component name,
the line stamp refers to its position in a class description file.
Otherwise,
and in particular for empty words,
the line stamp refers to the current input file position.
.PP
A word starting with
.B `{
starts a group.
The group is terminated with a word starting with
.BR `} .
All other words starting with a back quote
.B `
are replaced during printing.
Some replacements are globally defined,
others are set up by certain groups.
A table of replacements follows at the end of this section.
.PP
Groups are either loops over parts of the database
collected by
.I ooc
or they are conditionals based on a comparison.
Words inside a group are printed under control of the loop
or the comparison.
Afterwards, printing continues with the word following the group.
Groups can be nested,
but that may not make sense for some parts of the database.
Here is a table of words starting a loop:
.TS
center;
Lb L.
`{%	static methods for the current \f3`class\fP
`{%\(mi	dynamic methods for the current \f3`class\fP
`{%+	class methods for the current \f3`class\fP
`{()	parameters for the current \f3`method\fP
`{dcl	class headers in the \f3`desc\fP description file
`{pub	public lines in the \f3`desc\fP description file
`{prot	protected lines in the \f3`desc\fP description file
`{links\f2\& class\fP	dynamic and class methods defined for \f2class\fP
`{struct\f2\& class\fP	components for \f2class\fP
`{super	\f3`desc\fP and all its superclasses back to \f3`root\fP
.TE
.PP
A loop is terminated with a word starting with
.BR `} .
If the terminating word is
.B `},
in the loop over parameters,
and if the loop will continue for more parameters,
a comma followed by a blank is printed for this word.
If the terminating word is
.B `}n
and if the group has produced any output,
a newline is printed for this word.
Otherwise, nothing is printed for termination.
.PP
A conditional group starts with
.B `{if
or
.B `{ifnot
followed by two words.
The words are replaced if necessary and compared.
If they are equal,
the group starting with
.B `{if
is executed;
if they are not equal,
the group starting with
.B `{ifnot
is executed.
If either group is not executed
and if it is followed by a group starting with
.BR `{else ,
this group is executed.
Otherwise the
.B `{else
group is skipped.
.PP
In general it is best if the
.B `}
terminating the
.B `{if
group immediately precedes
.B `{else
on the same line of the report.
.PP
Here is a table of replaced words
together with the events that set up the replacements:
.TS
center;
Li S
Ab L.
set up globally
`	no text (empty string)
``	` (back quote)
`t	tab
`n	newline (limited to one blank line)
.sp .5v
.T&
Li S
Ab L.
set up once class descriptions are loaded
`desc	last \f2description\fP from command line
`root	root class' name
`metaroot	root's metaclass name
.sp .5v
.T&
Liz Rb
Ab L.
set up for a class	% %\(mi %+ `{dcl `{prot `{pub `{super
`class	class' name
`super	class' superclass name
`meta	class' metaclass name
`supermeta	metaclass' superclass name
.sp .5v
.T&
Liz Rb
Ab L.
set up for a method	`{% `{%\(mi `{%+ `{links\f2\& class\fP
`method	method's name
`result	method's result type
`linkage	method's linkage: \f3%\fP, \f3%\(mi\fP, or \f3%+\fP
`tag	method's tag
`,...	\f3, ...\fP if variable arguments are declared,
\^	   empty if not
`_last	last parameter's name if variable arguments,
\^	   undefined if not
.sp .5v
.T&
Liz Rb
Ab L.
set up for a declarator	`{() `{struct\f2\& class\fP
`name	name in declarator
`const	\f3const\fP followed by a blank, if so declared
`type	\f3void *\fP for objects, declared type otherwise
`_	\f3_\fP if used in declaration, empty otherwise
`cast	object's class name, empty otherwise
.sp .5v
.T&
Liz Rb
Ab L.
set up for lines from the description file	`{dcl `{prot `{pub
`class	set up for a class description, empty otherwise
`line	line's text if not class description, undefined otherwise
`newmeta	\f3\&1\fP if new metaclass is defined, \f3\&0\fP if not
.TE
.PP
A
.I description
on the command line of
.I ooc
sets up for a class.
Requesting a method header in a source file
sets up for a class and a method.
The loops
.BR `{dcl ,
.BR `{prot ,
and
.B `{pub
set up for lines from a class description file.
The loops
.BR `{% ,
.BR `{%\(mi ,
.BR `{%+ ,
and
.B `{links
.I class
set up for a method.
The loop
.B `{()
sets up for a parameter declarator.
The loop
.B `{struct
.I class
sets up for the declarator of a component of a class.
The loop
.B `{super
runs from
.I description
through all its superclasses.
.SS Environment
.B OOCPATH
is a colon-separated list of paths.
If a file name does not contain path delimiters,
.I ooc
looks for the file (class descriptions, sources, and report files)
by prefixing each entry of
.B OOCPATH
to the required file name.
By default,
.B OOCPATH
consists of the working directory and a standard place.
.SH FILES
. nf
. ta 30n
\f2class\f3.d\f1	description for \f2class\fP 
\f2class\f3.dc\f1	implementation for \f2class\fP 
\f2report\f3.rep\f1	report file
\f2\s-1AWKPATH\s0\^/\|*\fP\f3.awk\fP	modules
\f2\s-1AWKPATH\s0\^/\|*\fP\f3.dbg\fP	debugger modules
\f2\s-1OOCPATH\s0\^/\|\fP\f3c.rep\fP	implementation file reports
\f2\s-1OOCPATH\s0\^/\|\fP\f3dc.rep\fP	implementation thunks report
\f2\s-1OOCPATH\s0\^/\|\fP\f3etc.rep\fP	common reports
\f2\s-1OOCPATH\s0\^/\|\fP\f3h.rep\fP	interface file report
\f2\s-1OOCPATH\s0\^/\|\fP\f3header.rep\fP	common reports
\f2\s-1OOCPATH\s0\^/\|\fP\f3m.rep\fP	\f2makefile\fP dependency report
\f2\s-1OOCPATH\s0\^/\|\fP\f3r.rep\fP	representation file reports
\f2\s-1OOCPATH\s0\^/\|\fP\f3va.rep\fP	common reports
\f2\s-1OOCPATH\s0\^/\|\fP\f3[chr]-R.rep\fP	root class versions
. fi
.SH BUGS
The C preprocessor is applied to the output of
.IR ooc ,
not to the input,
i.e., conditional compilation should not be applied to
.I ooc
controls.
.tr ``
