AOF 持久化的实现
----------------------

AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。


命令追加
^^^^^^^^^^^

当 AOF 持久化功能处于打开状态时，
服务器在执行完一个写命令之后，
会以协议格式将被执行的写命令追加到服务器状态的 ``aof_buf`` 缓冲区的末尾：

::

    struct redisServer {

        // ...

        // AOF 缓冲区
        sds aof_buf;

        // ...
    };

举个例子，
如果客户端向服务器发送以下命令：

::

    redis> SET KEY VALUE
    OK

那么服务器在执行这个 :ref:`SET` 命令之后，
会将以下协议内容追加到 ``aof_buf`` 缓冲区的末尾：

::

    *3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n

又比如说，
如果客户端向服务器发送以下命令：

::

    redis> RPUSH NUMBERS ONE TWO THREE
    (integer) 3

那么服务器在执行这个 :ref:`RPUSH` 命令之后，
会将以下协议内容追加到 ``aof_buf`` 缓冲区的末尾：

::

    *5\r\n$5\r\nRPUSH\r\n$7\r\nNUMBERS\r\n$3\r\nONE\r\n$3\r\nTWO\r\n$5\r\nTHREE\r\n

以上就是 AOF 持久化的命令追加步骤的实现原理。


AOF 文件的写入与同步
^^^^^^^^^^^^^^^^^^^^^^^

Redis 的服务器进程就是一个事件循环（loop），
这个循环中的文件事件负责接收客户端的命令请求，
以及向客户端发送命令回复，
而时间事件则负责执行像 ``serverCron`` 函数这样需要定时运行的函数。

因为服务器在处理文件事件时可能会执行写命令，
使得一些内容被追加到 ``aof_buf`` 缓冲区里面，
所以在服务器每次结束一个事件循环之前，
它都会调用 ``flushAppendOnlyFile`` 函数，
考虑是否需要将 ``aof_buf`` 缓冲区中的内容写入和保存到 AOF 文件里面，
这个过程可以用以下伪代码表示：

.. code-block:: python

    def eventLoop():

        while True:

            # 处理文件事件，接收命令请求以及发送命令回复
            # 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中
            processFileEvents()

            # 处理时间事件
            processTimeEvents()

            # 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面
            flushAppendOnlyFile()

..
    ``flushAppendOnlyFile`` 函数的行为由服务器配置的 ``appendfsync`` 选项的值决定：

    - 当 ``appendfsync`` 选项的值为 ``always`` 时，
      ``flushAppendOnlyFile`` 函数每次执行都会将 ``aof_buf`` 缓冲区中的所有内容写入和同步到 AOF 文件。

    - 当 ``appendfsync`` 选项的值为 ``everysec`` 时，
      ``flushAppendOnlyFile`` 函数每次执行都会将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，
      但只有距离上次同步 AOF 文件超过一秒钟之后，
      服务器才会再次对 AOF 文件进行同步，
      并且该同步操作是由一个专门的线程负责执行的。

    - 当 ``appendfsync`` 选项的值为 ``no`` 时，
      ``flushAppendOnlyFile`` 函数每次执行都会将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，
      但服务器永远不会主动对 AOF 文件进行同步，
      而是由操作系统来决定该何时同步 AOF 文件。

``flushAppendOnlyFile`` 函数的行为由服务器配置的 ``appendfsync`` 选项的值来决定，
各个不同值产生的行为如表 TABLE_APPENDFSYNC 所示。

+---------------------------+-----------------------------------------------------------+
| ``appendfsync`` 选项的值  | ``flushAppendOnlyFile`` 函数的行为                        |
+===========================+===========================================================+
| ``always``                | 将 ``aof_buf`` 缓冲区中的所有内容写入并同步到 AOF 文件。  |
+---------------------------+-----------------------------------------------------------+
| ``everysec``              | 将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，        |
|                           | 如果上次同步 AOF 文件的时间距离现在超过一秒钟，           |
|                           | 那么再次对 AOF 文件进行同步，                             |
|                           | 并且这个同步操作是由一个线程专门负责执行的。              |
+---------------------------+-----------------------------------------------------------+
| ``no``                    | 将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，        |
|                           | 但并不对 AOF 文件进行同步，                               |
|                           | 何时同步由操作系统来决定。                                |
+---------------------------+-----------------------------------------------------------+

..
    +---------------------------+-----------------------------------------------+---------------------------------------------------+
    | ``appendfsync`` 选项的值  | 将 ``aof_buf`` 缓冲区的内容写入到 AOF 文件？  | 同步 AOF 文件？                                   |
    +===========================+===============================================+===================================================+
    | ``always``                | 是                                            | 是。                                              |
    +---------------------------+-----------------------------------------------+---------------------------------------------------+
    | ``everysec``              | 是                                            | 如果距离上次同步超过了一秒钟，那么进行同步。      |
    +---------------------------+-----------------------------------------------+---------------------------------------------------+
    | ``no``                    | 是                                            | 不主动同步 AOF 文件，何时同步交由操作系统决定。   |
    +---------------------------+-----------------------------------------------+---------------------------------------------------+

如果用户没有主动为 ``appendfsync`` 选项设置值，
那么 ``appendfsync`` 选项的默认值为 ``everysec`` ，
关于 ``appendfsync`` 选项的更多信息，
请参考 Redis 项目附带的示例配置文件 ``redis.conf`` 。

.. topic:: 文件的写入和同步

    为了提高文件的写入效率，
    在现代操作系统中，
    当用户调用 ``write`` 函数，
    将一些数据写入到文件的时候，
    操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，
    等到缓冲区的空间被填满、或者超过了指定的时限之后，
    才真正地将缓冲区中的数据写入到磁盘里面。

    这种做法虽然提高了效率，
    但也为写入数据带来了安全问题，
    因为如果计算机发生停机，
    那么保存在内存缓冲区里面的写入数据将会丢失。
    
    为此，
    系统提供了 ``fsync`` 和 ``fdatasync`` 两个同步函数，
    它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，
    从而确保写入数据的安全性。

..
    ``flushAppendOnlyFile`` 函数的行为可以用以下伪代码描述：

    .. code-block:: python

        def flushAppendOnlyFile():

            # 将缓冲区中的内容写入到 AOF 文件
            write_buf_to_file(server.aof_buf, aof_file)

            # 获取 appendfsync 选项的值
            value = get_appendfsync_option_value()
            
            # 如果值为 always ，那么同步 AOF 文件，并更新最后一次同步时间
            if value == always:

                fsync_or_fdatasync(aof_file)

                server.aof_last_fsync = unixtime_now()

            # 如果值为 everysec ，并且距离上次同步超过 1 秒钟
            # 那么使用子线程同步 AOF 文件，并更新最后一次同步时间
            elif value == everysec and  \
                 (unixtime_now() - server.aof_last_fsync) > 1:

                thread_sync(aof_file)

                server.aof_last_fsync = unixtime_now()

            # 如果值为 no ，那么不做动作，由操作系统负责同步
            else:

                pass

举个例子，
假设服务器在处理文件事件期间，
执行了以下三个写入命令：

1. ``SADD databases "Redis" "MongoDB" "MariaDB"``

2. ``SET date "2013-9-5"``

3. ``INCR click_counter 10086``

那么 ``aof_buf`` 缓冲区将包含这三个命令的协议内容：

::

    *5\r\n$4\r\nSADD\r\n$9\r\ndatabases\r\n$5\r\nRedis\r\n$7\r\nMongoDB\r\n$7\r\nMariaDB\r\n
    *3\r\n$3\r\nSET\r\n$4\r\ndate\r\n$8\r\n2013-9-5\r\n
    *3\r\n$4\r\nINCR\r\n$13\r\nclick_counter\r\n$5\r\n10086\r\n

如果这时 ``flushAppendOnlyFile`` 函数被调用，
假设服务器当前 ``appendfsync`` 选项的值为 ``everysec`` ，
并且根据 ``server.aof_last_fsync`` 属性显示，
距离上次同步 AOF 文件已经超过一秒钟，
那么服务器会先将 ``aof_buf`` 中的内容写入到 AOF 文件中，
然后再对 AOF 文件进行同步。

以上就是对 AOF 持久化功能的文件写入和文件同步这两个步骤的介绍。

.. topic:: AOF 持久化的效率和安全性

    服务器配置 ``appendfsync`` 选项的值直接决定 AOF 持久化功能的效率和安全性。

    当 ``appendfsync`` 的值为 ``always`` 时，
    服务器在每个事件循环都要将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，
    并且同步 AOF 文件，
    所以 ``always`` 的效率是 ``appendfsync`` 选项三个值当中最慢的一个，
    但从安全性来说，
    ``always`` 也是最安全的，
    因为即使出现故障停机，
    AOF 持久化也只会丢失一个事件循环中所产生的命令数据。

    当 ``appendfsync`` 的值为 ``everysec`` 时，
    服务器在每个事件循环都要将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，
    并且每隔超过一秒就要在子线程中对 AOF 文件进行一次同步：
    从效率上来讲，
    ``everysec`` 模式足够快，
    并且就算出现故障停机，
    数据库也只丢失一秒钟的命令数据。

    当 ``appendfsync`` 的值为 ``no`` 时，
    服务器在每个事件循环都要将 ``aof_buf`` 缓冲区中的所有内容写入到 AOF 文件，
    至于何时对 AOF 文件进行同步，
    则由操作系统控制。

    因为处于 ``no`` 模式下的 ``flushAppendOnlyFile`` 调用无须执行同步操作，
    所以该模式下的 AOF 文件写入速度总是最快的，
    不过因为这种模式会在系统缓存中积累一段时间的写入数据，
    所以该模式的单次同步时长通常是三种模式中时间最长的：
    从平摊操作的角度来看，
    ``no`` 模式和 ``everysec`` 模式的效率类似，
    当出现故障停机时，
    使用 ``no`` 模式的服务器将丢失上次同步 AOF 文件之后的所有写命令数据。
