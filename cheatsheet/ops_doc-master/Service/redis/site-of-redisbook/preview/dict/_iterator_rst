字典迭代器
---------------

Redis 为字典实现了相应的迭代器，
通过这个迭代器，
可以访问字典中保存的所有键值对。

因为 Redis 的字典使用哈希表作为底层实现，
因此，
对字典进行迭代实际上就是对字典所持有的哈希表进行迭代。

以下是程序迭代哈希表的步骤：

1. 定位到哈希表的索引 ``0`` 上。

2. 遍历索引上的所有节点，
   如果有多个节点组成了链表，
   那么整个链表上的所有节点都会被依次遍历。

3. 移动到哈希表的下一个索引，
   继续执行步骤 2 。

4. 当哈希表的所有索引都被遍历完时，
   迭代完毕。

举个例子，
在下图所示的哈希表中，
迭代器对节点的访问路径就用虚线箭头标示了出来，
而箭头上的数字就是节点被访问的顺序：

.. graphviz:: image/iterator.dot

对整个哈希表的访问过程如下：

1. 访问索引 ``0`` 上包含键 ``k1`` 的节点。

2. 访问索引 ``0`` 上包含键 ``k2`` 的节点。

3. 访问索引 ``1`` 上包含键 ``k3`` 的节点。

4. 访问索引 ``2`` 上包含键 ``k4`` 的节点。

5. 访问索引 ``2`` 上包含键 ``k5`` 的节点。

6. 访问索引 ``3`` 上包含键 ``k6`` 的节点。

当程序对一个字典进行迭代时，
它首先迭代哈希表 ``ht[0]`` ，
然后再迭代哈希表 ``ht[1]`` 。

对于一个包含有 :math:`N` 个键值对的字典来说，
遍历整个字典的复杂度为 :math:`O(N)` 。


创建迭代器
^^^^^^^^^^^^^^^

函数 ``dictGetIterator`` 创建并返回一个不安全迭代器：

::

    dictIterator *dictGetIterator(dict *d);

而函数 ``dictGetSafeIterator`` 则创建并返回一个安全迭代器：

::

    dictIterator *dictGetSafeIterator(dict *d);

以下表格描述了两种迭代器之间的不同之处：

+-----------------------------------------------+------------------------------------------------+
| 安全迭代器                                    |     不安全迭代器                               |
+===============================================+================================================+
| 数量会被记录到字典中：                        |     数量不会被记录到字典中：                   |
| 当创建一个安全迭代器时，                      |     无论创建还是删除不安全迭代器，             |
| 程序将字典的 ``iterators`` 属性的值增一；     |     程序都不会修改 ``iterators`` 属性。        |
| 当删除一个安全迭代器时，                      |                                                |
| 程序将字典的 ``iterators`` 属性的值减一。     |                                                |
+-----------------------------------------------+------------------------------------------------+
| 在迭代过程中，                                |     在迭代过程中，                             |
| 允许对字典进行修改，                          |     不允许对字典进行修改。                     |
| 比如执行添加、删除、更新等操作。              |                                                |
+-----------------------------------------------+------------------------------------------------+
| 在迭代过程中，不允许进行渐进式迁移。          |     在迭代过程中，允许进行渐进式迁移。         |
+-----------------------------------------------+------------------------------------------------+

在大多数情况下，
程序都使用不安全迭代器来遍历字典，
而少数一些特殊场景则使用了安全迭代器：

- 比如在执行 :ref:`SAVE` 命令、 :ref:`BGSAVE` 命令和 :ref:`BGREWRITEAOF` 命令时，
  为了尽量利用操作系统的写时复制（copy-on-write）机制，
  程序会使用安全迭代器来遍历数据库，
  从而避免引起渐进式迁移。

- 与此类似， 
  :ref:`KEYS` 命令也使用安全迭代器来遍历数据库，
  因为这样可以避免执行渐进式迁移，
  从而让 CPU 时间都用在处理迭代上面。

- 另外，
  有一些函数确实需要在迭代字典的同时对字典进行修改，
  比如 SENTINEL 模块的 ``removeMatchingSentinelsFromMaster`` 函数就需要在迭代字典的同时对字典进行删除操作，
  对于这类函数，
  它们只能使用安全迭代器。

``dictGetIterator`` 和 ``dictGetSafeIterator`` 的复杂度都为 :math:`O(1)` 。


返回当前节点
^^^^^^^^^^^^^^^

``dictNext`` 函数返回迭代器当前指向的节点，
如果整个字典的所有节点都已经被迭代完毕，
那么返回  ``NULL`` ：

::

    dictEntry *dictNext(dictIterator *iter);

``dictNext`` 的复杂度为 :math:`O(1)` 。


删除迭代器
^^^^^^^^^^^^^^^^

``dictReleaseIterator`` 删除给定的迭代器：

::
        
    void dictReleaseIterator(dictIterator *iter);

如果被释放的对象是一个安全迭代器，
那么将字典的 ``iterators`` 属性的值减一。

``dictReleaseIterator`` 的复杂度为 :math:`O(1)` 。
