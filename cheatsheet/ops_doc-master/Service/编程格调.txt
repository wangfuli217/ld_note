Write clearly -- don't be too clever.
Say what you mean, simply and directly.
Use library functions whenever feasible.
Avoid too many temporary variables.
Write clearly -- don't sacrifice clarity for efficiency.
Let the machine do the dirty work.
Replace repetitive expressions by calls to common functions.
Parenthesize to avoid ambiguity.
Choose variable names that won't be confused.
Avoid unnecessary branches.
If a logical expression is hard to understand, try transforming it.
Choose a data representation that makes the program simple.
Write first in easy-to-understand pseudo language; then translate into whatever language you have to use.
Modularize. Use procedures and functions.
Avoid gotos completely if you can keep the program readable.
Don't patch bad code -- rewrite it.
Write and test a big program in small pieces.
Use recursive procedures for recursively-defined data structures.
Test input for plausibility and validity.
Make sure input doesn't violate the limits of the program.
Terminate input by end-of-file marker, not by count.
Identify bad input; recover if possible.
Make input easy to prepare and output self-explanatory.
Use uniform input formats.
Make input easy to proofread.
Use self-identifying input. Allow defaults. Echo both on output.
Make sure all variables are initialized before use.
Don't stop at one bug.
Use debugging compilers.
Watch out for off-by-one errors.
Take care to branch the right way on equality.
Be careful if a loop exits to the same place from the middle and the bottom.
Make sure your code does "nothing" gracefully.
Test programs at their boundary values.
Check some answers by hand.
10.0 times 0.1 is hardly ever 1.0.
7/8 is zero while 7.0/8.0 is not zero.
Don't compare floating point numbers solely for equality.
Make it right before you make it faster.
Make it fail-safe before you make it faster.
Make it clear before you make it faster.
Don't sacrifice clarity for small gains in efficiency.
Let your compiler do the simple optimizations.
Don't strain to re-use code; reorganize instead.
Make sure special cases are truly special.
Keep it simple to make it faster.
Don't diddle code to make it faster -- find a better algorithm.
Instrument your programs. Measure before making efficiency changes.
Make sure comments and code agree.
Don't just echo the code with comments -- make every comment count.
Don't comment bad code -- rewrite it.
Use variable names that mean something.
Use statement labels that mean something.
Format a program to help the reader understand it.
Document your data layouts.
Don't over-comment


一、表达
  1.写清楚
  2.保守使用临时变量
  3.明白无歧义
  4.不要自己造所有的工具
  5.确保判断测试条件清楚易读

二、控制结构
  1.先用你顺手的高级语言写一遍程序，这时可以看清楚算法并作相应的调试，程序正确之后，再翻译成你编译器所处理的语言
  2.子例程和函数，把代码分成可独立管理的小段
  3.规划数据结构的时候要像规划控制流一样小心，尝试找到可以起到简化程序作用的数据表示形式

三、程序结构
  1.编写和维护大型程序唯一的方法是把它分解成一组函数、子例程和过程
  2.每一个模块应该只处理问题的一个方面，否则的话，模块就会变得大而复杂
  3.相对于其他模块，一个模块应该隐藏它如何完成工作的细节，否则这个模块就无法独立于其他模块来进行修改

四、输入和输出
  1.校验输入数据的合法于合理性
  2.保证输入数据不会违背程序的限制
  3.利用文件结束符号或结束标志来终止输入，不要让用户去计数
  4.识别输入错误并尽可能地恢复，不要一碰到错误就停止，也不要忽略错误了事
  5.在输入和输出时采用助记符，使得输入数据易于正确地准备，在输出时同时也將输入和默认值输出，并使得输出数据不言自明
  6.將I/O局限起来，不要散布在整个程序中。將处理文件结束和缓冲区等细节隐藏在函数中
  7.保证程序的结构反映出其所处理的数据

五、常见错误
  1.使用变量之前要初始化
  2.小心"差一"错误，确保在正确的次数下完成循环，对于等式的比较判断，确保有正确的分支处理
  3.检查数组的下标不要越界
  4.避免循环有多个出口
  5.检查程序的内部边界
  6.预防性编程，搞清楚哪些事可能出问题，并且添加代码以检查
  7.不要用浮点数来做累计，不要期望浮点小数数值遵循你熟悉的算术法则，他们不适用

六、效率和测试工具
  1.假如程序是错误的，再快也没用。
  2.让代码言简意赅。撰写时不要惦记着它运行得快。过早优化是万恶之源
  3.别为每个优化细节去操心，让编译器去照顾这些
  4.用心于算法，而非代码细节。记住，数据结构对算法的实现方式有显著影响
  5.在构造程序时放置测试语句，在决定"增效"之前先执行测试。在程序演进过程中，可將测试语句留下来随时运用

七、文档
  1.如果程序不正确，文档写得再好都没有用
  2.如果文档和代码不一致，那程序就没什么价值
  3.要在最大程度上使得代码本身就是自己的文档，如果做不到，重写代码而不是做文档的补充。好的代码需要的注释量要比坏的代码少
  4.注释提供的信息应该是从代码上无法获得的
  5.帮助记忆的变量名和标签，以及强调逻辑结构的代码布局，都有助于程序自身的文档化