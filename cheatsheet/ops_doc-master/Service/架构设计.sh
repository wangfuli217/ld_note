


framework(生产者/消费者模式：如何确定数据单元？){
啥是数据单元？
---------------------------------------
    何谓数据单元捏？简单地说，每次生产者放到缓冲区的，就是一个数据单元；每次消费者从缓冲区取出的，也是
一个数据单元。

数据单元的特性
---------------------------------------
◇关联到业务对象
◇完整性
    所谓完整性，就是在传输过程中，要保证该数据单元的完整。要么【整个】数据单元被传递到消费者，要么完全没有
传递到消费者。不允许出现【部分】传递的情形。
◇独立性
    所谓独立性，就是各个数据单元之间没有互相依赖，某个数据单元传输失败【不应该】影响已经完成传输的单元；
也【不能】影响尚未传输的单元。
◇颗粒度
    太大的颗粒度可能会浪费空间；太小的颗粒度可能会影响时间性能。颗粒度的权衡要基于多方面的因素，以及一些经验值的考量。
}


framework(生产者/消费者模式：队列缓冲区){
线程方式
---------------------------------------
◇内存分配的性能
    在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出
数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程
并不复杂。
    对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和
用户态/核心态切换的开销。
◇同步和互斥的性能
    同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能
导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。
◇适用于队列的场合
    所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合 
KISS 原则。


进程方式
---------------------------------------
跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。

◇匿名管道
    感觉管道是最像队列的IPC类型。生产者进程在管道的写端放入数据；消费者进程在管道的读端取出数据。整个的效果和
线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。
好处：
1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。
2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。
3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。、
缺点：
1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。
2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。
3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。
4. 最后，这种方式只能单向传数据。
大伙儿留意一下：
1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，
   直到管道中重新有数据。
2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（
   比如生产者进程输出了数据，但消费者进程没有立即读到）。

◇SOCKET（TCP 方式）
基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。
而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。
　　SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：
1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。
2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。
3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。
4. SOCKET 支持双向通讯，有利于消费者反馈信息。

这样的好处是很明显的，具体如下：
1. 能够应对暂时性的网络故障。并且在网络故障解除后，能够继续工作。
2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。
3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。
4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）
5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。
}

framework(生产者/消费者模式：环形缓冲区){
只有当存储空间的分配／释放非常【频繁】并且确实产生了【明显】的影响，你才应该考虑环形缓冲区的使用。
环形缓冲区 vs 队列缓冲区
---------------------------------------
◇外部接口相似
    普通的队列有一个写入端和一个读出端。队列为空的时候，读出端无法读取数据；当队列满（达到最大尺寸）时，
写入端无法写入数据。
    对于使用者来讲，环形缓冲区和队列缓冲区是一样的。它也有一个写入端（用于 push）和一个读出端（用于 pop），
也有缓冲区'满'和'空'的状态。所以，从队列缓冲区切换到环形缓冲区，对于使用者来说能比较平滑地过渡。

◇内部结构迥异
    大伙儿可以把环形缓冲区的读出端（以下简称 R）和写入端（以下简称 W）想象成是两个人在体育场跑道上追逐。
当 R 追上 W 的时候，就是缓冲区为空；当 W 追上 R 的时候（W 比 R 多跑一圈），就是缓冲区满。
所以环形方式相比队列方式，少掉了对于缓冲区元素所用存储空间的分配、释放。这是环形缓冲区的一个主要优势。

环形缓冲区的实现
---------------------------------------
◇数组方式 vs 链表方式
    环形缓冲区的内部实现，即可基于数组（此处的数组，泛指连续存储空间）实现，也可基于链表实现。
　　数组在物理存储上是一维的连续线性结构，可以在初始化时，把存储空间【一次性】分配好，这是数组方式的优点。
但是要使用数组来模拟环，你必须在逻辑上把数组的头和尾相连。在顺序遍历数组时，对尾部元素（最后一个元素）要作
一下特殊处理。访问尾部元素的下一个元素时，要重新回到头部元素（第0个元素）。
    使用链表的方式，正好和数组相反：链表省去了头尾相连的特殊处理。但是链表在初始化的时候比较繁琐，而且在
有些场合（比如后面提到的跨进程的 IPC）不太方便使用。

◇读写操作
◇判断'空'和'满'
办法1：始终保持一个元素不用
    当空环的时候，R 和 W 重叠。当 W 比 R 跑得快，追到距离 R 还有一个元素间隔的时候，就认为环已经满。
当环内元素占用的存储空间较大的时候，这种办法显得很土（浪费空间）。
办法2：维护额外变量
    如果不喜欢上述办法，还可以采用额外的变量来解决。比如可以用一个整数记录当前环中已经保存的元素个数
（该整数>=0）。当 R 和 W 重叠的时候，通过该变量就可以知道是'空'还是'满'。
◇元素的存储
　　由于环形缓冲区本身就是要降低存储空间分配的开销，因此缓冲区中元素的类型要选好。尽量存储【值类型】
的数据，而不要存储【指针（引用）类型】的数据。因为指针类型的数据又会引起存储空间（比如堆内存）的分配
和释放，使得环形缓冲区的效果大打折扣。

}

framework(生产者/消费者模式：双缓冲区){
1. 主要使用在屏幕绘制相关的领域（主要是为了减少屏幕闪烁）。另外，在设备驱动和工控方面，双缓冲也经常被使用。
2. 侧重于并发方面的同步/互斥开销。

--- > 内存分配的开销和同步/互斥的开销
只有当同步或互斥的开销非常明显的时候，你才应该考虑双缓冲区的使用。否则的话，大伙儿还是老老实实用最基本、最简单的队列缓冲区吧。

双缓冲区的原理 ---- 空间换时间
---------------------------------------
    所谓"双缓冲区"，故名思义就是要有俩缓冲区（简称 A 和 B）。这俩缓冲区，总是一个用于生产者，另一个用于消费者。
当俩缓冲区都操作完，再进行一次切换（先前被生产者写入的转为消费者读出，先前消费者读取的转为生产者写入）。由于
生产者和消费者不会同时操作同一个缓冲区（不发生冲突），所以就不需要在读写每一个数据单元的时候都进行同步/互斥操作。

    生产者或消费者如果要操作某个缓冲区，必须先拥有对应的互斥锁。补充一句：要达到"不冲突"的效果，其实可以有
多种搞法，今天只是挑一个简单的来聊。

双缓冲区的几种状态
---------------------------------------
◇俩缓冲区都在使用的状态（并发读写）
◇单个缓冲区空闲的状态
◇缓冲区的切换

可能的并发问题
---------------------------------------
◇死锁的问题

应用场景
---------------------------------------
◇用于并发线程
◇用于并发进程
}

framework(AOP){
    面向代理编程（英语：Agent-oriented programming，缩写为AOP），一种编程范型，它的观点主要集中于软件代理人
（Software agent）之上。它是由面向对象程序设计所发展出来。相对于面向对象程序设计以对象为主，代理人导向程序
设计则是以代理人为核心。代理人可以被视为是对象的进一步抽象化。
}

framework(CBSE){
    基于组件的软件工程（Component-based software engineering，简称CBSE）或基于组件的开发（Component-Based 
Development，简称CBD）是一种软件开发范型。它是现今软件复用理论实用化的研究热点，在组件对象模型的支持下，
通过复用已有的构件，软件开发者可以'即插即用'地快速构造应用软件。这样不仅可以节省时间和经费，提高工作效率，
而且可以产生更加规范、更加可靠的应用软件。
1. 基于流
2. 管道
}
framework(Declarative programming){
1. 声明式编程（英语：Declarative programming）是一种编程范型，与命令式编程相对立。它描述目标的性质，
   让电脑明白目标，而非流程。声明式编程不用告诉电脑问题领域，从而避免随之而来的副作用。而指令式编程
   则需要用算法来明确的指出每一步该怎么做。
2. 声明式编程通常被看做是形式逻辑的理论，把计算看做推导。声明式编程因大幅简化了并行计算的编写难度，
   自2009起备受关注。
3. 声明式语言包括数据库查询语言（SQL，XQuery），正则表达式，逻辑编程，函数式编程和组态管理系统。
4. 声明式编程通过函数、推论规则或项重写（term-rewriting）规则，来描述变量之间的关系。它的语言运行器
   （编译器或解释器）采用了一个固定的算法，以从这些关系产生结果。
约束式编程[]
领域专属语言[]
函数式编程[]
逻辑式编程[]

}
