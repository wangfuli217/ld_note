https://github.com/limingth/NCCL/blob/master/Unit-1/README.md # 进一步学习C语言
https://github.com/limingth/akaedu-c-learning  # 进一步学习C语言
https://github.com/limingth/free-programming-books/blob/master/free-programming-books-zh.md # book

https://github.com/codekissyoung/markdown # C 笔记
https://zh.cppreference.com/w/c           # C 语言参考手册

http://ace.acejoy.com/thread-3915-1-1.html # UNIX编程思想 有点教条化
https://github.com/zyxstar/md_note/blob/master/docs/Language/C/C%E8%AF%AD%E8%A8%80(Uplooking).md

https://www.ilovepdf.com/
https://github.com/zyxstar/md_note/blob/master/docs/Language/C/%E5%BE%81%E6%9C%8DC%E6%8C%87%E9%92%88(%E5%89%8D%E6%A1%A5%E5%92%8C%E5%BC%A5).md

C的注释工具? 
https://www.sanfoundry.com/1000-data-structure-questions-answers/ # Data Structures Using C 1000 Problems and Solutions
https://www.includehelp.com/c-programming-examples-solved-c-programs.aspx # C Problems and Solutions
https://github.com/greg-js/arch-wiki-md-repo # arch的中文wiki

https://github.com/JackChan1999/CPP_Design_Pattern

http://www.oualline.com/practical.programmer/index.html 

http://c.biancheng.net/view/411.html            # 语言中文网
https://cloud.tencent.com/developer/doc/1023    # 腾讯C语言手册

https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md # Chinese
http://c-faq-chn.sourceforge.net/ccfaq/ccfaq.html # go

https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md  # English

http://iso-9899.info/wiki/Main_Page  # iso-9899 C 主页

http://www.yolinux.com/TUTORIALS/LinuxTutorialSoftwareDevelopment.html # 软件开发纵览
http://ikeyword.net/tecmint.com # total 综合

http://www.lysator.liu.se/c/
# c-faq
http://www.eskimo.com/~scs/src/
ftp://ftp.funet.fi/pub/languages/C-style/              C编码格式

https://github.com/saradhix/c_pointer_faqs             C指针FAQ

https://www.cnblogs.com/life2refuel/tag/c/default.html 很多注释的库

https://github.com/fanghaos/AlgorithmAndCpp #CPP笔记 

https://en.wikipedia.org/wiki/Category:C_libraries    wiki C库
https://wiki.sei.cmu.edu/confluence/display/c         C安全编码手册
NLDBG=2    ./myprogram
NLCB=debug ./myprogram

https://libraries.io/                    # 库
https://github.com/quanpan302/phd        # 

https://github.com/wangzhione/cdesignbook # C修炼

https://github.com/linhua55/lkl_study # linux kernel library

https://github.com/hellokangning/TechNote # Note
https://github.com/lianzeng/personalNoteBook # Note
https://github.com/xierongz/Expert-C-Programming # note

http://www.softpanorama.org/Lang/c.shtml # 一页胜千页
https://github.com/lefticus/cppbestpractices # 同志仍需努力
https://github.com/lefticus/CppCoreGuidelines/ # 同志仍需努力
https://github.com/fffaraz/awesome-cpp # 一页胜千页

https://github.com/swenson/sort # 排序算法集合
https://github.com/ryanmjacobs/c # c shell编译执行

https://github.com/xgfone/snippet # 字言碎片

https://github.com/LexHsu/Summary                # note
https://github.com/twq0076262/the-c-study-notes  # note

https://github.com/wcybxzj/shang # 乱七八糟东东西西

免费下载地址在 http://linux.linuxidc.com/
用户名与密码都是www.linuxidc.com

"_清晰的是专业的；不清晰的则是外行的_" -- Sir Ernest Gowers

定义1：能长期稳定地编写出高质量程序的程序员称为编程老手。
定义2：能长期稳定地编写出高难度、高质量程序的程序员称为编程高手。
根据上述定义，马上得到第一推论：我既不是高手也算不上是老手

如果你需要真正的运行 时常量, 使用预定义宏 #define (或enum)。

一：熟悉基本的语法规则，保证代码可以通过编译器的编译；
二：可以以编译器的眼光看待代码，知道它所做的工作；
三：养成自己的语法习惯，可以熟练的解决问题。

变量命名: 类型+功能 类型作为前缀或者类型作为后缀
          功能+功能 功能_下划线_功能
          类型+类型 类型_下划线_类型
          类型+操作 类型_操作
C(语言标准库){
所谓标准库，即非第三方库，并且是平台无关的
C++在包含C语言的标准库头文件的时候，习惯做法是去掉.h后缀，并且加上c前缀。 如：
//C语言中
#include <stdlib.h>
#include <string.h>
//C++中包含C语言标准库头文件
#include <cstdlib>
#include <cstring>
##数据类型 
size_t是为了提高程序可移植而定义在标准C中的，其实就是unsigned int。
ssize_t是Unix系统中定义的，表示signed size_t,实际可以理解为int。
}
book(){       https://github.com/MrBluyee/source
C 专家编程 ： https://github.com/xierongz/Expert-C-Programming/blob/master/README.txt
不要被标题中的"专家"吓到，这实际是一本很轻松的书籍，它既包含了大量 C 语言技术细节和编程技巧，也包含了很多有趣的编程轶事；
C 陷阱与缺陷 ：
书如其名，这本书介绍了 C 语言中常见的坑和一些稀奇古怪的编程"技巧"，不少刁钻的C语言面试题都源自这本小册子；
C 语言参考手册 ：
全面且权威的 C 语言参考手册，而且覆盖 C99，如果你打算成为 C 语言专家，那么这本书不可错过；
C 标准库 ：
给出了15个C标准库的设计思路，实现代码，以及测试代码，配合 C 程序设计语言 阅读效果更佳；
C 语言接口与实现 ：
这本书展示了如何使用C语言实现可复用的数据结构，其中包含大量 C 语言高级技巧，以至于 Amazon 上排行第一的评论是 "Probably the best advanced C book in existance"，而排行第二的评论则是 "By far the most advanced C book I read"。
}
lint    cstyle
splint  indent
    软件的经济规律显示，越是在开发周期的早期发现bug，修复它所付出的代价就越小。所以让lint
程序(如果是编译器就更好了)取代调试器执行寻找bug的额外工作是一笔很合算的投资。但通过调试器里
发现问题又比内部测试小组发现问题强。最坏的结果就是由顾客发现问题。

program(编程和开发){
1)编写程序只是软件开发中的一个流程，并非全部；
2)程序编写需要遵循一定的规范，远远不只是实现功能那么简单；
3)程序编写者是程序的第一负责人，要对自己的程序进行充分的自测，而非只要程序编写完成便万事大吉了。

定义程序的目标 -> 设计程序 -> 编写代码 -> 编译 -> 运行程序 -> 测试和调试程序 -> 修改和维护程序
设计程序: 选择一个合适的方式来表示信息可以更容易地设计程序和处理数据。
编译：  目标代码文件缺失启动代码。启动代码充当着程序和操作系统之间的接口
        目标代码还缺少库函数
链接器：把你编写的目标代码、系统的标准启动代码和库代码这3部分合并成一个文件。
        对于库代码，链接器只会把程序中要用到的库函数代码提取出来。
}

program(我必须在程序退出之前释放分配的所有内存吗？){
    你不必这样做。一个真正的操作系统毫无疑问会在程序退出的时候回收所有的 内存和其它资源。
然而, 有些个人电脑据称不能可靠地释放内存, 从  ANSI/ISO C 的角度来看这不过是一个 实现的质量问题。
}

lower(底层){
一.知道你的代码是如何工作的叫"底层"
二.知道你的代码是如何分配内存的叫"底层"
三.知道你的代码是如何执行的叫"底层"
四.计算机不变的结构叫"底层",除了计算机体系改写...
知道JVM如何工作的不叫底层,因为Jvm会变化的,今天学的底层,明天就是高层了,呵呵....
正是那些不变的底层,被国外公司包装成可变的"底层",小心被外国公司忽攸喔...
}

要避免做成聪明的设计，因为聪明的设计常常是难于理解的。应该做出简单且易于理解的设计。
设计软件有两种策略，一是做的非常的简单，以至于明显没有缺陷。
                    二是做的非常的复杂，以至于没有明显的缺陷。

style(格调){
第一，编程意识的"格调"；       # 在意识上严格要求自己，要提高自己的思维的水准。
第二，程序设计的"格调"；       # 分析软件需求，看哪些功能比较容易实现，哪些比较复杂。
      # 画出程序流程图及模块框架，并决定哪些模块可以采用现成的，哪些需要新开发，哪些功能要先实现，哪些可以后面再完成。
第三，代码编写及测试的"格调"。 #
1)程序布局是否工整；2)变量命名是否规范；3)代码注释是否简明；
4)函数封装是否合理；5)程序接口是否恰当；6)实现方法是否正确；

一、表达
  1.写清楚
  2.保守使用临时变量
  3.明白无歧义
  4.不要自己造所有的工具
  5.确保判断测试条件清楚易读
二、控制结构
  1.先用你顺手的高级语言写一遍程序，这时可以看清楚算法并作相应的调试，程序正确之后，再翻译成你编译器所处理的语言
  2.子例程和函数，把代码分成可独立管理的小段
  3.规划数据结构的时候要像规划控制流一样小心，尝试找到可以起到简化程序作用的数据表示形式

三、程序结构
  1.编写和维护大型程序唯一的方法是把它分解成一组函数、子例程和过程
  2.每一个模块应该只处理问题的一个方面，否则的话，模块就会变得大而复杂
  3.相对于其他模块，一个模块应该隐藏它如何完成工作的细节，否则这个模块就无法独立于其他模块来进行修改

四、输入和输出
  1.校验输入数据的合法于合理性
  2.保证输入数据不会违背程序的限制
  3.利用文件结束符号或结束标志来终止输入，不要让用户去计数
  4.识别输入错误并尽可能地恢复，不要一碰到错误就停止，也不要忽略错误了事
  5.在输入和输出时采用助记符，使得输入数据易于正确地准备，在输出时同时也將输入和默认值输出，并使得输出数据不言自明
  6.將I/O局限起来，不要散布在整个程序中。將处理文件结束和缓冲区等细节隐藏在函数中
  7.保证程序的结构反映出其所处理的数据

五、常见错误
  1.使用变量之前要初始化
  2.小心"差一"错误，确保在正确的次数下完成循环，对于等式的比较判断，确保有正确的分支处理
  3.检查数组的下标不要越界
  4.避免循环有多个出口
  5.检查程序的内部边界
  6.预防性编程，搞清楚哪些事可能出问题，并且添加代码以检查
  7.不要用浮点数来做累计，不要期望浮点小数数值遵循你熟悉的算术法则，他们不适用

六、效率和测试工具
  1.假如程序是错误的，再快也没用。
  2.让代码言简意赅。撰写时不要惦记着它运行得快。过早优化是万恶之源
  3.别为每个优化细节去操心，让编译器去照顾这些
  4.用心于算法，而非代码细节。记住，数据结构对算法的实现方式有显著影响
  5.在构造程序时放置测试语句，在决定"增效"之前先执行测试。在程序演进过程中，可將测试语句留下来随时运用

七、文档
  1.如果程序不正确，文档写得再好都没有用
  2.如果文档和代码不一致，那程序就没什么价值
  3.要在最大程度上使得代码本身就是自己的文档，如果做不到，重写代码而不是做文档的补充。好的代码需要的注释量要比坏的代码少
  4.注释提供的信息应该是从代码上无法获得的
  5.帮助记忆的变量名和标签，以及强调逻辑结构的代码布局，都有助于程序自身的文档化
}

Style(C/C++){ C的回归.md
    美好的愿景：C++ 程序员指望可以建立强大的可复用的抽象层，面对世界上一切的具体应用。
低效的抽象编程模型，可能在两年之后你会注意到有些抽象效果不怎么样，但是所有代码已经依赖
于围绕它设计的'漂亮'对象模型了，如果不重写应用程序，就无法改正。
    使用 C++ 的程序员不断的强调复用性，却不断的需要重写代码。
    如果你想用更花哨的语言，C++绝对是最糟糕的选择。如果想要真正的高级特性，那就选择
有垃圾回收或者好的系统集成的，而不是既缺乏C的简约(sparseness)又缺乏C的直接而且没有
重要概念的高层绑定(high-level bindings to important concepts)的东西。

    进步是计算机软件工程和编程语言设计艺术逐步发展的重要原因。这也是为什么c++语言令人失望的原因：
c++对c语言中存在的一些最基本问题没有什么改进，而c++对c语言最重要的扩展(类)却是建立在脆弱的c类型模型上。
}

C(compiler){ ExpertC
编译器设计者的金科玉律：效率(几乎)就是一切：
运行效率(代码的运行速度)和编译效率(生成可执行代码的速度)。
有很多编译优化措施会延长编译时间，但却能缩短运行时间，还有一些有优化措施(如清除无用代码和忽略
运行时检查等)既能缩短编译时间，又能减少运行时间，同时还能减少内存的使用量。

C语言排斥强类型，允许程序员需要时可以在不同类型的对象间赋值。

根据编译器设计者的思路而发展形成的语言特性有：
1. 数组下标从0而不是从1开始
2. C语言的基本类型直接与底层硬件相对应
3. auto关键字显然是摆设。(auto是默认的变量内存分配方式，只对创建符号表入口的编译器设计者有意义)
4. 表达式中的数组名可以看做指针。(数组和指针并不是在任何情况下都是等效的)
5. float被自动扩展为double
6. 不许嵌套函数(函数内部包含另一个函数的定义) - 简化了编译器，并稍微提高了C程序的运行时组织结构.
7. register关键字：这一设计可以说是一个失误，如果让编译器在使用各个变量时自动处理寄存器的分配工作。
   显然比一经声明就把这类变量在生命期内始终保留在寄存器里要好。使用register关键字，简化了编译器，
   却把包袱丢给程序员。
C语言对直接由硬件支持的底层操作的强调，带来了极高的效率和移植性，反过来也帮助Unix获得了额巨大的成功。
}
C(标识符的3个属性){
1 标识符的3个属性: 作用域, 命名空间和链接类型. 　　
[*] C 语言有4种作用域(标识符声明的有效区域): 函数, 文件, 块和原型. (第4种类型 仅仅存在于函数原型声明的参数列表中)
[*] C 语言有4种命名空间: 行标(label, 即 goto 的目的地), 标签(tag, 结构, 联 合和枚举名称), 结构联合成员, 
    以及标准所谓的其它"普通标识符"(函数, 变量, 类 型定义名称和枚举常量). 另一个名称集(虽然标准并没有称其为
    "命名空间")包括了预 处理宏. 这些宏在编译器开始考虑上述4种命名空间之前就会被扩展. 　　
[*] 标准定义了3中"链接类型": 外部链接, 内部链接, 无链接. 对我们来说, 外部链接 就是指全部变量, 非静态变量和函数
    (在所有的源文件中有效); 内部链接就是指限于 文件作用域内的静态函数和变量; 而"无链接"则是指局部变量及类型定义
    (typedef) 名称和枚举常量.
}
C(C标准标识符标准建议规则){
 ANSI/ISO C标准标识符标准建议规则: 
 规则1: 所有下划线大头, 后跟一个大写字母或另一个下划线的标识符永远保留(所有的作 用域, 所有的命名空间). 
 规则2: 所有以下划线打头的标识符作为文件作用域的普通标识符(函数, 变量, 类型定义 和枚举常量)保留(为编译器后续实现保留). 
 规则3: 被包含的标准头文件中的宏名称的所有用法保留. 
 规则4: 标准中所有具有外部链接属性的标识符(即函数名)永远保留用作外部链接标识符. 
 规则5: 在标准头文件中定义的类型定义和标签名称, 如果对应的头文件被包含, 则在(同 一个命名空间中的)文件作用域内保留.
        (事实上, 标准声称"所有作用于文件作用域的标识符", 但规则4没有包含标识符只剩下类型定义和标签名称了.)
}
C(precompiler){ ExpertC
1. 字符串替换 -- 通常用于为常量提供一个符号名
2. 头文件包含 -- 一般性的声明可以被分离到头文件中，并且可以被许多源文件使用。
3. 通用代码模板的扩展， -- 宏(marco)在连续几个调用中所接收的类型可以不同(宏的实际参数只是按照原样输出)
宏最好只用于命名常量，并为一些适当的结构提供简便的记法。宏名应该大写，这样便很容易与函数调用区分开来。
注意: 千万不要使用C预处理器来修改语言的基础结果，因为这样一来C语言就不再是C语言了。

注意: 空格会对扩展的结果造成很大的影响
    #define a(y) a_expanded(y)
    a(x);
被扩展为
    a_expanded(x);
而
    #define a (y) a_expanded (y)
    a(x);
则被扩展为
(y) a_expanded (y) (x)
}
prototype(declare){ ExpertC
    ANSI C中最重要的新特性就是'原型'，这种特性取自C++。原型是函数声明的扩展，这样不仅
函数名和返回类型已知，所有的形参类型也是一致的。这就允许编译器在参数的使用和声明之间检查
一致性。
    把'原型'称为是'带有所有参数的函数名'是不够充分的，它应该被称作'函数签名'或者像Ada
那样称作'函数说明'。 函数签名--function signiture; 函数说明--function specification.

    每个实参都应该具有自己的类型，这样它的值就可以赋值给与所对应的形参类型对象。 -- 参数传递过程类似于赋值
    要使上述的赋值形式合法，必须满足下列条件之一：
    两个操作数都是指向有限定符或无限定符的相容类型指针，左边指针所指向的类型必须具有右边指针所指向
类型的全部限定符。

const限定符是修饰指针所指向的类型，而不是指针本身。
const char **也是一个没有限定符的指针类型。它的类型是"指向有const限定符的char类型的指针的指针"
由于char **和const char **都是没有限定符的指针类型，但它们所指向的类型不一样，前者指向char *后者指向 const char *，因此它们是不相容的。
const最有用的用法就是用它限定函数的形参，这样该函数将不会修改实参指针所指的数据，但其它函数却可能会修改它。

注意: const限定符是修饰指针所指向的类型，而不是指针本身。
注意: const和*通常只用于数组形式的参数中模拟传值调用
}
C(安静的改变){ ExpertC
1. 当执行算术运算时，操作数的类型如果不同，就会发生转换。
  数据类型一般朝着浮点精度更高、长度更长的方向装换，
  整型数如果转换为signed不会丢失信息，就转换为signed，否则转换为unsigned。
  
对无符号类型的建议 
1.尽量不要使用无符号类型，以免增加不必要的复杂性。 
2.尽量使用有符号类型，这样在设计升级混合类型的复杂细节时，不必担心如trainin3.c那样的边界情况(如-1被翻译为非常大的正数) 
3.只有在使用位段和二进制掩码时，才可以用无符号数。
  应该在表达式中使用强制类型转换，使操作数均为有符号数或无符号数，避免编译器来选择结果的类型。 

容易混淆的const 
关键字const并不能把变量变成常量。只是表示这个变量不能被赋值，即只读的，但不能防止通过程序的内部(甚至是外部)的方法来修改这个值。 
const最有用之处是限定函数的形参，使得函数不会修改实参指针所指的数据，但其他函数却可能修改它。 
training4.c揭示了const存在的问题，limitp是一个指向常量类型的指针，其不能用于修改整型数，但这个指针本身的值却可以改变(即可以指向不同的地址)， 这回造成一些罕见的错误。 
建议： const和*的组合通常只用于在数组形式的参数中模拟传值调用。
}
C(多个不确定副作用){
int i=7; printf("%d\n", i++ * i++);
是指在同一个表达式中使用导致同一对象修改两 次或修改以后又被引用的自增, 自减和赋值操作符的任何组合。
如果你不知道它们在不同的机器上如何实现, 这样的无知可能恰恰会有助于保护你。
}

C(语句块){
语句块代表了一个作用域，在语句块内声明的自动变量超出范围后立即被释放。除了用 "{ ... }"  表示一个常规语句块外，
还可以直接用于复杂的赋值操作，这在宏中经常使用。
int i = ({ char a = 'a'; a++; a; });
printf("%d\n", i);
最后一个表达式被当做语句块的返回值。相对应的宏版本如下。
#define test() ({  \
    char _a = 'a'; \
    _a++;          \
    _a; })
int i = test();
printf("%d\n", i);
在宏里使用变量通常会添加下划线前缀，以避免展开后跟上层语句块的同名变量冲突。
}
Style(C){ 1. C有C的规则.md 
    C 没有构造函数，没有析构函数。没有虚表，没有继承。const 的使用不那么严格，强制转换不那么忌讳。
没有模板，宏是强有力的工具。简单而统一的 ABI ，冗长但是有效的命名规则。
    C 的潜规则里，所有数据结构的最佳默认值是 0 ，这样可以方便的使用 calloc 或者 memset 。
在C++中，我们把传统的C风格的struct叫做POD(Plain Old Data)对象。一般来说，POD对象应该满足如下特性。

C语言中的6中语句：
1. 标号语句
2. 符合语句
3. 表达式语句
4. 选择语句
5. 迭代语句
6. 跳转语句

#include 是一种"拷贝-粘贴"的操作
头文件帮助编译器把你的程序正确地组合在一起。
\n 转义序列 %d 占位符 标识符identifier也就是一个变量、函数或其他实体的名称。
函数原型(prototype) == 函数声明(function declaration)

它很棒，但符合标准吗? ExpertC
1. 不可移植的代码(unportable code): 
  由编译器定义的(implementation-defined)，不同的编译器可能不同
    例如：当整型数向右移动时，要不要扩展符号位。
  未确定(unspecified) -- 在某些正确情况下的做法，标准并未明确规定应该怎么做。
    例如：参数求值的顺序
2. 坏代码(bad code)
  未定义的(undefined),在某些不正确情况下的做法，但标准未规定怎么做
    例如：当一个有符号整数溢出时该采取什么行动
  约束条件(a constraint) -- 这是一个必须遵守的限制或者要求。如果你不遵守，那么你的程序
的行为就会变成上面所说的未定义的。
  标准规定编译器只有在违反语法和约束条件的情况下才能产生错误信息。这意味着所有不属于
约束条件的语义规则你都可以不遵循，而且由于这种行为属于未定义行为，编译器可以采取任何行为
甚至不必通知你。
    例如：%操作符的操作数必须属于整形。所以，在非整数数据上使用%操作符可能会引发一条错误信息。
    
    例如：所有在C语言标准头文件中声明的标识符均保留，所以不能声明一个叫做malloc()的函数，因为
在标准头文件里已经有一个函数以此为名。但由于这个规定不是约束条件，因此可以违反它。

1. 可移植的代码(protable code) ExpertC
  1.1. 严格遵循标准的(strictly-conforming)
  只使用已确定的特性。
  不突破任何由编译器实现的限制
  不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出。
  1.2.遵循标准的(conforming),可以依赖一些某种编译器特有的不可移植的特性，但移植时需对其进行修改。
2. 编译限制
  在函数定义中形参数量的上限至少可以达到31个。
  在函数调用时实参数量的上限至少可以达到31个。
  在一条源代码行里至少可以有509个字符
  在表达式中至少可以支持32层嵌套的括号
  long int的最大之不得小于2147483647
  等等
}
C(区分0 的四种面孔){
1. 整形0。作为一个int整形，占据32位的空间。二进制表示为：00000000 00000000 00000000 00000000
2. 空指针。指针与整形占据的空间是一样的。0在指针的可以替换为NULL，现在使用nullptr。
int *pValue = 0; # 合法
int *pValue = 1; # 不合法，不可以表示地址
作为指针类型使用0时，推荐下面的使用方法：
float *pNum = NULL; # 赋值
if(pNum == NULL);   # 比较
3. 字符串结束标志'\0'
这里作为一个字符，占8位。二进制表示:00000000
    char sHello[12] = {"Hello c/c++"};
    if(sHello[11] == '\0') # 比较作为结束符使用
4. 逻辑FALSE/false
false/true是c++语言新增的关键字。FALSE/TRUE是通过#define定义的宏。
    #ifndef FALSE
    #define FALSE 0
    #endif
    #ifndef TRUE
    #define TRUE 1
    #endif
换言之，FALSE/TRUE是int类型，false/true是bool类型，两者是不一样的。
}

# 处理: 参数类型不指定 和 参数个数不指定 问题. 实现方式 序列list
va_start(){ man stdarg 和 va_copy 迭代器：crosstool\cheatsheet\ops_doc-mstaer\Service\IO处理参考说明.sh
va_list ap：定义一个指向个数可变的参数列表指针；
# 定义 ap
void va_start(va_list ap, last);：使参数列表指针ap指向函数参数列表中的第一个可选参数，
# 初始化 ap，依赖参数列表中 last 参数
  说明：last是位于第一个可选参数之前的固定参数，(或者说，最后一个固定参数； ... 之前的一个参数)，
  函数参数列表中参数在内存中的顺序与函数声明时的顺序是一致的。如果有xxx_va函数的声明是
  void va_test(char a, char b, char c, ...)，则它的固定参数依次是a,b,c，最后一个固定参数last为c，
  因此就是va_start(ap, c)。
  注意：last 不能是 函数类型 寄存器类型和数组类型。
type va_arg(va_list ap, type):  返回参数列表中指针ap所指的参数，返回类型为type，并使指针ap指向参数列表中下一个参数。
# 使用ap, 依赖 type 指定当前类型
void va_end(va_list ap):  清空参数列表，并置参数指针ap无效。
# 释放ap
  说明：指针ap被置无效后，可以通过调用va_start()、va_copy()恢复ap。
  每次调用va_start() / va_copy()后，必须得有相应的va_end()与之匹配。
  参数指针可以在参数列表中随意地来回移动，但必须在va_start() … va_end()之内。
void va_copy(va_list dest, va_list src):  dest，src的类型都是va_list，va_copy()用于复制参数列表指针，将dest初始化为src。
# 拷贝ap, 依赖src来自 va_start，va_copy

va_start va_arg va_copy va_end 依赖 va_list 类型；
va_arg va_copy va_end 依赖 va_start。
va_start 和 va_copy 依赖va_end给参数结尾

va_list aq = ap;              # 有些系统
va_list aq; *aq = *ap;        # 用些系统
va_list aq; va_copy(aq, ap)   # C99 才定义该函数 (统一系统之间差异)

#include <stdarg.h>
/*  指定自变量数量 */
void test(int count, ...){
    va_list args;
    va_start(args, count);
    for((int i = 0; i < count; i++)){
        int value = va_arg(args, int);
        printf("%d\n", value);
    }
    va_end(args);
}
/*  以 NULL  为结束标记 */
void test2(const char* s, ...){
    printf("%s\n", s);
    va_list args;
    va_start(args, s);
    char* value;
    do{
        value = va_arg(args, char*);
        if (value) printf("%s\n", value);
    }
    while (value != NULL);
    va_end(args);
}
/*  直接将 va_list 传递个其他可选自变量函数 */
void test3(const char* format, ...){
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}
int main(int argc, char* argv[]){
    test(3, 11, 22, 33);
    test2("hello", "aa", "bb", "cc", "dd", NULL);
    test3("%s, %d\n", "hello, world!", 1234);
    return EXIT_SUCCESS;
}
}
Style(C90 C99 C11){ ISO-C标准的名称为 ISO-IEC 9899-1990 | GB/T 15272-94
gcc -ansi -std=c90 
gcc -std=iso9899:1990 
gcc -std=gnu90
<float.h> <limits.h> <stddef.h> <stdarg.h>

gcc -std=c99
gcc -std=iso9899:1990 
gcc -std=gnu99
<stdbool.h>  <stdint.h> 

gcc -std=c11
gcc -std=iso9899:2011
<stdalign.h>  <stdnoreturn.h> 
}
Style(C90 C99 C11){  protoize 和 unprotoize ansi2knr 标准之间转换 cextract
1. 美国国家标准协会(ANSI)于1983年开发了一套新标准，并于1989年正式公布，该标准定义了C语言和C标准库。
2. 国际标准化组织于1990年采用了这套C标准(ISO C)
3. ISO C和ANSI C是完全相同的标准。

C精神：C90  -> 简单高效,最小意外原则
1. 信任程序员 # (Trust the programmer)
2. 不要妨碍程序员做需要做的事 # (Don't prevent the programmer from doing what needs to be done)
3. 保持语言精练简单 # (Keep the language small and simple)
4. 提供一种方法执行一项操作 # (Provide only way to do an operation)
5. 让程序运行更快，即使不能保证其可移植性 # (Make it fast, even if it is not guaranteed to be portable)
6. 不应该通过修改语言来处理某个特定平台所存在的限制
总结: 在 C 的设计中，优先考虑的是：
1. 如何才能简单地实现编译器(而不是让使用 C 的人们能够简单地编程)
2. 如何才能让程序员写出能够生成高效率执行代码的程序(而不是考虑优化编译器，使编译器生成高效率的执行代码)
C特性:
1. C语言采用编译模式而不是解释模式，引入类型系统，每个变量在使用前必须先声明。
2. C语言排斥强类型，C语言允许程序员需要时可以在不同类型的对象间赋值。
3. C语言的基本数据类型直接与底层硬件对应。
4. 表达式中的数组名可以看作是指针，但是数组和指针不是在任何情况下都是等效的。
5. register关键字简化了编译器，却把包袱丢给了程序员。
6. C语言是一种相当低级的语言，但是的类型体系仍然略显抽象。语言本省并没有精确定义基本类型的大小和表示法。
在最后一点上,标准委员会的用意是:作为实现,应该针对目标计算机定义最合适的某特定操作,而不是加强一个抽象,统一的定义.

C精神：C99
1. 支持国际化编程
2. 调整现有实践致力于解决明显的缺陷
3. 为适应科学和工程项目中的关键数值计算，提高C的适应性，让C比Fortran更有竞争力
C精神：C11 --> 处于对当前编程安全的担忧
不应要求服务小型机市场的供应商支持其目标环境中用不到特性。 -- 提供可选项支持

C90 增加:
1. ANSI C 把函数原型作为函数声明的一部分，原型的形式，其两者也有了很大的变化
2. ANSI C 增加了 enum, const, volatile, signed, void等关键字;弃掉了K&R C中的entry等关键字
3. 相邻字符串的面值会被自动连接在一起
4. 寻常算数转换(usual arithmetic conversation)
   4.1 无符号保留(unsigned preserving)原则，即当一个无符号类型与int或更小的整型混合使用时，结果类型是无符号类型。
   4.2 ANSI C 采用的是值保留(value preserving)原则，即当执行算数运算时，如果类型不同，就会发生转换。
       数据类型朝着浮点精度更高、长度更长的方向转换，
       整形数如果转换为signed不会丢失信息，就转换为signed，否则转换为unsigned -- 即包括整型升级和寻常算数转换
5. 符号粘贴(token-pasting)
6. 三字母词(trigraph)，即用3个字符表示一个单独的字符，如两字母词\t表示"tab"， 三字母词??<表示"开放的花括号"
7. ANSI C中有几个追加的功能：
		>结构体的一次赋值
		>将结构体作为函数返回值传递
		>将结构体作为函数返回值返回
		>auto变量的初始化
>但是C语言还是不能做到对数组进行整合利用，因为C语言的数组是const修饰符

C99 增加：
1. 变量声明可以放代码块的任何地方。ANSI C 规定变量的声明要全部写在函数语句的最前面，否则就会报编译错误。现在不需要这样写了，哪里需要使用变量，在哪里直接声明使用即可；
2. 源程序每行最大支持4095个字节。这个貌似足够用了，没有什么程序能复杂到一行程序有4KB个字符；
3. 支持//单行注释。ANSI C使用/**/没有C++的//注释方便，所以 C99 新标准借鉴过来了，也开始支持这种注释方式；
4. 标准库新增了一些头文件：如 stdbool.h、complex.h、stdarg.h、fenv.h 等。
   大家在 C 语言中经常返回的 true、false，其实这也是 C++ 里面定义的 bool 类型。
5. 增强了预处理功能。例如： 
   宏支持取可变参数 #define Macro(...) __VA_ARGS__ 
   使用宏的时候，允许省略参数，被省略的参数会被扩展成空串。
6. 支持 long long, long double _Complex, float _Complex 等类型
7. 支持不定长的数组，即数组长度可以在运行时决定，比如利用变量作为数组长度。声明时使用int a[var] 的形式。
   不过考虑到效率和实现，不定长数组不能用在全局，或 struct 与 union 里。
8. 复合字面量：初始化结构的时候允许对特定的元素赋值，形式为： 
   struct test{int a[3]，b;} foo[] = { [0].a = {1}, [1].a = 2 }; 
   struct test{int a, b, c, d;} foo = { .a = 1, .c = 3, 4, .b = 5 }; // 3,4 是对 .c,.d 赋值的
   int* i = &(int){ 123 };                              //  整型变量, 指针
   int* x = (int[]){ 1, 2, 3, 4 };                      //  数组, 指针
   struct data_t* data = &(struct data_t){ .x = 123 };  //  结构, 指针
   func(123, &(struct data_t){ .x = 123 });             //  函数参数, 结构指针参数
   如果是静态或全局变量，那么初始化列表必须是编译期常量。
   
9. 格式化字符串中，利用 \u 支持 unicode 的字符。
10. printf scanf 的格式化串增加了对 long long int 类型的支持。
11. 除了已有的 __line__ __file__ 以外，增加了 __func__ 得到当前的函数名。
12. 取消了函数返回类型默认为 int 的规定。

C99新增的头文件和库
    <complex.h> 支持复数算法
    <fenv.h> 给出对浮点状态标记和浮点环境的其他方面的访问
    <inttypes.h> 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数
    <iso646.h> 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏
    <stdbool.h> 支持布尔数据类型类型。定义宏bool，以便兼容于C++
    <stdint.h> 定义标准的、可移植的整型类型集合。该文件包含在<inttypes.h>中
    <tgmath.h> 定义一般类型的浮点宏
    <wchar.h> 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数
    <wctype.h> 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数

如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。
放宽的转换限制
    限制　　　　　　　　　　　　　C89标准　　C99标准
    数据块的嵌套层数　　　　　　　15　　　　　127
    条件语句的嵌套层数　　　　　　8　　　　　 63
    内部标识符中的有效字符个数　　31　　　　　63
    外部标识符中的有效字符个数　　6　　　　　　31
    结构或联合中的成员个数　　　　127　　　　1023
    函数调用中的参数个数　　　　　31　　　　　127
    
不再支持隐含式的int规则
　　删除了隐含式函数声明
　　对返回值的约束
　　　　C99中,非空类型函数必须使用带返回值的return语句.
　　扩展的整数类型
　　　　扩展类型 含义
　　　　int16_t 整数长度为精确16位
　　　　int_least16_t 整数长度为至少16位
　　　　int_fast32_t 最稳固的整数类型,其长度为至少32位
　　　　intmax_t 最大整数类型
　　　　uintmax_t 最大无符号整数类型
　　对整数类型提升规则的改进
　　　　C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型.
　　　　C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char
等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型.

long long int
　　C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64
- 1）。long long int能够支持的整数长度为64位。


C语言标准
    某些构造随编译器和硬件的实现而变化, 这一直是 C 语言的一个特点。这种有意的不严格规定可以
让编译器生成效率更高的代码, 而不必让所有 程序为了不合理的情况承担额外的负担。因此, 标准只是
把现存的实践整理成文。
    运行时检查与C语言的设计理念相违背。按照C语言的理念，程序员应该知道自己正在干什么，而且
保证自己的所作所为是正确的。对进行解引用操作的指针进行有效性检查大概是唯一的例外。

编程语言标准可以看作是语言使用者和编译器实现者之间的协议。
协议的 一部分是编译器实现者同意提供, 用户可以使用的功能。
而其它部分则包 括用户同意遵守, 编译器实现者认为会被最受的规则。
只要双方都恪守 自己的保证, 程序就可以正确运行。如果任何一方违背它的诺言, 则结果肯定失败。
}
C99(){
— restricted character set support via digraphs and <iso646.h>
(originally specified in AMD1)
— wide character library support in <wchar.h> and <wctype.h>
(originally specified in AMD1)
— more precise aliasing rules via effective type
— restricted pointers
— variable-length arrays
— flexible array members
—static and type qualifiers in parameter array declarators
— complex (and imaginary) support in <complex.h>
— type-generic math macros in <tgmath.h>
— thelong long int type and library functions
— increased minimum translation limits
— additional floating-point characteristics in<float.h>
— remove implicit int
— reliable integer division
— universal character names (\uand \U)
— extended identifiers
— hexadecimal floating-point constants and%aand %A printf/scanf
conversion specifiers
— compound literals
— designated initializers
—//comments
— extended integer types and library functions in<inttypes.h> and
<stdint.h>
— remove implicit function declaration
— preprocessor arithmetic done inintmax_t /uintmax_t
— mixed declarations and code
— new block scopes for selection and iteration statements
— integer constant type rules
— integer promotion rules
— vararg macros
— thevscanf family of functions in <stdio.h> and <wchar.h>
— additional math library functions in<math.h>
— floating-point environment access in<fenv.h>
— IEC 60559 (also known as IEC 559 or IEEE arithmetic) support
— trailing comma allowed inenum declaration
—%lf conversion specifier allowed in printf
— inline functions
— thesnprintf family of functions in <stdio.h>
— boolean type in<stdbool.h>
— idempotent type qualifiers
— empty macro arguments
— new struct type compatibility rules (tag compatibility)
— additional predefined macro names
—_Pragmapreprocessing operator
— standard pragmas
—__func_ _ predefined identifier
—VA_COPYmacro
— additionalstrftime conversion specifiers
— LIA compatibility annex
— deprecateungetc at the beginning of a binary file
— remove deprecation of aliased array parameters
}
C(typeof){
使用 GCC 扩展 typeof 可以获知参数的类型。
#define test(x) ({      \
    typeof(x) _x = (x); \
    _x += 1;            \
    _x;                 \
})
int main(int argc, char* argv[]){
    float f = 0.5F;
    float f2 = test(f);
    printf("%f\n", f2);
    return EXIT_SUCCESS;
}
}
Style(面向对象){
面向对象编程是一门哲学，它通过对语言建模来适应问题，而不是对问题建模以适应语言。
}
Style(模块){
由于需要高内聚 ，低耦合，模块通常 属于一下几类：
1. 数据池。数据池是一些相关的变量或者常量的集合，在C语言中，这类模块通常只是一个头文件。在 C语言库中，<float.h>和<limits.h>都属于这类模块。
2. 库。库是一组相关函数的集合。例如 <string.h>就是字符串处理函数库的接口。
3. 抽象对象。一个抽象对象是指对于隐藏的数据结构进行操作的一组函数的集合。
4. 抽象数据模块。
}

Philosophy(数据结构){
数据 是能被计算机识别、存储和处理的 信息载体
数据结构由 数据的值 与 数据之间的关系 (也是数值的一种) 所构成
数据结构 本质就是 数据表示 (数据的结构)， 算法 本质就是 数据处理 (数据的加工方法)
数据的 表示 和 处理 构成了计算系统的所有内涵

数据的逻辑结构：
    集合
    线性
    树形
    图状
    Tip: 其中的线性结构中又包含了 表、栈、队
    
数据的存储结构：
    顺序
    链式
    索引
    散列
数据结构的基础运算：
对于元素(个体)的操作：增加、删除、修改、查询
对于集合(群体)的操作：创建、排序、注销
}
Philosophy(模块化 数据结构 算法 阻塞点  正则表达式的发现){
1. 模块化是程序可维护性、可靠性的基础，实现模块化的原则是业务数据划分：即将数据根据业务
   划分成不同数据集和根据存储特性(内存、磁盘、内存磁盘映射、内存文件系统)划分不同数据集，
   最终通过API接口实现业务协议和模块交互要求。
   1.1 模块化依赖抽象而不是过程；模块与模块之间依赖过程和协议。
     模块与模块之间是通过接口交互
     每个模块是一个单独的编译单元
     做到这两点，每个模块都可以通过简单的一行命令独立出来提供单一的服务
   1.2 持续模块化
      当发现解决一个bug的时候，需要改很多地方代码，那么就是你需要立刻做模块化的信号
   1.3 配置模块化
      除了代码层面做好模块化，在打工程里面有很多配置文件，哪些配置文件需要放到模块里面，
      哪些需要放到根目录的，都需要仔细思量，最终达到的效果就是当要更换一个模块或者模块
      单独抽出来做服务的时候，花的成本最少
      
2. 模块化是程序迭代和重构的基础，通过调整数据结构实现模块内部代码的迭代、重构、模块进一步分解。
   数据结构在提高了程序可读性、减少代码冗余基础上，进一步增加了代码的可维护性和可读性。
3. 有了好的数据结构就可能有好的算法，在简单数据结构和简单算法达不到性能要求时，才会进一步要求
   更复杂的算法。在需要复杂算法的时候需要思考当前数据结构是否合理。
4. 进程通过增加阻塞点减少了CPU资源的消耗；进程通过发现阻塞点增加的数据吞吐量；
   通过数据是否存在和状态是否有效 驱动或控制阻塞点闭合。阻塞点是系统性的问题，
   在Linux中Socket IO、Pipe IO、条件变量、文件锁、信号、进程间通信都可以成为进程阻塞点实现方式。
5. 正则表达式发现：通常二进制协议方式更容易发现正则，文本协议方式比较难容易发现正则；
   一方面文本协议方式可以依赖二进制协议头，用以控制协议长度和其他特征内容
   一方面文本协议方式常常使用不可见模式进行字段划分，例如空格(SPACE)、Tab(\t)以及换行(\n) 回车(\r)
   文本协议还有json,xml,csv等格式化方式。
   总之有协议的地方就能实现数据驱动甚至数据表驱动进程执行。
}
    数据是程序的核心。代码的实现总是和数据结构紧密相关。在设计程序之前，精心地选择一个合适的数据结构是非常重要的。
因为，代码总是围绕着数据而展开。
    数据驱动编程需要将代码和数据结构划分清楚。在改变程序逻辑的时候，只要改变数据结构中的数据，而不需要改变代码。
    数据驱动编程不同于面向对象编程。数据驱动编程中，数据不仅是对象的状态，而且还定义了程序的控制流。
    数据驱动编程首先关注的是编写尽可能少的代码。而面向对象编程首先关注的是封装。
重要的原则： 
1、将重复性的代码改为表实现。用表来替换冗长的类似的代码。 
2、用数据结构来构造代码。 
这两条原则的目的是减少代码量。减少代码量的目的是减少BUG。

https://www.gitbook.com/book/cautonwong/hfp/details  # hexing firmware platform
  需要的是面向对象的设计观，不需要编程语言是面对对象的。即面向对象是思想，不是程序语言
  面向对象，是让不同的数据展现出共同的操作方式，适合成组的处理，也适合屏蔽对象实现的差异
  
  通过数据结构 -> 通过数据结构隔离差异

用最佳结构，写简单代码
数据驱动程序与函数指针的结合：把知识叠入数据以求逻辑质朴而健壮
    数据驱动编程的核心出发点是相对于程序逻辑，人类更擅长于处理数据。
    数据比程序逻辑更容易驾驭，所以我们应该尽可能的将设计的复杂度从程序代码转移至数据。

## 谷歌大牛的 C 语言编程建议和技巧
Philosophy(编程时应有清晰的哲学思维，而不是给予硬性规则){ http://www.lysator.liu.se/c/pikestyle.html
在任何情况下，都不应该照搬我所说的方式进行编程；要用你认为最好的编程方式来尝试完成程序。请一以贯之而且毫不留情的这么做。
1. 排版问题 -> 良好的版式布局能让程序的细节更容易理解
  排版规范一向都是至关重要的。当然，众所周知最有用的是缩进，千万别刻意修饰程序，例如要保持注释简洁明了。
通过程序整齐一致地说出想表达的。

2. 变量命名 ->  一致性很重要，这是所有易读程序的共同特征
            ->  对于变量名称，长度并不是名称的价值所在，清晰的表达才是。
  指针也需要合理的符号。np 仅仅只是作为指针 nodepointer 的助记符。如果一贯都遵从命名规范，那么很容易就能推断出 np 表示"节点指针"。
  在循环中数组的索引使用i更好，使用index或者elementnumber这样的名字更像是在说一种类型，同时也隐藏了它计数的本质。
  最后，我倾向于「最小长度」但「最大信息量」的命名，并让上下文补齐其余部分。
  全局变量在使用时很少有上下文帮助理解，那么它们的命名相对而言更需要令人易懂。
            ->  避免在变量的名字中使用大写字母，它看起来又笨又不舒服，像是糟糕的排版。
    
3. 指针的使用 -> 指针是一个很强大的表达工具，能帮助我们将事情说的更清楚
  指针只是一个单独的参数；但在接收的子程序中必须认为数组和索引是一体的。
  作为一条规则，如果你发现你的代码在描述一个数据结构的相关元素时有一些相似的、复杂的表达的话，恰当的使用指针能让事情变得简单。
  用过于复杂的表达方法引用一个对象很容易犯错，直接使用对象的地址有时候来的更简单.
    parent->link[i].type    -> lp->type
    parent->link[++i].type  -> (++lp)->type.

4. 过程名称
  过程名称应该表明它们是做什么的，函数名称应该表明它们返回什么。函数通常在像 if 这样的表达式使用，因此可读性要好。
    if(checksize(x))
  是没有太大帮助的，因为不能推断出 checksize 错误时返回 true，还是非错误时返回。相反
    if(validsize(x))
  使这点能清晰表达，并且在常规使用中将来也不大可能出错。

5. 注释
  1. 假如代码清晰，并且使用了规范的类型名称和变量名称，应该从代码本身就可以理解。
  2. 编译器不能检查注释，因此不能保证准确，特别是代码修改过以后。误导性的注释会非常令人困惑。
  3. 排版问题：注释会使代码变得杂乱。
如果代码需要靠注释来说明，那最好的方法是重写代码，以便能更容易地理解。这就把我们带到了复杂度。

4. 复杂度
规则1：你没法预测程序会将时间花费在哪儿。瓶颈会发生在意想不到的地方，除非你已经测试并定位了瓶颈，否则不要尝试去猜测和优化它。
规则2：测量。在测量之前不要为了提升速度优化代码。即使是在测量之后，也不要随意优化除非其中的一部分代码已经压倒其余代码。
规则3：当n很小的时候好的代码是很慢的，并且n通常都很小。好的算法都有一个很大的常量，除非你知道n很快就会变得很大，否则还是不要使用好的代码(即使n变大了，也先使用 规则2)。
规则4：好的算法比简单的算法更容易产生bug，并且它也更难去实现。尽可能使用简单的算法和简单的数据结构。
规则5：数据主导。如果你选择了正确的数据结构并且组织得很好，算法几乎总是不言而喻的。 数据结构，而不是算法，是编程的核心。
 
5. 数据编程
如果选择了适当的数据结构并把一切都组织得很有条理性，算法总是不言而喻的。编程的核心是数据结构，而不是算法。
    分析表是典型例子，它通过一种解析固定、简单代码段的形式，对编程语言的语法进行编码。
    有限状态机特别适合这种处理形式，但是几乎任何涉及到对构建数据驱动算法有益的程序，
都是将某些抽象数据类型的输入"解析"成序列，序列会由一些独立"动作"构成。
 
6. 函数指针 -> 面相对象编程的核心是清晰使用函数指针
    指针指向的程序必须遵守一些标准协议，函数实现的只是完成业务，复杂度是分散的。

    数据驱动程序不同于面向对象设计中的数据："数据驱动编程中，数据不但表示了某个对象的状态，实际上还定义了程序的流程；
OO看重的是封装，而数据驱动编程看重的是编写尽可能少的代码。"

数据驱动程序与函数指针的结合，变成了一种表现令人惊讶的工作方法。根据我的经验，这种方法经常会产生惊喜的结果。

数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法。——Rob Pike
程序员束手无策。。。。。只有跳脱代码，直起腰，仔细思考数据才是最好的行动。表达式编程的精髓。——Fred Brooks
数据比程序逻辑更易驾驭。尽可能把设计的复杂度从代码转移至数据是个好实践。——《unix编程艺术》作者。

1. 控制复杂度
2. 代码流程从命令式变成了 声明式
   关注数据，从命令式编程范式，转向了声明式编程范式。人类并不擅长流程处理，命令调用，更擅长处理数据，和理解声明式的，有语义的调用。
3. 隔离变化
4. 机制和策略的分离
}  

Philosophy(排错){
寻找熟悉的模式
检查最近的改动
不要两次犯同样的错误
现在排除，而不是以后
取得堆栈轨迹
键入前仔细读一读
把你的代码解释给别人
把错误弄成可以重现的
分而治之
研究错误的计数特性
显示输出，使搜索局部化
写自检测代码
写记录文件
画一个图
写记录文件
保留记录
}
Philosophy(测试){
测试代码的边界情况
测试前条件和后条件
使用断言
做防御性程序设计
检查错误的返回值
以递增方式做测试
首先测试最简单的部分
弄清所期望的输出
检验那些应当保持的特征
比较相互独立的实现
度量测试的覆盖面
自动回归测试
建立自包容测试
}

Philosophy(如何给变量取个简短且无歧义的名字){
[长命名存在的问题]
1. 长的类名会使开发者不易声明该类型的变量。
2. 长的方法命名会使它变得晦涩难懂.
3. 长的变量命名不利于代码重用，导致过长的方法链。

[选择一个好的命名]
命名有两个目标：
1. 清晰：你要知道该命名与什么有关
2. 精确：你要知道该命名与什么无关
---------------------------------------
1. 命名中无需含有表示变量或参数类型的单词
所以将类型说明加入到变量名中是多余的. 我们应该舍弃匈牙利命名法，如下：
// 不好的:                                      | // 改进:
String nameString;                              | String name;
DockableModelessWindow dockableModelessWindow;  | DockableModelessWindow window;

2. 特别是对于集合来说，最好使用名词的复数形式来描述其内容, 而不是使用名词的单数形式来描述. 
   如果开发者更在乎集合中存储的内容, 那么变量命名应当反映这一点。
// 不好的:                               | // 改进:
List<DateTime> holidayDateList;          | List<DateTime> holidays;
Map<Employee, Role> employeeRoleHashMap; | Map<Employee, Role> employeeRoles;
3. 这一点也同样适用于方法的命名。方法名不需要描述它的参数及参数的类型–参数列表已经说明了这些。
// 不好的:                                   | // 改进:
mergeTableCells(List<TableCell> cells)       | merge(List<TableCell> cells)
sortEventsUsingComparator(List<Event> events,| sort(List<Event> events, Comparator<Event> comparator)
    Comparator<Event> comparator)            | 
---------------------------------------
1. 省略命名中不是用来消除歧义的单词
    命名只是一个标识符：只是告诉你该变量是在哪定义的。并不是用来告诉阅读者所有他们想知道的
有关这个对象的详细信息。这是定义应该做的事情的。 命名只是让你找到他的定义。
// 不好的:                            | // 改进:
finalBattleMostDangerousBossMonster;  | boss;
weaklingFirstEncounterMonster;        | firstMonster;

---------------------------------------
1. 省略命名中可以从上下文获取的单词
// Bad:                                | // Better:
class AnnualHolidaySale {              | class AnnualHolidaySale {
  int _annualSaleRebate;               |   int _rebate;
  void promoteHolidaySale() { ... }    |   void promote() { ... }
}                                      | }
实际上, 一个命名嵌套的层次越多, 它就有更多的相关的上下文，也就更简短。
换句话说，一个变量的作用域越小，命名就越短。
---------------------------------------
1. 省略命名中无任何含义的单词
    实际上，有一些词语并没有实际意义，只是一些套话。比如：data, state, amount, value, manager, 
engine, object, entity和instance。
    一个好的命名能够在阅读者的脑海中描画出一幅图画。而将某变量命名为"manager"并不能向读者传达
任何有关该变量是做什么的信息. 它是用来做绩效评估的吗? 它是管理加薪的吗?
    在命名时可以问一下自己，把这个单词去掉含义是不是不变？如果是，那就果断把它剔除吧~~
// 好吃的比利时华夫饼
class DeliciousBelgianWaffleObject {
  void garnishDeliciousBelgianWaffleWithStrawberryList(
      List<Strawberry> strawberryList) { ... }
}
==> 首先，通过参数列表我们可以知道方法是用来处理一个strawberry的列表，所以可以在方法命名中去掉：
class DeliciousBelgianWaffleObject {
    void garnishDeliciousBelgianWaffle(
        List<Strawberry> strawberries) { ... }
}
==> 除非程序中还包含不好吃的比利时华夫饼或者其他国家的华夫饼，不然我们可以将这些无用的形容词去掉：
class WaffleObject {
  void garnishWaffle(List<Strawberry> strawberries) { ... }
}
==> 方法是包含在WaffleObject类中的，所以方法名中无需Waffle的说明：
class WaffleObject {
  void garnish(List<Strawberry> strawberries) { ... }
}
==> 很明显它是一个对象，任何事物都是一个对象，这也就是传说中的"面向对象"的含义，所以命名中无需带有Object
class Waffle {
  void garnish(List<Strawberry> strawberries) { ... }
}

}

readable(表面层次的改进){
1. 程序员之间的互相尊重体现在他所写的代码中。他们对工作的尊重也体现在那里。
表面层次上的改进 # 命名、注释以及审美——可以用于代码库每一行的小提示。
简化循环和逻辑   # 在程序中定义循环、逻辑和变量，从而使得代码更容易理解。
重新组织你的代码 # 在更高层次上组织大的代码块以及在功能层次上解决问题的方法。
精选话题         # 把"易于理解"的思想应用于测试以及大数据结构代码的例子。

2. 代码应当易于理解
可读性基本定理
2.1 关键思想
    代码的写法应当使别人理解它所需的时间最小化。
    当我们说"理解"时，我们对这个词有个很高的标准。如果有人真的完全理解了你的代码，他就应该能改动它、找出缺陷并且明白它是如何与你代码的其他部分交互的。
2.2 总是越小越好吗
    因此尽管减少代码行数是一个好目标，但把理解代码所需的时间最小化是一个更好的目标。
    
3. 表面层次的改进 # 选择好的名字、写好的注释以及把代码整洁地写成更好的格式。
3.1 把信息装到名字里  # 无论是命名变量、函数还是类，都可以使用很多相同的原则。
def GetPage(url): ...
    "get"这个词没有表达出很多信息。这个方法是从本地的缓存中得到一个页面，还是从数据库中，或者从互联网中？
如果是从互联网中，更专业的名字可以是FetchPage()或者DownloadPage()。

class BinaryTree
{ int Size();
...
};
    你期望Size()方法返回什么呢？树的高度，节点数，还是树在内存中所占的空间？问题是Size()没有承载很多信息。
更专业的词可以是Height()、NumNodes()或者MemoryBytes()。

class Thread { void Stop(); ... };
    Stop()这个名字还可以，但根据它到底做什么，可能会有更专业的名字。例如，你可以叫它Kill()，如果这是一个
重量级操作，不能恢复。或者你可以叫它Pause()，如果有方法让它Resume()。
send # deliver、dispatch、announce、distribute、route
find # search、extract、locate、recover
start # launch、create、begin、open
make # create、set up、build、generate、compose、add、new

# 避免像tmp和retval这样泛泛的名字
    使用像tmp、retval和foo这样的名字往往是"我想不出名字"的托辞。与其使用这样空洞的名字，不如挑一个
能描述这个实体的值或者目的的名字。
1. retval这个名字没有包含很多信息。用一个描述该变量的值的名字来代替它。
2. tmp这个名字只应用于短期存在且临时性为其主要存在因素的变量。
3. 如果你要使用像tmp、it或者retval这样空泛的名字，那么你要有个好的理由。
# 如何实现
1. 使用专业的单词——例如，不用Get，而用Fetch或者Download可能会更好，这由上下文决定。
2. 避免空泛的名字，像tmp和retval，除非使用它们有特殊的理由。
3. 使用具体的名字来更细致地描述事物——Server Can Start()这个名字就比CanListenOnPort更不清楚。
4. 给变量名带上重要的细节——例如，在值为毫秒的变量后面加上_ms，或者在还需要转义的，未处理的变量前面加上raw_。
5. 为作用域大的名字采用更长的名字——不要用让人费解的一个或两个字母的名字来命名在几屏之间都可见的变量。对于只存在于几行之间的变量用短一点的名字更好。
6. 有目的地使用大小写、下划线等——例如，你可以在类成员和局部变量后面加上"_"来区分它们。
# 如何实现
1. 命名极限最清楚的方式是在要限制的东西前加上max_或者min_。
2. 推荐用first和last来表示包含的范围
3. 推荐用begin和end来表示包含/排除范围
4. 当为布尔值命名时，使用is和has这样的词来明确表示它是个布尔值，避免使用反义的词(例如disable_ssl)。
5. 要小心用户对特定词的期望。例如，用户会期望get()或者size()是轻量的方法。
# 总结：
1. 选择专业的词。  # 关键思想：清晰和精确比装可爱好 1. 为名字附带更多信息 2. 名字应该有多长
2. 避免泛泛的名字(或者说要知道什么时候使用它)。
3. 用具体的名字代替抽象的名字。
4. 使用前缀或后缀来给名字附带更多信息。
5. 决定名字的长度。
6. 利用名字的格式来表达含义

3.2 布局 # 关键思想 一致的风格比"正确"的风格更重要。
1. 使用一致的布局，让读者很快就习惯这种风格。
2. 让相似的代码看上去相似。
3. 把相关的代码行分组，形成代码块。

3.3 记录你的思想
标记 通常的意义
1. TODO：我还没有处理的事情
2. FIXME：已知的无法运行的代码
3. HACK：对一个问题不得不采用的比较粗糙的解决方案
4. XXX：危险！这里有重要的问题

3.4 注释
请注意我们把写注释这件事拆成了几个简单的步骤：
1. 不管你心里想什么，先把它写下来。
2. 读一下这段注释，看看有没有什么地方可以改进。
3. 不断改进。
}
readable(把控制流变得易读){
条件语句中参数的顺序
1. 比较的左侧 "被问询的"表达式，它的值更倾向于不断变化
2. 比较的右侧 用来做比较的表达式，它的值更倾向于常量
?:条件表达式(又名"三目运算符")

关键思想
相对于追求最小化代码行数，一个更好的度量方法是最小化人们理解它所需的时间。
1. 默认情况下都用if/else。三目运算符?:只有在最简单的情况下使用。
2. 避免do/while循环
3. 最小化嵌套
4. 用做解释的变量
    拆分表达式最简单的方法就是引入一个额外的变量，让它来表示一个小一点的子表达式。
这个额外的变量有时叫做"解释变量"，因为它可以帮助解释子表达式的含义。

变量与可读性
1. 变量越多，就越难全部跟踪它们的动向。       # 减少变量，即那些妨碍的变量。
2. 变量的作用域越大，就需要跟踪它的动向越久。 # 缩小变量的作用域
3. 变量改变得越频繁，就越难以跟踪它的当前值。 # 操作一个变量的地方越多，越难确定它的当前值。

}
Philosophy(如何设计一套很差劲的API){
1. 函数名太短(故意省略个别字母， # trsnss
2. 太长(iOS/Mac编程)， # makingNamesMuchTooLongToBePractical
3. 或用同义词弄晕程序员(EmptyActivity与BlankActivity有啥区别)。  # Using synonyms
4. 过度复杂，      # Overcomplimification (easy things made hard!)
5. 不向后兼容等。  # Annoyance the 5.1beta3 – Version incompatibility
}

Philosophy(修复每个 bug 后都要问这三个问题){
Bug 只是表象，只是症状，修复后还要探究更深层的原因。
1. 我在其他地方犯了同样的错误吗？
2. 修了这个 bug 会引起什么连锁反应、会按下葫芦浮起瓢吗？
3. 怎样预防这种 bug 再次出现？
}
Philosophy(现代化编程){
    现代化编程技术都是关于流程和实际工具的，而不是它们之上的表层。
我不在乎你是否使用 Eclipse 或 Emacs，这和你如何现代化毫不相关。
何谓现代化？
1. 要包容，别随便嘲笑别人用的语言、工具；
   如果你嘲弄使用 Atom 文本编辑器、Visual Studio 或者 Emacs 编程的人，
   那你就不是社会化的。你需要尽可能的包容，否则就会付出代价。
2. 强制代码风格，如 go fmt；
    Go 语言有自己的格式化工具
3. 方便的依赖管理、单元测试；持续集成；版本控制。
    像 Rust、Go、Swift 这样的编程语言有自己的程序包管理系统
    像 Rust、Go、Swift 这样的编程语言有自己的程序包管理系统
    像 Rust、Go、Swift 这样的编程语言，在一开始就支持单元测试。
    持续集成
    版本控制
}

OOP(C语言实现继承的方法1){
struct device_t 
{
  enum device_class_t device_class;
  struct driver_t    *device_driver;
}

struct uart_device_t
{
  struct device_t     parent;
  //私有成员
}

struct  block_device_t 
{
  struct device_t     parent;
  //块设备的私有成员
}
1. 将基类作为子类的第一个成员，通过"组合"实现继承。 在linux kernel中充分使用此方式。
2. 基于此继承体系，对于一些接受struct device_t 指针形参的接口，就可以直接把上述的子类实例 
   struct uart_device_t* dev; 作为实参传进去(当然，这里需要指针强转一次(struct uart_device_t*)dev)。 
   这里就是OOP中"is a"的public继承关系，子类对象可以直接作为父类对象使用。 系统内部的核心API(数量很少)
   只是面向父类编程，无需关心具体的实例到底属于什么类型的子类，扩展性尚佳。
}
OOP(C语言实现继承的方法2){
struct device_t 
{
  enum device_class_t  device_class;
  struct driver_t    *device_driver;
  void            *private_data;//各设备私有成员
}
多态

struct driver_t
{
    struct device_t *(*init)(struct device_file_t *);
    uint16(*read)(struct device_t *, uint8 *, uint16);
    uint16(*write)(struct device_t *, uint8 *, uint16);
    uint16(*ioctl)(struct device_t *, void *);
};
}
C(中文输出问题){中文输出问题
1. 源代码文件UTF-8，输出控制台GBK
#include <stdio.h> /* 源代码默认UTF-8 */
#include <stdlib.h> /* system() 函数头文件 */
int main() {
    system("chcp 65001"); /* windows下的控制台编码UTF-8/65001，默认GBK/936 */
    int var1 = 1;
    char *str1 = "中文";
    printf("变量var1的值 %d，内存地址 %p\n", var1, &var1); /* 不修改控制台编码则此处乱码 */
    printf("变量str1的值 %s，内存地址 %p\n", str1, &str1);
    return 0;
}
/* 输出：变量var1的值 1，内存地址 000000000062FE4C    变量str1的值 中文，内存地址 000000000062FE40 */
------
#include <stdio.h>
#include <locale.h>
#include <wchar.h>
int main(void) {
    setlocale(LC_CTYPE, ""); /* 留空，从当前系统获得默认的环境编码 或 setlocale(LC_CTYPE, "chs") */
    wchar_t wstr[] = L"中文"; /* 宽字符，会做转换进入二进制文件 */
    wprintf(L"其他 %ls",wstr);
    return 0;
}
/* wchar_t：文件编码 -> Unicode(win:UTF-16/lin:UTF-32) -> wprintf转成本地编码输出 */
/* 输出：其他 中文 */





# 在 Linux  系统中，默认字符集是 UTF-8，可以⽤ wctomb  等函数进⾏转换。
# wchar_t 默认是 4  字节⻓度，⾜以容纳所有 UCS-4 Unicode  字符。
setlocale(LC_CTYPE, "en_US.UTF-8");
wchar_t wc = L'中';
char buf[100] = {};
int len = wctomb(buf, wc);
printf("%d\n", len);                             # 3
for ((int i = 0; i < len; i++)){
    printf("0x%02X ", (unsigned char)buf[i]);    # 0xE4 0xB8 0xAD
}

# 同样可以使⽤ L 前缀声明一个宽字符串。
setlocale(LC_CTYPE, "en_US.UTF-8");
wchar_t* ws = L"中国人";
printf("%ls\n", ws);                           # 中国人
char buf[255] = {};
size_t len = wcstombs(buf, ws, 255);
for((int i = 0; i < len; i++)){
    printf("0x%02X ", (unsigned char)buf[i]);  # 0xE4 0xB8 0xAD 0xE5 0x9B 0xBD 0xE4 0xBA 0xBA
}

# 和 char 字符串类型类似，wchar_t 字符串以⼀个 4  字节的 NULL 结束。
setlocale(LC_CTYPE, "en_US.UTF-8");
wchar_t ws[] = L"中国人";
printf("len %d, size %d\n", wcslen(ws), sizeof(ws)); # len 3, size 16
unsigned char* b = (unsigned char*)ws;
int len = sizeof(ws);
for ((int i = 0; i < len; i++)) {
    printf("%02X ", b[i]);    # 2D 4E 00 00 FD 56 00 00 BA 4E 00 00 00 00 00 00
}
}

link(C代码优化小贴士){
https://www.ezlippi.com/blog/2014/12/c-code-opt.html
}

link(一个合格的程序员应该读过哪些书){
https://www.ezlippi.com/blog/2014/07/qualified-programmer-should-read-what-books.html
}
C(define){
题目：请写一个宏定义 OPEN，替换 a = 1; b = 1; 这2条语句 
错误举例： 
#define OPEN { a = 1; b = 1; } 
#define CLOSE { a = 0; b = 0; } 
问题在于 OPEN 后面的分号，语法不能通过 
if (btn_is_down()) OPEN; else CLOSE; 
正确举例： 
#define OPEN do { a = 1; b = 1; } while (0)
}
C(ascii){
CR， LF， DEL 
0－127 可见部分 
0－0x20 空格之后...... 直到 0x7E(126) ~ 
'\11' 代表 八进制 ==9 
'\x11' 代表 16进制 ==17 
int a = 011, b = 0x11; 
printf("a = %d\n", a); 打印的是 9 
printf("b = %d\n", b); 打印的是 17

0x30 -> '0' 
0x41 -> 'A' 
0x61 -> 'a'
}
C(链接详解){
链接脚本 (ld --verbose) 默认链接脚本，需要得到 
第1个就是 .text 代码段的起始地址： 0x8048xxx 
第2个就是 .data 数据段的起始地址： 0x8049xxx 
第3个就是 读写 RO 页面：.text + .rodata + .plt RW 页面：.data + .bss + .got 
第4个就是 合并 .text : { *(.text) } .data : { *(.data) } 
第5个就是 程序的入口是从 _start 开始 ENTRY(_start)

静态库 
文件名 .a 
生成 gcc -c -> .o 
  ar rs (ranlib) -> .a 
    r：添加或创建 
    s：创建索引 
使用 gcc -lname -Lpath -Idir (-static) 
［库的搜索路径］ gcc -print-search-dir 
  gcc -static 静态链接 
  好处：如果是.a来参与链接，则只取出需要的部分来链接 
  
共享库 
文件名 .so 
生成 gcc -c -fPIC -> .o gcc -shared -> .so 
使用 gcc -lname -Lpath -Idir 
问题 找不到共享库，怎么办？ error while loading shared libraries: libstack.so: cannot open shared object file: No such file or directory 
解决： 1. 修改环境变量 export LD_LIBRARY_PATH= 
       2. 修改缓存文件(/etc/ld.so.cache) vi /etc/ld.so.conf + sudo ldconfig -v 
       3. 拷贝文件法 cp libxxx.so /usr/lib (/lib) 
       4. 写死文件法 gcc -o main -Wl,-rpath,/home/akaedu/... 
       
动态链接的过程 
.plt 段：Procedure Linkage Table 指令 
.got 段：Global Offset Table 数据 
/lib/ld-linux.so.2 动态加载器 + 链接器 

共享库的命名 
real name: libc-2.5.so (libc-2.8.90.so) 
真正库文件 soname: libc.so.6 
符号链接 linker name: libc.so 本质上是一段链接脚本

}
C(类型){
类型就是一组值以及在这些值上的一组操作。
变量的类型是在声明变量时确定的；表达式的类型是由表达式操作符的定义决定的。

C类型                                       [类型分类]   [类型分类]  [类型分类]
short, int, long, long long(有符号和无符号)  整数类型     算术类型   标量类型
char (有符号和无符号)                        ...  ...     ...  ...   ...  ...
_Bool                                        ...  ...     ...  ...   ...  ...
enum{...}                                    ...  ...     ...  ...   ...  ...
float,double,                                浮点类型     ...  ...   ...  ...
long double                                  ...  ...     ...  ...   ...  ...
float _Complex,                              ...  ...     ...  ...   ...  ...
double _Complex,                             ...  ...     ...  ...   ...  ...
long double _Complex,                        ...  ...     ...  ...   ...  ...
float _Imaginary                             ...  ...     ...  ...   ...  ...
double _Imaginary                            ...  ...     ...  ...   ...  ...
long double  _Imaginary                      ...  ...     ...  ...   ...  ...
T*                                                  指针类型         ...  ...
T[...]                                              数组类型         聚合类型
struct {...}                                        结构类型         ...  ...
union  {...}                                                         联合类型
T      (...)                                                         函数类型
void                                                                 void类型

}
C(存储类型){
1. 存储类型决定了所声明对象或函数的可见性和生命周期。
static   真正是"指定存储区间"的关键字，只有 static。 可是，当你在函数的外面使用 static 的时候，就是使用作用域来控制了，而不是使用存储期。
extern   使得在其他地方定义的外部变量可以在本地可见
auto     是默认的，所以没有显式指定的必要
typedef : 具有作用域的优点。(也就是说，typedef可以在一个函数或块内声明)。可以给编码带来便利才被归纳到存储类型修饰符中来的
register  给出编译器优化提示； register只对声明在块内的变量有效。

C程序的每个变量都具有3个性质。
  1. 存储期限  自动存储期限和静态存储期限。
  2. 作用域    块作用域和文本作用域。
  3. 链接     外部链接、内部链接和无链接。外部链接的变量可以被几个文件所共享，具有内部链接
           的变量只能属于单独一个文件，但是此文件中的几个函数可以共享这个变量。无链接的变量属于
           单独一个函数，而且不能被共享。
       
变量的默认存储期限、作用域和链接都依赖于变量声明的位置。
  1. 在块内部声明的变量具有自动存储期限、块作用域并且无链接。
  2. 在程序的最外层，任意外部声明的变量具有静态存储期限、文件作用域和外部链接。
}
C(类型限定符){
类型限定符。只有两种类型限定符： const 和volatile。声明可以指定一个限定符、两个都有或者一个也没有。
}
C(类型说明符){
类型说明符。关键字void、int 、double、float等。
}
C(复合字面量){   数组，结构体和联合体
    C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。
当使用复合赋值时，在括弧内指定类型，后跟由花括号围起来的初始化列表；
若类型为数组，则不能指定数组的大小建成的对象是未命名的。
例： double *fp = (double[]) {1.1, 2.2, 3.3};
    该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。

在C99中，可以使用复合字面量创建没有名字的数组，比如：
int total = sum((int []){3, 0, 1, 4, 5}, 5);
1.  复合字面量：初始化结构的时候允许对特定的元素赋值，形式为： 
    struct test{int a[3]，b;} foo[] = { [0].a = {1}, [1].a = 2 }; 
    struct test{int a, b, c, d;} foo = { .a = 1, .c = 3, 4, .b = 5 }; // 3,4 是对 .c,.d 赋值的
}
declare(声明和定义){
1. 声明和定义
    首先, 尽管一个全局变量或函数可以(在多个编译单元中)有多处声明, 但是定义却只能允许出现一次。
定义是分配空间并赋初值(如果有)的声明。
    最好的安排是在某个相关的.c文件中定义, 然后在头文件(.h)中进行外部声明,在需要使用的时候, 
只要包含对应的头文件即可。定义变量的.c文件也应该包含该头文件, 以便编译器检查定义和声明的一致性。
特别是：永远不要把外部函数的原型放到.c文件中。如果函数的定义发生改变，很容易忘记修改原型，
而错误的原型贻害无穷。

2. 声明的格式;
基本类型 生成基本类型的东西 
说明： 声明符--或者是一个简单标识符，或者如同*p, a[10], f()这样的符号；
说明被声明的变量是指向基本类型的指针、基本类型的数组或者返回基本类型的函数。 *;[];()都是声明符的一部分。

3. 同一个静态(static)函数或变量的所有声明都必须包含static存储类型吗？
    语言标准并没有严格规定这一点(最重要的是第一个声明必须包含static)，但是规则却比较复杂，
而且函数和数据对象的规定不太一致。(这个领域有很多历史变化)因此，最安全的做法是让static一致
地出现在所有的定义和声明中。

存储类型static； 类型定义typedef； extern范围限定；const类型限定

什么是声明，什么是定义。
定义：只能出现在一个地方   确定对象的类型并分配内存，用于创建新的对象。例：int my_array[100];
声明：可以多次出现         描述对象的类型，用于指代其他地方定义的对象(例如在其他文件里)。例：extern int my_array[];
注意: 声明不分配内存，只是描述其他地方创建的对象。

    extern 对象声明告诉编译器对象的类型和名字，对象的内存分配则在别处进行。由于并未在声明中
为数组分配内存，所以并不需要提供关于数组长度的信息。对于多维数组，需要提供除最左边一维之外
其他维度的长度--这就给编译器足够的信息产生相应的代码。

4. 在使用函数和变量之前声明它们并不是为了消除编译器告警，声明也为编译项目注入有用的秩序。
当项目中的声明安排得井然有序的时候，(类型)不匹配和其他的困难就可以更容易地避免。同时编译器
也更容易找到出现的错误。

5. 声明说明符分为以下3大类：
  存储类型 。存储类型一共有4种：auto、static、extern和register。在声明中最多可以出现一种存储类型。如果表示存储类型，则必须把它放置在声明中的首要位置。
  类型限定符。只有两种类型限定符： const 和volatile。声明可以指定一个限定符、两个都有或者一个也没有。
  类型说明符。关键字void、int 、double、float等。

6. 声明通常包括：
  声明结构、联合或枚举等用户自定义类型 (UDT) 。
  声明函数。
  声明并定义一个全局变量。
  声明一个外部变量。
  用typedef  为已有类型声明一个新名字。
如果声明函数时同时出现函数体，则此函数的声明同时也是定义。
如果声明对象时给此对象分配内存 (比如定义变量)，那么此对象声明的同时也是定义。
}

define(宏陷阱){
1. 不能忽视宏定义中的空格；　
2. 宏并不是函数；　
3. 宏并不是语句；　
4. 宏并不是类型定义。
}

const(使用实例){
准确来说 const 是只读的意思，而不是常量
const 初始目的是为了继承预编译指令的优点而消除它的缺点
Item      const     #define
速度      快           慢
内存      少           多
执行      编译过程中   编译过程前
类型      有类型       无类型(替换)
所属      变量(只读)   常量

const int a=1;
int const b=2; //前面两种方式相同
const int c; //如果在定义时不赋初值，后面将没有机会，因为它是只读的
int const array[5]={1,2,3,4,5};
const int brray[5]={1,2,3,4,5};
int x=1,y=2,z=3,u=4;
const int *p1=&x; //p1可变，*p1只读
int const *p2=&y; //p2可变，*p2只读
int *const p3=&z; //p3只读，*p3可变
const int *const p4=&u; //p4只读，*p4只读
//a=3; //error C2166: l-value specifies const object
//b=4; //error C2166: l-value specifies const object
//c=5; //error C2166: l-value specifies const object
//array[0]=6; //error C2166: l-value specifies const object
//brray[0]=6; //error C2166: l-value specifies const object
x=7; 
//*p1=7; //error C2166: l-value specifies const object
p1=&y;
y=8;
//*p2=8; //error C2166: l-value specifies const object
p2=&x;
z=9;
*p3=10;
//p3=&x; //error C2166: l-value specifies const object
u=11;
//*p4=12; //error C2166: l-value specifies const object
//p4=&x; //error C2166: l-value specifies const object
看起来有点混乱，不过这里有一个记忆和理解的方法：
先忽略类型名(编译器解析的时候也是忽略类型名)，我们看const离哪个近。"近水楼台先得月"，离谁近就修饰谁
判断时忽略括号中的类型
const (int) *p; //const修饰*p，*p是指针指向的对象，不可变
(int) const *p； //const修饰*p，*p是指针指向的对象，不可变
(int)*const p; //const修饰p，p不可变，p指向的对象可变
const (int) *const p; //前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变
}
const(define){
编译器处理方式不同
    宏定义在预处理阶段展开，const常量在编译运行阶段使用。
类型和安全检查不同
    宏定义没有类型，不做任何类型检查，仅仅是展开。
    const常量有具体的类型，在编译阶段会执行类型检查。
存储方式不同
    宏定义仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。
    const常量在内存中分配（即可以在堆中也可以在栈中）。
是否可调试
    const可调试，而宏定义不可以调试。
是否节省空间
    const可以节省空间，避免不必要的内存分配。
    只为const分配一次地址空间。const在运行时只有一份拷贝，而宏定义有多份拷贝。
    宏定义只做替换，不做计算，不做表达式求解
    宏定义编译时就替换了，程序运行时，并不分配内存。
}

typedef(define){
typedef为一种类型引入新的名字，而不是为变量分配空间。"宣称这个名字是指定类型的同义词"
一般情况下，typedef用于简洁地表示指向其他东西的指针。
场景：
1、数组、结构、指针以及函数的组合类型。
2、可移植类型。short,int ,long，在使用的时候直接在typedef中修改即可。

typedef: 1)可以让变量定义更清晰， 2)便于以后修改和移植，更灵活；
注：1.不要在一个typedef中放入几个声明器。
    2.千万不要把typedef嵌入到声明的中间部分。
总结：我们平常读源代码看到的奇怪的声明，应该就是利用的typedef。typedef可以用来简化定义，
    一般是涉及函数指针的声明才有简化声明的必要，假如是函数的话，只要声明一次。
    
typedef int x[10]和#define x int[10]的区别
1.可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做。
例：#define peach int
    unsigned int i;     /* 没问题 */
    typedef int banana;
    unsigned banana i;  /* 错误!非法 */
2.在连续几个变量的声明中，用typedef定义的类型能够保证声明中的所有变量均为同一种类型，
而#define定义的类型则无法保证。
例：#define int_ptr int *
    int_ptr chalk, cheese;
    经过宏扩展后，第二行变为：
    int *chalk, cheese;
这使得chalk和cheese称为不同的类型。

操作typedef的提示
    typedef应该用在：
1.数组、结构、指针以及函数的组合类型
2.可移植类型。
    当把代码移植到不同平台时，要选择正确的类型如short、int、long时，只要在typedef中进行修改。
3.typedef也可以为后面的强制类型转换提供一个简单的名字。

typedef接收作用域，可以在局部、函数和代码块内使用。
define 场合ifdef一起使用

C语言存在多种名字空间：
    标签名(label name)。
    标签(tag)：这个名字空间用于所有的结构体、枚举和联合。
    成员名：每个结构体或联合都有自身的名字空间。
    其他。
在同一个名字空间里，任何名字必须具有唯一性，但在不同的名字空间里可以存在相同的名字。
由于每个结构体或联合具有自己的名字空间，所以同一个名字可以出现在许多不同的结构内。

对于typedef struct baz {int baz;} baz; 即相当于 typedef struct baz {int baz;} baz_type;
1. typedef声明引入了baz_type作为struct baz {int baz;}的简写形式
2. struct baz xxxxx; 使用的是结构标签
3. baz yyyyy; 使用的是结构类型
}
function(extern){
1) 函数声明的时候extern可以省略,推荐封装库的时候不要省略
2) C中声明参数名可以省略,推荐不要省略,参数名能让人提高看懂这个接口的可能
3) 函数声明C中什么都不加,默认参数是 不确定,C++ 默认是 void.

extern:  默认修饰符，用于函数表⽰ "具有外部链接的标识符"，这类函数可用于任何程序文件。用于变量声明表示该变量在其他单元中定义。
}
inline(){
inline :  修饰符 inline  建议编译器将函数代码内联到调用处，但编译器可以主决定是否完成。通
常包含循环或递归函数不能被定义为 inline 函数。
static  inline :  内链接函数，在当前编译单元内内联。不过 -O0  时依然是 call 。
inline :  外连接函数，当前单元内联，外部单元为普通外连接函数 (头文件中不能添加 inline  关键字)。
附：inline  关键字只能⽤在函数定义处。
}
function(restrict){
这是很装逼的关键字用于编译器优化. 关键字restrict只用于限定指针；该关键字用于告知编译器，
所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；
这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。

extern void *mempcpy (void *__restrict __dest,
                      const void *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
}
function(retval返回不确定长度内容方法){
1.函数可以返回一个常量，或指向常量的指针。
2.使用全局声明的变量。
3.使用静态数组。
4.显式分配一些内存，保存返回值。
5.最好的解决方案就是要求调用者分配内存来保存函数的返回值。为了提高安全性，调用者应该同时指定缓冲区的大小。
}

pointer(指针类型){ 
1. 先有"指针类型"。然后有了"指针类型的变量"和"指针类型的值"。
使用 int 类型表示整数。因为 int 是"类型"，所以存在用于保存 int 型的变量，当然也存在 int 型的值。
指针类型同样如此，既存在指针类型的变量，也存在指针类型的值。
指针类型的值实际是指内存的地址。

2. 声明中的[]和表达式中的[]意义完全不同。表达式中的*和声明中的*的意义也是完全不同的。
编译器会帮我们记住指针指向什么样的类型

*(p + i) == *(i + p) == p[i] == i[p]

单目运算符*被称为解引用。
单目运算符&被称为地址运算符。
后置运算符[]被称为下标运算符。
通过指针访问结构体的成员的时候，会使用->运算符。
}

pointer(指针与自增){
共有五种搭配(不包括括号括住自增的情况)情况，可分为两类。 ##优先级 () > ++ > *
##后向自增 有两种：
    *p++
    (*p)++

j = *p++;
//等价于
j = *p;
p++;

j = (*p)++;
//等价于
j = *p;
(*p)++;

##前向自增 有三种：
    ++(*p)；
    ++*p;
    *++p;

++*p和++(*p)等价。
j = ++(*p);
//等价于
(*p)++;
j = *p;

j = *++p;
//等价于
++p;
j = *p;
}

 c deep.md
https://github.com/wilmosfang/blog/tree/33b967ef5bb93e7cb0a78c4f21a9ce0fcc505f76/_posts
pointer(函数指针){
1. 函数指针和指针函数
char *(*fun1)(char *p1,char *p2) # 见moosefs中的main.c中timeentry, chldentry内函数定义
char **fun2(char *p1,char *p2)
char *fun3(char *p1,char *p2)

第一条是定义一个函数指针，此函数返回值为一个字符型指针
第二条是定义一个函数，此函数返回值为一个字符型的二级指针
第三条是定义一个函数，此函数返回值为一个字符型的指针
Tip: 对于函数指针 char (*fun)(char *p1,char *p2) ，
    可以这么理解 char (*)(char *p1,char *p2) fun ，对于数组指针 char (*p)[5] 也可以这么理解 char (*)[5] p
char fun(char *p1,char *p2); //声明或定义函数
char (*pf)(char *p1,char *p2); //定义一个函数指针
pf=&fun; //给函数指针赋值，与函数绑定
(*pf)("xx","yy"); //使用指针来调用函数

一般用typedef声明一个函数指针的类型，然后将函数赋值给函数指针变量。它有两种声明方式： 
###1
typedef void (*handle_t)(int);
handle_t handle = foo;
###2
typedef void handle_t(int);
hanle_t* handle = foo;

2. *(int*)&p
函数指针与普通指针没什么差别，只是指向的内容不同而已
#include <stdio.h> 

void function(){
	printf("Call Function!\n");
}

void main(){
	void (*p)();
	*(int*)&p=(int)function;
	(*p)();
}
使用函数指针的好处在于，可以将实现同一功能的多个模块统一起来标识，这样一来更容易后期维护，系统结构更加清晰
便于分层设计，利于系统抽象，降低耦合度以及使接口与实现分开

3. (*(void(*)())0)()  # 南京林洋boot部分
void(*)() 函数指针类型
(void(*)())0 将0强制转换为函数指针类型
(*(void(*)())0) 取0地址开始的一段内存里面的内容
(*(void(*)())0)() 函数调用

4. 函数指针数组
这是在定义一个函数指针数组
char *(*pf[3])(char *p)
以下为用法

#include <stdio.h> 

char * fun1(char *p){
	printf("%s\n",p);
	return p;
}

char * fun2(char *p){
	printf("%s\n",p);
	return p;
}

char * fun3(char *p){
	printf("%s\n",p);
	return p;
}

void main(){
	char *(*pf[3])(char *p);

	pf[0]=fun1; //因为fun的值就是函数首地址
	pf[1]=&fun2;
	pf[2]=&fun3;

	pf[0]("fun1");
	pf[1]("fun2");
	pf[2]("fun3");
}

5. 函数指针数组的指针
这是在定义一个函数指针数组的指针
char *(*(*pf)[3])(char *p);
pf是一个指针，而非数组名
#include <stdio.h> 

char * fun1(char *p){
	printf("%s\n",p);
	return p;
}

char * fun2(char *p){
	printf("%s\n",p);
	return p;
}

char * fun3(char *p){
	printf("%s\n",p);
	return p;
}

void main(){
	char *(*a[3])(char *p); //a是一个数组名
	char *(*(*pf)[3])(char *p)=&a; //pf是一个指针


	a[0]=fun1;
	a[1]=&fun2;
	a[2]=&fun3;

	pf[0][0]("fun1");
	pf[0][1]("fun2");
	pf[0][2]("fun3");
} 

}
pointer(二级指针){
记录普通变量地址的指针叫做一级指针
二级指针可以记录一级指针的地址
二级指针声明的时候需要写两个*
	int num=0;
    int *p_num=&num;
    int **pp_num=&p_num;

二级指针变量名称前加**可以表示捆绑的
    普通变量存储区 		**pp_num=10;
二级指针变量名称前加*可以表示捆绑的		//一个* 抵一个p
    一级指针变量存储区   	*pp_num=NULL;
二级指针变量名称可以代表它自己的存储区


二级指针可以用来代表指针数组，但是不能代表二维数组
    二维数组名不占存储空间的

二级指针通常作为函数的形式参数使用，
    它可以让被调用函数修改调用函数的一级指针存储区内容
(就像一级指针做形参，就是为了让被调用函数修改调用函数的普通变量)
}
pointer(*p++自增p还是p所指向的变量?){
后缀++和--操作符本质上比前缀一目操作的优先级高, 因此*p++和*(p++)等价, 它自增p并返回p自增之前所指向的值。
要自增p指向的值, 使用(*p)++, 如果副作用的顺序无关紧要也可以使用++*p。
# 新手C程序员
char *dst, const char *src
int i;
for(i = 0; src[i] != '\0'; i++)
    dst[i] = src[i];
dst[i] = '\0';
# 地道C程序员
while(*dst++ = *src++) -> 将赋值、指针递增和测试赋值操作的结果合并成单一的赋值表达式
    ;
# 有经验的程序员
char *s = dst;
while((*dst++ = *src++) != '\0')
    ;
}

array(多维数组初始化){
实际上就是 "元素为数组" 的数组，注意元素是数组，并不是数组指针。
多维数组的第一个维度下标可以不指定。
int x[][2] ={
    { 1, 11 },
    { 2, 22 },
    { 3, 33 }
};
int col = 2, row = sizeof(x) / sizeof(int) / col;
for (int r = 0; r < row; r++){
    for (int c = 0; c < col; c++){
        printf("x[%d][%d] = %d\n", r, c, x[r][c]);
    }
}
# 多维数组的元素是连续排列的，这也是区别指针数组的一个重要特征。
int x[][2] ={
    { 1, 11 },
    { 2, 22 },
    { 3, 33 }
};
int len = sizeof(x) / sizeof(int);
int* p = (int*)x;
for (int i = 0; i < len; i++){
    printf("x[%d] = %d\n", i, p[i]);
}

# 我们可以初始化特定的元素
int x[][2] ={
    { 1, 11 },
    { 2, 22 },
    { 3, 33 },
    [4][1] = 100,
    { 6, 66 },
    [7] = { 9, 99 }
};
int col = 2, row = sizeof(x) / sizeof(int) / col;
for (int r = 0; r < row; r++){
    for (int c = 0; c < col; c++){
        printf("x[%d][%d] = %d\n", r, c, x[r][c]);
    }
}
}

array(多维数组传递){
/*  数组名默认指向第一元素指针，和 test2 一个意思 */
void test1(int len, int x[]){
    int i;
    for (i = 0; i < len; i++) {
        printf("x[%d] = %d; ", i, x[i]);
    }
    printf("\n");
}
/*  直接传递数组第一个元素指针 */
void test2(int len, int* x){
    for (int i = 0; i < len; i++) {
        printf("x[%d] = %d; ", i, *(x + i));
    }
    printf("\n");
}

/*  数组指针: 数组名默认指向第一个元素指针，&array 则是获得整个数组指针 */
void test3(int len, int(*x)[len]) {
    for (int i = 0; i < len; i++) {
        printf("x[%d] = %d; ", i, (*x)[i]);
    }
    printf("\n");
}
/*  多维数组: 数组名默认指向第一个元素指针，也即是 int(*)[] */
void test4(int r, int c, int y[][c]) {
    for (int a = 0; a < r; a++) {
        for (int b = 0; b < c; b++) {
            printf("y[%d][%d] = %d; ", a, b, y[a][b]);
        }
    }
    printf("\n");
}
/*  多维数组: 传递第一个元素的指针 */
void test5(int r, int c, int (*y)[c]){
    for (int a = 0; a < r; a++) {
        for (int b = 0; b < c; b++) {
            printf("y[%d][%d] = %d; ", a, b, (*y)[b]);
        }
        y++;
            }
    printf("\n");
}
/*  多维数组 */
void test6(int r, int c, int (*y)[][c]){
    for (int a = 0; a < r; a++) {
        for (int b = 0; b < c; b++) {
            printf("y[%d][%d] = %d; ", a, b, (*y)[a][b]);
        }
    }
    printf("\n");
}

/*  元素为指针的指针数组，相当于 test8 */
void test7(int count, char** s){
    for (int i = 0; i < count; i++) {
        printf("%s; ", *(s++));
    }
    printf("\n");
}
void test8(int count, char* s[count]){
    for (int i = 0; i < count; i++) {
        printf("%s; ", s[i]);
    }
    printf("\n");
}
/*  以 NULL  结尾的指针数组 */
void test9(int** x){
    int* p;
    while ((p = *x) != NULL) {
        printf("%d; ", *p);
        x++;
    }
    printf("\n");
}
int main(int argc, char* argv[]){
    int x[] = { 1, 2, 3 };
    int len = sizeof(x) / sizeof(int);
    test1(len, x);
    test2(len, x);
        test3(len, &x);
    int y[][2] ={
        {10, 11},
        {20, 21},
        {30, 31}
    };
    int a = sizeof(y) / (sizeof(int) * 2);
    int b = 2;
    test4(a, b, y);
    test5(a, b, y);
    test6(a, b, &y);
    char* s[] = { "aaa", "bbb", "ccc" };
    test7(sizeof(s) / sizeof(char*), s);
    test8(sizeof(s) / sizeof(char*), s);
    int* xx[] = { &(int){111}, &(int){222}, &(int){333}, NULL };
    test9(xx);
    return EXIT_SUCCESS;
}
}
pointer(array 数组指针和指针数组){
1. 数组指针
int (*p)[n];
p是一个指向整型一维数组的指针，p+1偏移n个整型数据的长度　　
数组指针只占有一个指针存储空间

注意: 派生出数组之后，再派生出指针，即为指向数组的指针
      表达式中，数组可以解读成指针，但这 不是"指向数组的指针"，而是"指向数据 初始元素 的指针"

    数组指针(也称行指针)定义 int (*p)[n]; ()优先级高，首先说明p是一个指针，指向一个
整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过
n个整型数据的长度。 如要将二维数组赋给一指针，应这样赋值：
    int a[3][4];
    int (*p)[4];    //该语句是定义一个数组指针，指向含4个元素的一维数组。
    p=a;            //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
    p++;            //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
所以数组指针也称指向一维数组的指针，亦称行指针。

2. 指针数组
int *p[n]
p[n]表示有n个元素的数组，int *指明了该数组为有n个指针元素的指针数组　　
指针数组占有多个指针存储空间

初始化1.
for(j=0;j<4;j++){
    pea[j] = (char *)malloc(10 * sizeof(char));
}
初始化2.
一次性的用malloc分配整个x * y个数据的数组：
(char *)malloc(row_size * column_size * sizeof(char));
然后，使用一个循环，用指针指向这块内存的各个区域。

    指针数组 定义 int *p[n]; []优先级高，先与p结合成为一个数组，再由int*说明这是
一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，
这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且
它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个
元素的值，a的首地址的值。 如要将二维数组赋给一指针数组:
    int *p[3];//这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
    int a[3][4];
    p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针,所以要分别赋值。
for(i=0;i<3;i++){
  p[i]=a[i];
}

3. 数组指针和指针数组在指向二维数组时，其引用是一样的，比如要表示数组中i行j列一个元素：
*(p[i]+j)
*(*(p+i)+j)
(*(p+i))[j]
p[i][j]

4. 如果想要把什么东西的类型强制转换为指向数组的指针，就不得不使用下面的语句来表示这个强制类型转换：
char (*j)[20];  /*j是一个指向数组的指针，组内右20个char元素。*/
j = (char (*)[20])malloc(20);

多维数组和数组指针组合形式的实参和形参对应关系
                      实参                   形参
数组的数组            char c[8][10];        char (*) [10]; 数组指针
指针数组              char *c[15];          char **c;        指针的指针
数组指针(行指针)    char (*c) [15];       char (*c) [15]; 不改变
指针的指针            char **c;             char **c;        不改变 
}
pointer(array 数组指针和指针数组){
int hoge[2][3]  数组的数组
                适用于两个数组长度都确定时
                0   1   2   4   5   6
                ┌───┬───┬───┬───┬───┬───┐
                │           │           │
                └───┴───┴───┴───┴───┴───┘


int (*hoge)[3]   指向数组 的指针
                 指针加一即前进一个数组的长度
                 本例中即 3 * sizeof(int)，也可用来解读 数组的数组
                 适用于主数组是可变的，但 子数组 长度确定时
                 0   1   2
         hoge ──>┌───┬───┬───┐
                 │           │
       hoge+1 ──>├───┼───┼───┤
                 │           │
                 ├───┼───┼───┤
                 │           │
                 ├───┼───┼───┤
                 │           │


int *hoge[2]    指向指针 的数组
                适用于主数组长度确定，但 子数组 长度不确定
                0   1
                ┌───┬───┐
                │ *   * │
                └─┼─┴─┼─┘      ┌─┬─┬─┬─┬─┬─
                  │   └───────>└─┴─┴─┴─┴─┴─
                  │            ┌─┬─┬─┬─┬─┬─┬─┬─
                  └───────────>└─┴─┴─┴─┴─┴─┴─┴─

int **hoge      指向指针 的指针
                当上例中数组的个数不确定(可变数组)时
                适用于 两个数组均 长度不确定
                0   1
        hoge ──>┌───┬───┬─
                │ *   *
                └─┼─┴─┼─┴─     ┌─┬─┬─┬─┬─┬─
                  │   └───────>└─┴─┴─┴─┴─┴─
                  │            ┌─┬─┬─┬─┬─┬─┬─┬─
                  └───────────>└─┴─┴─┴─┴─┴─┴─┴─
                  
5. 注意下面代码中指针的区别。
int x[] = {1,2,3,4,5,6};
int *p1 = x;        // 指向整数的指针
int (*p2)[] = &x;   // 指向数组的指针
p1 的类型是 int*，也就是说它指向一个整数类型。数组名默认指向数组中的第一个元素，因此 x 默认也是 int* 类型。
p2 的含义是指向一个 "数组类型" 的指针，注意是 "数组类型" 而不是 "数组元素类型"，这有本质上的区别。
    数组指针把数组当做一个整体，因为从类型角度来说，数组类型和数组元素类型是两个概念。
因此"p2 = &x" 当中 x 代表的是数组本身而不是数组的第一个元素地址，&x 取的是数组指针，而不是"第一个元素指针的指针"。

int x[][4] = {{1, 2, 3, 4}, {11, 22, 33, 44}};
int (*p)[4] = x; !! ! ! ! // 相当于 p = &x[0]
    x 是一个二维数组，x 默认指向该数组的第一个元素，也就是 {1,2,3,4}。不过要注意，
这第一个元素不是 int，而是一个 int[]，x 实际上是 int()[] 指针。因此 "p = x" 而不是 "p = &x"，否则 p 就指向 int ()[][] 了。
    既然 p 指向第一个元素，那么 *p 自然也就是第一行数组了，也就是 {1,2,3,4}，
(*p)[2] 的含义就是第一行的第三个元素。p++ 的结果自然也就是指向下一行。我们还可以直接用 *(p + 1) 来访问 x[1]。
}
pointer(数组的数组){
注意: C中不存在真正的多维数组，只存在数组的数组。
int hoge[3][2]可以通过hoge[i][j]的方式去访问，hoge[i]指"int的数组(元素2)的数组(元素3)"中的第i个元素，其 类型为int[2]

1. 参数传递
试图将数组进行参数传递时，考虑"将int的数组作为参数传递时"，对应函数原型为
void func(int *hoge);

在"int的数组(元素2)的数组(元素3)"的情况下，将后面的数组解释成指针时，表达为"指向int数组(元素2)的指针"，
原型则为
void func(int (*hoge)[2]);

另写成下面的方式，也都被解释成上面的
void func(int hoge[3][2]);
void func(int hoge[][2]);
}

array(pointer 数组和指针比对){
1. C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素的地址指针
2. 数组的数组    char a[3][4]
   指针数组      char *a[10]
   数组的指针    char (*p)[4]
   指针的指针    char **p
3. 当数组超过一维时，将第一维改写为指向数组首元素首地址的指针之后，后面的维度也不可改写
   比如 a[4][5][6] 作为参数时可以被改写为 (*p)[4][5]
}
array(pointer 数组和指针的区别){
对于数组，在编译时就能知道数组的首地址
对于指针，在编译时只能知道指针变量的地址，该地址里面的内容才是指针指向的数组的地址 

指针和数组的区别：指针是对内存的间接引用，数组是对内存的直接引用

数组和指针的其他区别
表4-1                            数组和指针的区别
---------------------------------------------------------------------------------------
|            指针                           |                      数组                  |
|-------------------------------------------|-----------------------------------------   |
|保存数据的地址                             |保存数据                                    |
|-------------------------------------------|-----------------------------------------   |
|间接访问数据，首先取得指针的内容，把它作为 |直接访问数据，a[I]只是简单地以a+I为地址取得 |
|地址，然后从这个地址提取数据。             |数据                                        |
|如果指针有一个下标[I]，就把指针的内容加上I |                                            |
|作为地址，从中提取数据                     |                                            |
|-------------------------------------------|-----------------------------------------   |
|通常用于动态数据结构                       |通常用于存储固定数目且数据类型相同的元素    |
|-------------------------------------------|-----------------------------------------   |
|相关的函数为malloc(),free()。              |隐式分配和删除                              |
|-------------------------------------------|-----------------------------------------   |
|通常指向匿名数据                           |自身即为数据名                              |
-----------------------------------------------------------------------------------------

首先需要注意的是"地址y"和"地址y的内容"之间的区别。
例：X = Y;
    在这个上下文环境里，符号X的含义是X所代表的地址。在编译时可知，表示存储结果的地方。
    符号Y的含义是Y所代表的地址的内容。知道运行时才知，如无特别说明，表示"Y的内容"。
注意: C语言引入了"可修改的左值"这个术语与数组名区分，因为数组名是个不可修改的左值。
注意: 左值：可修改的左值(允许出现在复制语句左边)和不可修改的左值
数组下标引用与指针的区别：
    1.关键：每个符号的地址在编译时可知。故数组下标可以直接操作；但指针使用时需要在运行时取得它的当前值，
然后对它进行解除引用。
    2.对于指针，编译器想要取得指针指向的内容，需要先得到指针的内容，把它作为指针指向的内容的地址，再到
这个地址去取内容。

注意: 代码：小心取地址符号&，小心sizeof, 指针加减(按指针所指向的元素的大小移动)，将数组名或字符串名的值即是其第一个元素的地址！
char name_array[] = "test"; char *name = "test";
printf("name address:%#x\n", name_array);          // name address:0xae87e590  第一个元素char*
printf("name address:%#x\n", &name_array[0]);      // name address:0xae87e590  第一个元素char*
printf("name address:%#x\n", &name_array);         // name address:0xae87e590  数组的地址 char[5]*
printf("name address:%#x\n", name_array+1);        // name address:0xae87e591  + sizeof(char)
printf("name address:%#x\n", &name_array+1);       // name address:0xae87e595  + sizeof(char[5])
printf("name address:%#d\n", sizeof(name_array));  // name address:5           sizeof(char[5])
printf("==============\n");
printf("name address:%#x\n", name);                // name address:0x4008a2    指针变量的值 char*
printf("name address:%#x\n", &name[0]);            // name address:0x4008a2    所指空间第一个元素的地址
printf("name address:%#x\n", &name);               // name address:0xae87e588  指针的地址
printf("name address:%#x\n", name+1);              // name address:0x4008a3    + sizeof(char)
printf("name address:%#x\n", &name+1);             // name address:0xae87e590  + sizeof(char*)
printf("name address:%#d\n", sizeof(name));        // name address:8           sizeof(char*)

1a.对数组进行下标引用的步骤：
char a[9] = "abcdefgh";
...
c = a[i];
首先，编译器符号表有数组a的地址，假设为9980；
运行时步骤1：取i的值，将它与9980相加(获得a[i]对应的偏移地址)
运行时步骤2：取地址(9980+i)的内容。
2a.对指针进行下标引用的步骤：
char *p = "abcdefgh";
...
c = p[i];
首先，编译器符号表有一个p，假设地址为4624；
运行时步骤1：取地址4624的内容，为5081；
运行时步骤2：取得i的值，并将它与5081相加；
运行时步骤3：取地址(5081+i)的内容。
3a 总结
char a[] = "abcdefgh"; ... a[3];
char *p = "abcdefgh"; ... p[3];
在这两种情况下，都可以取得字符'd'，但两者的途径非常不一样。
定义为指针，但以数组方式引用，编译器将会：
a.取得符号表中p的地址，提取存储于此处的指针。
b.把下标所表示的偏移量与指针的值相加，产生一个地址。
c.访问上面这个地址，取得字符。
}
pointer(function){
1. 函数指针
定义：函数类型 (*指针变量名)(形参列表);
例：int (*p)(); 函数类型：表示函数的返回类型
形参列表：表示函数指针所指向的函数的参数列表

函数指针是指向函数的指针
函数指针与其所指向的函数的返回值类型，参数类型及参数个数应一致

2. 指针函数
定义：类型 *函数名(参数表)
例：int *func(x,y);
指针函数是返回值为指针的函数
}
pointer(null){
空指针在概念上不同于未初始化的指针。空指针可以确保不指向任何对象或函数; 而未初始化指针则可能指向任何地方。

根据语言定义, 在指针上下文中的常数 0 会在编译时转换为空指针。也就是说, 在初始化、赋值或比较的时候, 
如果一边是指针类型的值或表达式, 编译器可以确定另一边的常数 0 为空指针并生成正确的空指针值。
因此下边的代码段完全 合法：
    char *p = 0;
    if(p != 0)
然而, 传入函数的参数不一定被当作指针环境, 因而编译器可能不能识别未加 修饰的 0 表示 指针。在函数
调用的上下文中生成空指针需要明确的类型转换, 强制把 0 看作指针。
例如, Unix 系统调用 execl 接受变长的以空指针结束 的字符指针参数。它应该如下正确调用：
    execl("/bin/sh", "sh", "-c", "date", (char *)0);
如果省略最后一个参数的 (char *) 转换, 则编译器无从知道这是一个空指针, 从而当作一个 0 传入。

execl("/bin/sh", "sh", "-c", "date", NULL);         /* WRONG */
execl("/bin/sh", "sh", "-c", "date", 0);            /* WRONG */
execl("/bin/sh", "sh", "-c", "date", (char *)NULL); /* RIGHT */

类似 if(p) 这样的 缩写, 尽管完全合法, 但被一些人认为是不好的风格。 另外 一些人认为恰恰是好的风格;

ANSI C 允许 NULL 的可选定义
    #define NULL ((void *)0)
除了潜在地帮助错误程序运行 (仅限于使用同样类型指针的机器, 因此帮助有限) 以外, 这样的定义还可以发现错误使用 NULL 的程序

有两条简单规则你必须遵循:
    当你在源码中需要空指针常数时, 用 0 或 NULL。
    如果在函数调用中 0 或 NULL 用作参数, 把它转换成被调函数需要 的指针类型
    
注意: free(NULL)是可以的，不会报错

注意: 区分三个特殊的常量：
1. NULL，有时候NULL是定义为0的，有时候是定义为(void*)0的，为了程序的可移植性，还是要养成良好的习惯，
   默认编译器会理解我们所写的0应该理解成指针NULL。
   标准允许将 NULL 定义成(void*)0，所以在 NULL 被定义成(void*)的时候，如果使用 NULL 来结束字符串，编译器必然会提示警告。
   在 C 中，为 0 的地址上应该是不能保存有效数据的吧？放什么都起不到任何作用，这没什么大不了的。
   #define NULL ((void*)0)  有的环境
   #define NULL 0           有的环境
2. 0，这个不用解释了，但是在某些情况下，NULL，'\0'其实都是0。
3. '\0':C语言的标准中，空字符的定义为：所有的位为0的字节，称为null character，也就是说空字符是
   "值为0的字符"，其实写作'\0'实际上是一种约定俗成，也为了程序读起来更自然。
}

pointer(现实地讲, 数组和指针地区别是什么 ？){
    数组自动分配空间, 但是不能重分配或改变大小。
    指针必须明确赋值以指向 分配的空间 (可能使用 malloc), 但是可以随意重新赋值 (即, 指向不同的对 象), 
同时除了表示一个内存块的基址之外, 还有许多其它的用途。
}

pointer(当 p 是指针时, if(p) 是合法的表达式吗？){
是的. 
}

pointer(const char *p 和 char * const p 有何区别？){
    const char *p m(也可以写成 char const *p ) 声明了一个指向字符常量的 指针, 因此不能改变它所指向的字符;
char * const p 声明一个指向 (可变) 字符的指针常量, 就是说, 你不能修改指针。
从里到外 看就可以理解它们;

1.1 指针常量
    指针常量意指 "类型为指针的常量"，初始化后不能被修改，固定指向某个内存地址。
我们无法修改指针自身的值，但可以修改指针所指目标的内容。
1.2 常量指针
    常量指针是说 "指向常量数据的指针"，指针目标被当做常量处理 (尽管原目标不一定是常量)，
不能用通过指针做赋值处理。指针自身并非常量，可以指向其他位置，但依然不能做赋值操作。

}

pointer(bus){
bus error (core dumped) 总线错误(信息已转储)
总线错误基本是由于未对齐的读或写操作引起的。(出现未对齐的内存访问请求时，被堵塞的组件是地址总线)
对齐，alignment, 数据项只能存储在地址是数据项大小的整数倍的内存位置上
只要对齐了，就能保证一个原子数据想不会跨越一个页或Cache块的边界
    union { char a[10];
            int i;
        } u;
    int *p = (int *)&(u.a[1]);
    *p = 17; // p中未对齐的地址会引起一个总线错误！
}
pointer(指针问题){
1.坏指针错误：
    malloc申请内存错误
    在指针赋值前就用它来引用内存，
    向库函数传送一个坏指针。
    对指针进行释放之后再访问它的内容
2.改写(overwrite)错误：
    越过数组边界写入数据，在动态分配的内存两端之外写入数据
    改写一些堆管理数据结构(在动态分配的内存之前的区域写入数据容易发生这种情况)
3.指针释放引起的错误：
    释放同一个内存块两次
    释放一块未曾使用malloc分配的内存
    释放仍在使用中的内存
    释放一个无效的指针
注：在遍历链表时正确释放元素的方法：使用临时变量存储下一个元素的地址。

对于野指针：养成在定义指针后且在使用之前完成初始化的习惯就好。 
对于悬空指针：一个避免这个错误的方法是在释放它的引用后将该指针的值重置为NULL。

导致段错误的直接原因
    解除引用一个包含非法值的指针
    解除引用一个空指针
    未得到正确的权限时进行访问。如往只读的文本段存储值就会引起段错误
    用完了堆栈或栈空间
}
gcc( 64 32) {
安装32位运行时库
64位Linux操作系统下使用-m32编译参数时，可能会由于缺少本地运行时库报错。不久前Ubuntu16.04系统自动升级到GCC7.4.0之后，编译32位程序
$ gcc -g -Wall -m32 test.c -o Test

方法1
$ sudo apt-get install gcc-multilib g++-multilib
    方法2
$ sudo apt-get install ia32-libs
    方法3
但是以上两种方法对本次遇到的问题都不起作用，经过仔细检查后发现系统升级后原有的gcc-5全套组件并未被移除，因此修改编译命令为如下：
$ gcc-5 -g -Wall -m32 test.c -o Test
编译成功！
}

https://github.com/zanghu/gitbook_notebook/blob/73363969d04a5a40fd05d5b7c878418a0a7d4127/c/basic/c052.md
void(指针){
指针void *的性质
    C语言中的内存池、多态、回调等数据结构、或机制的实现严重依赖于void *指针，那么这些相关代码中
令人眼花缭乱的各种指针类型转换的安全性如何呢？
问题1: 任何类型指针与void *指针相互转换是否是安全、可逆的？
答案：是安全、可逆的。
需要注意的是，这里应该不包括函数指针，对于函数指针与void *之间的相互转化关系，ISO C中似乎没有明确地叙述

问题2: 不同类型的指针，其表示方式是否相同（指针类型转化前后是否相等）？
答案：根据ISO C99/11，不同类型不一定有相同的表示方式。参考如下的ISO C99/11中的叙述：

    虽然void *指针作为一种“一般等价物”可以用于可逆的与任何类型指针进行相互转化，
但这并不意味着转化前后其内存表示和对齐方式是不变的。ISO C只保证:
(1) `void *`类型与`char *`类型之间；
(2) 兼容的指针类型之间；
(3) 所有指向`struct`对象的指针类型之间；
(4) 所有指向`union`对象的指针类型之间；
(5) 以上四点提到的指针类型之外的指针类型之间；
以上每一点中的指针类型具有相同的内存表示和对齐方式。

问题3: 不同类型的指针其sizeof大小是否一定相等？
答案：不一定。原因由第前面一个问题答案的分析中就可以得出。
事实上，ISO C不仅没有保证不同类型的指针大小相等，甚至没有给出基本数据类型short、int、long等等的严格大小

问题4: ISO C是否规定了基本数据类型的sizeof大小？
答案：否，标准仅仅给出了基本数据类型的最低精度表示范围。

问题5: void *指针进行算数运算触发编译器警告怎么办？
gcc编译命令中加入-wpointer-arith项后，会触发void *指针进行算数运算的告警。
这种告警的原因在于，指针的加减法算数运算中，指针所指位置移动的字节长度实际上是与指针所指的类型相关的。例如：
  int a[10];
  int *b = a + 1; # b指向a[1], 指针所指的位置移动了1*sizeof(int)字节

}
void(功能和应用){
void类型
  void的字面意思是"无类型"，
  void * 则为无类型指针，void *可以指向任何类型的数据。 void几乎只有"注释"和限制程序的作用。
void真正发挥作用在于：
1.对函数返回的限定：
2.对函数参数的限定：
3.void型指针：
使用void类型指针要注意的几条规则：
  void*类型只有地址信息没有类型信息，所以不能计算偏移。
  任何指针(包括函数指针)都可以赋值给void指针。
  void指针赋值给其他类型的指针时都要进行转换。
  void指针在强制转换成具体类型前，不能解引用。
  void指针不能参与指针运算，除非进行转换。
void指针的应用场合
  当进行纯粹的内存操作的时候，可以使用void指针。
  当传递一个指向未定类型的指针时候，可以使用void指针。
  指向0的地址。
  数据指针。
  
float *p1;
int *p2;
void *p3;
//p1=p2; //warning C4133: '=' : incompatible types - from 'int *' to 'float *'
p1=(float*)p2; //经过转化是可以的
p2=(int*)p1; //经过转化是可以的
//p2=p1; //warning C4133: '=' : incompatible types - from 'float *' to 'int *'
p3=p1; //空指针可以接受其它类型指针值
p3=p2; //空指针可以接受其它类型指针值
}   
signed(C99 stdint){
signed long long int li = 214748364 ; 64位
前缀：0x 0X 0 (十六进制小写，十六进制大写，八进制)
后缀：uU, lL  (无符号unsigned int, or long int，有符号long int)

unsigned int ui = 65535u
 <limits.h> <stdint.h>
Macro Type Value
CHAR_BIT smallest object that is not a bit-ﬁeld (byte)8
SCHAR_MIN   signed char         -127 / -(27 - 1)
SCHAR_MAX   signed char         +127 / 27 - 1
UCHAR_MAX   unsigned char       255 / 28 - 1
CHAR_MIN    char                see below
CHAR_MAX    char                see below
SHRT_MIN    short int           -32767 / -(215 - 1)
SHRT_MAX    short int           +32767 / 215 - 1
USHRT_MAX   unsigned short int  65535 / 216 - 1
INT_MIN     int                 -32767 / -(215 - 1)
INT_MAX     int                 +32767 / 215 - 1
UINT_MAX    unsigned int        65535 / 216 - 1
LONG_MIN    long int            -2147483647 / -(231 - 1)
LONG_MAX    long int            +2147483647 / 231 - 1
ULONG_MAX   unsigned long int   4294967295 / 232 - 1
Version ≥ C99
Macro Type Value
LLONG_MIN   long long int           -9223372036854775807 / -(263 - 1)
LLONG_MAX   long long int           +9223372036854775807 / 263 - 1
ULLONG_MAX  unsigned long long int  18446744073709551615 / 264 - 1
}
signed(overflow){
int chkadd(int a, int b) 
{ 
    if(INT_MAX - b < a){ 
        fputs("int overflow\n", stderr); 
        return INT_MAX; 
    } 
    return a + b; }
}
float(C99){ <float.h> -> float、double和long double
float f = 0.314f;        /* suffix f or F denotes type float */
double d = 0.314;        /* no suffix denotes double */
long double ld = 0.314l; /* suffix l or L denotes long double */
/* the different parts of a floating point definition are optional */
double x = 1.; /* valid, fractional part is optional */
double y = .1; /* valid, whole-number part is optional */

一般而言，类型float/double 有7/16个有效位(小数点后面的位数)；

整数之间除法结果为整数
浮点数之间除法结果为浮点数

Suffix  Type        Examples
none    double      3.1415926 -3E6
f, F    float       3.1415926f 2.1E-6F
l, L    long double 3.1415926L 1E126L

一种是实浮点类型，包括float、double和long double；
另一种是复数类型，包括float _Complex、double _Complex和long double _Complex。
}
size_t(C99){
    在C99中，size_t类型可以比unsigned long更长。但C99中的printf可以直接显示出size_t
类型值而不需要强制转换。方法是在转换说明 中的一般整数代码前使用字母z，比如%zu。
}
function(指针函数){
1. 指针函数定义
typedef int (*funcptr)(); # 定义函数指针

2. 指针函数返回指针函数定义 方法1
typedef int (*funcptr)();         /* generic function pointer */
typedef funcptr (*ptrfuncptr)();  /* ptr to fcn returning g.f.p. */

funcptr start(), stop();
funcptr state1(), state2(), state3();

void statemachine(){
    ptrfuncptr state = start;
    
    while(state != stop)
        state = (ptrfuncptr)(*state)();
}

funcptr start(){
    return (funcptr)state1;
}

2. 指针函数返回指针函数定义 方法2
struct functhunk {
    struct functhunk (*func)();
};

struct functhunk start(), stop();
struct functhunk state1(), state2(), state3();

void statemachine()
{
    struct functhunk state = {start};

    while(state.func != stop)
        state = (*state.func)();
}

struct functhunk start()
{
    struct functhunk ret;
    ret.func = state1;
    return ret;
}
}
macro(C99){
C99允许宏调用中的任意或所有参数为空，只需要添加相应的逗号。
#define ADD(x,y) (x+y)
i = ADD(,k); //相当于 i = (+k);

#define JOIN(x,y,z) x##y##z
int JOIN(a,b,c), JOIN(a,b,), JOIN(a,,c), JOIN(,,c); //相当于 int abc, ab, ac, c;

在C99中可以定义可变参数的宏：
#define TEST(condition, ...) ( \
    (condition)?printf("Passed test:%s\n", #condition):\
    printf(__VA_ARGS__) \
)
    ...记号出现在宏参数列表的最后，前面是普通参数，__VA_ARGS__是一个专用的标识符，
只能出现在具有可变参数个数的宏的替换列表中，代表所有与省略号相对应的参数。宏TEST
至少需要两个参数，从第二个开始的参数与省略号相匹配，而且这些参数可以为空。

1. 宏有两个运算符，#和##。第二个运算符常用作"粘合"运算符,用于将两个记号粘在一起。
   # 运算符将宏的一个参数转换为字符串字面量，
例如：
#define PRINT_INT(n) printf(#n " = %d\n", n)

#define STRINGIZE(x) #x
STRINGIZE("foo") //相当于 "\"foo\""

##运算符将两个记号粘合在一起形成一个新的记号，例如：
#define GENERIC_MAX(type)        \
type type##_max(type x, type y)  \
{                                \
    return x > y ? x : y;        \
}
GENERIC_MAX(float)  //产生一个float_max函数
}
string(C){
字符串字面量"a"是以指针来表示的，字符常量'a'是以整数来表示的。

初始化字符串变量 -> 一定要确保字符大小跟数组大小的适配。
char date[8] = "June 14";      //编译器自动在末尾添加了‘\0’
char date[8] = "June14";       // 当不足n个字符时，编译器把剩余部分初始化为空字符
char date[8] = "June 14 2014"; // 当超出n个字符时，编译器不会自动在末尾添加空字符

字符串惯用法
// 搜索结尾
while(*s)
    s++;
或者
while (*s++)
    dosomething;
// 字符串复制
while (*p++ = *s++)
    ;
对于多维字符数组，char *str[]比char str[][] 更加节省空间。
}
string(C99){
char* str = "hello, world"; /* string literal */
/* string literals can be used to initialize arrays */
char a1[] = "abc"; /* a1 is char[4] holding {'a','b','c','\0'} */
char a2[4] = "abc"; /* same as a1 */
char a3[3] = "abc"; /* a1 is char[3] holding {'a','b','c'}, missing the '\0' */
/* it is good practice to denote string literals as such, by using `const` */
char const* s1 = "foobar";
s1[0] = 'F'; /* compiler error! */

/* normal string literal, of type char[] */
char* s1 = "abc";
/* wide character string literal, of type wchar_t[] */
wchar_t* s2 = L"abc";
Version ≥ C11
/* UTF-8 string literal, of type char[] */
char* s3 = u8"abc";
/* 16-bit wide string literal, of type char16_t[] */
char16_t* s4 = u"abc";
/* 32-bit wide string literal, of type char32_t[] */
char32_t* s5 = U"abc";

|-------|-----------|---------------------|
|prefix | base type |  encoding           |
|-------|-----------|---------------------|
|none   | char      |  platform dependent |
|L      | wchar_t   |  platform dependent |
|u8     | char      |  UTF-8              |
|u      | char16_t  |  usually UTF-16     |
|U      | char32_t  |  usually UTF-32     |
|-------|-----------|---------------------|
Escape SequenceRepresented Character
\unnnn Universal character name
\Unnnnnnnn Universal character name

\nnn Octal value
\xnn... Hexadecimal value

-------|--------------------------- |
suffix | Explanation                |
-------|--------------------------- |
L, l   | long int                   |
LL, ll | (since C99) long long int  |
U, u   | unsigned                   |
-------|--------------------------- |

strtok(), strtok_r() and strtok_s() 
strtok_s is thread-safe 
strtok_r is re-entrant

strlen() 非ASCII字符集问题
char asciiString[50] = "Hello world!";
char utf8String[50] = "Γειά σου Κόσμε!"; /* "Hello World!" in Greek */
printf("asciiString has %zu bytes in the array\\n", sizeof(asciiString));
printf("utf8String has %zu bytes in the array\\n", sizeof(utf8String));
printf("\\"%s\\" is %zu bytes\\n", asciiString, strlen(asciiString));
printf("\\"%s\\" is %zu bytes\\n", utf8String, strlen(utf8String));

char * string = "hello world";
char const * string = "hello world"
char const string_arr[] = "hello world";

char modifiable_string[] = "hello world"
char modifiable_string[] = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'};

strcpy snprintf  strncat strncpy
strncpy(b, a, sizeof(b)); /* the third parameter is destination buffer size */
b[sizeof(b)/sizeof(*b) - 1] = '\0'; /* terminate the string */
printf("%s\n", b); /* "0123456" will be printed */


char * string_array[] = {
    "foo",
    "bar",
    "baz"
};
char modifiable_string_array_literals[][4] = {
    "foo",
    "bar",
    "baz"
};
等价于
char modifiable_string_array[][4] = {
    {'f', 'o', 'o', '\0'},
    {'b', 'a', 'r', '\0'},
    {'b', 'a', 'z', '\0'}
};

char* s1 = "Hello"
        " World!";
# s1=Hello World!
char* s2 = "Hello \
            World!";
# s2=Hello             World!
atoi, atol, atoll and atof #  If the value of the result cannot be represented, the behavior is undeﬁned. 
float strtof(const char *nptr, char **endptr);                          float
double strtod(const char *nptr, char **endptr);                         double
long double strtold(const char *nptr, char **endptr);                   long double
long strtol(char const* p, char** endptr, int nbase);                   long int
long long strtoll(char const* p, char** endptr, int nbase);             
unsigned long strtoul(char const* p, char** endptr, int nbase);         
unsigned long long strtoull(char const* p, char** endptr, int nbase)    

formatted
int sprintf ( char * str, const char * format, ... );
int sscanf ( const char * s, const char * format, ...);

strcmp(), strncmp() Standard C, strcasecmp(), strncasecmp() POSIX extension

size_t strspn(const char *s, const char *accept);  # 可以接受字符集，
size_t strcspn(const char *s, const char *reject); # 不可接受字符集，
}
bool(){
1. stdbool.h  C99
true = 1
false = 0
bool类型变量, 等价于 unsigned char . 只有0和1.

2. #define bool int
#define true 1
#define false 0
3.  C99, _Bool
_Bool x = 1;
_Bool y = 0;
    C99提供了_Bool类型，与一般整型不同，_Bool只能赋值为0或者1。一般来说往_Bool变量中
存储非零值会导致变量赋值为1。C99还提供了一个新的头文件<stdbool.h>，提供了宏bool代表_Bool。

1. 指针判断
char const* s = ....;   /* some pointer that we receive */   -- 不推荐
if (s != NULL && s[0] != '\0' && isalpha(s[0])) {
   printf("this starts well, %c is alphabetic\n", s[0]);
}

char const* s = ....;   /* some pointer that we receive */   -- 推荐
if (s && s[0] && isalpha(s[0])) {
   printf("this starts well, %c is alphabetic\n", s[0]);
}
}
sizeof(){
printf("%zu\n", sizeof(int)); /* Valid, outputs the size of an int object, which is platform-dependent. */
printf("%zu\n", sizeof int); /* Invalid, types as arguments need to be surrounded by parentheses! */

char ch = 'a';
printf("%zu\n", sizeof(ch)); /* Valid, will output the size of a char object, which is always 1 for all platforms. */
printf("%zu\n", sizeof ch);  /* Valid, will output the size of a char object, which is always 1 for all platforms. */


int b[100]; 
void fun(int b[100]){ 
int x=sizeof(b); //4，b此时只是一个指针，指针在32位平台中为4个字节 
}

int *p=NULL,a[100]; 
int x=sizeof(p); //4,指针在32位平台中为4个字节 
int y=sizeof(*p); //4,int型指针所指内容为int型整数，int型整数为4字节 
int z=sizeof(a); //400,a为int型数组的首地址，100个元素，共400字节 
int u=sizeof(a[100]); //4,第100个元素还是整型，占4字节，虽然这个元素因为越界并不存在 
int v=sizeof(&a); //400,a为int型数组的首地址，100个元素，共400字节 
int w=sizeof(&a[0]); //4,第0个元素还是整型，占4字节 
int r=sizeof(b); //400,b为int型数组的首地址，100个元素，共400字节 
fun(a);
}
bitwise(){
不要应用于有符号整形。

int i = 0x01 << 2 + 3; // 32 , 算术运算优先级高 
int j = 0x01 << 2 + 32; // 0 , 溢出 
int k = 0x01 << 2 - 3; // 0 
int l = 0x01 >> 2 - 3; // 0 不能为负数 
int m = 0x01 << 2; // 4
}
bitfield(字节序的困扰以及结构体字节对齐的困扰){
Parameter     | Description
--------------|----------------------------------------
type-speciﬁer | signed, unsigned, int or _Bool
identifier    | The name for this ﬁeld in the structure
size          | The number of bits to use for this field

struct B
{
    unsigned char c1 : 1;
    unsigned char    : 2;    /* Skips 2 bits in the layout */
    unsigned char c2 : 2;
    unsigned char    : 0;    /* Causes padding up to next container boundary */
    unsigned char c3 : 4;
    unsigned char c4 : 1;
};

不建议使用字节序
1. 字节序不支持数组；字节序不支持指针引用；字节序不支持函数返回
2. 取地址操作符&不能应用于字节序
3. sizeof不支持字节序
4. typedef支持的不好
typedef struct mybitfield
{
    unsigned char c1 : 20;   /* incorrect, see point 3 */
    unsigned char c2 : 4;    /* correct */
    unsigned char c3 : 1;
    unsigned int x[10]: 5;   /* incorrect, see point 1 */
} A;
int SomeFunction(void)
{
    // Somewhere in the code
    A a = { … };
    printf("Address of a.c2 is %p\n", &a.c2);      /* incorrect, see point 2 */
    printf("Size of a.c2 is %zu\n", sizeof(a.c2)); /* incorrect, see point 4 */
}

字节序使用场景：
1. 嵌入式内存受限的环境中
2. 嵌入式需要操作寄存器的环境中
}
更多实例：crosstool\cheatsheet\ops_doc-master\Service/IO处理参考说明.sh 中 initializer
initializer(C99){ 数组，结构体和联合体
    C90标准要求结构体对象或数组的初始化器（应是指对象创建时用花括号初始化方法）
中的元素按照固定顺序出现，这个顺序对于结构体对象来说就是结构体属性成员的定义顺序，
对于数组来说就是数组的元素顺序。
    ISO C99标准中提供了一种允许用户在使用花括号{}初始化结构体对象或数组元素时，
不需要严格按照结构体成员的定义顺序队成员进行赋值、也不需要按照数组元素的索引序
对元素进行赋值的对象初始化方法。

moosefs中RunTab和LateRunTab符合C90标准。moosefs中termsignal，reloadsignal，ignoresignal符合C90标准。
       中errtab符合C90标准。mfs_opts_stage2也符合C90标准, errtab[]={ERROR_STRINGS} 符合C90标准。 opstr[] validstr[]
       中vstring[] 数组性字符串
       中mfsnetdump.c 中cmdtab[] 字符串和宏对应关系
       中mfsclient 中 char* sugid_clear_mode_strings[] = {SUGID_CLEAR_MODE_STRINGS}; *sesflagposstrtab[]={SESFLAG_POS_STRINGS}
                                                                                char *sesflagnegstrtab[]={SESFLAG_NEG_STRINGS};
moosefs中mfs_meta_oper和mfs_oper符合C99标准，
主要应用是结构体数组 RunTab LateRunTab errtab mfs_opts_stage2 cmdtab[] # 回调函数+字符串 数值+字符串, 数组来源至宏
          字符串数组 opstr对应枚举值 errtab对应宏值                    # 字符串数组按顺序对应宏顺序或者字符串顺序
          大型结构体 mfs_meta_oper mfs_oper                            # 支持大量回调函数，只需要实现部分回调函数
          数值型数组 termsignal reloadsignal ignoresignal              # va_list 类型多值传递的数组形式
          数组类型字符串 id                                            # 利用C语言中，字符串的自动连接功能

情况1: 数组初始化
对于数组初始化，可以使用下面例子中的方式明确指定初始化值赋给数组的那个元素。
// 花括号中每个等号表达式左侧方括号内的索引必须是常量表达式，
// 即便数组是自动（猜想应该是指数组大小是自动初始化的，即int a[]=...）初始化的
int a[6] = { [4] = 29, [2] = 15 };
上面的初始化式等价于
int a[6] = { 0, 0, 15, 0, 29, 0 };

情况2：结构体初始化
对于结构体初始化器，在花括号内部通过‘.fieldname = ’的方式指明每个要赋值的属性成员的名字来对制定属性赋值。
struct point { int x, y; };
可以按照如下方式初始化
struct point p = { .y = yvalue, .x = xvalue };
上面的代码等价于
struct point p = { xvalue, yvalue };

另外一部分仍使用传统的方式。举例来说：
int a[6] = { [1] = v1, v2, [4] = v4 };
上面的初始化语句等价于
int a[6] = { 0, v1, v2, 0, v4, 0 };


情况3：索引为枚举类型的数组的初始化
当被初始化的数组的索引下表是枚举类型时，c99-style designated initializer的初始化方式将变得特别有用。举例来说:
int whitespace[256]
  = { [' '] = 1, ['\t'] = 1, ['\h'] = 1,
      ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 };

情况4：元素是结构体对象的数组的初始化
当数组元素是自定义结构体对象时，可以用如下方法：
// 数组元素是上面例子中的struct point
struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };
}

array(基本操作){ 数组是指将固定个数、相同类型的变量排列起来的对象。
注意： C语言中只有一维数组，对于一个数组只能做两件事：确定数组的大小(C99标准允许变长数组VLA)；获取指向数组下标为0的元素的指针
注意: 如果数组的长度比所提供的初始化值的个数要多，剩余的几个元素会自动设置为0。
      如果元素的类型是指针，那么它们被初始化为NULL；
      如果元素类型是float，那么它们被初始化为0.0。
      
初始化规则:
  如果数组为静态⽣存周期，那么初始化器必须是常量表达式。
  如果提供初始化器，那么可以不提供数组⻓度，由初始化器的最后一个元素决定。
  如果同时提供⻓度和初始化器，那么没有提供初始值的元素都被初始化为 0  或 NULL

1. 数组初始化
int array[10];              /* 内容不确定 */
int array[10] = {0};        /* 内容确定，都为0 */
int array[10] = {1, 2, 3};  /* 内容确定，[0]=1, [1]=2, [2]=3 其余为0 */
int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; 
//should use for-loop here ! Attention: can not use memset() since memset() fill same value for each byte;
int array[10] = {[2] = 5, [1] = 2, [4] = 9}; /* 内容确定，[1]=2, [2]=5, [4]=9 其余为0 ; C99提供 */

int array[] = {1, 2, 3};            /* 自动确定数组大小为3 */
int array[] = {[3] = 8, [0] = 9};   /* 自动确定数组大小为4 */

2. 数组在传递过程中的长度
void f(int x[][4]) {
    assert(sizeof(*x) == sizeof(int) * 4);
}
void g(int (*x)[4]) {
    assert(sizeof(*x) == sizeof(int) * 4);
}
void h(int **x) {
    assert(sizeof(*x) == sizeof(int*));
}
int main(void) {
    int foo[2][4];
    f(foo);
    g(foo);

    int **bar = malloc(sizeof(*bar) * 2);
    assert(bar);
    for (size_t i = 0; i < 2; i++) {
        bar[i] = malloc(sizeof(*bar[i]) * 4);
        assert(bar[i]);
    }
    h(bar);
   
    for (size_t i = 0; i < 2; i++) {
        free(bar[i]);
    }
    free(bar);
}

3. 多维数组初始化
int a[3][4] = {  
   {0, 1, 2, 3} ,   /*  initializers for row indexed by 0 */
   {4, 5, 6, 7} ,   /*  initializers for row indexed by 1 */
   {8, 9, 10, 11}   /*  initializers for row indexed by 2 */
};
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

4. 获取和设置
int val;
int array[10];

*(array + 4) = 5;
*(4 + array) = 5;

array[4] = 5;
4[array] = 5; /* Weird but valid C ... */

val = array[4];
val = 4[array]; /* Weird but valid C ... */
}
array(数组大小){
int a[5]={1,2,3,4,5}; 
int i=sizeof(&a);       //20 这是一个地址，但为什么是20个字节的长度呢 
int j=sizeof(a);        //20 a作为一个首地址，为什么是20个字节的长度呢 
int k=sizeof(&a[0]);    //4 
int l=sizeof(&a[5]);    //4 即便这个元素不存在

int *ptr=(int *)(&a+1); // 一次性跳数组长度的字符个数
printf("%d,%d\n",*(a+1),*(ptr-1)); // 2,5 
printf("%x,%x,%x,%x,%x\n",a,&a,a+1,&a+1,ptr-1); //18ff34,18ff34,18ff38,18ff48,18ff44
对指针进行加1操作，得到的是连续内存中下一个元素的地址
一个类型为T的指针的移动，是以sizeof(T)为移动单位的
&a 与 a 的值是一样的，但是意思不一样
&a 是数组(结构体/构造体)的首地址
a 是数组首元素的首地址
&a+1，取数组a的首地址，该地址的值加上sizeof(a)的值，即&a+5*sizeof(int)
可以将a理解为结构体名，同时其值为&a[0]
a+1，是数组下一元素的首地址，即 a[1]的首地址

char a[5]={'a','b','c','d','e'};
char (*p1)[3]=&a;
char (*p2)[3]=a;
char (*p3)[10]=&a; 
char (*p4)[10]=a; 
printf("%x,%x,%x,%x,%x\n",a,p1+1,p2+1,p3+1,p4+1); //18ff40,18ff43,18ff43,18ff4a,18ff4a
数组指针，是一个指针 ，但是它每次加一后，跳过的内存字节数为 n*sizeof(type)

int a[4]={1,2,3,4}; 
int *ptr1 =(int *)(&a+1); 
int *ptr2=(int *)((int)a+1); 
printf("%x,%x\n",ptr1[-1],*ptr2); // 4,2000000

int a[3][2]={(0,1),(2,3),(4,5)}; 
int *p; p=a[0]; 
printf("%d\n",p[0]); //1
仔细看看花括号里面嵌套的是小括号，而不是花括号。即这花括号里嵌套了逗号表达式。（这考的是眼力）

int a[5][5]; int (*p)[4]; 
p=a; 
printf("a_ptr=%#p,p_ptr=%#p\n",&a[4][2],&p[4][2]); // a_ptr=0X0018FF3C,p_ptr=0X0018FF2C 
printf("%p,%d\n",&p[4][2]-&a[4][2],&p[4][2]-&a[4][2]); //FFFFFFFC,-4
&a[4][2] 表示 &a[0][0]+4*5*sizeof(int)+2*sizeof(int)
&p[4][2] 表示 &a[0][0]+4*4*sizeof(int)+2*sizeof(int)
所以差 4*sizeof(int) ，而地址相减获得的是此类型数据占用内存的单位数，所以，虽然相差16个字节，但是相差4个单位，一个int占4字节


int a=3, b = 5;  
printf(&a["Ya!Hello!how is this? %s\n"], &b["junk/super"]);  
printf(&a["WHAT%c%c%c %c%c  %c !\n"], 1["this"],  
    2["beauty"],0["tool"],0["is"],3["sensitive"],4["CCCCCC"]);  
// Hello! how is this? super
// That is C !

signed char a = 0xe0;  
unsigned int b = a;  
unsigned char c = a;  
A. a>0 && c>0 为真 B. a == c 为真 C. b 的十六进制表示是：0xffffffe0 D. 上面都不对
A 错：a 是负数，c 是正数，跟 0 比较要转换到 int。
    signed char a 其实也就是char a，其转换到int负数还是负数(高位填充1)转换后结果为0xFFFFFFE0
    unsigned char c 也为0xE0，但其是正数（signed char转unsigned char 底层位不变 只是改变了解释规则）
    unsigned char 转int，正数还是正数（高位填充0）转换后结果为0x000000E0
B 错：B错？首先说 a 和 c 的二进制表示一模一样，都是 0xe0，那么比较就不相等？！是的。
    一个char型和一个unsigned char比较，其中的类型如何转换？
    C语言的整型提升规则：C的整型算数运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符型和短整型操作数在使用之前被转换为普通整型。
    本博的早期文章：http://blog.csdn.net/yang_yulei/article/details/8068210
    所以，a == c中，a和c都要先转换成int型，再比较。有A选项分析知，a转int型为负数，b转int型为正数，故它俩不等。
C 对：C对？C 怎么就对了？a 是一个 signed char，赋值给 unsigned int 的 b，前若干个字节不是补 0 吗？
    但实际情况是：首先 signed char 转换为 int，然后 int 转换成 unsigned int，所以最初是符号扩展，
    然后一个 int 赋值给了 unsigned int（其实还是整型提升规则）
}

array(既然数组引用会蜕化为指针, 如果arr是数组, 那么arr和 &arr又有什么区别呢？){
区别在于类型。
在标准 C 中, &arr 生成一个 T 型数组 的指针, 指向整个数组。
在  ANSI 之前的 C 中, &arr 中的 & 通常会引起一个警告, 它通常被忽略。
在所有的 C 编译器中, 对数组的简单引用(不包括 & 操作符)生成一个 T 的指 针类型的指针, 指向数组的第一成员。
}
array(我该如何动态分配多维数组 ？){
    传统的解决方案是分配一个指针数组, 然后把每个指针初始化为动态分配的 列。 以下为 一个二维的例子:
#include <stdlib.h> 
int **array1 = malloc(nrows * sizeof(int *)); 
for(i = 0; i < nrows; i++) 
    array1[i] = malloc(ncolumns * sizeof(int));
    当然, 在真实代码中, 所有的 malloc 返回值都必须检查。你也可以使用 sizeof(*array1)  
和 sizeof(**array1) 代替 sizeof(int *) 和 sizeof(int)。

你可以让数组的内容连续, 但在后来重新分配列的时候会比较困难, 得使用一点指针算术:
    int **array2 = malloc(nrows * sizeof(int *));
    array2[0] = malloc(nrows * ncolumns * sizeof(int));
    for(i = 1; i < nrows; i++)
        array2[i] = array2[0] + i * ncolumns;
在两种情况下, 动态数组的成员都可以用正常的数组下标 arrayx[i][j] 来访问  
(for 0 <= i <nrows 和 0 <= j <ncolumns)。
   
   如果上述方案的两次间接因为某种原因不能接受, 你还可以同一个单独的动态分配 的一维数组来模拟二维数组:
    int *array3 = malloc(nrows * ncolumns * sizeof(int));
但是, 你现在必须手工计算下标, 用 array3[i * ncolumns + j] 访问第 i, j 个成员。
使用宏可以隐藏显示的计算, 但是调用它的时候要使用括号和逗号, 这看起来不太象 多维数组语法, 而且宏需要至少访问一维。
 
当然, 使用这些技术, 你都必须记住在不用的时候释放数组。而且你可能不能混用动态数组和传统的静态分配数组。
}

array(当我向一个接受指针的指针的函数传入二维数组的时候, 编译器报错了){
    数组蜕化为指针的规则 不能递归应用。 数组的数组 (即 C 语言中的二维数组) 
蜕化为数组的指针, 而不是指针的指针。 数组指针常常令人困惑, 需要小心对待;

如果你向函数传递二位数组:
    int array[NROWS][NCOLUMNS];
    f(array);
那么函数的声明必须匹配:
    void f(int a[][NCOLUMNS])
    { ... }
或者
    void f(int (*ap)[NCOLUMNS]) /* ap 是个数组指针 */
    { ... }
在第一个声明中, 编译器进行了通常的从 数组的数组 到 数组的指针 的隐式转换。

    第二种形式中的指针 定义显而易见。因为被调函数并不为数组分配地址, 所以它并不需要知道总的 大小, 
所以行数 NROWS 可以省略。但数组的宽度依然重要, 所以列维度  NCOLUMNS (对于三维或多维数组, 相关的维度) 
必须保留。
    如果一个函数已经定义为接受指针的指针, 那么几乎可以肯定直接向它传入 二维数组毫无意义。
}

array(int array[] = {1, 2, 3}; extern int array[];){
file1.c:                        file2.c:
int array[] = {1, 2, 3};        extern int array[];
int arraysz = sizeof(array);    extern int arraysz;

file1.h:
#define ARRAYSZ 3
extern int array[ARRAYSZ];
file1.c:                    file2.c:
#include "file1.h"          #include "file1.h"
int array[ARRAYSZ];

0, -1, or NULL作为结尾
file1.c:                        file2.c:
int array[] = {1, 2, 3, -1};    extern int array[];
}
array(数组是"二等公民"){
数组不能直接赋值
作为参数传递会退化为指针
不能作为函数返回值
}
enum(定义){
注意: enum把一串名字与一串整型值联系在一起。
枚举的一般形式：
    enum 可选的标签
{内容...}可选的变量定义;

enum 是int类型；
enum: 表达一种映射关系,不同元素的值可以相等，eg：enum {Typea = 1, Typeb = 1};

枚举也可以用来创建新的数据类型
枚举类型存储区就是一个整数类型存储区，
	这种存储区里应该只能记录几个有限的整数
声明枚举类型时需要提供一组名称，每个名称对应一个整数，
	这些整数才可以放到枚举类型存储区

枚举类型中第一个名字对应的整数是0，向后依次递增
可以在声明枚举类型时指定某个名称对应的数字，
它后面的名称对应的数字也会随着改变


1. 使用enum代替int和char*, 可以在编译时刻提示报错，避免传递错误的值。
enum week{ MON, TUE, WED, THU, FRI, SAT, SUN };
enum week{ DOW_INVALID = -1,   /* 边界枚举 */
  MON, TUE, WED, THU, FRI, SAT, SUN,
  DOW_MAX };

2. enumeration constant without typename
enum { buffersize = 256, };
static unsigned char buffer [buffersize] = { 0 };

3. Enumeration with duplicate value
enum Dupes
{
   Base, /* Takes 0 */
   One, /* Takes Base + 1 */
   Two, /* Takes One + 1 */
   Negative = -1,
   AnotherZero /* Takes Negative + 1 == 0, sigh */
};
}
logical(Short circuit 短路){

int a = 20;
/* here 'print(a)' is not called, since a 'a != 20' is false. */
if (a != 20 && print(a)) {
  printf("I won't be printed!\n");
}
/* here 'print(a)' is called, since a 'a == 20' is true. */
if (a == 20 && print(a)) {
  printf("I will be printed!\n");
}

const char *name_for_value(int value){
    static const char *names[] = { "zero", "one", "two", "three", };
    enum { NUM_NAMES = sizeof(names) / sizeof(names[0]) };
    return (value >= 0 && value < NUM_NAMES) ? names[value] : "infinity";
}

逗号列表规定了从左到右的计算顺序：
printf("%d %d", f1(), f2()); # f1() 和 f2() 函数谁先被调用不确定，因为这里不是逗号列表
}

logical(sequence point序列点){
    序列点是一个时间点(在整个表达式全部计算完毕之后或在 ||、&&、? : 或逗号 运算符处, 
或在函数调用之前), 此刻尘埃落定, 所有的副作用都已确保结束。 
ANSI/ISO C 标准这样描述:
    在上一个和下一个序列点之间, 一个对象所保存的值至多只能被表达式的 计算修改一次。
    而且前一个值只能用于决定将要保存的值。
    
    第二句话比较费解。它说在一个表达式中如果某个对象需要写入, 则在同一表达式中对该
对象的访问应该只局限于直接用于计算将要 写入的值。这条规则有效地限制了只有能确保在
修改之前才访问 变量的表达式为合法。例如 i = i+1 合法, 而 a[i] = i++ 则非法。
}

macro(宏函数定义原则){
(1)函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以传参时要格外小心。
(2)调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。
(3)函数式宏定义要注意格式，尤其是括号。
(4)若函数参数为表达式，则普通函数的调用与函数式宏定义的替换过程是不一样的。
(5)函数式宏定义往往会导致较低的代码执行效率。
#define square(x) x * x
#define square(x) ((x) * (x))

函数式宏定义：#define MAX(a,b) ((a)>(b)?(a):(b))
普通函数     ： MAX(a,b) { return a>b?a:b;}

#define max(a, b) ((a) > (b) ? (a) : (b))
max(biggest, x[i++])
... 上面代码中的赋值语句将被扩展为：
biggest = ((biggest) > (x[i++]) ? (biggest) : (x[i++]));
解决这类问题的一个办法是，确保宏 max 中的参数没有副作用。


利用宏可以定义伪函数，通常用 ({  ... })  来组织多个语句，最后一个表达式作为返回值 (无 return ，且有个 ";" 结束)。
#define test(x, y) ({   \
    int _z = x + y;     \
    _z; })
int main(int argc, char* argv[]){
    printf("%d\n", test(1, 2));
    return EXIT_SUCCESS;
}
展开:
int main(int argc, char* argv[]){
    printf("%d\n", ({ int _z = 1 + 2; _z; }));
    return 0;
}
}
macr(书写多语句宏的最好方法是什么？ ){
    通常的目标是书写一个象包含一个单独的函数调用语句的宏。这意味着 调用者 需要提供最终的分号, 
而宏体则不需要。因此宏体不能为简单 的括弧包围的复合语句, 因为如果这样, 调用的时候就会发生语法错 
(明显是 一个单独语句, 但却多了一个额外的分号), 就像在 if/else 语句的 if 分支 中多了一个 else 分句一样。

所以, 传统的结局方案就是这样使用:
#define MACRO(arg1, arg2) do {  \
    /* declarations */      \
    stmt1;           \
    stmt2;           \
    /* ... */            \
    } while(0)    /* 没有结尾的 ; */
    当调用者加上分号后, 宏在任何情况下都会扩展为一个单独的语句。 优化的编译器会去掉条件为0的无效 
测试或分支, 尽管 lint 可能会警告。

do {...} while(0)
1. 帮助定义复杂的宏以避免错误，同时使用宏可添加;，符合代码习惯
2. 避免使用goto控制流程(break)
3. 避免由宏引起的警告, #define EMPTYMICRO do{}while(0)
}
macr(怎样写参数个数可变的宏？){
    一种流行的技巧是用一个单独的用括弧括起来的的 参数 定义和调用宏, 参数在 宏扩展的时候成为类似 
printf() 那样的函数的整个参数列表。
    #define DEBUG(args) (printf("DEBUG: "), printf args)
    if(n != 0) DEBUG(("n is %d\n", n));
明显的缺陷是调用者必须记住使用一对额外的括弧。

    gcc 有一个扩展可以让函数式的宏接受可变个数的参数。 但这不是标准。
另一种 可能的解决方案是根据参数个数使用多个宏 (DEBUG1, DEBUG2, 等等), 或者用 逗号玩个这样的花招:
#define DEBUG(args) (printf("DEBUG: "), printf(args)) 
#define _ , 
DEBUG("i = %d" _ i);
    C99 引入了对参数个数可变的函数式宏的正式支持。在宏 原型 的末尾加上符号 ... 
(就像在参数可变的函数定义中), 宏定义中的伪宏 __VA_ARGS__ 就会在调用是 替换成可变参数。
最后, 你总是可以使用真实的函数, 接受明确定义的可变参数。
如果你需要替换宏, 使用一个 函数和一个非函数式宏, 如 #define printf myprintf。
}
__VA_ARGS__(){
__VA_ARGS__ 标识符用来表示一组可选性自变量。
#define println(format, ...) ({   \
    printf(format "\n", __VA_ARGS__); })
int main(int argc, char* argv[]){
    println("%s, %d", "string", 1234);
    return EXIT_SUCCESS;
}
展开:
int main(int argc, char* argv[]){
    ({ printf("%s, %d" "\n", "string", 1234); });
    return 0;
}
}
macro(警告信息 warning: macro replacement within a string literal是什么意思？){
有些 ANSI 前的编译器/预处理器把下面这样的宏
    #define TRACE(var, fmt) printf("TRACE: var = fmt\n", var)
解释为
    TRACE(i, %d);
这样的调用会被扩展为
    printf("TRACE: i = %d\n", i);
换言之, 字符串常量内部也作了宏参数扩展。
K&R 和标准 C 都没有定义这样的宏扩展。当你希望把宏参数转成 字符串时, 你可以使用
新的预处理操作符 # 和字符串常量连接 (ANSI 的另 一个新功能):
    #define TRACE(var, fmt) \
        printf("TRACE: " #var " = " #fmt "\n", var)
}
struct(packed){
Alignment 对齐 
Padding 填充 
是因为要对齐，所以才有了填充；(为什么要对齐呢？)
由此引出了一个 GCC 的扩展语法：紧致 packed
}
struct(定义){
结构就是一种把一些数据项组合在一起的数据结构。
  struct 结构标签(可选) {
    类型1 标识符1
    类型2 标识符2
    ...   ...
    类型N 标识符N
  } 变量定义(可选);
结构的内容可以是任何其他数据声明：单个数据项、数组、其他结构、指针等。

结构的参数传递：
1.参数在传递时首先尽可能地存放到寄存器中(追求速度)
注：int型变量i跟只包含一个int型成员的结构变量s在参数传递时的方式可能完全不同。一个int
参数一般会被传递到寄存器中，而结构参数则很可能被传递到堆栈中。

2.在结构中放置数组，可以把数组当做第一等级的类型，用赋值语句拷贝整个数组(数组本身不可以用赋值语句拷贝)，以传值
调用的方式把它传递到函数，或者把它作为函数的返回类型。

注意：结构中允许存在位段、无名字段以及字对齐所需的填充字段
注意: 位段的类型必须是int，unsigned int 或 signed int(或加上限定词)
struct Name(Optional) {
  int A :         6; //注意符号位占1bit
  unsigned int B: 2; //定义bit的类型可以是signed/unsigned/enum
  int         :   1; //填充位可以不需要名字
  int         :   0; //用来区分字边界，不占用内存,也不需要名字
  stuct Name* link;  //指向自己类型的指针
}var1(Optional); 这里的var1是个变量(最好换行)，不是类型，因为没有加typedef,那只能这样: struct Name st;
typedef struct Name1{}Name; 这里的Name是个类型，不是变量，因为typedef的作用,这时候就可以用Name去定义变量:Name st <===> struct Name1 st;
typedef struct Name{}Name; 如果是这样定义的，那么: Name st <====> struct Name st; 都是合理的；
如果structA里面嵌套定义structB,那A的内存包含了B，不论B是否显示定义了实例，eg:struct A{ struct{ int; };}; ==> sizeof(A)=4;

struct s_tag { int a[100]; };
可以把数组当作第一等级的类型，用赋值语句拷贝整个数组，以传值调用的方式把它传递到函数，或者把它作为函数的返回类型。

注意: 函数调用的参数会优先放在寄存器里面，其次才放到栈(映射到cache/ddr)；
}

struct(typedef){
typedef struct student { 
int age; 
char sex; 
} Stu_st,*Stu_pst; 
struct student stu1={23,'f'}; 
Stu_st stu2={24,'m'}; //与 stu1 的定义形式等价 
struct student *stu3=&stu1; 
Stu_pst stu4=&stu2; //与 stu3 的定义形式等价
    虽然看起来很奇怪，但是只要将 struct student { ... } 和 struct student { ... } * 看作成一个整体，
对整体进行命名就容易理解了
}

typedef(const){
typedef struct student
{
    int age;
    char sex;
} *Stu_pst; 
struct student stutmp1={23,'f'},stutmp2={24,'m'};
const Stu_pst stu1=&stutmp1; //const 在前的定义 , 参考之前的const使用方法，如果将 Stu_pst 与 typedef struct student { ... } * 进行简单替换，理论上const 修饰的是 *stu1 从而限定的是 stu1 指的对象，即stu1指的对象不能改变，stu1本身应该可以改变值  
Stu_pst const stu2=&stutmp2; //const 在后的定义 , 参考之前的const使用方法，如果将 Stu_pst 与 typedef struct student { ... } * 进行简单替换，理论上const 修饰的是 stu2 从而限定的是 stu2 本身，即stu2本身不能改变，stu2指的对象应该可以改变值
stu1->age=12; 
stu1->sex='m'; //结果stu1所指的对象可以接受修改
stu2->age=13;
stu2->sex='f'; 
//stu1=&stutmp2; //error C2166: l-value specifies const object //stu1 本身不能修改，stu1所指的对象反而可以接受修改，说明了const修饰的其实是指针变量本身，与stu2的一样
//stu2=&stutmp1; //error C2166: l-value specifies const object 

这个实验结果与我们之前的理解有些出入，原因是 typedef struct student { ... } * 被编译器当作了一个整体，解释的过程中，Stu_pst 是一个类型名，被忽略掉，从而直接修饰了指针本身
}
struct(声明 struct x1{...}; 和 typedef struct { ...} x2; 有什么不同？ ){
    第一种形式声明了一个 '结构标签'; 第二种声明了一个 '类型定义'。
主要的区别是在后文中你需要用 struct x1 引用第一种, 而用 x2 引用第二种。
    也就是说, 第二 种声明更像一种抽象类新 --- 用户不必知道它是一个结构, 而在声明它的 
实例时也不需要使用 struct 关键字。
    typedef struct x3 { ... } x3; 
    x3既是一个结构标签，也是一个类型定义，结构标签和类型定义分别在不同的命名空间。
}
struct(C语言中用什么方法实现抽象数据类型最好？){
    答：用户使用指向未公开定义的结构类型的指针绝对是个好办法。换言之，用户只需要使用结构的指针，
如不需要知道结构的成员是什么，如调用参数或返回值为该结构指针的函数；只要不使用->、sizeof()、操作符
及真实结构的声明，C语言就可以正确的处理不完全类型的结构指针；只有在实现抽象数据类型的原文件中才需要
此范围内的完整声明。
}

union(定义){
联合的一般形式：
    union 可选的标签
    {
        类型1 标识符1;
        类型2 标识符2;
        ...
        类型N 标识符N;
    }可选的变量定义。

联合(一般作为大型结构的一部分存在)的作用：
    1.节省空间，有些数据项不可能同时出现，可用联合节省空间
    2.把同一个数据解释成两种不同的东西。
注意: 联合不需要额外的赋值和强制类型转换，同一个数据可解释为两个不一样的东西
      联合存储区的大小是其中最大子变量存储区的大小
如下value.byte.c0
union bits32_tag {
    int whole;  /* 一个32位的值 */
    struct {char c0, c1, c2, c3;} byte;  /* 4个8位的字节 */
} value;
}

union(大小端){
  小端模式:数据的低字节保存在起始地址;
  大端模式:数据的高字节保存在起始地址;
  大小端字节序转换：以字节为单位转换,通常是逐个字段(u64,u32,u16)进行转换，u8不需要转换；
eg: 0x1234ABCD, 数据的低字节-->高字节顺序是：CD --AB--34--12, 这个数据的字节顺序与大小端无关，
  而且数据对象在内存中肯定是从低地址到高地址依次存取的，区别是低地址该放低字节还是高字节。
 
对于struct来说，member之间的地址顺序肯定是低地址-->高地址，第1个member肯定是低地址，这个与大小端无关。
每个member内的字节顺序才和大小端有关系。
假如占用的内存地址是0x00000000---0x00000004,对于小端，0x00000000存放0xCD, 对于大端，0x00000000存放0x12;

4.大小端转换：只有整型数据才存在大小端转换。
  把一个u32变量赋值给一个u8指针就必须考虑： 
   1)是否需要考虑字节序(大小端转换)，取决于协议，比如socket通信要求用大端；
   2)内存地址align:某些芯片，如果指针指向的内存地址不是4字节对齐，这时强行用u32对它赋值(eg: *((u32*)rarPtr) = rarWord)，DSP会出问题，必须调用平台特定接口, ARM/X86正常赋值；
     在linux host上的case是测试不出来的，因为linux支持任意地址的变量赋值；
  u8* rarPtr = (u8*)(resp.raRespData);
  u32 rarWord     = (u32)((taCmd & 0x7ff) << 20 | (ulGrant & 0xfffff)) ; 
_mem4(rarPtr) = reverseByteOrder(rarWord); 根据协议，taCmd是在低地址，ulGrant在高地址，所以这里需要做大小端转换；
}

http://soft.dog/
https://github.com/wilmosfang/blog
union(大小端实例){

系统的存储分为两种模式：大端模式 和 小端模式
    大端模式(big_endian)：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中
    小端模式(little_endian)：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中

使用int和char还有共用体的存储特性，可以获取系统的存储模式
小端模式：
int i=1;
00000000 00000000 00000000 00000001
大端模式：
int i=1;
00000001 00000000 00000000 00000000
}

stdalign(){ stdalign.h
In C, the alignment requirement is measured in size_t
printf("Alignment of char = %zu\n", alignof(char));
printf("Alignment of max_align_t = %zu\n", alignof(max_align_t));
printf("alignof(float[10]) = %zu\n", alignof(float[10]));
printf("alignof(struct{char c; int n;}) = %zu\n", alignof(struct {char c; int n;})); 
}

inttype(){
PRId8   "d"
PRId16  "d"
PRId32  "d"
PRId64  __PRI64_PREFIX "d"
PRIi8   "i"
PRIi16  "i"
PRIi32  "i"
PRIi64  __PRI64_PREFIX "i"
PRIo8   "o"
PRIo16  "o"
PRIo32  "o"
PRIo64  __PRI64_PREFIX "o"
PRIu8   "u"
PRIu16  "u"
PRIu32  "u"
PRIu64  __PRI64_PREFIX "u"
PRIx8   "x"
PRIx16  "x"
PRIx32  "x"
PRIx64  __PRI64_PREFIX "x"
PRIX8   "X"
PRIX16  "X"
PRIX32  "X"
PRIX64  __PRI64_PREFIX "X"
}
cnotes(特殊标识){ cdecl
|------------------------|----------------------|---------------|
|Operator                | Relative Precedence  | Associativity |
|------------------------|----------------------|---------------|
|[] (array subscription) | 1                    | Left-to-right |
|() (function call)      | 1                    | Left-to-right |
|* (dereference)         | 2                    | Right-to-left |
|------------------------|----------------------|---------------|

|------------------|----------------------------------------------|
|Expression        | Interpretation                               |
|------------------|----------------------------------------------|
|thing[X]          | an array of size X of...                     |
|thing(t1, t2, t3) | a function taking t1, t2, t3 and returning...|
|*thing            | a pointer to..                               |
|------------------|----------------------------------------------|

char *names[20];      20个char类型指针
char (*place)[10];    1个指针,指向10个char类型数组的
int fn(long, short);  函数fn，有两个参数long类型和short类型，返回值int类型
int *fn(void);        函数fn，没有参数，返回值int*类型
int (*fp)(void);      指针fn，没有参数，返回值int类型


char *(*(*a[N])())();
用 typedef 逐步完成声明:
    typedef char *pc;       /* 字符指针           */  char *;
    typedef pc fpc();       /* 返回字符指针的函数 */  char *();
    typedef fpc *pfpc;      /* 上面函数的指针     */  char *(*());
    typedef pfpc fpfpc();   /* 返回函数指针的函数 */  char *(*())();
    typedef fpfpc *pfpfpc;  /* 上面函数的指针     */  char *(*(*))();
    pfpfpc a[N];            /* 上面指针的数组     */      char *(*(*a[]))();
使用 cdecl 程序, 它可以把英文翻译成 C 或者把 C 翻译成英文:
    cdecl> declare a as array of pointer to function returning pointer to function returning pointer to char
    char *(*(*a[])())()

*(*pfpc)()  is a char 
(*pfpc)()   is a pointer to char 
(*pfpc)     is a function returning pointer to char 
pfpc        is a pointer to function returning pointer to char

int myFunction(int x, int y){
    return x * 2 + y;
}
int (*fn)(int, int) = &myFunction;
int x = 42;
int y = 123;
printf("(*fn)(%i, %i) = %i\n", x, y, (*fn)(x, y)); /* Outputs "fn(42, 123) = 207". */
printf("fn(%i, %i) = %i\n", x, y, fn(x, y)); /* Another form: you don ot need to dereferenceexplicitly */
}
rvalue(if switch){
if ((buffer = malloc(1024)) != NULL)
}

expertc(多做之过){
1a. 定义
switch(表达式){
    case 常量表达式：
             零条或多条语句；
              break；
    case 常量表达式：
              零条或多条语句；
              break；
    default: 
              零条或多条语句；
}
注意: -- 缺少采用'fall through'，在97%的情况下都是错误的。
  }
1b. 特性 注意: 
  1. switch语句，default可以出现在case列表的任何位置，default在其它case均无法匹配时被执行。
     如果没有default，而且所有的case均不匹配，那整条switch语句便什么都不做。
  2. 标准的C编译器至少允许一条switch语句有257个case标签，这是为了允许switch满足一个8bit字符的所有情况(256+EOF)。
  3. case后面必须为常量值或常量表达式 -- const int a = 2; case a: j=2; 不允许
  4. 使用switch... case...break...时，养成添加/* fall through */的习惯
  
1b. 问题
  1.对case可能出现的值太过于放纵
      int i = 2;
      switch(i){
          case 5+3: ;
          case 2: printf("loop\n");
          defau1t: i++;
          case 3: ;
      }

  2. 可以在switch的左花括号之后声明一些变量，但变量不会被初始化。
      switch(i){
        int a = 2; // 内部变量
        case 1: j=1;
        case 2: j=2;
        case 3: j=3;
        default: j=4;
        printf("%d\n",a);
     }
      training2.1.c表明了这一问题。
      注意: 所以如果需要一些临时变量最好放在块的开始处。

  3.switch语句内部的任何语句都可以加上case标签，并在执行时跳转到那里。
      正如training2.2.c所展示的错误，当把default的"l"错写成数字1，并不会报错，
      实际效果相当于default子句并不存在与switch语句中。
      switch(i){
        case 5+3: do_again:
        case 2: printf("loop\n");goto do_again;
        default: i++;
        case 3: ;
    }
  
  4.switch语句不会在每个case标签后面的语句执行完毕后自动中止。
  一旦执行某个case语句，程序将会依次执行后面所有的case，除非遇到break语句。
  这称之为"fall through"。详情如training2.3.c所示。
    switch(2){
        case 1: printf("case 1\n");
        case 2: printf("case 2\n");
        case 3: printf("case 3\n");
        case 4: printf("case 4\n");
        default: printf("default\n");
    }
  
2.2.2 C自动合并相邻字符串常量
 ANSI C引入的一个新特性：
  注意: 相邻的字符串常量将被自动合并成一个字符串的约定
      这省掉了过去在书写多行信息时必须在行末加'\'的做法，但这种自动合并意味着
  字符串数组在初始化时，如果不小心漏掉了一个逗号，编译器将不会发出错误信息，而是
  悄无声息地把两个字符串合并在一起。
  training2.4.c表明了这一问题。

2.2.3 太多的缺省可见性
  定义C函数时，在缺省情况下函数的名字是全局可见的，即加不加extern效果一样。
  如果想限制对这个函数的访问，必须加个static关键字
      function apple() {/* 在任何地方均可见 */}
      extern function pear() {/* 在任何地方均可见 */}
      static function turnip() {/* 在这个文件之外不可见 */}
    作用域过宽的问题常见于库中：一个库需要让一个对象在另一个库中可见。唯一的办法
是让它变得全局可见，但这样一来，它对于链接到该库的所有对象都是可见的了。

注意: interpositioning指用户编写和库函数同名的函数并取而代之。
}
expertc(误做之过){
注意 1. malloc(strlen(str))几乎总是错的，malloc(strlen(str)+1)才是正确的。
注意 2. sizeof的操作数是个类型名时，必须加上括号，但如果是变量就不必。

许多符号是被'重载'的————在不同的上下文环境里有不同的意义。
C语言的符号重载
  1.static：在函数内部，表示该变量的值在各个调用间一直保持延续性，即只做一次初始化
            在函数这一级，表示该函数只对本文件可见
  2.extern：用于函数定义，表示全局可见(属于冗余的)
            用于变量，表示它在其他地方定义
  3.void  ：作为函数的返回类型，表示不返回任何值
            在指针声明中，表示通用指针的类型
            位于参数列表这种，表示没有参数
  4.*     ：乘法运算符
            用于指针，间接引用
            在声明中，表示指针
  5.&     ：位的AND操作符
            取地址操作符
  6.=       赋值符
    ==      比较运算符
  7.<<=   ：左移复合赋值运算符
    <=      小于等于运算符
  8.  <   ：小于运算符
            #include指令的左定界符
  9.()    ：在函数定义中，包围形式参数表
            调用一个函数
            改变表达式的运算次序
            将值转换为其他类型(强制类型转换)
            定义带参数的宏
            包围sizeof操作符的操作数(如果它是类型名)
  p38页的apple = sizeof(int) * p;经测试为int的长度乘以p，若p为指针会报错。
注意: 让一个符号所表达的意思越多，编译器就越难检测到这个符号在你的使用中所存在的异常情况。  

2.3.2 "有些运算符的优先级是错误的"
    C语言运算符优先级存在的问题
    优先级问题         |  表达式           人们可能误以为的结果       实际结果
     -------------------------------------------------------------------------------
    .的优先级高于      |  *p.f            p所指向的字段f (*p).f     对p取f偏移，作为指针
    ->用于取消这个问题 |                                              然后进行解除引用操作
     -------------------------------------------------------------------------------
    []高于*            |  int *ap[]       ap是个指向int型数组的指针  ap是指向int型的指针为
                       |                                              元素的数组int *(ap[])
     -------------------------------------------------------------------------------
    函数()高于*        |  int *fp()       fp是个函数指针,该函数返    fp是个函数返回int *
                       |                   回int型 int(*fp)()
     ----------------------------------------------------------------------------
    ==和=!高于运算符   |  (val&mask!=0)    (val&mask)!=0              val&(mask!=0)
     ----------------------------------------------------------------------------
    ==和=!高于赋值符   |  c=getchar()!=EOF (c=getchar())!=EOF         c=(getchar()!=EOF)
     ----------------------------------------------------------------------------
    算术运算法高于移   |
    位运算符           |  msb<<4 + lsb     (msb<<4)+lab               msb<<(4+lsb)
     ----------------------------------------------------------------------------
    逗号运算符在所有运 |
    算符中优先级最低   |  i=1,2            i=(1,2)                    (i=1),2
    
注意: 表达式中如果有布尔操作、算术运算、位操作等混合计算，始终应该在适当的地方加上括号。
    
注意: 结合性是仲裁者，在几个操作符具有相同的优先级时决定先执行哪一个。
    在C语言中，跟顺序有关的问题，有些定义的很好，如优先级和结合性，有些则定义的很含糊，如大部分表达式里各个操作数
计算的顺序就是不确定的，它的目的是为了让编译器设计者选区最合适的方法来产生最快的代码。之所以说"大部分"，是因为
某些操作符如&&和||等，其操作数的计算是规定顺序的。这两个操作符严格按照从左到右的顺序依次计算两个操作数，当结果
提前得知时便忽略剩余的计算。但是，在函数调用中，各个参数的计算顺序是不确定的。

2.3.3 早期gets()中的Bug导致了Internet蠕虫
    gets()函数从流中读入一个字符串，但其无法检查缓冲区的空间，故如果函数调用者提供一个指向堆栈的指针，
并且gets()函数读入的字符数量超过缓冲区的空间，多出来的字符会继续写入到堆栈，覆盖原先的内容。
所以推荐用fgets()彻底取代gets(),fgets()函数对读入的字符数设置了一个限制，这样就不会超出缓冲区范围。
}
expertc(少做之过){
2.4.1 用户名中若有字母f,便不能收到邮件。
    有些C程序员采用了一种 约定，带'--'的参数标识'从这里开始，没有参数是选项开关，即使它是以连字符开头'。
2.4.2 空格————最后的领域
    1.'\'字符可用于对一些字符进行'转义'，包括newline(这里指回车键)
        即\和新行之间如果多了空格会造成问题，并且很难被发现。
        这通常出现在用于转义连续多行的宏定义
    2.如果将所有的空格都弃之不用，也会陷入麻烦。
        例如: z = y+++x;
            ANSI C规定如果下一个标记有超过一种的解释方案，编译器将选取能组成最长字符序列的方案。
            所以，上例将解析为z = y++ +x;
            但 z = y+++++x;会有麻烦，按照前面的策略将解析为z = y++ ++ +x;这将引起一个编译错误：'++操作符迷失于空格间'
            即使编译器能推断(从理论上说)唯一有效的编排方式是 z = y++ + ++x;还是会出现编译错误。
            training2.6.c说明了这个问题。
    3.当程序员有两个指向int的指针并想对两个int数据执行除法运算时，
        ratio = *x/*y;
    但编译器会报错：出现了语法错误。问题出在除法运算符"/"与"*"操作符之间缺少空格。
    编译器误认为/*是一个注释的开始部分。

2.4.3 C++的另一种注释形式
    "//"注释符
    对于a //*
        //*/ b
    在C语言中表示a/b，但在C++中表示a。
    在training2.7.c中可知'//'注释符可用的情况下上例结果为a。

2.4.4 编译器日期被破坏
    当函数返回的是一个指向局部变量的指针时，当控制流离开局部变量的范围，变量将失效，无法得知变量的内容。
    解决方案
    1.返回一个指向字符串常量的指针(最简单的解决方案，适用于无需计算字符串的内容)
        例：return "Only";
    2.使用全局声明的数组
    3.使用静态数组(static关键字)
    4.显示的分配一些内存，保存返回的值
        但要注意释放内存，在函数内分配后，很容易忘记在使用函数后释放该内存，造成严重的问题。
    5.要求调用者分配内存来保存函数的返回值。
        例：buffer = malloc(size);
            fuc(buffer,size);
            free(buffer);

2.4.5 lint程序绝不应该被分离出来
lint程序是程序的道德准则。当你做错事时，它会告诉你那里不对。应该始终使用lint程序，按照它的道德准则办事。
}
expertc(声明是如何形成的){
    C语言声明的语法有时会带来严重的问题。C语言声明的语法对于编译器的处理来说并
不是什么大不了的事，但是对于一般的程序员，它却会成为障碍。

注意: 存储类型说明符(storage-class)：extern static register auto typedef
注意: 类型限定符(type-qualifier): const volatile
注意: "在函数调用时，参数按照从右到左的次序压到堆栈里"这种说法过于简单，参数在传递时首先尽可能地存放到寄存器中(追求速度)

3.1 只有编译器才会承认的语法
  1.把类型强制转换为指向数组的指针：
      char (*j)[20];      //j是一个指向数组的指针，数组内有20个char元素
      j = (char (*)[20]) malloc(20);
  如果把星号两边的括号拿掉，代码会变得非法。
  
  2.涉及指针和const的声明可能出现集中不同的顺序：
      const int * grape;
      int const * grape;
      int * const grape_jelly;
  在最后一种情况下，指针是只读的，而在另外两种情况下，指针所指向的对象是只读的。
  
  3.对象和指针都是只读的声明方法有两种：
      const int * const grape_jam;
      int const * const grape_jam;
      
const 修饰离它最近的类型。

3.2 声明的核心 -- 声明器(declarator)
    声明器就是标识符以及与它组合在一起的任何指针、函数括号、数组下标等。
声明器语法如下所示
    指针 opt 直接声明器

3.2.1 <C语言中的声明器declarator>
数量                C语言中的名字           C语言中的出现形式
-------------------------------------------------------------
零个或多个          指针                    下列形式之一：
                                            * const volatile
                                            * volatile
                                            *
                                            * const
                                            * volatile const
-------------------------------------------------------------
有且只有一个        直接声明器               标识符
                                         或：标识符[下标]
                                         或：标识符(参数)
                                         或：(声明器)
-------------------------------------------------------------
零个或一个          初始化内容           = 初始化

声明确定了变量的基本类型以及初始值(有的话)
3.2.2 <C语言中的声明器>
数量                C语言中的名字           C语言中出现的名字
-------------------------------------------------------------
至少一个类型说明符     类型说明符            void char short int long
(并非所有组合都合法)  (type-specifier)    signed unsigned float double
                                        结构说明符(struct-specifier)
                                        枚举说明符(enum-specifier)
                                        联合说明符(union-specifier)
                    存储类型              extern static register
                    (storage-class)     auto typedef
                    类型限定符            const volatile
                    (type-qualifier)
-------------------------------------------------------------
有且只有一个          声明器                参见上表
-------------------------------------------------------------
零个或更多            更多的声明器          ,声明器
-------------------------------------------------------------
一个                 分号                ；

在合法的声明中存在限制条件，不可以像下面这样做：
    函数的返回值不能是一个函数，  所以像foo()()这样是非法的
    函数的返回值不能是一个数组，  所以像foo()[]这样是非法的
    数组里面不能有函数，          所以像foo[]()这样是非法的
但下面的是合法的：
    函数的返回值允许是一个函数指针；        如int (*func())()
    函数的返回值允许是一个指向数组的指针；  如int (*foo)[]
    数组里面允许有函数指针；                如int (*foo[])()
    数组里面允许有其他数组；                如int foo[][]
}
expertc(优先级规则){
C语言声明的优先级规则
    A   声明从它的名字开始读取，然后按照优先级顺序依次读取
    B   优先级从高到低依次是：
        B.1 声明中被括号括起来的那部分
        B.2 后缀操作符：
            括号()表示这是一个函数，而
            方括号[]表示这是一个数组。
        B.3 前缀操作符：星号*表示 "指向...的指针"
    C   如果const和(或)volatile关键字的后面紧跟类型说明符(如int,long等)，其作用于类型说明符
在其他情况下，const和(或)volatile关键字作用于它左边紧邻的指针星号。

注意: 同一优先级的运算符，运算次序由结合方向所决定。
注意: 所有优先级相同的操作符，运算符的结合性也相同。
优先级  运算符  名称或含义        使用形式                   结合方向    说明
1       []      数组下标          数组名[常量表达式]         左到右      –           非运算符
        ()      圆括号            (表达式)/函数名(形参表)    左到右      –           非运算符
        .       成员选择(对象)    对象.成员名                左到右      –           非运算符
        ->      成员选择(指针)    对象指针->成员名           左到右      –           非运算符
2       -       负号运算符        -表达式                    右到左      单目运算符  单目运算符
        ~       按位取反运算符    ~表达式                    右到左      单目运算符  单目运算符
        ++      自增运算符        ++变量名/变量名++          右到左      单目运算符  单目运算符
        --      自减运算符        --变量名/变量名--          右到左      单目运算符  单目运算符
        *       取值运算符        *指针变量                  右到左      单目运算符  单目运算符
        &       取地址运算符      &变量名                    右到左      单目运算符  单目运算符
        !       逻辑非运算符      !表达式                    右到左      单目运算符  单目运算符
        (类型)  强制类型转换      (数据类型)表达式           右到左      –           单目运算符
        sizeof  长度运算符        sizeof(表达式)             右到左      –           单目运算符
3       /       除                表达式/表达式              左到右      双目运算符  算术运算符
        *       乘                表达式*表达式              左到右      双目运算符  算术运算符
        %       余数(取模)        整型表达式%整型表达式      左到右      双目运算符  算术运算符
4       +       加                表达式+表达式              左到右      双目运算符  算术运算符
        -       减                表达式-表达式              左到右      双目运算符  算术运算符
5       <<      左移              变量<<表达式               左到右      双目运算符  移位运算符
        >>      右移              变量>>表达式               左到右      双目运算符  移位运算符
6       >       大于              表达式>表达式              左到右      双目运算符  关系运算符
        >=      大于等于          表达式>=表达式             左到右      双目运算符  关系运算符
        <       小于              表达式<表达式              左到右      双目运算符  关系运算符
        <=      小于等于          表达式<=表达式             左到右      双目运算符  关系运算符
7       ==      等于              表达式==表达式             左到右      双目运算符  关系运算符
        !=      不等于            表达式!=表达式             左到右      双目运算符  关系运算符
8       &       按位与            表达式&表达式              左到右      双目运算符  位运算符
9       ^       按位异或          表达式^表达式              左到右      双目运算符  位运算符
10      |       按位或            表达式|表达式              左到右      双目运算符  位运算符
11      &&      逻辑与            表达式&&表达式             左到右      双目运算符  逻辑运算符
12      ||      逻辑或            表达式||表达式             左到右      双目运算符  逻辑运算符
13      ?:      条件运算符        表达式1?表达式2:表达式3    右到左      三目运算符  三目运算符
14      =       赋值运算符        变量=表达式                右到左      –           赋值运算符
        /=      除后赋值          变量/=表达式               右到左      –           赋值运算符
        *=      乘后赋值          变量*=表达式               右到左      –           赋值运算符
        %=      取模后赋值        变量%=表达式               右到左      –           赋值运算符
        +=      加后赋值          变量+=表达式               右到左      –           赋值运算符
        -=      减后赋值          变量-=表达式               右到左      –           赋值运算符
        <<=     左移后赋值        变量<<=表达式              右到左      –           赋值运算符
        >>=     右移后赋值        变量>>=表达式              右到左      –           赋值运算符
        &=      按位与后赋值      变量&=表达式               右到左      –           赋值运算符
        ^=      按位异或后赋值    变量^=表达式               右到左      –           赋值运算符
        |=     按位或后赋值       变量|=表达式               右到左      –           赋值运算符
15      ,       逗号运算符        表达式,表达式,…            左到右      –           逗号运算符


1.2 运算符的优先级问题 -- 熟悉运算符优先级，一种简单的记法是单目 > 双目 > 三目 位运算大于逻辑运算。
1. (),[],-> .  "高于"  单目    # ! ~ ++ -- (type) * & sizeof 
          单目 "高于"  双目
算术运算符 "高于"  移位运算符  # 算术运算符 * / % + -
移位运算符 "高于"  关系运算符  # 移位运算符 >> <<
关系运算符 "高于"  逻辑运算符  # 关系运算符 < <= > >= == != & ^ |
逻辑运算符 "高于"  条件运算符  # 逻辑运算符 && ||
                               # 
          高于 三目            # 三目 ?:
          赋值                 # = /= */ %= += -= <<= >>= &= ^= |= 
          逗号                 # ,   # 注意: 分隔函数参数的逗号不能理解为逗号运算运算符
  while((c=getc(in)) != EOF) putc(c,cout);
  if((flags & FLAG)!=0)
  r = (hi<<4) + low;

优先级问题         |  表达式           人们可能误以为的结果       实际结果
 -------------------------------------------------------------------------------
.的优先级高于*     |  *p.f            p所指向的字段f (*p).f     对p取f偏移，作为指针
->用于取消这个问题 |                                              然后进行解除引用操作
 -------------------------------------------------------------------------------
[]高于*            |  int *ap[]       ap是个指向int型数组的指针  ap是指向int型的指针为
                   |                                              元素的数组int *(ap[])
 -------------------------------------------------------------------------------
函数()高于*        |  int *fp()       fp是个函数指针,该函数返    fp是个函数返回int *
                   |                   回int型 int(*fp)()
 ----------------------------------------------------------------------------
==和=!高于运算符   |  (val&mask!=0)    (val&mask)!=0              val&(mask!=0)
 ----------------------------------------------------------------------------
==和=!高于赋值符   |  c=getchar()!=EOF (c=getchar())!=EOF         c=(getchar()!=EOF)
 ----------------------------------------------------------------------------
算术运算法高于移   |
位运算符           |  msb<<4 + lsb     (msb<<4)+lab               msb<<(4+lsb)
 ----------------------------------------------------------------------------
逗号运算符在所有运 |
算符中优先级最低   |  i=1,2            i=(1,2)                    (i=1),2

注意: 表达式中如果有布尔操作、算术运算、位操作等混合运算，始终应在适当的地方加上括号，使之清楚明了
注意: 所有的赋值符(包括复合赋值符)都具有右结合性。
注意: 在C语言中，跟顺序有关的问题，有些定义的很好，如优先级和结合性，
      有些则定义的很含糊，如大部分表达式里各个操作数计算的顺序就是不确定的，
      C语言的目的是为了让编译器设计者选取最合适的方法来产生最快的代码。
}
expertc(对链接的思考){
编译器驱动器(compiler driver)包括
  预编译器(preprocessor)
  语法和语义检查器(syntactic and semantic checker)
  代码生成器(code generator)
  汇编程序(assembler)
  优化器(optimizer)
  链接器(linker)
  驱动器程序(driver program)
优化器几乎可以加在上述所有阶段的后面。

约定由系统向程序提供一个接口，介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，称为应用程序二进制接口(Application Binary Interface,ABI).
ABI 保证运行良好的应用程序不会受同样运行良好的底层系统软件升级的影响。

动态链接的主要目的：把程序与它们使用的特定的函数库版本中分离出来。

1.动态链接库文件的扩展名是".so"，而静态库文件的扩展名是".a"
2.例如，你通过-lthread选项，告诉编译链接到libthread.so
  编译器被告知根据选项-lthread链接到相应的函数库，函数库的名字是libthread.so——"lib"部分和文件的扩展名被省掉了，但在前面加一个"l"。
3.编译器期望在确定的目录找到库
编译器查看一些特殊的位置，如在/usr/lib中查找函数库。
同时，编译器选项-Lpathname告诉链接器一些其他的目录，如果命令中加入了-l选项，链接器就
往这些目录查找函数库。同理-Rpathname选项也是如此。
同时系统中存在几个环境变量，LD_LIBRARY_PATH和LD_RUN_PATH，也用于提供这类信息，但出于
安全性、性能和创建/运行独立性方面的考虑，不提倡使用环境变量。
4.观察头文件，确认所使用的函数库
想要了解要链接到哪些函数库，一个好的建议是观察程序所使用的#include指令。
5.与提取动态库中的符号相比，静态库中的符号提取的方法限制更严
}
expertc(setjmp和longjmp){
这两个函数通过操纵过程活动记录实现，它们协同工作：
    1.setjmp(jmp_buf j)必须首先被调用。表示：使用变量j记录现在的位置。函数返回零。
    2.longjmp(jmpbuf j,int i)可以接着被调用。表示：回到j所记录的位置，使其像从原先的setjmp()函数返回一样。
        但是函数返回i，使代码能够知道它是实际上是通过longjmp()返回的。
    3.当使用与longjmp()时，j的内容被销毁。
setjmp保存了一份程序的计数器和当前的栈顶指针。也可以保存一些初始值。
longjmp恢复这些值，有效地转移控制并把状态重置回保存状态的时候。称为"展开堆栈(unwinding stack)"。
longjmp会导致转移，但和goto不同。
    1.goto语句不能跳出C语言当前的函数。
    2.用longjmp只能跳回到曾经到过的地方。
注：保证局部变量在longjmp过程中一直保持它的值的惟一可靠方法是声明为volatile。
    setjmp/longjmp最大的用途是错误恢复。
setjmp和longjmp使程序难以理解和调试，故非特殊需要，最好避免使用。
}
expertc(ctool){
检查源码的工具：indent(C程序美化器，和cb类似), 
                cflow(打印程序中调用者／被调用着的关系) 
                cscope(一个基于ASCII码C程序的交互式浏览器), 
                ctags(创建一个标签文件), 
                lint(C程序检查器), 
                vgrind(格式器，用于打印漂亮的C列表)
检查可执行文件的工具：
                dis(目标代码反汇编工具), 
                dump -Lv(打印动态链接信息), 
                ldd(打印文件所需的动态)， 
                nm(打印目标文件的符号列表)， 
                strings(查看嵌入二进制文件中的字符串), 
                sum(打印文件的校验和与程序块计数)
帮助调试工具：truss(打印可执行文件所进行的系统调用), 
                ps, ctrace(修改你的源文件，文件执行时按行打印), 
                debugger(交互式调试器), 
                file
性能优化工具：tcov(显示每条语句执行次数的计数), 
            time(实际时间和CPU时间), 
            prof(每隔程序所消耗时间的百分比), 
            gprof(调用图配置数据)
}
expertc(再论指针){
1. 表达式中数组名(与声明不同)被编译器当作一个指向该数组第一个元素的指针; 
    "表达式中的数组"就是指针
2. 下标总是与指针的偏移量相同
3. 在函数参数的声明中，数组名被编译器当作指向该数组第一个元素的指针
   "作为函数参数的数组名"等同于指针
4. 用a[i]这样的形式对数组进行访问总是被编译器"改写"或解释为像*(a+1)这样的指针访问
   这样做的根本原因不是指针比数组快，而是指针和偏移量才是底层硬件所使用的基本类型。
5. 多维数组初始化时，可省略最左边下标的长度(也只能是最左边)，如int rhubarb[][3] = { {0, 0, 0}, {1, 1, 1},};
6. sizeof(数组名)返回的是数组总的字节数
7. 指针数组必须用指向为字符串而分配的内存的指针进行初始化
8. 向函数传递一个一位数组：增加一个额外的参数或者赋予数组最后一个元素一个特殊的值
9. 向函数传递一个普通的多维数组：必须提供除了最左边一维以外多有维的长度。即多维数组最主要的一维长度不必显式书写。

char pea1[4][6];  // 表示pea是一个包含4个元素的数组，每个元素是一个char类型的数组
假设在编译器符号表中，pea的地址为9980，pea[i][j]引用时步骤：
    1.取i的值，把它的长度调整为一行的宽度(这里是6)，然后加到9980上。
    2.取j的值，把它的长度调整为一个元素的宽度(这里是1)，然后加到前面所得出的结果上。
    3.从地址(9980 + i*scale-factor1 + j*scale-factor2)中取出内容。

char *pea2[4];    //char *pea[4]的定义表示pea是一个包含4个元素的数组，每个元素为一个指向char的指针。
假设在编译器的符号表中，pea的地址为4624，pea[i][j]引用时步骤：
    1.取i的值，乘以指针的宽度(4个字节)，并把结果加到4624上。
    2.从地址(4624 + i*4)取出内容，为5081。
    3.取j的值，乘以元素的宽度(这里是1个字节)，并把结果加到5081上。
    4.从地址(5081 + j*1)取出内容。
    
char **pea3;      //int类型的指针的指针  pea3 = pea1         *(*(pea + i) + j)

实参              解释          所匹配的形参    解释
char c[8][10];  数组的数组   char (*c)[10];     数组指针
char *c[15];    指针数组     char **c;          指针的指针
char (*c)[64];  数组指针     char (*c)[64];     不改变
char **c;       指针的指针   char **c;          不改变
在上面几种定义中，都可以使用如pea[i][j]这样的形式，尽管在不同的情况中访问的实际类型并不相同。
尽管这几种下标形式在源代码里看上去是一样的，而且被编译器解释为同一种指针表达式，但它们在各自的情况下所引用的实际类型并不相同。

向函数传递一个一维数组
  1. 增加一个额外的参数，表示元素的数目(argc就是起这个作用)。
  2. 赋予数组最后一个元素一个特殊的值，提示它是数组的尾部(字符串结尾的'\0'字符就是起这个作用)。
     这个特殊值必须不会作为正常的元素值在数组中出现。
     
向函数传递一个二维数组
   1. 现在需要两个约定，其中一个用于提示每行的结束，另外一个用于提示所有行的结束。 
      提示单行结束可以使用一维数组所用的两种方法，提示所有行结束也可以这样。
   2. 但怎么知道指针到达了数组的最后一行了呢？
      可以增加一个额外的行，行内所有元素的值都是不可能在数组正常元素中出现的，能够提示数组超出了范围。
      当对指针进行自增操作时，要对它进行检查，看看它是否到达了那一行。
      另一种方法是，定义一个额外的参数，提示数组的行数。
      
1. 向函数传递多维数组参数的方法
方法一：my_func(int my_array[10][20]); # 它迫使函数只处理10行20列的int型数组。
想要的是一个确定更为普通的多维数组形参的方法，使函数能够操作任意长度的数组。
方法二：my_func(int my_array[][20]);   # 这样做法仍不够充分，因为每一行都必须正好是20个整数的长度
        my_func(int (*my_array)[20]);  
参数列表中(*my_array)周围的括号是绝对需要的，这样可以确保它被翻译为一个指向20个元素的int数组的指针，而不是一个20个int指针元素的数组。
my_func(char **my_array);              # 注意：只有把二维数组改为一个指向二维数组每行的指针数组的前提下才可以这样做！

注意： 指针数组这种数据结构的美感在于：它允许任意的字符串指针数组传递给函数，但必须是指针数组，
    而且必须是指向字符串的指针数组。这是因为字符串和指针都有一个显示的越界值(分别为NUL和NULL)，
    可以作为结束标记。
注意:  至于其他类型，并没有一种类似的通用且可靠的值，所以并没有一种内置的方法知道何时到达数组某一维的结束位置。
    即使是指向字符串的指针数组，通常也需要一个计数参数argc，记录字符串的数量。
方法四：char_array[row_size * i + j] = ...  # 一维数组模拟二维数组

总结：
一维数组——没有问题，但需要包括一个计数值或者是一个能够标识越界位置的结束符。被调用的函数无法检测数组参数的边界。
二维数组——不能直接传递给函数，但可以把二维数组改写为一个一维的指针数组，并使用相同的下标表示方法。对于字符串来说，这样做是可以的，对于其他类型，需要增加一个记数值或者能够标识越界位置的结束符。同样，它依赖于调用函数和被调用函数之间的约定。
三维或更多维的数组——都无法使用。必须把它分解为几个维数更少的数组。

2. 使用指针从函数返回一个数组
严格的说，无法直接从函数返回一个数组。但是，可以让函数返回一个指向任何数据结构的指针，当然也可以是一个指向数组的指针。
记住，声明必须在使用之前。一个声明的例子是：
int (*paf())[20];
这里，paf是一个函数，它返回一个指向包含20个int元素的数组的指针。 它的定义可能如下：

int (*paf())[20]{
    int (*pear)[20];
    pear = malloc(20*sizeof(int));
    return pear;
}
可以用这样的方法来调用函数：

int (*result)[20];
result = paf();
(*result)[3] = 12;
或者玩个花样，定义一个结构体(利用结构体可以整体赋值的特性)；

struct a_tag{
    int array[20];
}x,y;
struct a_tag my_func(){... return y;}
x = y;
x = my_func();
x.array[i] = 38;
千万要注意，不能从函数中返回一个指向函数的局部变量的指针
}
expertc(再论数组){ 
声明本身还可以进一步分成3种情况：
1. 外部数组(external array)的声明。
2. 数组的定义(定义是声明的一种特殊情况，它分配内存空间，并可能提供一个初始值)。
3. 函数参数的声明。

1a. 形式表现相同 (程序员对数组和指针的理解)
所有作为函数参数的数组名总是可以通过编译器转换为指针。
    注意: func(char a[]); == func(char a[10]); == func(char *a);
    my_function(int *turnip) {...}
    my_function(int turnip[]) {...}     # 语法糖
    my_function(int turnip[200]) {...}  # 语法糖
    注意1：编译器必须把数组形式改写成指向数组第一个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝。
    注意2：不管程序员实际所写的是哪种形式，函数并不自动知道指针所指的数组共有多少个元素，
          所以必须要有个约定，如数组以NULL结尾或者另有一个附加的参数表示数组的范围。
    int my_int; //数据定义
    int *my_int_ptr;
    int my_int_array[10];
    调用时的实参           | 类型                        | 通常目的
    -----------------------|-----------------------------|----------------------
    func(&my_int);         | 一个整型数的地址            | 一个int参数的传址调用
    func(my_int_ptr);      | 指向整型数的指针            | 传递一个指针
    func(my_int_array);    | 整型数组                    | 传递一个数组
    func(&my_int_array[i]);| 一个整型数组某个元素的地址  | 传递数组的一部分
    注意：处于func()函数内部，就没有一种容易的方法分辨这些不同的实参，因此也无法知道调用该函数是出于何种目的。

    int main(int argc, char **argv) == int main(int argc, char *argv[])
当一个数组名出现在一个表达式中时，它会被转换为一个指向该数组第一个元素的指针。
    注意: c = a[i]  == c = *(a+i) == p = a + i; c = *p.
    
使用数组(在语句或表达式中引用)时，数组总是可以写成指针的形式，两者可以互换。
2a. 形式表现不同 (程序员对数组和指针的理解)
   外部数组(external array)的声明
   定义 int a[10] = {0};
   声明 int a[]; # 而不是 int *a;
   
3a. 编译器对数组和指针的理解
   数组和指针在编译器处理时是不同的，在运行时的表示形式也是不一样的，并可能产生不同的代码。
   对编译器而言，一个数组就是一个地址，一个指针就是一个地址的地址。
   
4a. 数组下标是建立在指针的概念基础上的； 指针和偏移量是建立在硬件模型的基础上的；所以，编译器常对指针和数组一视同仁。
对数组的引用如a[i]在编译时总是被编译器改写成*(a + i)的形式。C语言标准要求编译器必须具备这个概念性的行为。
在表达式中，指针和数组是可以互换的，因为它们在编译器里的最终形式都是指针，并且都可以进行取下标操作。
数组下标是定义在指针的基础上的，所以优化器常常可以把它转换为更有效率的指针表达形式，并生成相同的机器指令。
C语言把数组下标改写成指针偏移量的根本原因是指针和偏移量是底层硬件所使用的基本模型。

注意: 把作为形参的数组和指针等同起来是出于效率原因的考虑。
      类似的，函数的返回值绝不能是一个函数、数组，而只能是指向数组或函数的指针。

注意: C中不存在真正的多维数组，只存在数组的数组。
@ 数组的数组 
当几个[]修饰符连续出现时(方括号里面是数组的范围)，就是定义一个多维数组。
1b. C语言的方法多少有点独特：定义和引用多维数组唯一的办法就是使用数组的数组。
2b. 在C语言中，可以像下面这样声明一个10*20的多维字符数组：
char carrot[10][20];
或者声明一种看上去更像数组的数组形式：
typedef char vegetable[20];
vegetable carrot[10];
单个字符都是通过carrot[i][j]的形式，编译器在编译时会把它解析为*(*(carrot+i)+j)的形式。
注意; C语言中多维数组最大的用途是存储多个字符串。
注意: 数组可以省略最左边下标的长度(也只能是最左边的下标)，编译器会根据初始化值的个数推断出它的长度。

1a1. 初始化二维字符串数组的方法：
char vegetables[][9] = {
    "beet",
    "barley",
    "basil",
    "broccoli",
    "beans"
};
2a2. 建立指针数组
char *vegetables[] = {
    "carrot",
    "celery",
    "corn",
    "cilantro",
    "crispy fried potatos"
}; 
3a3. 只有字符串常量才可以初始化指针数组。指针数组不能由非字符串的类型直接初始化：
int *weights[] = {
    {1,2,3,4,5},
    {6,7},
    {8,9,10}
}; //无法成功编译
注意: 因为指针数组使用"\0"来作为数组结束标识；而其他类型没有结束标识。
4a4. 如果想用这种方法对数组进行初始化，可以创建几个单独的数组，然后用这些数组名来初始化原先的数组：
int row_1[] = {1,2,3,4,5,-1}; // -1作为行结束标志
int row_2[] = {6,7,-1};
int row_3[] = {8,9,10,-1};
int *weights[] = {
    row_1,
    row_2,
    row_3
}; 

}
C99:
    C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型
的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x
格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char
型变元。ll和hh修饰符均可以用于n说明符。
    格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。格式如下：[-]0xh.hhhhp±d;
    

https://www.thinkage.ca/gcos/expl/c/lib/printf.html
Nout = printf(format[,arg1,arg2,...]);
const char *format;  描述如何格式化arg参数序列
arg1,arg2,...        待格式化的arg序列，如果占位符大于参数个数，会输出不可预期的结果；如果占位符小于参数个数，多于部分被忽略。
int Nout             printf输出的字符个数
自动会将 char short 转成 int, 自动会见 float 转成 double。
placeholders = %[modifiers][miniwidth][.precision]type
miniwidth: 最小宽度     
modifiers: 修饰符   flag
precision: 精度     
下面对组成格式说明的各项加以说明： 
1. %：表示格式说明的起始符号，不可缺少。 
2. -：有-表示左对齐输出，如省略表示右对齐输出。
3. 0：有0表示指定空位填0,如省略表示指定空位填。 
4. m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度。用于说明输出的实型数的小数位数。未指定n时，隐含的精度为n=0位。 
5. l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。

                                             指定对齐(justification) 填充(padding) 截断(truncation)功能
                                             输出宽度和对齐方向       仅限于小数数值类型
key(现代方法 -> 格式输出 printf){ -%m.pX   m:最小字段宽度(整数常量) p:精度(整数常量)    X:转换说明符(字母)
一般地，转换说明可以用%m.pX格式或%-m.pX格式，其中m和p都是整数常量，X是字母。m和p都是可选的，
        如果省略p，则m和p之间的小数点也需要去掉。  printf "%10.f\n" "1000.1"  #       1000
    最小字段宽度(minimum field width) m指定了要显示的最少字符数量。
      1. 如果要显示的数值所需的字符数小于m，那么值在字段内是右对齐的；printf "%2d\n" 1000   # 1000
      2. 如果字符数多于m，那么字段宽度会自动扩展。                    printf "%5d\n" 1000   #  1000
      3. 在m前面放上一个负号会导致左对齐。                            printf "%-5d\n" 1000  # 1000
    精度 (precision) p的含义依赖于转换说明符(conversion specifier)**X**的选择:
      d -- 指定小数点后应该出现的数字的个数
           (如果不足则会添加前导0)；
           如果省略p，则默认为1。                          printf "%e" 1.23456        # 1.234560e+00
      e -- 指定小数点后数字个数(默认值为6，会添加尾随0)；  printf "%e" 1.23456555557  # 1.234566e+00
           如果p为0则不显示小数点。                        printf "%le" 1.23456555557 # 1.234566e+00
      f -- 同e。
      g -- 指定小数点后有效数字的最大数量(不会添加尾随0)； printf "%g" 1.234561111   # 1.23456
           如果数值没有小数点后的数字，则不会显示小数点。  printf "%lg" 1.2          # 1.2

a. 格式化 格式化字符串
    * 和 placeholders 都需要argument参数与之对应  printf("%*d", width, num);     #       1000  C99
    %%                使用%可以转义%字符          printf("We had 100%% attendance!\n"); # We had 100% attendance!
                                                  printf("%f%%", 1.0/3); # 0.333333%。
    对于单精度数，使用%f格式符输出时，仅前7位是有效数字，小数6位． printf "%lf" 1.23456555557中·
    对于双精度数，使用%lf格式符输出时，前16位是有效数字，小数6位． printf "%lf" 1.23456555557中·
printf函数族的转换说明符由字符%和跟随其后的最多5个不同的选项构成：
b 1.标志(可选项，可多选)  Flag Characters
    -：在字段内左对齐(默认右对齐)
    ' ' 空白 : 若符号为正，则显示空格，负则显示"-" e.g. "% 6.2f"   printf "% f\n" "1000.1"   #  1000.100000
                                                                   printf "% f\n" "-1000.1"  # -1000.100000
    +：有符号数总是以+或-开头(默认只有负数以-开头) printf "%+d" 111111111    # +111111111
                                                   printf "%+d" -111111111   # -111111111
    ： 有符号数非负数值前加空格(选项会被+选项覆盖)
    #：o:八进制数以0开头，                                 1000 -> 01750 (1750)
       x|X: 十六进制非零数以0x或0X开头。                   1000 -> 0x3e8|0X3E8 (3e8|3E8)
       浮点数始终有小数点。不能删除由g或G转换输出的尾部零  printf "%g" 11    # 11
                                                           printf "%#g" 11   # 11.0000
       a,A,e,E,f,F,g,G  # 没有影响
    0：用前导零在数的字段宽度内进行填充(非空格)。1000 -> 0000001000(1000)  # "%010d"
                                                 -1000 -> -000001000(-1000) # "%010d" 
       如果flag同时存在"-"和 0 忽略0             1000 -> 1000(1000)  # "%-010d"
                                                 -1000 -> -1000(-1000) # "%-010d"
       如果flag同时存在precision, 0不被忽略       1000 -> 0000001000(1000)  # "%0.10d"
                                                 -1000 -> -000001000(-1000) # "%0.10d"
       d,i,o,u,x,X,a,A,e,E,f,F,g,G # 支持
       如果转换说明是d、i、o、u、x或X，而且指定了精度，那么可以忽略这个选项(此选项会被-选项覆盖)
c 2.区域最小字段宽度(可选项) "%" 符号之后第一个有效数字 # 除0
d 3.精度(可选项)             "%" 后 "." 符号之后第一个有效数字
e 4.长度修饰符(可选项)
    h(short int | unsigned short int)、l(long int | unsigned long int) L后面a,A,e,E,f,F,g,G (long double)
    C99新增：hh(signed char | unsigned char)、ll(long long int | unsigned long long int)、j(intmax_t uintmax_t)、z(size_t ssize_t)、t(ptrdiff_t)
f 5.转换说明符(必选项)
    d、i(int) i有符号十进制整数(与%d相同)
    o、u(无符号十进制整数)、x、X(unsigned)  
    e、E (double) [-]d.ddde_+dd
    f、F (double) [-]ddd.ddd [-]inf [-]infinity nan NaN [-]INF [-]INFINITY NAN* 浮点数(包括float和doulbe)
    # "%m.nf"：输出浮点数，m为宽度，n为小数点右边数位 
      printf "%3.1f" 3852.99 # 3853.0
    g、G (double) 6为数值，  浮点数不显无意义的零"0"
    a、A (double) [-]0xh.hhhhp_+  浮点数、十六进制数字和p-(P-)记数法(C99) # 0xh.hhhhp+d 0xh.hhhhp-d -0xh.hhhhp+d -0xh.hhhhp-d 
    c字符 
     # "%m.ns"：输出m位，取字符串(左起)n位，左补空格，当n>m or m省略时m=n
    s  printf "%7.2s" CHINA #      CH
    p、n
    C99新增：F、a、A
    
%n
Nothing printed. The argument must be a pointer to a signed int, where the number of characters written so far is stored.
意思是，不会打印任何东西。 这个参数必须是一个有符号整数的指针，它存储它出现之前打印的所有字符数。
printf "%s %n" "abcdefg" abc # echo $abc 此时输出abc为8

sprintf(pattern, "%%%dX%%n", inpos);

printf("blah %n blah\n", &val);   # blah blah
printf("val = %d\n", val);        # val = 5

int n; 
printf("%s: %nFoo\n", "hello", &n); 
printf("%*sBar\n", n, "");

①d格式：用来输出十进制整数。有以下几种用法： 
  %d：按整型数据的实际长度输出。 printf "%d" 123456 # 123456
  %md：m为指定的输出字段的宽度。
  如果数据的位数小于m，则左端补以空格，  printf "%10d" 123456 #     123456
  若大于m，则按实际位数输出。            printf "%1d" 123456  # 123456
  %ld：输出长整型数据。                  printf "%ld" 123456  # 123456
②o格式：以无符号八进制形式输出整数。对长整型可以用"%lo"格式输出。同样也可以指定字段宽度用“%mo”格式输出。
③x格式：以无符号十六进制形式输出整数。对长整型可以用"%lx"格式输出。同样也可以指定字段宽度用"%mx"格式输出。 
④u格式：以无符号十进制形式输出整数。对长整型可以用"%lu"格式输出。同样也可以指定字段宽度用“%mu”格式输出。
⑤c格式：输出一个字符。
⑥s格式：用来输出一个串。有几中用法 
  %s：例如:printf("%s", "CHINA")输出"CHINA"字符串(不包括双引号)。 printf "%s" "CHINA"   # CHINA
  %ms：输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部输出。若串长小于m，则左补空格。
  %-ms：如果串长小于m，则在m列范围内，字符串向左靠，右补空格。    printf "%10s" "CHINA" #      CHINA
  %m.ns：输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。 printf "%10.2s" "CHINA" #         CH
  %-m.ns：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n>m，则自动取n值，即保证n个字符正常输出。printf "%10.2s" "CHINA" # CH        
⑦f格式：用来输出实数(包括单、双精度)，以小数形式输出。有以下几种用法：
  %f：不指定宽度，整数部分全部输出并输出6位小数。 
  %m.nf：输出共占m列，其中有n位小数，如数值宽度小于m左端补空格。 printf "%10.2f" 3.14   #       3.14
  %-m.nf：输出共占n列，其中有n位小数，如数值宽度小于m右端补空格。printf "%-10.2f" 3.14  # 3.14      
⑧e格式：以指数形式输出实数。可用以下形式： 
  %e：数字部分(又称尾数)输出6位小数，指数部分占5位或4位。 
  %m.ne和%-m.ne：m、n和”-”字符含义与前相同。此处n指数据的数字部分的小数位数，m表示整个输出数据所占的宽度。
⑨g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。
  
读写短整形时，在前面添加字母h.
读写长整型时，前面添加字母l

%［标志］［输出最少宽度］［．精度］［长度］类型 "％-md" ：左对齐，若m比实际少时，按实际输出。
%[flags][min field width][precision][length]conversion specifier
  -----  ---------------  ---------  ------ -------------------
   \             #,*        .#, .*     /             \
    \                                 /               \
   #,0,-,+, ,',I                 hh,h,l,ll,j,z,L    c,d,u,x,X,e,f,g,s,p,%
   -------------                 ---------------    -----------------------
   # | Alternate,                 hh | char,           c | unsigned char,
   0 | zero pad,                   h | short,          d | signed int,
   - | left align,                 l | long,           u | unsigned int,
   + | explicit + - sign,         ll | long long,      x | unsigned hex int,
     | space for + sign,           j | [u]intmax_t,    X | unsigned HEX int,
   ' | locale thousands grouping,  z | size_t,         e | [-]d.ddde±dd double,
   I | Use locale's alt digits     t | ptrdiff_t,      E | [-]d.dddE±dd double,
                                   L | long double,  ---------=====
   if no precision   => 6 decimal places            /  f | [-]d.ddd double,
   if precision = 0  => 0 decimal places      _____/   g | e|f as appropriate,
   if precision = #  => # decimal places               G | E|F as appropriate,
   if flag = #       => always show decimal point      s | string,
                                             ..............------
                                            /          p | pointer,
   if precision      => max field width    /           % | %
}

printf(){
### 输出中占位符
转换说明|输出
--------|--
'%a' '%A'|浮点数、十六进制和p计数法(C99/C11)
'%c'|单个字符
'%d'|有符号十进制整数
'%e' '%E'|浮点数、e计数法
'%f'|浮点数，十进制计数法
'%g' '%G'|根据值的不同自动选择'%f'或'%e'
'%i'|有符号十进制整数和'%d'相同
'%o'|无符号八进制整数
'%p'|指针
'%s'|读入一个字符串、遇到空格、制表符或换行符结束
'%u'|无符号十进制整数
'%x' '%X'|无符号十六进制整数，使用十六进制数0f和0F
'%%'|读入%
'%zd'| 'size_t'类型

### printf()的标记
标记|含义
----|----
- | 待打印项左对齐，即从字段的左侧开始打印该项。`"%-20s"`
+ | 有符号值若为正，则在值前面显示加号；若为负，则显示减号。`"%+6.2f"`
空格| 有符号值若为正，则在值前面显示前导空格（不显示任何符号）；若为负则显示减号+标记覆盖一个空格。`"%6.2f"`
# | 把结果转换为另一种形式。`%o`则以0开始；`%x`或`%X`则以`0x`或`0X`开始；`%g`和`%G`防止结果后面的0被删除。
0 | 对于数值格式，前导0代替空格填充字段宽度。对于整数格式，如果出现`-`或精度，则忽略该标记

### printf()的修饰符
修饰符|含义
------|----
标记| 五种标记（'-'、'+'、'空格'、'#'和0），可以不使用标记或使用多个标记
数字| 最小字段宽度，如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段
.数字| 精度
h  | 和整型转换一起使用，表示'short int'或'unsigned short int'
hh | 和整型转换一起使用，表示'signed char'或'unsigned chart'
j  | 和整型转换一起使用，表示'intmax_t'或'uintmax_t'
l  | 和整型转换一起使用，表示'long int'或'unsigned long int'
ll | 和整型转换一起使用，表示'long long int'或'unsigned long long int'
L  | 和浮点数转换一起使用，表示'long double'类型的值
t  | 和整型转换一起使用，表示'ptrdiff_t'类型，'ptrdiff_t'是两个指针的差值的类型(C99)
z  | 和整型转换一起使用，表示'size_t'的值，'size_t'是'sizeof'返回的类型(C99)
}
printf(占位符){

##占位符 |%|对应类型| |---|---- |d|int |c|char |s|char * |f|float,double |p|指针类型 |lf|double |lu|unsigned long

    在printf的时候double类型可以用%f或%lf。而scanf的时候double要用%lf

当用%p输出指针地址的时候，格式是0x加上十六进制地址值。如果为空指针则打印**(nil)**。

###格式化串 "%a.bs"
    对于a,它表示如果字符串长度小于a,那么右对齐左边补空格，若大于a则原样输出不限制
    对于b，它表示如果字符串长度超过b，那么只取前b个

##参数压栈顺序 printf的参数压栈顺序是从右到左的，所以：
	char a[] = "abcde";
	char *p = a;
	printf("%c %c\n",*p,*(++p));

打印结果为：b b 
##格式化字符串
printf("%7.2s\n%-5.3s\n","hello","world");
printf("%.4s","jelly");

%7.2s表示输出的字符串占7个位置，右对齐，左补空格，输出2个字符。
%-5.3s表示输出的字符串占5个位置，左对齐，右补空格，输出3个字符。
##可变长度的格式化输出

int var = 5;
printf("%*d\n",var,123);
//等价于
printf("%5d\n",123);

printf动态指定长度信息的数字，采用”*”来占用一个本来需要一个指定宽度或精度的常数数字的位置,例如：
printf(s, "%.*s%.*s", 7, a1, 7, a2);或printf(s, "%.*s%.*s", sizeof(a1), a1, sizeof(a2), a2);
printf(s, "%-*d", 4, 'A'); # 产生"65 "
printf(s, "%#0*X", 8, 128); # 产生"0X000080"，"#"产生0X
printf(s, "%*.*f", 10, 2, 3.1415926); # 产生" 3.14"
printf("We had 100%% attendance!\n"); # We had 100% attendance!
printf("%*d", width, num);     #       1000  C99
printf("%2$*1$d", width, num); #       1000  Signle Unix Specification

}
printf(ANSI控制码){


##ANSI控制码 适用于Linux系统。用法比如：
printf("\33[1m hello world\33[0m");
控制码         说明
\33[0m      关闭所有属性
\33[1m      设置高亮度
\33[4m      下划线
\33[5m      闪烁
\33[7m      反显
\33[8m      消隐
\33[nA      光标上移n行
\33[nB      光标下移n行
\33[nC      光标右移n行
\33[nD      光标左移n行
\33[y;xH    设置光标位置
\33[2J      清屏
\33[K       清除从光标到行尾的内容
\33[s       保存光标位置
\33[u       恢复光标位置
\33[?25l    隐藏光标
\33[?25h    显示光标
\33[30m -- \33[37m  设置前景色
\33[40m -- \33[47m  设置背景色

###颜色码 格式： \033[X ;Y m …… \033[0m X (字背景颜色范围):40--49
40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色 46:深绿 47:白色
Y (字颜色):30--39
30:黑 31:红 32:绿 33:黄 34:蓝色 35:紫色 36:深绿 37:白色

##Trick ###printf("5432"+1) 这条语句看似无理，实则有理。输出是432。
"5432"是一个字符串。+1就是指针位置+1。相当于：
char a[] = "5432";
printf("%s",a+1);
}

rc = sscanf(buf, "%10s %d.%d", header, &version_major, &version_minor);
if ((rc == EOF) || (rc != 3)){
返回值：成功匹配和赋值变量的个数。
        返回的个数可以少于提供参数的个数。
        0 意味着此次匹配失败。
        EOF 意味着输入流结束 或者 意味着输入流出错，通过ferror或errno确认流出错原因。 
}
int sscanf(const char *s, const char *format, ...);
1、格式输入
sscanf("字符串","类型",&获取变量名);
将字符(字符串)以某种格式赋给变量，即某种格式获取字符串中的变量
2、获取指定长度的字符串
sscanf("字符串","%ns",&获取变量名);
获取字符串中的n个字符，赋给变量，(若字符串中字符个数 < n 则取最大值(即0—n))
3、获取指定内容
注：若第一个字符不在范围内则获取失败，一直获取到不在范围内的第一个字符为止
sscanf("字符串","范围",&获取变量名);
sscanf可以支持格式字符%[] 这为分析字符串提供了很大方便(其实scanf也支持%[])
(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字， %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母
(2)^: 表示不取，如：%[^1]表示读取除'1'以外的所有字符， %[^/]表示除/以外的所有字符
(3),: 范围可以用","相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母 
(4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %[^ ](注意^后面有一个空格)
(5)%*s%s:忽略第一个字符串， %s%*s忽略第二个字符串(用于两个字符串)

scanf("%[abcd]", ptr); # 如果输入一个字符串“cbadkjf”，那么ptr得到的字符串是cbad，kjf三个字符都属于定界符，输入到k字符时输入字符串被截断，kjf三个字符被留在stdin里面
scanf("%[^abcd]", ptr); # 如果输入字符串“jksferakjjdf”，ptr得到的字符串是“jksfer”。如果想限制输入字符串的字符数量，可以象s说明符那样，在[]前面使用位域，
scanf("%10[^abcd]", ptr); # 结果字符串最多只能包含10个字符(除'/0'字符外)。
    [符号可以作为扫描列表中的一个成员，但]字符除紧贴最左边的[字符或抑扬符两种情况外，其余情况下都不会被看作扫描列表的成员。
例如“%[]abcd]”或者“%[^]abcd]”，上述两种情况下]字符属于扫描列表的成员，

    众所周之，scanf以空白字符为定界符，但如果输入的字符串是以其它字符为定界符的，那怎么办？
[]就是专门处理这个问题的转换说明符。[]转换说明符可以通过两种方式产生结果字符集，如果第一个
[字符右边没有抑扬符（^），那么处于[]之间的字符就是结果字符集，不在其中的可输入字符都作为
定界符；如果左边[符号紧靠一个抑扬符（^），那么意义相反，^和]之间的字符是定界符，其余可输入
字符是结果字符集。

fscanf(fd,"%*[^/n]/n");//%*是虚读，没有存，只是让指针跳过了这个变量！
%n说明符输出有效字符数量，%n在scanf和printf中都可使用。与%n相对应的形参是一个int类型的指针，%n不影响scanf和printf的返回值。
例如：
scanf("%d %d%n", &i, &j, &k);
如果输入434 6434，则k等于8，而scanf的返回值仍然为2。又如：
scanf("%c%n", &ch, &k);
输入“sbcdefdg”后，k等于1，而不是8，因为%c只取一个字符，%n输出的是有效字符数量。

  # "*"表示该输入项读入后不赋予任何变量，即跳过该输入值。
  # "宽度"表示输入读入字符的长度，对于整型表示截取相应宽度的数字赋给后面列表中的相应变量；
  对于字符型表示读入相应长度的字符后把第一个字符赋给相应的变量，其余的自动舍弃。
  例如scanf("%2d%3d",&a, &b);如果输入为12345则将12赋给a，将45赋给b；
      scanf("%2c%3c",&a, &b);如果输入为12345则将'1'赋给a，将'3'赋给b .
"%s"       整个输入作为一个串,并设置末尾的'/0'
"%ns",     n为整数,读入的串最长不超过n,然后在末尾补'/0'
%nf        读入的浮点数最多有n位整数,位数多于n,会截断。
"%n[a-z]"  读入最多n个字符,如果遇到非a-z的字符,停止
"%[^=]"    读入任意多的字符,直到遇到"="停止
"%n[^=]"   读入"="号前的至多n个字符

sscanf("hello word c!","%*s%s",&num1); # 忽略第一个字符串,只获取第二个字符串
sscanf(buf, "%*s %d", &status)         # 
sscanf(arr,"%[a-z,1-5]s",&num2);            # 获取字符串arr中的a~z,或1~5中的字符
sscanf(buf, "%255s %d", proto, &status);    # 获取长度最多255的字符串，在获取一个数值
sscanf(line, "%255s %1023s HTTP/%3[1.0]", method, url, protocol) # 获取长度最多255的字符串 获取长度最多1023的字符串 获取长度最多3的字符串
sscanf(buf, "%10s %d.%d", header, &version_major, &version_minor); # 获取长度最多10的字符串 数值.数值
sscanf(cursor, "%d %63s %1023s ", &index, type, name)
sscanf(line, "%255[^:]: %"PRIu64" %255[^:]: %"PRIu64, label1, &operations, label2, &bytes) # 获取最长255个不包含:的字符串。
sscanf(line, " %255[^:]: %"PRIu64" %*u %*u %"PRIu64 " %"PRIu64" %*u %*u %"PRIu64, name, &operations, &bytesSent, &bytesReceived, &time) 
sscanf(line, "%"PRIu64" %"PRIu64" %"PRIu64" %"PRIu64" %"PRIu64" %*u %*u %"PRIu64"", &readBytes, &writeBytes, &readOperations, &writeOperations, &waitTime, &runTime) 
sscanf(tmp + 4, "\t%d\t%d", &(proc->uid), &(proc->euid))
sscanf(tmp + 4, "\t%d", &(proc->gid))
sscanf(line, "MemTotal: %"PRIu64, &systeminfo.memory.size)
sscanf(buf, "%*s%*[: ]%d", &content_length)
sscanf(arr,"%1s",&num1);//获取arr中的1个字符，赋给num1
sscanf(arr,"%d",&num1);//字符49->数值1，将arr中的字符串转化成整型，赋给num1

sscanf(utsname.release, "%d.%d.%d", &osrel, &osvers, &ossub)
sscanf(linebuf, "%19s %255[^#]",tagname, tagvalue); # 配置文件        key value
sscanf(line, "VmData: %lld", &(curtask->mem.vdata));
sscanf(line, "%*s %llu", &dskwsz);
sscanf(curname, "%[^/]/host%d/bus%d/target%d/lun%d", cutype, &hostnum, &busnum, &targetnum, &lunnum);
sscanf(linebuf, "%511[^:]: %lld\n", label, &value)  # 以:作为分隔符的 key:value

key(现代方法 -> 格式输入 scanf){
    调用scanf函数是读数据的一种有效但不理想的方法。许多专业C程序员会避免用scanf函数，
而是采用字符格式读取所有数据，然后再把它们转换成数值形式。
    在寻找数据的起始位置时，scanf函数会忽略空白字符(包括空格、制表符、换页符、换行符)。
    当scanf函数遇到一个不可能属于当前项的字符时，会把此字符放回原处并结束当前项的读取，
以便在扫描下一个输入项或下一次调用时再次读入。因此，scanf函数会保留数据之后的空白字符，
从而会在下一次读取时碰到。
转换说明%i也可以用于读写整数，但是它可以匹配八进制、十进制、十六进制表示的整数：
    如果输入的数有前缀0，则将其作为八进制数来处理；
    如果输入的数有前缀0X或0x，则作为十六进制数来处理；
    如果以上两者都不满足，则作为十进制数处理，此时与%d相同。
浮点型的读写
  %e、%f、%g —— 读取单精度浮点数
  读取double时，在e、f、g前放置字母l
  当读写long double 时，在前面放置字母L
  
  # scanf的格式控制的一般形式为：%[*][宽度][F|N][h|l]类型字符

  "%%" 表示一个"%"
### scanf()转换说明
转换说明|含义
--------|----                                  
'%c'                | 字符                     
'%d'                | 有符号十进制整数         十进制形式
'%e' '%f' '%g' '%a' | 浮点数(C99添加了'%a')    float
'%E' '%F' '%G' '%A' | 浮点数(C99添加了'%A')    
'%i'                | 有符号十进制整数         十进制形式，十六进制形式，八进制形式
'%o'                | 有符号八进制整数         八进制形式
'%p'                | 指针、地址               
'%s'                | 字符串                   没有空白的字符串
'%u'                | 无符号十进制整数         无符号十进制形式
'%x' '%X'           | 有符号十六进制整数       无符号十六进制性
%[]                 | 一个字符集 
%%                  | 一个精度符号

### scanf()转换的修饰符
转换说明|含义
--------|----
*       | 抑制赋值，放在'%'和转换字符之间时，会跳过相应的输出项
数字    | 最大字段宽度。输入达到最大宽度或第一次达到空白符时停止
hh      | 整数作为'signed char' 或 'unsigned char'                # d, i, o, u, x, X, or n
ll      | 整数作'long long' 或'unsigned long long'
h、     | short int | unsigned short int                          # d, i, o, u, x, X, or n
l       |  long int or unsigned long int                          # d, i, o, u, x, X, or n
f e g   | double
lc ls   | wide charactor wide string
L       | long double 或者 long long
j       | 在类型转换说明后面时，表明使用'intmax_t'或'uintmax_t'。'%zd'、'%zo'
z       | 在类型转换说明后面时, 表明使用'sizeof'的返回值                     size_t
t       | 在类型转换说明后面时， 表明使用表示两个指针差值的类型。'%td'、'tx' ptrdiff_t
}
key(现代方法 -> fget和scanf){
使用fgets函数读入一整行，fgets函数可以读入空字符，并且会在末尾末尾存储一个空字符。fgets函数特点如下：
  fgets函数不会在开始读字符串之前跳过空字符(scanf会跳过)。
  fgets函数会持续读入直到找到换行符才停止(scanf会在任意空白字符处停止)。
  fgets函数会忽略换行符，而不会把它存储到数组中，用空字符代替换行符。
}
key(现代方法 -> 为什么使用%lf读取double类型的值，而用%f进行显示){
    C语言更倾向于使用double类型，float类型则被看成二等公民，经典C要求所有浮点计算都采用双精度的格式。
scanf和printf函数都是变长参数列表函数，当调用带可变长度参数列表的函数时，编译器会安排float参数自动
转换为double类型，其结果是printf函数无法区分float类型和double类型的参数，因而在printf函数调用中%f既
表示float又表示double类型的参数。
    另一方面，scanf函数是通过指针指向变量的，这时float类型与double类型的区别是非常重要的，因此%f告诉
scanf函数在所传地址位置存储一个四字节的float类型值，而%lf告诉scanf函数在该地址上存储一个八字节的double
类型值。
}
key(现代方法 -> 赋值){
在许多编程语言中，赋值是语句；在C语言中，赋值就像+那样是运算符。
换句话说，赋值操作产生结果，就如同两个数相加产生结果一样。赋值表达式v=e的值就是赋值运算后v的值。

    赋值运算符要求它的左操作数必须是左值。左值表示存储在计算机内存中的对象，而不是常量或计算出的结果。
    C语言有一条不同寻常的规则，那就是任何表达式都可以用作语句。换句话说，不论表达式是什么类型，
计算什么结果，我们都可以通过在后面添加分号的方式将其转换成语句。例如：++i;
}
key(现代方法 -> 语句类型){
return语句 —— return加表达式
表达式语句 —— 表达式直接加上分号
选择语句 —— if、switch
重复语句 —— while、do、for
跳转语句 —— break、continuew、goto
复合语句 —— 多条语句放在{和}之间组合而成
空语句 —— 只有分号的语句
}
key(现代方法 -> 逻辑表达式){
    在许多编程语言中，类似i < j这样的表达式都具有特殊的布尔类型或逻辑类型，这样的类型只有两个值，即假和真。
而在C语言中，诸如i < j这样的比较运算会产生整数：0（假）或1（真）。同样，==运算符产生的结果也是0或者1，
根据i是否小于、等于或大于j，表达式(i >= j) + (i == j)的结果分别是0、1或2。
    由于<运算符是左结合的，表达式i < j < k等价于(i < j) < k，首先检测i是否小于j，然后用比较后的结果（0或1）
来和k进行比较，也就是说这个表达式并不是检测j是否位于i和k之间。
}
key(现代方法 -> 结构体中的比特位){
C语言可以直接定义：
struct file_data {
    unsigned int day: 5;
    unsigned int month: 4;
    unsigned int year: 7;
};
或者使用更加简化的声明：
struct file_data {
    unsigned int day:5, month:4, year:7;
}
出于可移植性考虑，应该的把所有的位域声明为unsigned int或signed int。在C99中位域可以具有类型_Bool。
}
key(div|mod){
x/y x%y当两个操作数符号不同时，由C语言内建运算符所得出的返回值取决于具体编译器的实现。
C语言标准只是强调，如果x/y是可表示的，那么(x/y)*y+x%y必须等于x。

  取余运算在计算商值向0方向舍弃小数位
  取模运算在计算商值向负无穷方向舍弃小数位
同时，也可以这样理解：
  取余，遵循尽可能让商大的原则
  取模，遵循尽可能让商小的原则

-13/5 = -2 则，-13%5 -> -13-(-2)*5 = -3  # 向负无穷大舍入
-13/5 = -3 则，-13%5 -> -13-(-3)*5 = 2   # 向零舍入

-13/5       返回为不超过z(-2.6)的最大值。

1. ceiling(x,y)返回不小于x/y的实数商的最小整数 - 只支持小数
double ceil(double x);
float ceilf(float x);
long double ceill(long double x);

2. floor(x,y)  返回不大于x/y的实数商的最大整数 - 只支持小数
double floor(double x);
float floorf(float x);
long double floorl(long double x);

# 向零舍入                                     - 只支持整数
div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(long long numerator, long long denominator);
div_t q = div(-5, 3); ->  q.quot and q.rem are -1 and -2

在C99中，除法的结果总是向零截取的(-9/7的结果是-1)，i%j值的符号与i的相同(-9%7的结果是-2)。
}
key(realloc){
1. realloc和动态数组VLC
realloc能够对一个现在的内存块大小进行重新分配(通常是使之扩大)，同时不会丢失原先内存块的内容。
当需要在动态表中增长一个项目时，可以进行如下操作：
1.对表进行检查，看看它是否真的已满。
2.如果确实已满，使用realloc()函数扩展表的长度。并进行检查，确保realloc()操作成功进行。
3.在表中增加所需要的项目。

void * realloc ( void * ptr, size_t new_size );
注意: 
1.在实践中，不要把realloc()函数的返回值直接赋值给当前指针。如果realloc()函数失败，它会使该指针的值变成NULL，这样就无法对现有的表进行访问。
2.当一个大型表突然需要增长时，系统的运行速度可能会慢下来，而且这在什么时候发生是无法预测的。内存分配成倍增长是最关键的原因。
3.重分配操作很可能把原先的整个内存块移到一个不同的位置，这样表中元素的地址便不再有效。为避免麻烦，应该使用下标而不是元素的地址。
4.所有的"增加"和"删除"操作都必须通过函数来进行，这样才能维持表的完整性。只是这样一来，修改表所涉及到的东西就比仅仅使用下标要多得多。
5.如果表的项目数量减少，可能应该缩小表并释放多余的内存。这样内存收缩的操作对程序的运行速度有很大的影响。每次收缩表时，编译器最好能够知道任一时刻表的大小。
6.当某个线程对表进行内存重新分配时，你可能想锁住表，保护表的访问，防止其他线程读取表。对于多线程代码，这种锁总是必要的。

关于realloc的行为方式，结合源码总结为：
1. realloc失败的时候，返回NULL；
2. realloc失败的时候，原来的内存不改变，也就是不free或不move，(这个地方很容易出错)；
3. 假如原来的内存后面还有足够多剩余内存的话，realloc的内存=原来的内存+剩余内存,realloc还是返回原来内存的地址;
假如原来的内存后面没有足够多剩余内存的话，realloc将申请新的内存，然后把原来的内存数据拷贝到新内存里，原来的内存将被free掉,realloc返回新内存的地址；
4. 如果size为0，效果等同于free()；
5. 传递给realloc的指针可以为空，等同于malloc；
6. 传递给realloc的指针必须是先前通过malloc(), calloc(), 或realloc()分配的。
}
expertc(库函数和系统调用){
函数库调用                        | 系统调用
----------------------------------|----------
所有的ANSI C编译器中，C函数库相同 | 相关各个操作系统
调用函数库的一个程序              | 调用系统内核的服务
与用户程序相关联                  | 操作系统的一个进入点
在用户地址空间执行                | 在内核地址空间执行
运行时间属于"用户"时间            | "系统"时间
过程调用，开销小                  | 内核上下文切换，开销大
C函数库libc有300个程序            | Unix中有90个系统调用
----------------------------------|----------
}
key(enum){
enum PROTO
{
    PROTO_HTTP,
    PROTO_FTP,
    PROTO_SMTP,
    PROTO_SSH,

    PROTO_NUM  /* 表示协议数量 */
};

int nCntProto[PROTO_NUM];
---------------------------------------
}

expertc(类型升级){
注意: 1. 整型升级：char，short int或者int型位段，包括它们的有符号或无符号类型，以及枚举类型，
      可以使用在需要int或unsigned int的表达式中。如果int可以完整表示原类型的所有值，那么该原类型
      的值就转换为int，否则转换为unsigned int。
注意: 2. 算术转换: 操作数类型为算术类型的双目运算符会引发转换，并以类似的方式产生结果类型。
      首先，如果其中一个操作数的类型是long double，那么另一个操作数也被转换为long double。
      其次，如果其中一个操作数的类型是double，那么另一个操作数也被转换为double。
      再次，其中一个操作数的类型是float，那么另一个操作数也被转换为float。
      否则，两个操作数进行整型升级，执行下面的规则：
      如果其中一个操作数的类型是unsigned long int，那么另一个操作数也被转换为unsigned long int。
      其次，如果其中一个操作数的类型是long int，而另一个操作数的类型是unsigned int，
            如果long int能够完整表示unsigned int的值，那么unsigned int类型操作数被转换为long int，
            如果long int不能完整表示unsigned int的值，那么两个操作数都被转换为unsigned long int。
      再次，如果其中一个操作数的类型是long int，那么另一个操作数也被转换为long int。
      再再次，如果其中一个操作数的类型是unsigned int，那么另一个操作数也被转换为unsigned int。
      如果以上情况都不属于，那么两个操作数都为int。
      
      浮点操作数和浮点表达式的值可以用比类型本身所要求的更大的精度和更广的范围来表示，而它的类型并不因此改变。
      
注意: 3. 对无符号类型的建议: 
a.尽量不要在代码中使用无符号类型，以免增加不必要的复杂性。尤其是，不要仅仅因为无符号数不存在负值而用它来表示数量。
b.尽量使用像int那样的有符号类型，这样在涉及升级混合类型的复杂细节时，不必担心边界情况(如-1被升级为非常大的正数)。
c.只有在使用位段和二进制掩码时，才可以用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号数或者无符号数，这样就不必由编译器来选择结果的类型。

#include <stdio.h>

int array[] = {23,34,12,17,204,99,16};
#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))

int main(){
    int d=-1,x=0;
    if(d <= TOTAL_ELEMENTS -2)
        x = array[d+1];
    printf("%d",x);
    return 0;
}
编译输出警告：
warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
出现原因:
TOTAL_ELEMENTS所定义的值是unsigned int类型(因为sizeof()的返回类型是无符号数)。
if语句在signed int和unsigned int之间测试相等性，所以d被升级为unsigned int类型，
-1转换成unsigned int的结果是一个非常大的正整数，导致表达式的值为假。

if(d <= (int)TOTAL_ELEMENTS -2)
}


#include <stdio.h> 
int main() { 
unsigned int a; 
a = -1; 
printf("a = %d\n", a); # -1
 return 0; 
 }
key(数据的存储与表示-数据的存储){
任何计算机问题都可以用分层思想解决，赋值语句 a = -1; 和打印语句 printf("a = %d\n", a); 可以说是位于不同层次的操作
1. 赋值语句只负责把数据按一定的规则放入内存，不关心数据的含义，属于低级操作。
2. 高级函数 printf 按照指定格式把数据输出。
也就是说赋值语句a=-1;把-1作为一个整型常量，按照补码的方式存入了a对应的空间中。很显然,-1在内存中存的就是 1111 1111 1111 1111 1111 1111 1111 1111。
赋值语句才不管你这是正数还是负数、是奇数还是偶数、是质数还是合数……只要这是一个整型常量，赋值操作就存储其对应的补码形式，它就是这么天真、单纯。
此时内存中这 32 条 1 根本就没有正负或类型之分，它就只是"32条1"，仅此而已。
}
key(数据的存储与表示-数据的表示){
    如果机器(计算机)只是"自己玩自己的"，那就根本不会存在"数据的表示"这一说法，正是由于要进行人机交互，同样的 0 和 1 才会「变成」文字、
图片、视频、声音、灯的亮灭、电平的变化等人类可感知到的信号。对于命令行打印而言，printf 语句就担当了"翻译官"重任。
    当用 %d(十进制有符号整数)去打印一个数据，这时候就要关心数据的正负了，具体表现为程序将内存中最高位的二进制当做符号位，
根据符号正负将二进制补码转换为十进制数再打印输出(正负数补码转换规则不同)。如果把 1111 1111 1111 1111 1111 1111 1111 1111 
当做有符号数，就是 -1，如果当做无符号数(用 %u 打印),他就是 4294967295(直接把"32条1"转换为十进制数)。
    同样的数据，用不同的方式打印得到的结果不同，数据的存储是一回事，而数据的表示是另外一回事。打印结果从 -1 变成了
4294967295，并不代表数据发生了改变(事实上如果不用 = 去写这块空间的话，数据是不会变的)，对数据的解析方式决定了
数据的显示结果，眼见不一定为实。

    数据的存储与表示就像编码与解码，只有用同一种规则对数据进行读写、显示才能消除歧义，保证程序的正确性。
}
key(数据的存储与表示-变量类型的作用){
1. 定义变量的存储空间大小(如 char 类型的 -1 是 8 个 1， 而 int 类型的 -1 有 32 个 1)
2. 定义指针变量可访问范围的大小(如 int * 类型的变量能访问一块 4 个字节的空间)
3. 定义变量的取值范围，便于编译器做数值溢出判断 —— 只要变量在取值范围内并且使用相同的类型进行存储与表示，程序就能正常工作(如 char 的范围是 -128 到 127， 用 unsigned int 定义就用 %u 打印，上面是故意制造错误来探究本质)
4. 定义了变量转换为二进制(读写)的规则(如 int 型的 1 和 float 型的 1.0 在内存中的二进制表示是不同的)
5. 定义了变量所能执行的操作(如 % 运算只能用于整型数据)

废话了那么多其实只是想说明一件事：数据在内存中存着什么就是什么，用什么形式表示就看到什么，两者独立、互不干扰。
}
# 斯坦福 https://github.com/zyxstar/md_note/blob/master/docs/Language/C/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F(stanford_cs107).md#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BA%95%E5%B1%82%E8%A1%A8%E7%A4%BA
         https://github.com/nrosiello/Stanford-CS107

遇到整型基本作为 int，遇到浮点型基本作为 double 来考虑。
key(数据的底层表示:stanford_cs107){
char      1   byte
short     2   bytes
int       4   bytes 
long      4   bytes 
long long 8   bytes 
float     4   bytes 
double    8   bytes 

二进制计算对应规则
1    1    1    1       1    1    1    1
128  64   32   16      8    4    2    1
2^7  2^6  2^5  2^4     2^3  2^2  2^1  2^0

1. char 类型可以存放小于等于127的值            至少8位
2. short int和int可以存放小于等于 32,767的值   至少16位
3. long int可以存放小于等于为2,147,483,647     至少32位
4. int 类型所代表的天然机器字长；这是多数整型变量的当然之选。
5. 任意指针的大小占sizeof(long)个字节, 指针类型本质是long类型，
    在64bit cpu, sizeof(long)=64, sizeof(int)=32; 
    在32it cpu, sizeof(long)=32, sizeof(int)=32;
6. C++11定义了long long 类型，在32bit cpu ：sizeof(long long) = 64;
7. 64bit arm : float:4; double:8; int:4; short:2; long long:8 long:8; 
   和32bit arm比较，只有 long 大小变了，其它的不变，long long 也不变；
8. C++ Primer 说明
字节(char)：可寻址的最小内存块，一般是8bit;
字：   内存读写的基本单元(如果写单个字节会截断)，一般是32bit 或 64bit, 取决于CPU和数据总线；
类型： 决定了该如何解释内存中的bit内容；
float:  在32bit/64bit cpu中一般都是32bit，带符号，单精度, ( sign << 31 ) | ( exp << 23 ) | ( fract & 0x007fffff ), 32bit = 1bit sign + 8bit exp + 23bit M;
double: 在32bit/64bit cpu中是64bit, 带符号，双精度；64bit = 1bit sign + 11bit exp + 52bit M;
short: 2字节；
int : 32 bit 带符号，[INT_MIN, INT_MAX]  <climits><cfloat>, 在32bit/64bit cpu中一般都是32bit
字符型: char, signed char[-128, 127], unsigned char,  其中 char 到底是等价于signed char 还是 unsigned char 取决于编译器；
规则： 在算术表达式中不要使用char 和 bool; 浮点运算用double, 因为double的运算代价和float一样的。signed/unsigned只针对整型，float没有这个说法；

9.float 浮点数的二进制表示：f = s * M * 2^e; 其中M是有效数字1 <=M < 2;M=1.xxxxx,M的精度是2^(-23)，23位10进制小数(0.00000011920928955078125)
在计算机内部保存时，只保存后面的.xxxxx部分，
32bit = 1bit sign + 8bit exp( 指数,2为底) + 23bit(有效数字M). 其中,指数部分的真实值 = 指数内存值 - 127;

要查看1个float数的内存值很简单： printf("0x%x ",  *(unsigned int*)&f);
float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +1.70E+38,  比 long long 整型的范围还大。所以整型赋值给float不会溢出(但会丢失精度)，反之会溢出。
[-16777216, 16777216]这个范围的整数可以精确的用float表示，超过范围会丢失精度。
eg: (12.375)10 = (12)10 + (0.375)10 = (1100)2 + (0.011)2 = (1100.011)2=(1.100011)2 * 2^3 //10进制小数转二进制小数
eg: 88.8  =>   0x42b1999a,  0.0 => 0x00000000;  负浮点数存储和正浮点数只差1个符号位，其它位完全一致，
eg: -88.8 =>   0xc2b1999a   -0.0 =>0x80000000;   
eg: float f = 0.123456788888888f; 初始值
printf("%f", f); //=0.123457 这仅仅是显示的问题，float 能表示的10进制真实小数位数是23位，但不意味精度可以达到23位，实际精度是8位。
printf("%.20f", f);//0.12345679104328155518 和初始化值不同，因为初始化值是实数，实数转为float会丢失精度(最大丢失精度是10^-8);
# cout.precision(20);cout << f; //0.12345679104328155518

float f  = 0.123456786000000f; //f ==0.12345678359270095825
float f2 = 0.123456780000000f; //f2==0.12345678359270095825 注意f2和f的初始化不一样，但结果一样，因为丢失了精度，精度在8~9位小数。


sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
Type   (bits)   signed          signed          unsigned
char    8       -127            127             255
short   16      -32,767         32,767          65,535
int     16      -32,767         32,767          65,535
long    32      -2,147,483,647  2,147,483,647   4,294,967,295
类型最大最小值： <limits.h>
<inttypes.h>

int8_t   -> signed char 
uint8_t  -> unsigned char
short 推荐使用 int16_t or uint16_t 类型.
int   推荐用 int32_t 和 uint32_t类型开发. 
long 声明变量的时候用!长整型 x86上四字节, x64上8字节. 一定不比int字节数少.  C99之后出现long long类型8字节.
声明变量的时候用! 四字节. 精度是6-7位左右.  
声明变量的时候用!八字节,精度在15-16位左右.有的时候压缩内存用float代替.
}
key(负数的表示:反码和补码:stanford_cs107){
原码  最高位为符号位
反码  符号位不变，其它取反
补码  在反码的基础上加1

如果用反码来表示负数，试计算short数据类型的15+(-15)
15:  00000000 00001111
-15: 11111111 11110000
0:   11111111 11111111
导致0有两种表示，更好的方式是使用补码，取反加1
15:  00000000 00001111
-15: 11111111 11110001
0:  100000000 00000000
正负数相加时，因为先取反，则两者&时，会出现16位1，再加1，则发生多米诺效应，第17位进位丢失，留下16位0。
同时负数取反加1即为它的绝对值(正数)

计算机内部全部用补码来计算
正数的补码就是原码
负数的补码为：除去符号位，先取反码，再加1
其实负数的补码 转换到 原码，也可采取 取反再+1，这样比-1再取反容易操作
}

key(类型转换:expertc){
1.变量拷贝与内存共享：
int i = 8; float f = i; 
//这是拷贝，把i 的值取出来，赋给f，f = 8; 两者的数学值相等，
但f在内存中的二进制值和i的二进制值不同，i是0x8，而f是0x41000000;

int i = 8; float f = *((*float)&i); 
// 这是内存共享(union)， f != 8; f = 1.12104e-44; 两者的二进制内容相同都是0x8，
但是得到的数学值不同. 运算结果取决于数学值；

int i = 8; float f; memcpy(&f, &i, sizeof(float)); 
//f = 1.12104e-44 内存拷贝的效果类似于内存共享。

总结：1)数据类型不同，同样的内存值，数值不同，运算结果不同；
      2)地址共享不会改变内存值；
      3)Type t = 8; t 的内存值不一定是0x8;
}

注意: 值的类型并非值本身所固有的一种特性，而是取决于值的使用方式。
key(类型转换:stanford_cs107){
非负数的转换
  多byte转成少byte时，发生 截断(丢失高位)
    short s = 321; /*00000001 01000001*/
    char ch = s;
    printf("%c", ch); -- 65
  少byte转成多byte时，原值按位拷贝，高位用0补
    char ch = 'A'; /*01000001*/
    short s = ch;
    printf("%d", s);  -- 65
    
负数转换
  多byte转成少byte时(截位最高位为1时)，情况不确定(window/linux C是 截断，成为 负数 )
    int i = 98305; /*00000000 00000001 10000000 00000001*/
    short s = i;
    printf("%d", s); -- -32767
  少byte转成多byte时，原值按位拷贝，高位用1补(可以和上面[非负数的少转多]统一描述为不足
的高位以符号位补[称为 符号扩展])short s=-1; int i=s;
    short s = -1; /*11111111 11111111*/
    int i = s;
    printf("%d", i); -- -1
    
整型与浮点型转换
  直接进行赋值，而类型不同，因此会先计算出来值，然后转换一种类型表示出来，底层byte pattern发生变化.
    short s = 5;
    float f = s;
    printf("%f", f); -- 5

  将内存中byte强制为某类型
    总的来说就是 字节拷贝，大小尾系统 没有 区别，因为 地址&总指向 最低 字节
    int i = 98305; short s = *(short*)&i; 保留低位，丢失高位
      int i = 98305; /*00000000 00000001 10000000 00000001*/
      short s = *(short*)&i;
      printf("%x %x %d", i, s, s); /* 18001 ffff8001 -32767 */
    int i = 1078523331; float f = *(float*)&i; 意义完全不同，变成极小的数(见下节float表示)
      int i = 1078523331; /*01000000 01001000 11110101 11000011*/
      float f = *(float*)&i;
      printf("%f", f); /*3.14*/

  如何得到i = 1078523331
     union ufloat {
     float f;
     int i;
     };
     union ufloat uf;
     uf.f = 3.14;
     printf("%d", uf.i);
  double d = 3.1416; char c = *(char*)&d; 保留1byte低位，其余丢失
    double d = 3.1416;
    char c = *(char*)&d;
    printf("%c", c);
  short s = 45; double d = *(double*)&s; 比较危险，越界访问s后面6byte空间
}
key(float的表示:stanford_cs107){
3部分构成：表示为(-1)^s * 1.f * 2^(e-127)

|               |长度   |表示为 |说明                        |
|---------------|-------|-------|----------------------------|
|符号位sign     |1 bit  |__s__  |                            |
|指数Exponent   |8 bits |__e__  |(2^(e-127))  范围为-127~128 |
|有效位Mantissa |23 bits|__f__  |(2^-1 + 2^-2 + ...)         |

示例：
0 00010110 01100000000000000000000
=
(-1)^0 * 1.(2^-2+2^-3) * 2^(2^1+2^2+2^4-127)
注意: 如何分解float，假如7.0，则需要确保f为1.XXX，指数位为-127~128之间
7.0 =   7.0 * 2^0   =   3.5 * 2^1   =   1.75 * 2^2

浮点数是由下面四个元素组成的：
组件  组件描述
S   符号 ( +/- )
b   指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...
e   指数，一个介于最小值 emin 和最大值 emax 之间的整数。
p   精度，基数 b 的有效位数
基于以上 4 个组成部分，一个浮点数的值如下：
floating-point = ( S ) p x be
或
floating-point = (+/-) precision x baseexponent
}
key(endian){
union data{
    short inter;
    char ch;
};
union data c;
c.inter = 0x1122;
if(c.ch == 0x22)
    printf("The compute is little-endian.\n");
else
    printf("The compute is big-endian,\n");
}
key(地址与指针类型:stanford_cs107){
    int arr[5];
    arr[3] = 128; /*00000000 10000000*/

    ((short*)arr)[7] = 2;
    printf("%d\n", arr[3]); /*00000000 00000010 00000000 10000000*/

    ((short *)(((char *)(&arr[1]))+8))[3] = 100;
    printf("%d\n", ((short*)arr)[9]);
    
ps 大小尾有区别，小尾系统中((short*)arr)[7]=2;，大尾的则为((short*)arr)[6]=2;
(short*)arr将认为有10个short空间，第7的位置修改了原先基于int*时的第3位置的数据。
((short *)(((char *)(&arr[1]))+8))[3]=100;可以非常灵活的控制需要访问的地址空间
0       1       2       3       4       5
┌───────┬───────┬───────┬───────┬───────┐
└───────┴───────┴───────┴───────┴───────┘
        ^
        |
        (char *)(&arr[1]) 即地址&arr[1] 理解成 char* 类型

        0 1 2 3 4 5 6 7 8
        ┌─┬─┬─┬─┬─┬─┬─┬─┐
        └─┴─┴─┴─┴─┴─┴─┴─┘
                        ^
                        |
                        (char *)(&arr[1]))+8，sizeof是基于char的

                        0   1   2   3   4
                        ┌───┬───┬───┬───┐
                        └───┴───┴───┴───┘
                        ^           ^
                        |           |
                        此地址理解成short*
                                    |
                                    该地址存入100
结构体、数组、强制类型等内存访问技巧还可以用来访问活动记录中其他的变量
}

key(swap泛型版本:stanford_cs107){
void swap(void *vp1, void *vp2){   |  void swap(void *vp1, void *vp2, int size){
    void temp = *vp1;              |      char buffer[size];
    *vp1 = *vp2;                   |      /* char* buffer = malloc(size);*/
    *vp2 = temp;                   |      memcpy(buffer, vp1, size);
}                                  |      memcpy(vp1, vp2, size);
                                   |      memcpy(vp2, buffer, size);
                                   |      /* free(buffer);*/
                                   |  }
--------------------------------------- [ swap 版本问题 ]
1. 不能声明void型的temp变量
    1.1 void用在函数返回值，声明没有什么可返回:void fun(){}
    1.2 void可作为函数指针:void* addr = &i;
    1.3 void作为方法的唯一参数说明:int main(void){}
2. 不能对vp1进行解引用，因为没类型信息，机器不知道要提取多少个字节
--------------------------------------- [ swap size版本说明 ]
1. 比上个版本多出size参数，表示需要交换的byte长度
    1.1 不需要const修饰，参数上使用const更多用于共享信息时，起到保护作用，防止被意外修改
    1.2 size参数可以传入一个常数，但可读性不好，而用sizeof(int)则明确的指出了需要转换的数据类型
2. char buffer[size]，现在版本编译器 允许声明一个大小依赖于参数的数组
    2.1 虽然声明成char，其实只是利用该字符缓冲区来留出足够内存空间存放size大小的字节，该空间位于栈中(buffer是局部变量)，函数运行后空间 自动释放
    2.2 vp1并不介意解释成字符串，只是作为一个存储空间，并不利用该buffer去做字符相关操作
    2.3 如果不支持该 非常数 作为数组长度的声明，可使用malloc在 堆 中创建一个缓冲区，并记得最后 释放
3. memcpy进行内存单元的拷贝，注意此函数并不关心你的数据类型，单纯的进行单元的拷贝而已，所以虽然编译可能通过，
   但是还需要自己进行判断和控制
4. void*的使用，通过它能够实现泛型，即针对于int，short，char，struct等类型都能够保证能够拷贝交换成功
5. C++的template和这里的区别和优缺点。使用模板的话，编译后，会为每种类型都生成一种代码，比如int对应的，
   float对应的，这样如果调用次数很多的话，代码体积会增大，冗余过多。而这里编译出来就一套代码，更加简洁。
   但因为没有类型检查，调用时需要很小心
6. 但不同长度类型的vp1与vp2是不能被调用的，如int与short的类型的数据swap，简单的结果就是，截断拷贝或者多拷贝
   数据，大小尾表现还不一样。

swap(&husband, &wife, sizeof(char*));    # OK
swap(husband, wife, sizeof(char*));      # NO

}

key(lsearch泛型:stanford_cs107){
void* lsearch(void *key, void *base, int n,             | void *lsearch(void *key, void *base, int n, int elemSize){
              int elemSize, int(*cmpfn)(void*,void*)){  |     int i;
    int i;                                              |     for ((i = 0; i < n; i++)) {
    for((i=0; i<n; i++)){                                 |         void* elemeAddr = (char*)base + i * elemSize;
        void* elemAddr = (char*)base + i * elemSize;    |         if (memcmp(key, elemeAddr, elemSize) == 0)
        if(cmpfn(key, elemAddr) == 0)                   |             return elemeAddr;
            return elemAddr;                            |     }
    }                                                   |     return NULL;
    return NULL;                                        | }
}                                                       | 
                                                        | 
int IntCmp(void *elem1, void *elem2){                   | 
    int* ip1 = elem1;                                   | 
    int* ip2 = elem2;                                   | 
    return *ip1 - *ip2;                                 | 
}                                                       | 
---------------------------------------
1. int(*cmpfn)(void*,void*)中的cmpfn前面可以不加*，但加上可读性更好，表示函数指针
2. int IntCmp(void *elem1, void *elem2)中，elem1指向&key的地址，elem2则是每次迭代数组元素的址，
   相当于&array[i]
3. int* ip1 = elem1;将void*强制转换成int*类型，即它本来的类型，但在elem1前面并不需要显式写成(int*)elem1，
   这个转换是隐式的
4. cmpfn应为函数，或类的静态方法，不能是实例方法，实例方法中，其实是将方法与对象相关的地址作为第一个隐含
   参数(即this指针)传递给方法

}

key(stack的泛型版本:stanford_cs107){
typedef struct{
    void *elems;
    int elemSize;
    int logicLen;
    int allocLen;
    void (*freefn)(void*);
}stack;

void StackNew(stack *s, int elemSize, void(*freefn)(void*));
void StackDispose(stack *s);
void StackPush(stack *s, void *elemAddr);
void StackPop(stack *s, void *elemAddr);

/* stack.c */
void StackNew(stack *s, int elemSize, void(*freefn)(void*)){
    assert(elemSize > 0);
    s->elemSize = elemSize;
    s->logicLen = 0;
    s->allocLen = 4;
    s->elems = malloc(4 * elemSize);
    s->freefn = freefn;
    assert(s->elems != NULL);
}

void StackDispose(stack *s){
    int i;
    if((s->freefn != NULL)) {
        for((i = 0; i < s->logicLen; i++)) {
            s->freefn((char*)s->elems + i * s->elemSize);
        }
    }
    free(s->elems);
}

static void StackGrow(stack *s){
    s->allocLen *= 2;
    s->elems = realloc(s->elems,s->allocLen*s->elemSize);
    assert(s->elems != NULL);
}

void StackPush(stack *s, void *elemAddr){
    if((s->logicLen == s->allocLen)){
        StackGrow(s);
    }
    void *target = (char*)s->elems+s->logicLen*s->elemSize;
    memcpy(target, elemAddr, s->elemSize);
    s->logicLen++;
}

void StackPop(stack *s, void *elemAddr){
    assert(s->logicLen > 0);
    s->logicLen--;
    void *source = (char*)s->elems+s->logicLen*s->elemSize;
    memcpy(elemAddr, source, s->elemSize);
}
/* app */
void stringFree(void* elemAddr) {
    char** p = (char**)elemAddr;
    free(*p);
}
---------------------------------------

}

key(memcpy原理:stanford_cs107){
1. memcpy将使用暴力复制，每次拷贝4个字节，它不会检查目标与源地址重叠问题，当源地址在目标地址之前，
   容易出问题，目标地址在源地址之前，则能正常工作，但memmove就没有问题，但性能稍降低。当确信没有重叠时，
   优先使用memcpy
}

http://cm.bell-labs.com/cm/cs/who/dmr/index.html   Users Reference to B
http://www.cs.bell-labs.com/cm/cs/cbook/index.html K&R 的网页
ftp://ftp.uu.net/doc/standards/ansi/x3.159-1989/   Rationale(理论依据)
C语言ISO标准文档: ISO-IEC 9899-1990 中文： GB/T 15272-94
pointer(征服C指针){
1. 提高编译器的告警级别；不可无视或者制止编译的告警
2. 先有"指针类型"。然后有了"指针类型的变量"和"指针类型的值"。
3. 变量不一定按照声明的顺序保存在内存中。
4. 声明中的[]和表达式中的[]意义完全不同。表达式中的*和声明中的*的意义也是完全不同的。
5. [] 是语法糖，对于编译器来说，[]这样的运算符完全可以不存在。
6. 一般情况下，使用指针的程序比较高效。这完全是"那个时代的错误"。
7. 无论如何都要将数组进行值传递的时候，建议将数组整体整理成结构体成员。
    Pascal 和 Java 中不能写带有可变长参数的函数。
    Java 在 JDK1.5 之后的版本也开始支持可变长函数了。——译者注
8. printf : 
头文件stdarg.h提供了一组方便使用可变长参数的宏
va_list一般是这样定义typedef char *va_list;
va_start(ap, format)意味着 使指针ap指向参数format的下一个位置
宏va_arg()指定ap和参数类型，就可以顺序的取出可变长部分的参数
va_end(ap);是一个空定义的宏，只因标准里指出了对于va_start()的函数需要写va_end()
要实现可变长参数的函数就必须知道参数的类型和个数。
9. 一旦调用 malloc()，绝对要对返回值进行检查，并且进行完善的处理。
10. 表达式代表某处的内存区域的时候，我们称当前的表示式为左值(lvalue) -- locator value；
    相对的是，表达式只是代表值的时候，我们称当前的表达式为右值。
    表达式中有时候存在左值，有时候不存在左值。
11. 对于 C 语言，在表达式中的数组可以被解读成"指向初始元素的指针"
函数的参数也是表达式，所以，此时的数组也可以被解读成"指向初始元素的指针"
因此，向函数传递的往往是指针。
12. 函数指针也分类型，不同类型的函数指针适合与不同的函数捆绑
}
key(派生类型定义 -> 征服C指针){
在C中，除标识符外，有时候还必须定义"类型"：
1. 在强制转型运算符中
2. 类型作为sizeof运算符的操作数
从标识符的声明中，将标识符取出后，剩下部分自然就是类型名：
声明           |声明的解释                    |类型名       |类型名的解释
---------------|------------------------------|-------------|-----------------------------
int hoge       |hoge是int                     |int          |int类型
int *hoge;     |hoge是指向int的指针           |int *        |指向int的指针类型
double *p[3]   |p是指向double指针的数组(元素3)|double *[3]  |指向double指针的数组(元素3)类型
double (*p)[3] |p是指向double数组(元素3)的指针|double(*)[3] |指向double数组(元素3)的指针类型
void (*func)() |func是指向返回void函数的指针  |void (*)()   |指向返回void函数的指针类型

2. 方法
首先着眼于 标识符(变量名或函数名)
从距离标识符最近的地方开始，依照优先顺序解释派生类型(指针、数组和函数)。优先顺序说明如下：
    用于 整理声明内容的括号
    用于表示 数组的[] ，用于表示 函数的()
    用于表示 指针的*
解释完派生类型，使用"of, to, returning"将它们 连接 起来 (of 指针, to数组, return 函数)
最后，追加 数据类型修饰符(在左边，int,double等，如果函数，即为返回类型)

C语言          |英语表达                                     |中文表达
---------------|--------------------------------------------|-------
int hoge[10][3]|hoge is array(num 10) of array(num 3) of int|hoge是int数组(元素3)的数组(元素10)(反序)
int *hoge[10]  |hoge is array(num 10) of pointer to int     |hoge是 指向int指针的 数组(元素10)
int (*hoge)[3] |hoge is pointer to array(num 3) of int      |hoge是 指向int数组(元素3)的 指针
int *func(double) |func is function(double) return int*     |func是一个返回int*的函数(参数是double)
}

key(派生类型说明 -> 征服C指针){
派生类型: 指针, struct, union, enum, 数组

标量类型(scalar): char, int, double和枚举型, 指针
聚合类型(aggregate): 数组, union, struct
对聚合类型的支持:
  结构体的一次性赋值
  将结构体作为函数参数值传递
  将结构体作为函数返回值返回
  auto 变量的初始化
  
C语言的类型分为：
  对象类型(char、int、数组、指针、结构体等)
  函数类型
  不完全类型 结构体标记的声明就是一个不完全类型的典型例子。
    在 C 标准中，void 类型也被归类为不完全类型。
    
1. 指针
由引用类型T派生的指针类型，称为指向T的指针
                    全体类型为 被引用类型T
   ┌────────────────────────┴────────────────────────┐
   ┌───────┐     ┌───────┐     ┌───────┐     ┌───────┐ point to ┌───────┐
   │       │<----│       │<----│       │<----│       │<---------│pointer│
   └───────┘     └───────┘     └───────┘     └───────┘          └───────┘
   表达式中的函数自动转换成"指向函数的指针"，但当函数是地址运算符&或者sizeof运算符的操作数时，
表达式的函数不能变换
    函数调用运算符()的操作数不是"函数"，而是"函数的指针"

2. 数组(元素个数作为数组的属性)
和指针类型相同，数组类型也是从其元素的类型派生出来的，元素个数作为类型的属性 添加在类型后面

                    全体类型为 元素类型
   ┌────────────────────────┴────────────────────────┐
   ┌───────┐     ┌───────┐     ┌───────┐     ┌───────┐ inclued  ┌───────┐
   │       │<----│       │<----│       │<----│       │<---------│pointer│
   └───────┘     └───────┘     └───────┘     └───────┘          ├───────┤
                                                                │ num   │
                                                                └───────┘
3. 函数(参数信息作为函数的属性)
    函数类型的其他派生类型有不太相同的一面，无论int还是double，或数组、指针、结构体，
大体都可以作为变量被定义，这些变量在内存占有一定的空间，通过sizeof运算符可以取得它们
的大小，像这样有特定长度的类型，称为 对象类型

可是函数类型不是对象类型，因为函数没有特定长度，C中不存在"函数类型的变量"：
  函数类型是无法得到特定长度的，所以从函数类型派生出的数组类型是不可能的，即不可能出现"函数的数组"这样的类型
    但可以存在"指向函数的指针的数组"，先派生出指针类型，再派生出数组
  可以有"指向函数的指针"类型，但不能做运算的，因为无法得到当前指针类型的大小
  函数类型也不能成为结构体和共用体的成员
    但可以将"指向函数的指针"类型作为结构体成员
  即函数类型是 不能派生出除了指针类型之外的其他任何类型 的。
  此外，数组类型是不能派生出函数类型的，在C中，数组是不能作为函数返回值返回的。

}
key(不完全类型:-> 征服C指针-前桥和弥){
不完全类型，指函数之外，类型的大小不能被确定的类型，结构体标记的声明 就是一个不完全类型的例子
typedef struct Woman_tag Woman;
typedef struct{
    Woman *wife;
} Man;
struct Woman_tag{
    Man *hashand;
};
    Woman类型的标记被声明的时候，还不知道其内容，所以无法确定其大小。因为不能确定大小，
所以不能将不完全类型变成数组，也不能作为结构体成员，只能用于取得指针，将Woman类型
的指针作为结构体成员。
    之后在定义struct Woman_tag的内容的时候，Woman就不是不完全类型了；对于不完全类型，
只能取得其指针void类型也被归类为不完全类型
}
key(空的下标运算符[]:-> 征服C指针-前桥和弥){
1. 函数的形参的声明
2. 根据初始化表达式可以确定数组大小的情况
int a[] = {1, 2, 3};
char str[] = "abc";
double matric[][2] = {{1, 0}, {0, 1}};
char *color_name[] = {
    "red",
    "green",
    "blue"
};
char color_name2[][6] = {
    "red",
    "green",
    "blue"
};
int a[][3] = {
    {1, 2, 3},
    {4, 5},
    {6}
};
char str[][5] = {
    "hoge",
    "hog",
    "ho",
}
使用extern声明 全局变量 的情况

通过以下的代码，可以证明字符串常量本质还是数组：
printf("size..%d\n", sizeof("abcdefghijklmnopqrstuvwxyz"));
}
key(只能使用标量:-> 征服C指针-前桥和弥){
1. 标量 就是指char、int、double和枚举等数值类型，以及指针，相对的，像数组、结构体和共用体这样的
   将多个标量进行组合的类型，称为 聚合类型(aggregate)

if(str == "abc")这样的代码为什么不能执行预期的动作呢，确实已经将"abc"放到了str中，条件表达式却不为真。
    1.1 通常答案是，这个表达式不是在比较字符串的内容，它只是 在比较指针
    1.2 另一个答案是，字符串其实就是char类型的数组，也就是说它 不是标量，当然在C里面不能用==进行比较了。

2. C语言是一门，不用说对输入输出，就连数组和结构体也放弃了通过语言自身进行整合利用的语言。
3. 但如今ANSI C通过以下几个追加的功能(早期C语言不存在)，能够让我们整合地使用聚合类型了：
    3.1 结构体的一次赋值(无须再使用memcpy())
    3.2 将结构体作为函数返回值传递
    3.3 将结构体作为函数返回值返回
    3.4 auto变量的初始化
4. 但依然不能做到对数组的整合利用，如数组赋值给另外一个数组，或者将数组作为参数传递。所以在结构体能
替换数组的情况下，应优先使用。
}
key(关于指针:-> 征服C指针-前桥和弥){
指针类型、指针类型变量、指针类型的值，经常被简单的统称为"指针"，造成歧义，必须明确：
    1. 先有 指针类型
    2. 所以有了 指针类型的 变量 和 指针类型的 值(内存的地址)
    
指针和地址之间关系
几乎所有的处理程序中，所谓的"指针类型的值"，实际上是指内存的地址。对此的疑问有：
    归根结底，指针就是地址，地址就是内存中被分配的"门牌号"，所以，指针类型和int类型是一回事吧
        在C中，指针和整数是没有区别的，但运行环境不具有普适性，很多运行环境中，int类型和指针类型的长度并不相同，
        此外，对于分段寻址的(段地址+偏移量)也不适用。
    指针就是地址吧，那么指向int的指针也好，指向double的指针也好，它们有什么不一样吗，有必要区分它们吗？
        对于大部分运行环境来说，当程序运行时，不管是指向int的指针，还是指向double的指针，都保持相同的表现形式
注意:编译器记住指针指向什么样的类型
}
key(声明函数形参的方法-> 征服C指针-前桥和弥){
针对上例，有人会将get_word()声明成如下
int get_word(char buf[], int buf_size, FILE *fp);
只有声明函数形参时，数组的声明才可以被解读成指针

即使像
int func(int a[10]);

这样定义了元素的个数，编译器也是 无视 的，还是解读成
int func(int *a);
}
key(关于scanf-> 征服C指针-前桥和弥){
    在一般C语言书中，经常使用scanf("%d", &hoge)，scanf()
不是以行单位对输入内容进行解释，而是对连续字符流进行解释(换行符也视为一个字符)。
    scanf()连续的从流读入字符，并且对和格式说明符"%d"相匹配的部分进行变换处理，如输入"123\n"时，
从流中取得123部分的内容，并对它进行处理，换行符依旧会残留在流中，后续如果存在getchar()就会吞食
这个留下的换行符。
    此外，当scanf()变换失败的时候，(比如尽管指定了%d，但输入的却是英文字符)将导致失败的部分遗留在流中。
    在读入过程中有几个对象被成功地变换，则scanf()的返回值就为几。
    
    为了避免后续字符的遗留影响后面的输入时，可使用如下方式：
char buf[256];
int hoge;
fgets(buf, sizeof(buf), stdin);
sscanf(buf, "%d", &hoge);
}
key(现代方法 作用域-> 征服C指针-前桥和弥){
C语言的变量具有区间性的作用域，用语句包围的是作用域，static控制静态连接，extern控制外部连接。
对于全局变量，作用域指文件作用域，链接指外部链接。
对于程序员来说，这些方式都是控制命名空间的，没什么不同，统一使用"作用域"叫法

1. 编译器可以确认四种不同类型的作用域 -- 文件作用域，函数作用域，代码块作用域和原型作用域。
   标识符声明的位置决定他的作用域。
2. 当代码块处于嵌套状态，如果内层代码块有一个标识符和外层代码块的标识符重名时，
   内层标识符将隐藏外层标识符。
3. 不是嵌套的代码块则稍有不同，声明于每个代码块的变量无法被另一个代码块的变量访问，因为他们的代码块并没有重叠之处。
   两个代码块的变量不可能同时存在，所以编译器可以把他们存储与同一个内存地址。
   这种共享不会带来任何危害，因为在任何时刻，两个非嵌套的代码块最多只有一个处于活动状态。
4. 任何在代码块之外声明的变量/函数都具有文件作用域。当该文件被#include于其他文件中时，就像是他们直接写到那些文件中一样。
5. 原型作用域（prototype scope）只适用于在函数原型中声明的参数名。实际上，该参数名不必与定义中的形参同名，不需要与实参同名。
}
key(现代方法 -> 链接属性){
1. 标识符的作用域与他的链接属性有关，但这两个属性是两个完全不同的属性。
2. 连接属性主要是用于处理不同文件中的同名函数/变量。
3. 链接属性共有三种：external internal 和 none。
4. internal链接属性的标识符在同一个原文件中的声明都指向同一个实体，但位于不同文件的多个声明则分属于不同实体。
5. 属于external属性的标识符不论被声明多少次，位于几个源文件都指向同一个实体。
6. 如下所示，缺省情况下，b c f 链接属性为external，其余为none。c 之所以为 external是因为他是个函数名。
     int b;  
     int c (ind d)  {
         int e;  // static 只对链接属性为 external 的标识符有效，如果在此处加上 static ，那么效果将完全不一样。
         int f(int g);
     }

7. 关键字extern 和 static 用于改变链接属性。对一个external前面加上static会将其链接属性变为internal。
8. 当external用于原文件中的第一个标识符的第一次声明时，他指定该标识符具有external链接属性。但是，
   如果它用于该标识符的第二次或者以后的声明时，他并不会更改第一次声明所指定的链接属性。
}

cdecl(){
int (*func)(int *) 
编译器的处理
第一步：找到未定义的标识符 (func),在这里(int*)已经有定义了，而(func)是我们自定义的标识符，
        而且没有被定义(因为不知道是什么类型的) 
第二步：往右看看到了圆括号，往左看看到了*，确定func为一个指针，然后处理得到 int (int *)
第三步：往右看看到了圆括号，那么可以确定func为一个函数指针，它的参数为一个int指针类型的，
        然后往左看，看到int，那么确定返回的类型为int类型的 */
int (*p2)(int *, int (*f)(int *)); 
首先找到p2，然后找到*p2，然后判断p2指向函数， 
然后看到第二个参数找到一个未定义的f，然后找到*f，然后找到f指向函数， 
然后找到f指向的函数有一个参数为int*类型的，然后找到f指向的函数的返回值为int类型， 
然后找到p2指向的函数有两个参数为int*和指向函数的指针，然后找到p2指向的函数的返回值为int类型的 

int (*p3[5])(int*); 
用上述方法得到p3为一个包含5个元素的数组， 每个元素都是一个函数指针， 
函数指针指向的类型为int(int*)
}
key(cdecl-> 征服C指针-前桥和弥){
1. 声明从它的名字开始读取，然后按照优先级顺序依次读取
2. 优先级从高到低依次是：
    2.1 声明从被括号括起来的那部分
    2.2 后缀操作符：括号()表示这是一个函数；方括号[]表示这是一个数组
    2.3 前缀操作符：星号*表示 指向...的指针
3. 如果const和(或)volatile关键字的后面紧跟类型说明符(如int,long等)，那么它作用于类型说明符，在其他情况下，const和(或)volatile关键字作用于它左边紧邻的指针星号

对于char * const *(*next)();的声明：
    首先，看变量next，适用规则1
    它直接被括住，看成一个整体，得出next是一个指向...的指针，适用规则2.1
    考虑括号外的东西，在星号前缀和括号后缀作出选择，适用规则2
    规则2.2，告诉我们优先级较高的是右边的函数括号，得出next是一个函数指针，指向一个返回...的函数
    然后根据规则2.3，处理前缀星号，得出指针所指的内容
    最后，根据规则3，把char * const解释为指向字符的 常量指针
    综合起来，这个声明表示next是一个指针，它指向一个函数，该函数返回另一个指针，该指针指向一个类型为char的常量指针

cdecl> explain char * const *(*next)()
declare next as pointer to function returning pointer to const pointer to char

cdecl> explain int(*fun())
declare fun as function returning pointer to int

cdecl> explain int(*fun())()  #返回函数指针的 一个函数
declare fun as function returning pointer to function returning int

cdecl> explain int(*foo())[]  #返回指向int数组的指针的 一个函数
declare foo as function returning pointer to array of int

cdecl> explain int(*foo[])()  #函数指针数组
declare foo as array of pointer to function returning int
}
key(const能否代替#define-> 征服C指针-前桥和弥){
const能否代替#define
const int HOGE_SIZE = 100;
int hoge[HOGE_SIZE];
是不行的，C中数组的元素必须为常量，const修饰的标识符不是常量，只是只读而已(C++另当别论)
}

key(拾遗-> 征服C指针-前桥和弥){
1. ANSI C会擅自将相邻的两个字符串连接起来
char *color_name[] = {
    "red",
    "green",
    "blue"
    "yellow"
}
会构成只有"red","green","blueyellow"3个元素的数组
2. 共用体的初始化针对第一个成员实施的
3. 全局变量的声明
    建立全局变量命名规则 建立工具去检查，确保只有一个地方定义，其它文件中使用extern，使用宏来帮助：
#ifdef GLOBAL_VARIABLE_DEFINE
#define GLOBAL /* 定义无 */
#else
#define GLOBAL extern
#endif /* GLOBAL_VARIABLE_DEFINE */

GLOBAL int global_variable;
    1. 将头文件写成这样，只有某一个文件使用了
    #define GLOBAL_VARIABLE_DEFINE，从而保证了只有一个地方定义，而其它地方是extern
    2. 使用了这个技巧，就无法使用初始化表达式，对于全局变量，最好少用初始化表达式，
    而借助一些函数来完成，因为前者只能发生一次，而函数调用却可以多次发生。
    3. 但如果确实需要对数组进行初始化时，可使用下面方式：
GLOBAL char *color_name[]
#ifdef GLOBAL_VARIABLE_DEFINE
= {
    "red",
    "green",
    "blue",
}
#endif /* GLOBAL_VARIABLE_DEFINE */
;
}

key(关键字说明){
1. assignment context 导致赋值或者转换到已知类型的目标的表达式上下文。
C语言中的赋值上下文有初始化、赋值表达式的右侧、类型转换、return语句和缺少原型的函数参数。
2. bind 非正式地结合在一起，通常用来表示根据优先级规则，那些操作数和那个操作数结合在一起。
3. decay: 隐式转换为稍简单类型的过程。非正式地，C语言的数组和函数趋向退化为指针。
4. unary: 一元的， 指带一个操作数的操作符。

4. declaration 一般地，描述一个或多个变量、函数、结构、联合或枚举的名称和类型的语法元素
   具体地，指明在其他地方定义的变量或函数的声明。
5. dclarator：  C语言声明的'第二半'，包含标识符名称和可选的*,[],或()的语法，
   该语法标明标识符是指针、数组、函数或其他组合。
6. definition 变量或函数分配和可选地初始化存储或提供函数的声明。
7. dereference: 查找被引用的值。通常"被引用的值"是指针指向的值，因此"解引用"就是指找出指针所指向何物
   (在C语言中，用一元操作符*或数组下表操作符[])。
8 filed 结果或联合的成员。具体地指位域。
formal parameter 形参 actual argument 实参 argument 参数
9. full expression:形成表示的语句的完整表达式，if,switch,while,for或do/while语句的控制表达式之一
  或者初始使或return语句中的表达式。完整表达式不是更大的表达式的一部分。
  
10. 宿主环境 hosted environment 支持C库的C语言环境，
11. 独立环境 freestanding environment 不支持C库的C语言环境，用于嵌入应用或类似目的。
12. 标识符 identifier 通常在特定命名空间和作用域中有特定意义的名称。
13. token 符号: 编译器或其他解释器可见的最小语法单元：关键字、标识符、二元操作符
    
13. 实现 implementation 编译器或其他语言翻译器，包括他的运行库。用在"普通的char是有符号还是无符号值由实现定义"
  和"这些标识符由实现保留"这样的语句中。
14. 实现定义的 implementation-defined 指那些标准没有完全定义，但要求任何特定的实现都必须定义、提供文档的行为。
    例如：普通的char是有符号还是无符号值由实现定义。
15. 不完全类型 incomplete type 没有完全说明但是在某种上下文中还是可以使用的类型。例如：
  无维度数组、有标记符但没有成员信息的结构或联合类型。
16. 严格符合标准 strictly conforming 指仅使用ANSI|ISO C中的功能而不依赖任何不确定、
    未定义或实现定义的行为的程序。
17. 未定义的 undefined 指标准中未规定的行为，不要未实现对此作任何合理的动作。
    例如表达式 i = i++的行为。
18. unspecified 不确定的： 之标准没有完全规定的行为，每个实现必须对其选择某种行为，但可以不提供文档。
    甚至不必一致。例如:函数参数和其他子表达式的求值顺序。
    
16. int 整数类型，通常和机器的自然字长匹配，通常用来代表C语言中的整数。
17. integral 整型： 指可以代表整数的类型。C语言中的整型是char型、三种大小的int型(short int和long)
    上述类型的signed和unsigned变体及枚举。
18. 对象 object 可以被C程序操作的任何数据块：简单变量、数组、结构、malloc分配的内存块等。
19. tag 标签 特定结构、联合或枚举的名称。

19. opaque 不透明的 形容意在成为抽象数据的数据类型:使用该类型的代码不应该知道该类型如何实现
pass by reference 按引用传递 pass by value 按值传递
20. 优先级 precddence 标明操作符在解析过程中和他的操作数结合的紧密程度的"力量"。
    尤其是跟相邻的操作符比较而言。优先级根结合性和显示的括号一起决定表达式如何被解析；
    那些操作符应用于那些操作数，哪些子表达式是哪些操作符的操作数。
    优先级不一定表示任何求值顺序。
21. ragged array 不规则数组：通常用指针模拟的数组，其中的行不一定等长。
22. short circuit 短路; 当结果可以确定时提前结束表示的求值。C语言中的短路操作符有&&,||和?.
    对于&&和||，如果第一个操作数可以决定结果(对于&&为零，对于||为非零)则第二个操作数不会被求值
    对于? 根据第一个操作数的值，只有第二个或第三个操作数之一被求值
23. side effect 副作用：当表达式或子表达式被求值时，除了生成一个值以外而总是发生的事。
    典型的副作用有：修改变量、打印输出
}
key(volatile修饰符){
    被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，
要么编译器失去大量优化的机会(确保本条指令不会因编译器的优化而省略，且要求每次直接读值)

    遇到这个关键字定义的变量，编译器对访问的代码不再进行优化，如何理解这个优化，其实就是为了提升访问速度而不从源地址读取，
从缓存中读取，如何理解它的作用，有了这个修饰后可以保证对特殊地址的稳定访问。
volatile const int i=0; 
const volatile int j=0; 
//i=2; //error C2166: l-value specifies const object 
//j=3; //error C2166: l-value specifies const object
volatile 和 const 同时修饰时，以 const 的属性为主

# volatile :  目标可能被其他线程或事件修改，使用该变量前，都须从主存重新获取。
}
key(restrict修饰符){
    用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。
关键字restrict有两个读者: 一个是编译器，它告诉编译器可以自由地做一些有关优化的假定(该指针是访问分配的
内存的唯一且初始的方式，那么编译器可以将上述对指针的操作进行优化); 另一个读者是用户，他告诉用户仅使用
满足restrict要求的参数.

    具有 restrict  限定符的指针被称为限定指针。告诉编译器在指针生存周期内，只能通过该指针修改对象，
但编译器可自主决定是否采纳该建议。
    restrict :  修饰指针。除了该指针，不能用其他任何方式修改目标对象。
}
key(sig_atomic_t类型){
在写这种类型的变量时不会被中断，意味着有具有虚拟存储器的系统中，这种变量不会跨越页边界。
}

key(有关数组){
1. 对于int arr[5]，arr与&arr是有区别的，它们的值是一样的，但意义不一样，前者代表 数组元素首地址，
   后者为 数组的地址，当它们进行指针加减运算时，如arr+1代表前进一个int类型的长度，而&arr+1，则
   前进int[5]类型的长度
}

key(malloc建议){
1. 考虑给malloc()加一层包装，在每次分配内存的时候多留一点空间，然后在 最前面部分
   设定区域的大小信息，填充如0xCC的值，防止未做好初始化，并增加计数；
2. 而free()也做个包装，在区域被释放前故意 做一些破坏(如填充0xCC，防止再被引用)，
   方便BUG的查找，也增加计数，最后看是否和malloc()的计数一致；
3. 当然这些包装只在调试模式下有效，去掉调试模式，发行版的还是直接调用底层函数。
4. 谨慎使用realloc()，如果利用它扩展巨大内存区域，复制上花费很多时间，同时也造成
   大量的的空间过度活跃。如果想要动态为大量元素分配空间，最好不要使用连续的内存区域，考虑使用链表。

}
C(堆栈){
1. 有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈出栈的操作。call ret
   堆的数据结构并不是由系统(无论是机器系统还是操作系统)支持的，而是由函数库提供的。
[堆]
    1. 系统调用可能不支持任意大小的内存分配。有些系统的系统调用只支持固定大小及其倍数的内存请求(按页分配)；这样的话对于大量的小内存分类来说会造成浪费。
    2. 系统调用申请内存可能是代价昂贵的。系统调用可能涉及用户态和核心态的转换。
    3. 没有管理的内存分配在大量复杂内存的分配释放操作下很容易造成内存碎片。
 1、管理方式不同；
 2、空间大小不同；
 3、能否产生碎片不同；
 4、生长方向不同；
 5、分配方式不同；
 6、分配效率不同；
 
C 函数默认采用cdecl 调用约定，参数从右往左入栈，且由调用者负责参数出栈和清理。
C 语言中所有对象，包括指针本身都是 "复制传值" 传递，我们可以通过传递 "指针的指针" 来实现传出参数。
}

language(C语言有一段精辟的论述){
    C 拥有在效率方面的名声。它能写出程序尽可能是使用处理器的资源。写出这样的代码取决于对处理器以及翻译器
如何把 C 语言中的概念映射为机器码这两方面的知识的了解。没有几个开发人员对这些课题有足够的了解以便能始终
写出非常有效率的程序。笔者有时预测用自己写的编译器生成的代码都有困难。笔者发现一个普适法则：如果有任何
开发人员声称在语句级上有一种使用方法效率最高，都可以很安全的说他错了。语句级的性能开销不需要去争论，
交给翻译器去操心好了。
    
    C 拥有在致密性上的名声。每条 C 语句对应的机器码指令的体积比相对于别的语言来说是一个很小的数字。可以说，
C 是一种所见即所得的语言，从 C 语言映射到机器码简洁、显而易见。(暂时把优化器在后面做的工作先放在一边)。
这个期望曾经被 WG14 的一些成员用作反对等于操作符用于结构类型的论据；那样的话，一条操作就将潜在的生成大量
的代码，用于逐条比较每个结构成员。引入 inline 函数声明从一些角度破坏了这一点(这取决于 inline 是被想象
成类函数宏的替代品，还是在当前嵌入一个不能被实现成宏的函数)。
    
    C 有着是一种表里如一的语言的名声。开发者通常能预测到他们所写代码的行为。没有什么阴暗角落藏着一些
偶然一遇的用法会导致一些语言概念以意想不到的方式运作。虽然 C 委员会不能绝对保证永远不会出现另人惊奇的行为，
但他们一直致力于最小意外原则。
}
key(数组怪异写法){
printf("%c\n", 5["abcdssdc"]);
--------------------------------------
char *tmp = "abcdssdc";
printf("%c\n", tmp+5);
 
在 C 语言中， '[]' 操作符里外可以互换。一个数组表达式 "a[5]" ，可以写成 "5[a]" 。在编译器看来，这两种
写法最后都会翻译成 "*(a+5)" 。更进一步，只要表达式 "x[y]" 中， x 和 y 可以进行加法运算，且运算后的结果
可以正常作为一个地址被引用，那这种写法就是合法的，且编译器不会报任何错误。
}
key(offsetof){
今天在看 c-faq 的时候，碰到一个很奇怪的写法：
    *(int *)((char *)structp + offsetf) = value;
其中 offsetf 是由 offsetof 宏计算出来的。
    struct test {
        char c;
        int i;
    };
    针对上面的结构体，offsetof(struct test, i) 就会返回成员i在这个结构体中的相对偏移量。
    在 linux 下面，如果你安装了 kernel header 的话，你可能会找到这个文件： /usr/include/linux/stddef.h 。
这个文件不是 glibc 的 stddef.h ，而是 kernel 用的头文件，如果你打开的话，发现这是一个空的头文件。其实
用户态程序真真引用的 stddef.h 在你对应的编译器相关目录下面，由于我用的是 gcc ，所以要找的头文件在这： 
usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h 。
    打开这个头文件，定位到 offsetof 宏，发现它的定义是这样的：
    /* Offset of member MEMBER in a struct of type TYPE. */
    #define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)
    
    好吧，看来 gcc 并没有按照 ANSI C 来走，它这个地方做了一个跳转，网上的说法是为了兼容 C++ 。先不管了，
从标准 stddef.h 扒下来一份，发现有两种版本，最传统的版本是这样的：
    #define offsetof(type,m) ((size_t)&(((type *)0)->m))
    
    你可能会说，它引用了空指针，肯定运行不了。其实这并不算引用空指针问题，尽管表面上看上去是，因为这个
偏移量是在编译时确定的，并不是在运行时。

既然那个版本不是通用的，那么修改一下：
    #define offsetof(type,m) ( (size_t) (((char *)&(((type *)0)->m)) - (char *)((type *)0)) )
---------------------------------------
    #define container_of(ptr, type, member) ({ \
    const typeof( ((type *)0)->member ) *__mptr = (ptr); \
    (type *)( (char *)__mptr - offsetof(type,member) );})
    
---------------------------------------    
利用stddef.h 中的 ofsetof 宏可以获取结构成员的偏移量。
typedef struct{
    int x;
    short y[3];
    long long z;
} data_t;
int main(int argc, char* argv[]){
    printf("x %d\n", offsetof(data_t, x));
    printf("y %d\n", offsetof(data_t, y));
    printf("y[1] %d\n", offsetof(data_t, y[1]));
    printf("z %d\n", offsetof(data_t, z));
    return EXIT_SUCCESS;
}
}

key(-std=c99){
    在 C99 的规范，已经不允许隐式函数声明了。所以如果你在用 gcc 编译的时候，加上 -std=c99 的时候，
编译器马上会出现一个警告：隐式函数声明。如果你再加上一个 -Werror 的选项的话，那就直接出现错误了。

    从这也可以看出，不同的标准之间的差异。以后编译程序的时候，还是尽量加上 -Wall -std=c99 ，
可以发现很多隐藏的错误。
}

pitfallc(程序错误){
程序设计错误实际上反映的是程序与程序员对该程序的"心智模式".
人们深植心中，对于周遭世界如何运作的看法和行为

程序错误的分类
    程序员没有正确理解语法细节，导致语义出现了问题；
    程序员对于语义产生误解；
    程序在链接时出错；
    对库函数产生了误用；
    由于预处理器的介入导致的错误；
    在一个平台里可以运行，而移植到另一个平台则无法运行。
}
key(现代方法 -> 错误处理){
错误处理的机制：assert宏和errno变量。
1. void assert(int expression);
assert有一个缺点：它引入了额外的检查，因此会增加程序的运行时间。一般只在测试的时候使用assert函数，
但当最终程序完成时，会禁用掉assert。要禁用assert函数，只需要在包含<assert.h>之前定义宏 DEBUG即可：
#define NDEBUG
#include <assert.h>
不要在assert调用中使用有副作用的表达式，或者有副作用的函数调用。一旦禁止了assert调用，这些表达式将不会被计算。

2. 通过检查errno的值是否为0，来判断函数调用是否发生错误。如果不为0，则表示函数调用过程中有错误发生。
当错误发生时，向errno存储的值通常是EDOM或者ERANGE(两个宏都定义在errno.h中)，这两个值的含义如下:
   定义域错误EDOM:传递给函数的参数不属于函数的定义域。
   取值范围错误ERANGE：函数的返回值太大，无法使用double类型的值表示。
可以用函数描述出错的原因：
void perror(const char *s); //打印出错误信息
char *strerror(int errnum); // 返回一个描述相应错误的字符串

3. <signal.h>提供了处理异常情况的工具，即信号。信号有两种类型，运行时错误和程序以外导致的错误。
当有错误或者外部信号产生时，我们称产生了一个信号。
大多数信号是异步的：他们可以在程序执行过程中的任意时刻发生，而不仅是在程序员所知道的特定时刻发生。
除了自己的信号处理函数外，还可以使用<signal.h>提供预定义的处理函数。下面这两个函数都是用宏表示的：
    SIG_DFL 函数按照“默认”方式处理信号。可以使用如下的方式安装SIG_DEF
signal(SIGINT, SIG_DFL);
    SIG_IGN 当信号发生时，忽略该信号：
signal(SIG_INT,  SIG_IGN);

4. 非局部跳转
int setjmp(jmp_buf env);    // 初始化env，方便与longjmp函数使用。
void longjmp（jmp_buf env, int val）;
    通常情况下，函数被返回调用它的位置。我们无法使用goto语句使它专转到其他地方，因为goto语句只能跳转到
统一函数内的标号处。但是<setjmp.h>可以使一个函数直接跳转到另一个函数，而无需返回。
    setjmp宏标记一个程序中的一个位置，随后可以使用longjmp函数跳转到这个位置。这种机制主要用于错误处理。
setjmp函数会将当前环境保存到env中，然后返回0。longjmp函数根据env的值恢复环境变量，然后从setjmp宏调
用中返回，这次setjmp宏的返回值是val，就是longjmp函数的第二个参数。

}

pitfallc(词法陷阱){
1.1. = 不同于 ==  # 注意=是赋值符号，而==作为比较，在if判断条件中要注意区分。
用类似3==x 解决=和==之间的误用
1.2. & 和 | 不同于 && 和 || # & 是按位与运算符，而 | 是按位或运算符。
1.3. 词法分析中贪心法  # a---b ; a -- - b ; a - -- b
如何确定哪些字符组成符号？ # 词法分析一般是贪婪策略，就是会优先匹配出更长的词法单元。
每一个符号应该包含尽可能多的字符，也就是说，编译器从左到右一个字符一个字符的读入，
若该字符组成一个符号，那么再读入下一个字符，判断已经读入的两个字符组成的字符串是
否可能是一个符号的组成部分；若可能，继续读入下一个字符，重复上述判断，直到读入
字符串已不可能组成一个有意义的符号。
1.4.整数常量 # 若整型常量的第一个字符为0，那么该常量将被视作八进制数。
初始化或赋值的时候需要注意0开头的数字是八进制数，如012实际上是10
空格(32/0x20, 对应于^@), 0(48/0x30), A(65/0x41), a(97/0x61)
换行LF(0x0A), 回车CR(0x0D, 对应于^M)
vim下的normal模式下ga可查看ascii码
1.5. 字符与字符串
单引号与双引号含义不同：单引号引起的一个字符代表一个整数，
该整数对应与字符在编译器采用的字符集中的序列值；双引号引起的字符串，代表指向一个无名数组起始字符的指针。
# 单双引号不能混用
1.6 字符串常量会自动在后面加\0,strcpy函数会拷贝\0，strlen函数则不计算\0, strncpy不会给字符串最后追加\0.
}
pitfallc(语法陷阱){
注意: C语言允许初始化列表中多余的逗号，例如 int days[] = {1, 2, 3, 4,}; 为什么有这种特性？

先给出结论：对常数0进行类型转化，转换成一个函数指针，然后调用该函数指针所指向的函数，即位置0的函数。
1.1 (*(void(*)())0)() # 按使用方式来声明
将0转换为函数指针(这个函数指针返回值为void参数为空)，然后再调用这个函数. 用typedef比较好理解
 typedef void (*funcptr)();
 (*(funcptr)0)();

(void)(*signal(int,void(*)(int)))(int);
signal的参数是整形和函数指针,返回值也是函数指针。用typedef比较好理解
typedef (void ) (*handler)(int);
handler signal(int,handler);

1.3 分号
if (x[i] >big); big = x[i]; //多于分号
if (n < 3) return   //缺少分号
logrec.date = x[0];
logrec.time = x[1];
1.4 其他的一些诸如switch穿越，缺少break; # 在没有break的地方加上注释！
1.5 函数调用 -- 记得写() # f(); 函数调用 f; 什么都不做。
1.6 else悬挂 
}
pitfallc(语义陷阱){
1.1 指针与数组 --- 指针和数组 指向数组的指针(int (*pint)[31]) 包含指针的数组(int *pint[31])
1.2 非数值指针 --- 
  malloc可能分配空间失败，记得判断返回值。
  char r[100]实际上会分配101个空间 -- 居然要讲这种东西。。。
  记得free。。。
1.3 作为参数的数组说明
int strlen(char s[]) == int strlen(char *s)
main(int argc, char *argv[]) == main(int argc, char *argv[])
extern char *hello != extern char hello[]
1.4 避免"举隅法" 
char *p,*q;
p = "xyz"
q = p;
q[1] = 'Y'; # 出错
1.5 空指针并非空字符串 
if(p == (char*0)) != if(strcmp(p, char(*0)) == 0)
1.6 边界计算与不对称边界 # 序列点问题
1.7 整数溢出
  无符号运算没有溢出一说
  如果算数运算中一个操作数是有符号整数，另一个无符号整数，则均会转换为无符号整数
  如果两个都是有符号整数，则溢出结果未定义
  正确检测溢出的方法if ((unsigned)a +(unsigned)b < INT_MAX) 或 if (a < INT_MAX - b), INT_MAX在<limits.h>中
}
pitfallc(连接){
1. 声明与定义
外部对象(external object)，每个外部代表着机器内存中的某个部分，并通过一个外部名称来识别。
extern int a; 显示的说明a的存储空间是在程序的其他的地方分配
2. static 修饰符能够减少命名冲突
两个或两个以上的同名外部对象会导致命名冲突。
static 修饰符能使变量、函数作用域限制于一个源文件内。
3. 形参，实参与返回值 
  任何C函数都含有一个形参列表，该变量在函数调用时被初始化
  任何C函数都有返回类型，要么是void，要么是函数生成结果的类型
  C语言中的形参和实参匹配的规则有些复杂，ANSI C允许程序在声明时指定函数的参数类型
  如果一个函数没有float、short、char类型的参数，在其声明中可以省略参数类型说明
  对于类似的声明double square()，float类型的参数会自动转化为double类型，short和char类型的参数会自动转换为int类型
4. 检查外部类型       # 声明与定义的统一同样适用于外部变量(废话)
5. 头文件 # 每个外部变量只在一个头文件中声明，定义该外部对象的模块都应该包括这个头文件。
}
pitfallc(库){
1. 当一个程序异常终止时，程序输出的最后几行常常会丢失，原因？如何解决这个问题？ # setbuf()
使用errno检测错误
    建议使用if(返回的错误值){检查 errno}的方式
    并未强制要求库函数实现errno机制，同时errno的值是前一个执行失败的库函数设置的值
    
使用perror(), errno.h; exit(EXIT_SUCCESS), exit(EXIT_FAILTURE), stdlib.h
}
pitfallc(assert){

#define assert(e) \
    ((void) ((e) || (_assert_error (__FILE__, __LINE__))))
    
int  _assert_error(char *filename, int line){
    printf("Error ouccurred in %s at line:%d\n", filename, line);
    exit(-1);
}


assert(0) 是一个很好的方法，用于指明"不可能发生"的情况。
assert(!"ptr==NULL -- can not hanppen") 特很好

#undef assert
#ifdef NDEBUG
#define assert(e) ((void)0)
#else
extern void assert(int e);
#define assert(e) ((void)((e) || \
        (fprintf(stderr, "%s:%d Assertion Failed:%s\n", \
        __FILE__, (int)__LINE__, #e), abort(), 0)))
#endif

assert已检查的运行时错误;
raise未检查的运行时错误 ;
}
pack(){
1. 在模块范围内就用：
#pragma pack(n)//设定
……
#pragma pack()//取消

等价于：

#pragma pack(push)
#pragma pack(n)//设定
……
#pragma pack(pop)

2. 指定一个结构体对齐：

typedef struct tagBITMAPINFOHEADER
{
    u32     biSize;
    u32     biWidth;
    u32     biHeight;
    u16     biPlanes;
    u16     biBitCount;
    u32     biCompression;
    u32     biSizeImage;
    u32     biXPelsPerMeter;
    u32     biYPelsPerMeter;
    u32     biClrUsed;
    u32     biClrImportant;
}__attribute__ ((packed)) BITMAPINFOHEADER;
}
__attribute__(){
gcc 扩展关键字 __attribute__ 用于设置函数属性, 变量属性, 数据类型属性等, 向编译器提供更多数据, 帮助编译器执行优化

描述函数属性

    使用 addr2line 工具分析源代码, 统计程序的运行状态

void fun()         __attribute__ ((regparm(0)));			//不需要通过任何寄存器来传递参数, 参数只是通过堆栈来传递
void fun()         __attribute__ ((regparm(3)));			//通过寄存器传递多达3个的参数(EAX, EDX, ECX), 更多的参数才通过堆栈传递, 减少一些入栈出栈操作, 调用更快
void noreturnfun() __attribute__ ((noreturn));				//函数不会返回
void centon()      __attribute__ ((alias("__centon")));		//设置函数别名，函数是 __centon, 别名是 centon
void main_enter()  __attribute__ ((constructor));			//main_enter 函数在进入 main 函数前调用
void main_exit()   __attribute__ ((destructor));			//main_exit 函数在 main 函数返回后调用
void fun()         __attribute__ ((noinline));				//fun 函数不能作为 inline 函数优化
void fun()         __attribute__ ((section("specials")));	//将函数放到 specials 段中，而不是通常的 text 段中

}
C99(c reference manual读书笔记){
1 c 源文件的字符集(character set)包含在ISO/IEC 10646的Latin block中. 包括5种类型，分别是 52个lating大小写字母，10个数字(0-9)，空格，horizontal tab(ht) vertical tab(VT) form feed(FF) 以及29个graphic 字符(这个可以去看c99的手册).而不在集合内的字符可能会出现在注释/字符常量/字符串常量/文件名中.在c中还有执行字符集(execution character)的概念,一般来说编译和运行都在相同的电脑，则source字符集和执行字符集都是相同的.
2 在c的源程序中，blank, end-of-line, vertical tab, form feed, horizontal-tab都会被认为是空格(whitespace characters).
3 c89中要求逻辑行的最大长度是509个字符，而c99是4095个字符.
5 多字节字符(multibytes characters),主要针对非英语的环境.编码实现分为state-independent和state-depend,顾名思义，一个是编码依赖于前一个多字节字符，一个是不依赖于前一个多字节字符.
6 c语言中的comments是在预处理器处理之前就被remove的(标准c将会替换comments为为一个空格). 只有一些非标准的c实现才支持nestable comments,因此在c中注释大段的代码最好使用#if 0 #endif这种形式.c99添加了c++的注释形式(//).

1 预处理器主要是处理源代码中以#开头的行，预处理器执行完毕后的代码必定是一个合法的c程序.
2 预处理器的命令是完全不依赖于c语言的语法的.
3 预处理器不会parse源代码，预处理的词法处理和编译器的是不同的，预处理器能够理解合法的c标记，可是它也会忽略在c编译器中认为是不合法标记。比如下面的代码,对于预处理器来说，没有任何问题的.
4 standard c允许#后面有空格，但是一些老的c编译器是不允许的。如果#后面没有任何字符(除了空格),那么standard c则认为这是一个空行，一些老的编译器有可能有不同的行为.
5 预处理器的执行是在宏处理之前的，因此如果一个宏扩展后是一个预处理命令，那么这个命令是不会被执行的，然后在编译的时候就会出错，比如下面的代码:

GCC 支持 switch 范围扩展。
int x = 1;
switch (x)
{
    case 0 ... 9: printf("0..9\n"); break;
    case 10 ... 99: printf("10..99\n"); break;
    default: printf("default\n"); break;
}
char c = 'C';
switch (c)
{
    case 'a' ... 'z': printf("a..z\n"); break;
    case 'A' ... 'Z': printf("A..Z\n"); break;
    case '0' ... '9': printf("0..9\n"); break;
    default: printf("default\n"); break;
}

1. 无条件跳转
无条件跳转:  break, continue,  goto, return 。
goto 仅在函数内跳转，常用于跳出嵌套循环。如果在函数外跳转，可使用longjmp。
}

header(stdint.h){
1. 由于在不同系统上 char 可能代表有符号或无符号8位整数，因此建议使 unsigned char/signed char 来表示具体的类型。
INT8_MIN        INT8_MAX     UINT8_MAX
INT16_MIN       INT16_MAX    UINT16_MAX
INT32_MIN       INT32_MAX    UINT32_MAX
INT64_MIN       INT64_MAX    UINT64_MAX

PRId8   PRIid8    PRIod8    PRIud8   PRIxd8    PRIXd8
PRId16  PRIid16   PRIod16   PRIud16  PRIxd16   PRIXd16
PRId32  PRIid32   PRIod32   PRIud32  PRIxd32   PRIXd32
PRId64  PRIid64   PRIod64   PRIud64  PRIxd64   PRIXd64

%"PRIu32"
%016"PRIX64"
%10"PRIu32"

2. 通过宏进行强制类型
# 64系统
define __INT64_C(c)  c ## L
define __UINT64_C(c) c ## UL
# 32系统
define __INT64_C(c)  c ## LL
define __UINT64_C(c) c ## ULL

0x200    -> int
200U     -> unsigned int
0L       -> long
0xf0f0UL -> unsigned long
0777LL   -> long long
0xFFULL  -> unsigned long long

3. 浮点系统
float:  32 位 4  字节浮点数，精确度 6。
double:  64 位 8  字节浮点数，精确度 15。
long double:  80 位 10 字节浮点数，精确度 19 位

4. 类型转换
在表达式中，可能会将 char、short  当做默认 int (unsigned  int)  类型操作数，但float并不会自动转换为默认的 double 类型。
当包含无符号操作数时，需要注意提升后类型是否能容纳⽆符号类型的所有值。
long a = -1L;
unsigned int b = 100;
printf("%ld\n", a > b ? a : b); # -1
在 32 位系统中，它们都是 32 位整数，
且 long 并不足以容纳 unsigned int 的所有值，因此编译器会将这两个操作数都转换为 unsigned long，也就是高等级的无符号版本，

赋值和初始化时，右操作数总是被转换成左操作数类型。
函数调⽤时，总是将实参转换为形参类型。
将 return  表达式结果转换为函数返回类型。
任何类型 0  值和 NULL 指针都视为 _Bool  false，反之为 true 。
}
header(limits.h){


}
header(inttypes.h){ http://duanple.blog.163.com/blog/static/70971767201031210480305/
1. 定宽整型
    <inttypes.h> 提供的定宽整型包括带符号整型(如 int8_t、int16_t、int32_t、int64_t) 
和无符号整型(如 uint8_t、uint16_t、uint32_t、uint64_t)。
    定义为可容纳规定位数的最短整型的派生类型包括 int_least8_t、int_least64_t、uint_least8_t、uint_least64_t 等。
    对于循环计数器和文件描述符等操作，使用 int 或无符号 int 是安全的；对于数组索引，
使用 long 也是安全的。但是，不应不加选择地使用这些定宽类型。
可将定宽类型用于下列各项的显式二进制表示：
  磁盘数据
  通过数据线
  硬件寄存器
  二进制接口规范
  二进制数据结构
2. 诸如 unintptr_t 的有用类型
    <inttypes.h> 文件包括大小足以容纳一个指针的带符号整型和无符号整型。这些类型以 intptr_t 
和 uintptr_t 形式提供。使用 uintptr_t 类型作为指针的整型而非基本类型，如无符号 long。
    需要执行地址运算时，intptr_t 和 uintptr_t 类型对于强制转换指针非常有用。因此，
应使用 intptr_t 和 uintptr_t 类型，而不是 long 或无符号 long。
    此外，<inttypes.h> 还提供 intmax_t 和 uintmax_t，后两者是可用的最长(以位为单位)
带符号整型和无符号整型。
3. 常量宏
    使用宏 INT8_C(c)、INT64_C(c)、UINT8_C(c)、UINT64_C(c) 等指定给定常量的大小和符号。
基本上，必要时这些宏会在常量的末尾添上 l、ul、ll 或 ull。
    可使用 INTMAX_C(c) 和 UINTMAX_C(c) 宏使常量成为最长类型。
4. 限制
    由 <inttypes.h> 定义的限制是用于指定各种整型的最小值和最大值的常量，其中包括
每个定宽类型的最小值(如 INT8_MIN、INT64_MIN 等)和最大值(如 INT8_MAX、INT64_MAX 等)
及其对应的无符号的最小值和最大值。
    <inttypes.h> 还定义支持的最长整型的最小值和最大值，其中包括 INTMAX_MIN 和 
INTMAX_MAX 及其对应的无符号的最小值和最大值。
5. 格式字符串宏
    <inttypes.h> 文件还包括指定 printf(3S) 和 scanf(3S) 格式说明符的宏。实质上，
如果宏名称内置了参数的位数，这些宏将在格式说明符前面添加 l 或 ll，以便将参数 标识为
long 或 long long。
    
}
header(stddef.h){
<stdio.h> and <stddef.h>
((void *)0) == NULL

使用 NULL 只是一种风格习惯; 预处理器把所有的 NULL 都还原回 0, 而编译还是依照 上文的描述处理指针上下文的 0。
特别是, 在函数调用的参数里, NULL 之前 (正如在 0  之前) 的类型转换还是需要。
NULL 只能用作指针常数;
}
header(stdio){
strcpy() sprintf() strcat() 存在安全隐患， 其对应的安全版为： strncpy() snprintf() strncat()
###scanf、sscanf、fscanf scanf的参数与sscanf、fscanf的后两个参数相同。
三个函数很像，唯一的区别就是输入源不同。
scanf的输入源是标准输入，sscanf的输入源是指定的字符串，而fscanf的输入源是指的的输入流。
所以scanf可以看作是第一个参数为stdin的fscanf
}
header(stdlib){

数值类型转换 |函数名| |----| |atof| |atoi| |atol| |strtod| |strtol| |strtoul| 
###atof 函数名的含义是ascii to float。将字符串（char *）转换为浮点型（double）。
double atof(const char *s)
该函数会忽略掉前导空白符。如果该字符串不是合法字符串，程序不会报错。有如下两种情形：
    在合法字符串的末尾有非法字符，如"123.123abc"。编译器会直接忽略末尾的非法字符，返回值123.123000
    在合法字符串的其他位置有非法字符，该函数会返回0.000000
    
###atoi
int atoi(const char *s)
将字符串（char *）转换为整型（int）。 如果字符串s，中包含小数则直接忽略小数点之后的部分。其他注意事项同atof。

char *s1="123.123";
char *s2="123.123abc";
char *s3="abc123";
printf("%d\n",atoi(s1)); //输出123
printf("%d\n",atoi(s2)); //输出123
printf("%d\n",atoi(s3)); //输出0

###atol
long atol(const char *s)
将字符串（char *）转换为长整型（long）。注意事项同aoti函数。 

###strtod
double strtod(const char *s,char **endp)
将字符串转换为浮点型，将不能转换的部分存到endp中。

###strtol
long strtol(const char *s,char **endp,int base)
将字符串s转换为长整型，未转换的部分保存到endp。base是假定的s的基底。即字符串s描述的是一个base进制的数。
base的取值范围为：
    0 （视作十进制）
    2<=base<=36

###strtoul
unsigned long strtoul(const char *s,char **endp,int base)
与strtol类似，只不过转换后的类型是unsigned long类型。

函数名 	描述
abs 	求int型绝对值
labs 	求long型绝对值
div 	int型除法，保留商和余数
ldiv 	long型除法，保留商和余数

###rand
int rand()
通常不单独使用，需要使用srand函数设置随机数种子。 实际是伪随机数，如果设置的种子相同，则随机数产生的数字序列可以认为固定了。 

###srand
void srand(unsigned int seed)
其参数为新的随机数序列的种子。这个序列后来对rand的调用返回。通常以时间为种子,这样可以避免种子相同。
}
header(string){

}
memo(先做对,再做快
先使其可靠,再让其更快
先把代码弄干净,再让它变快){

# 《编程风格的元素》
# 1.Write clearly - don't be too clever.
要写清楚，不要自作聪明
# 2.Say what you mean, simply and directly.
简单、直截了当地表达你的意思 
# 3.Use library functions whenever feasible.
尽可能使用库函数
# 4.Avoid too many temporary variables.
不要使用太多的临时变量
# 5.Write clearly - don't sacrifice clarity for "efficiency."
要写清楚-不要为所谓的"效率"牺牲清晰度
# 6.Let the machine do the dirty work.
让机器去做麻烦的事情
# 7.Replace repetitive expressions by calls to a common function.
将重复代码替代为调用通用函数
# 8.Parenthesize to avoid ambiguity.
使用括号避免歧义
# 9.Choose variable names that won't be confused.
选择没有歧义的变量名
# 10.Avoid unnecessary branches.
避免使用不必要的分支
# 11.If a logical expression is hard to understand, try transforming it.
如果逻辑表达式不好理解,就试着做下变形
# 12.Choose a data representation that makes the program simple.
采用让程序更简洁的数据表达形式
# 13.Write first in easy-to-understand pseudo language; then translate into whatever language you have to use.
先用易于理解的伪代码写;再翻译成你使用的语言
# 14.Modularize. Use procedures and functions.
模块化.使用过程和函数
# 15.Avoid gotos completely if you can keep the program readable.
只要你能保证程序的可读性,能不用goto就别用
# 16.Don't patch bad code - rewrite it.
不要给糟糕的代码打补丁 - 重写就是了.
# 17.Write and test a big program in small pieces.
编写以及测试一个大型程序的时候,分块进行
# 18.Use recursive procedures for recursively-defined data structures.
使用递归过程来处理递归定义的数据结构
# 19.Test input for plausibility and validity.
始终要测试输入的正确性和有效性
# 20.Make sure input doesn't violate the limits of the program.
确保输入不会超出程序的限制
# 21.Terminate input by end-of-file marker, not by count.
通过文件结束符来终止输入,而不是通过记数
# 22.Identify bad input; recover if possible.
识别错误输入;并尽可能修复
# 23.Make input easy to prepare and output self-explanatory.
让输入容易构造;让输出表述清楚
# 24.Use uniform input formats.
使用统一的输入格式
# 25.Make input easy to proofread.
让输入容易校对
# 26.Use self-identifying input. Allow defaults. Echo both> 
# 27.Make sure all variable are initialized before use.
确保所有的变量在使用前都被初始化
# 28.Don't stop at
# 29.Use debugging compilers.
打开编译程序的调试选项
# 30.watch out for off-by-one errors.
小心off-by-one错误(http://en.wikipedia.org/wiki/Off-by-one_error)
# 31.Take care to branch the right way>
# 32.Be careful if a loop exits to the same place from the middle and the bottom.
当循环中有多个跳出点时要小心
# 33.Make sure your code does "nothing" gracefully.
如果什么都不做,那么也要优雅地表达这个意思
# 34.Test programs at their boundary values.
用边界值测试程序
# 35.Check some answers by hand.
手工检查一些答案
# 36.10.0 times 0.1 is hardly ever 1.0.
10.0乘以0.1很难保证永远是1.0
# 37.7/8 is zero while 7.0/8.0 is not zero.
7/8 等于0,而7.0/8.0不等于0
# 38.Don't compare floating point numbers solely for equality.
不要简单地判断两个浮点数是否相等
# 39.Make it right before you make it faster.
先做对,再做快
# 40.Make it fail-safe before you make it faster.
先使其可靠,再让其更快
# 41.Make it clear before you make it faster.
先把代码弄干净,再让它变快
# 42.Don't sacrifice clarity for small gains in "efficiency."
别为一丁点"性能"就牺牲掉整洁
# 43.Let your compiler do the simple optimizations.
简单的优化让编译器去做
# 44.Don't strain to re-use code; reorganize instead.
不要过分追求重用代码;下次用的时候重新组织一下即可
# 45.Make sure special cases are truly special.
确保特殊的情况的确是特殊的
# 46.Keep it simple to make it faster.
保持简单以使其更快
# 47.Don't diddle code to make it faster - find a better algorithm.
不要死磕代码来加快速度 - 找个更好的算法
# 48.Instrument your programs. Measure before making "efficiency" changes.
用工具分析你的程序.在做"性能"改进前先评测一下
# 49.Make sure comments and code agree.
确保注释和代码一致
# 50.Don't just echo the code with comments - make every comment count.
不要在注释里仅仅重复代码 - 让每处注释都有价值
# 51.Don't comment bad code - rewrite it.
不要给糟糕的代码做注释 - 应该重写它
# 52.Use variable names that mean something.
采用有意义的变量名
# 53.Use statement labels that mean something.
使用有意义的语句标签
# 54.Format a program to help the reader understand it.
格式化程序让阅读代码的人更容易理解
# 55.Document your data layouts.
为数据布局撰写文档
# 56.Don't over-comment.
不要过分注释
}

1. 存储在计算机中的所有内容都是数字。计算机以数字形式存储数字和字符。每个字符都有
一个数字码，计算机载入寄存器的指令也以数字形式存储，指令集中的每条指令都有一个数字码
2. 计算机程序最终必须以数字指令码来表示。

extern(附录){
一些有用的C语言网络资源：
C语言标准化组织ISO JTC1/SC22/WG14的主页，在这里可以找到ISO C的文档：http://www.open-std.org/jtc1/sc22/wg14/
《The Development of the C Language》作者Dennis Ritchie，极为经典的论文。 http://cm.bell-labs.com/cm/cs/who/dmr/chist.html
"C语言全景"这个网站内容很全面：http://www.softpanorama.org/Lang/c.shtml
Dan Saks在embedded.com上的专栏Programming Pointer ，里面文章很有深度，值得一读。
http://www.lysator.liu.se/c/c-www.html 这也是一个C语言资源汇总页面。
http://www.ioccc.org/index.html 混乱C语言代码大赛，很著名。
http://en.wikipedia.org/wiki/Underhanded_C_Contest 另外一个C语言编程大赛，主要面向黑客。
comp.lang.c以及c.moderated这两个讨论组推荐订阅，相当于互联网最大的C相关编程问题论坛：
http://groups.google.com/group/comp.lang.c
http://groups.google.com/group/comp.lang.c.moderated
这里对C语言的各种bit操作做了收集整理，不少题目在面试时候经常出现。http://graphics.stanford.edu/~seander/bithacks.html
台湾的惯C达人Jserv博客，建议大家订阅：http://blog.linux.org.tw/~jserv/
一些值得关注及研究的C语言相关项目：
TinyCC，被很多项目用作动态编译C语言的编译器引擎：http://bellard.org/tcc/
GCC的标准库实现：http://en.wikipedia.org/wiki/GNU_C_Library
Glib是GTK的底层辅助编程库，与C标准库是不一样的，在C语言上实现了面向对象机制：http://en.wikipedia.org/wiki/GLib
dietlibc在前面博客文章介绍过，C标准库的另一种实现：http://www.fefe.de/dietlibc/
一些C语言编程时可以使用的工具软件，帮你提高代码质量：
http://www.splint.org/
http://valgrind.org/
http://www.dwheeler.com/flawfinder/
PMD可用于检测重复代码 http://pmd.sourceforge.net/cpd.html
llvm的静态分析项目 http://clang-analyzer.llvm.org/
C语言编程规范编程标准：
http://en.wikipedia.org/wiki/MISRA_C
http://www.eecs.harvard.edu/~ellard/CS50-96/programming-style.html
http://developers.sun.com/solaris/articles/secure.html
cert这个文档国内有中文翻译版本：https://www.securecoding.cert.org/confluence/display/seccode/CERT+C+Secure+Coding+Standard
http://www.cs.utah.edu/dept/old/texinfo/standards/standards_toc.html
C语言编程电子书及教程：
http://publications.gbdirect.co.uk/c_book/ 这一本写的非常详细，你可以把它看成是类似谭浩强版的教科书。
http://www.knosof.co.uk/cbook/cbook.html 这一本云风曾经推荐过，相当深入的介绍了C99标准，深入细节时候需要读读。
http://www.duckware.com/bugfreec/index.html 这本书在网上流传一个中文版本，《编写优化、高效、无错地代码》，另外也有英文影印版《编程精粹》。
http://wangcong.org/blog/?page_id=196 作者王聪，也是相当hard geek，从两个样章看，包含了相当多的内容。
《C语言深度解剖》这本可以在百度文库或google搜到，可以读读，有些参考性。
《C标准和实现》作者姚新颜，他的《深度探索C、C++》算是当年比较有深度的书籍，可惜已经绝版了。这本书也可以在百度文库搜到。这本书也比较值得读。
良葛格C语言学习笔记 http://caterpillar.onlyfun.net/Gossip/CGossip/CGossip.html
C与C++的兼容性问题 http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B
另一个文档关于C与C++标准兼容性问题：http://david.tribble.com/text/cdiffs.htm
《C Elements of Style》http://www.oualline.com/books.free/style/index.html
《Linux安全编程》http://www.dwheeler.com/secure-programs/
《C Craft》电子版 http://crypto.stanford.edu/~blynn/c/
《The function pointer tutorials》函数指针教程。http://www.newty.de/fpt/index.html
C语言编程及Unix系统调用，想用C在Unix或者Linux编程的朋友可以参考。http://www.cs.cf.ac.uk/Dave/C/
优化C、C++代码 http://www.eventhelix.com/RealtimeMantra/Basics/OptimizingCAndCPPCode.htm
图文并茂介绍C语言的指针 http://boredzo.org/pointers/
另外一篇介绍C语言优化的文章 http://www.prism.uvsq.fr/~cedb/local_copies/lee.html
一个C语言教学ppt http://www.slideshare.net/petdance/just-enough-c-for-open-source-programmers
一些Unix下C语言编程相关的文章 http://users.actcom.co.il/~choo/lupg/tutorials/index.html
Unix下如何建立静态、动态C语言函数库 http://users.actcom.co.il/~choo/lupg/tutorials/libraries/unix-c-libraries.html
如何使用GDB http://users.actcom.co.il/~choo/lupg/tutorials/debugging/debugging-with-gdb.html
一些C语言编程技巧 http://users.bestweb.net/~ctips/
Advanced C programming，高级C语言编程，可以提高水平，非常有帮助 http://www.mpi-inf.mpg.de/departments/rg1/teaching/advancedc-ws08/literature.html
C语言问答，这些题目也可用于面试 http://www.gowrikumar.com/c/
}