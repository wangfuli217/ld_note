https://www.linuxidc.com/Linux/2011-04/34523.htm

https://www.linuxidc.com/Linux/2016-12/138670.htm

https://www.linuxidc.com/Linux/2016-05/131148.htm

https://www.linuxidc.com/Linux/2016-05/131147.htm  # SSL/TLS原理详解
https://www.linuxidc.com/Linux/2016-11/137556.htm  # 抓包分析SSL/TLS连接建立过程
总结

https://juejin.im/post/584b76d3a22b9d0058d5036f #  SSL/TLS 握手过程详解
http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html # SSL/TLS协议运行机制的概述

-------------------- ruanyifeng -----------------------------------
一、作用
不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。
    （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。
    （2） 篡改风险（tampering）：第三方可以修改通信内容。
    （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。
SSL/TLS协议是为了解决这三大风险而设计的，希望达到：
    （1） 所有信息都是加密传播，第三方无法窃听。
    （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
    （3） 配备身份证书，防止身份被冒充。
目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.
2的支持。
TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。
SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然
后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题。
（1）如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session k
ey），用它来加密信息。
由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本
身，这样就减少了加密运算的消耗时间。
因此，SSL/TLS协议的基本过程是这样的：
    （1） 客户端向服务器端索要并验证公钥。
    （2） 双方协商生成"对话密钥"。
    （3） 双方采用"对话密钥"进行加密通信。
    客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网
站，否则会分不清应该向
客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原
因。
    对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name
 Indication扩展，
允许客户端向服务器提供它所请求的域名。

# 
第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。
第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

-> RSA算法，改为 Diffie-Hellman算法
采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。
这是DH算法的一个简单描述：
1) A随机产生一个大整数a，然后计算Ka=ga mod n。（a需要保密）
2) B随机产生一个大整数b，然后计算Kb=gb mod n。（b需要保密）
3) A把Ka发送给B,B把Kb发送给A
4) A计算K=Kba mod n
5) B计算K=Kab mod n
由于Kba mod n= （gb mod n）a mod n= （ga mod n）b mod n，因此可以保证双方得到的K是相同的，K即是共享的密钥。
意思是说client与server端都有一个随机数是不会通过网络传输的。所以保证了安全。


session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，
只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。


# FAQ
# Q1
首先：RSA使用公钥加密之后，只能使用私钥解密。
其次：第三个随机数是使用公钥加密的，此时发送给服务器，服务器必须使用私钥才能解。
上文有些人说已经得到服务器私钥，那你都知道私钥了，肯定是知道第三个随机数是什么。
然后使用这3个随机数导出一个密钥，然后使用约定的加密方法在此之后加密所有传输的内
容。

文中并没有讲约定的什么加密方法，其实是双方约定DES/AES/3DES之类的，早期用过RC4之
类的，这算法安全性很低。
常用的移动端、PC比较流行的加密方法是：EECDH+CHACHA20 EECDH+CHACHA20-draft EECDH+
AES128 RSA+AES128 EECDH+AES256 RSA+AES256 EECDH+3DES RSA+3DES

关于证书：
证书必须是CA颁发的，当然你也可以自己建立根证书，然后颁发证书。但是这个根证书没有
浏览器信任，除非你导入到自己电脑的「受信任的根证书」，比如12306就这么弄的。浏览
器会去检查你的证书以及根证书是否信任
# Q2
使用PKI机制进行密钥交换只是TLS规范的一种实现形式，还有其他的形式可以用于密钥交换，比如SRP和PSK协议。
# Q3
关于 至于为什么一定要用三个随机数，来生成"会话密钥" 这个地方，其实还有一点：pre-master key 用服务器的公钥加密，
可以防止第三方冒充服务器，因为任何人都可以获取已经公开的服务器公钥与客户段进行通信。想要获得 pre-master key 
明文只有利用服务器的私钥进行解密，所以这里进行了服务器的身份验证，也防止了中间人攻击。

另外，当服务器需要验证客户端时，客户端在发送 pre-master key 之前需要发送客户端公钥到服务器，可以选择对 
pre-master key 用客户端的私钥签名然后再用服务器公钥加密，则服务器收到 pre-master key 同时对客户端进行了身份验证。
# Q4
三个随机数通过一个密钥导出器最终导出一个对称密钥
# Q5
仔细看了每一位的留言，发现很多人对三个随机数的作用有疑问，其实是这样的：
1. 第一个随机数是客户端以明文的方式发到服务器的，而且是个明文的伪随机数
2. 第二个随机数是服务端以明文的方式发到客户端的，也是一个明文的伪随机数
3. 第三个随机数是客户端以服务器的公钥加密后发到服务器的，是一个加密的伪随机数
先说结论：如果能保证第三个随机数是真正的随机数，而非伪随机数，那么第1和第2个随机数是没任何必要的。
握手的过程就是因为考虑到第3个是伪随机数，才引入前2个伪随机数，由3个伪随机数构造一个相对更随机的伪随机数，
再基于这个最终的伪随机数计算出会话密钥(Session Key)。

所以一个中间攻击人即使截获了第1和第2个伪随机数，同时也知道第3个是伪随机数(单纯这么一个伪随机数，下大力气是有可能碰撞到的)，
在三个伪随机数运算后再做加密的情况下，他碰撞到最终结果的难度也是成倍或几十、几百倍的上升。

    不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，
因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
    对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，
三个随机数通过一个密钥导出器最终导出一个对称密钥。
    pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret
就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，
那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，
可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。

-------------------- linuxidc -----------------------------------

证书 私钥和公钥

公钥则是附带在证书的信息中，可以公开的。
证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证
书被串改。
证书还有个有效期。

对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合
法的客户端。
服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法
性进行验证。

客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服
务端，
服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产
生Master Secret。
第一项的随机数，是整个握手阶段出现的第三个随机数，它是客户端使用一些加密算法(例
如：RSA, Diffie-Hellman)产生一个48个字节的Key，这个Key叫 PreMaster Secret，很多
材料上也被称作 PreMaster Key。

SSL/TLS 握手过程
Client Hello -> 客户端生成的随机数 Random1、客户端支持的加密套件（Support Cipher
s）和 SSL Version 等
Server Hello -> 从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件， 还
会生成一份随机数 Random2
                两个随机数会在后续生成对称秘钥时用到。
Certificate  -> 服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验
证通过后取出证书中的公钥。
Server Key Exchange -> 如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这
一步。
Certificate Request -> 服务端要求客户端上报证书，这一步是可选的，对于安全性要求
高的场景会用到。
Server Hello Done   -> 通知客户端 Server Hello 过程结束。
Certificate Verify  -> 客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性
，验证通过后取出证书中的服务端公钥，
                       再生成一个随机数 Random3，再用服务端公钥非对称加密 Random
3 生成 PreMaster Key
Client Key Exchange -> 客户端根据服务器传来的公钥生成了 PreMaster Key，Client Ke
y Exchange 就是将这个 key 传给服务端，
                       服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成
的 Random3
                       至此，客户端和服务端都拥有 Random1 + Random2 + Random3，
两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进
行对称加密。
Change Cipher Spec(Client) -> 客户端通知服务端后面再发送的消息都会使用前面协商出
来的秘钥加密了，是一条事件消息。
Encrypted Handshake Message(Client) -> 这一步对应的是 Client Finish 消息，客户端
将前面的握手消息生成摘要再用协商好的秘钥加密，
                       这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密
，能解出来说明前面协商出来的秘钥是一致的。
Encrypted Handshake Message(Server) -> 这一步对应的是 Server Finish 消息，服务端
也会将握手过程的消息生成摘要再用秘钥加密，
                      这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，
能解出来说明协商的秘钥是一致的。
Application Data -> 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会
用这个秘钥加密后再通过 TCP 进行可靠传输。
                      
ClientHello              # 
 ServerHello             # 
 ServerCertificate       # 
 ServerKeyExchange       # 
 CertificateRequest      # 
 Server Hello Done       # 
ClientCertificate        # 
ClientKeyExchange        # 
CertificateVerify        # 
ChangeCiperSpec          # 
Finished                 # 
 ClientCertificate       # 
 ClientKeyExchange       # 
 CertificateVerify       # 
 ChangeCiperSpec         # 
 Finished
# "握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是
明文的


Client Key Exchange
Certificate Verify

PreMaster secret，Master secret，session secret


MD5
       MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一
致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已
有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身
有MD2、MD3和MD4。

SHA
      安全散列算法SHA (Secure Hash Algorithm)，用于确保信息传输完整一致。SHA基于
MD5实现。
是美国国家标准技术研究所发布的国家标准FIPS PUB 180，最新的标准已经于2008年更新到
FIPS PUB 180-3。其中规定了SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向
散列算法。SHA-1，SHA-224和SHA-256适用于长度不超过2^64二进制位的消息。SHA-384和SH
A-512适用于长度不超过2^128二进制位的消息。

DES  
       DES是Data Encryption Standard（数据加密标准）的缩写，DES算法为密码体制中
的对称密码体制。它是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它
作为非机要部门使用的数据加密标准，二十年来，它一直活跃在国际保密通信的舞台上，扮
演了十分重要的角色。
        DES是一个分组加密算法，他以64位为分组对数据加密。同时DES也是一个对称算法
：加密和解密用的是同一个算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验）
，密匙可以是任意的56位的数，而且可以任意时候改变。其中有极少量的数被认为是弱密匙
，但是很容易避开他们。所以保密性依赖于密钥。
        特点：分组比较短、密钥太短、密码生命周期短、运算速度较慢。
　　  DES算法具有极高安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还
没有发现更有效的办法。而56位长的密钥的穷举空间为256，这意味着如果一台计算机的速
度是每一秒种检测一百万个密钥，则它搜索完全部密钥就需要将近2285年的时间。
        DES现在已经不视为一种安全的加密算法，因为它使用的56位秘钥过短，以现代计
算能力，24小时内即可能被破解。也有一些分析报告提出了该算法的理论上的弱点，虽然实
际情况未必出现。该标准在最近已经被高级加密标准（AES）所取代。

3DES
      3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption A
lgorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。由于计算机运
算能力的增强，原版DES密码的密钥长度变得容易被暴力破解；3DES即是设计用来提供一种
相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块
密码算法。

AES
      高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是
美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且
广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NI
ST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年
，高级加密标准已然成为对称密钥加密中最流行的算法之一。
       AES的区块长度固定为128 位元，密钥长度则可以是128，192或256位元。
 
RSA
      RSA加密算法是一种非对称加密算法。在公钥加密标准和电子商业中RSA被广泛使用。
RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿
德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们
三人姓氏开头字母拼在一起组成的。
       RSA算法的可靠性基于分解极大的整数是很困难的。假如有人找到一种很快的分解因
子的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可
能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还
没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是
不能被解破的。
       RSA算法利用两个很大的质数相乘所产生的乘积来加密。这两个质数无论哪一个先与
原文件编码相乘，对文件加密，均可由另一个质数再相乘来解密。但要用一个质数来求出另
一个质数，则是十分困难的。因此将这一对质数称为密钥对(Key Pair)。在加密应用时，某
个用户总是将一个密钥公开，让需发信的人员将信息用其公共密钥加密后发给该用户，而一
旦信息加密后，只有用该用户一个人知道的私用密钥才能解密。具有数字凭证身份的人员的
公共密钥可在网上查到，亦可在请对方发信息时主动将公共密钥传给对方，这样保证在Inte
rnet上传输信息的保密和安全。

ECC
      ECC椭圆曲线加密算法是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提
出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。
       与经典的RSA，DSA等公钥密码体制相比，椭圆密码体制有以下优点：
       1.安全性高:有研究表示160位的椭圆密钥与1024位的RSA密钥安全性相同。
       2.处理速度快:在私钥的加密解密速度上，ecc算法比RSA、DSA速度更快。
       3.存储空间占用小。
       4.带宽要求低。