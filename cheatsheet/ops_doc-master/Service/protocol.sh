
format(四种基本格式){
一般而言，应用层协议设计有四种常见方法：
    每个发送的包长度固定
    包每行均采取特殊结束标记用以区分（例如HTTP使用的\r\n）
    包前添加长度信息（所谓的TLV模式，即type、length、value）
    利用包本身的格式解析（如XML、JSON等）
P.S. 还有诸如google的protobuf等跨语言的协议打包格式。

1. 每个发送的包长度固定
很简单的思路，我们可以定义服务端和客户端均采用同一个结构体进行数据传输，这样的话很容易根据结构体大小来进行分隔收到的数据。

2. 包每行均采取特殊结束标记用以区分（例如HTTP使用的\r\n）
这个也很简单理解，采用纯ASCII发送信息的时候，完全可以采用这种方式。比如一个包中，每行采用\r\n进行分隔，包结束采用\r\n\r\n进行分隔等等。
如果在包的数据中出现了结束标记怎么办？转义呗～

3. 包前添加长度信息（所谓的TLV模式，即type、length、value）
这个理解起来也不困难，以结构体为例，即便是服务端和客户端采用多种结构体进行通信，只需要加上一个类型字段和长度字段，这样不就解决了么。
不过这里的type、length以及value只是指导思想，大家完全可以自行去实现自己的格式。

4. 利用包本身的格式解析（如Xml、Json等）
}

design(){
1. 协议的结构
协议头的格式
  协议头有哪些协议类型
协议体的结构
  协议体有哪些子结构
  
2. 协议的序列化
  每个发送的包长度固定和包前添加长度信息(TLV模式，即type、length、value)会关联到序列化的问题
  
3. 协议解析
  协议头和协议体之间的关系
  协议头的解析
  协议体的解析

4. 协议构建
  协议头和协议体之间的关系
  协议头的构建
  协议体的构建
  
5. 协议的流程
  从用户名密码注册到sessionid获得
  请求和发送模式
  注册和通告模式
  心跳维护方式
  异常字符串或异常标识符
  请求状态和配置管理，交互流程的记录和可读化表示
  
6. 连接管理和数据包处理
  连接状态与数据包关系
    分配连接
    创建连接
    释放连接
    有状态的连接
    无状态的连接

7. 统计信息
  发送和接收字节数，数据包数和连接创建数
}

blocked(同步、异步、阻塞、非阻塞){
a. 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication).
   同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。
   异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。
    1.同步与异步是关于指令执行顺序的。
  1.1. moosefs中，客户端请求元数据服务器写数据，元数据服务器通知存储数据服务器创建数据块，
元数据服务器等到存储数据服务器回应之后，告知客户端向那些存储数据服务器的数据块写数据。
  1.2. moosefs中，客户端向存储数据服务器写数据的时候，在第一个65536大小请求未确认的情况下，就已经发送
后续的65536大小写数据请求，等到所有65536大小请求都完成的时候，向write返回写数据结束。
---- ----
同步：
  1.3 所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。
      也就是必须一件一件事做,等前一件做完了才能做下一件事。
      就是由*调用者*主动等待这个*调用*的结果。
  例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事
  1.4 异步：当c端一个异步过程调用发出后，调用者不能立刻得到结果。
      实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
  例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕
  
举个通俗的例子：
  你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，"我查一下"，
然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
  而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。
然后查好了，他会主动打电话给你。在这里老板通过"回电"这种方式来回调。
  
  
b. 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
   阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，
   说白了是一种读取或者写入操作函数的实现方式；
   阻塞方式下读取或者写入函数将一直等待，
   非阻塞方式下，读取或者写入函数会立即返回一个状态值。

    2. 阻塞非阻塞是关于线程与进程的。  阻塞非阻塞是针对进程或者线程的调用结果来说的
  2.1 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，
cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。
  2.2 阻塞和同步： 对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。
而此时，当前线程还会继续处理各种各样的消息。
  2.3 非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

c. 在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。
IO multiplexing(poll|select|epoll)
     阻塞              非阻塞           --> 同步IO
Linux   Windows   .NET
 AIO      IOCP    BeginInvoke|EndInvoke --> 异步IO
--------------------------------------------------------
        Blocking           NON-Blocking
同步    Read|Write         Read|Write(O_NONBLOCK)
异步    select|poll|epoll  AIO
1. 同步阻塞 2. 同步非阻塞 3. 异步阻塞 4. 异步非阻塞
  
同步IO都会有一个阻塞的过程，但是不应该等同于"阻塞IO"，
因为"阻塞IO"、"非阻塞IO"和"IO复用"、"消息驱动IO"、"异步IO"同属于是linux下五种IO模式，
其中前四种都属于同步IO，都会有一个阻塞的过程。
}


protocol(通信方式){
主要有以下三大类:
(一)SERVER/CLIENT方式
    1.一个Client方连接一个Server方，或称点对点(peer to peer)： 
    2.多个Client方连接一个Server方，这也是通常的并发服务器方式。 
    3.一个Client方连接多个Server方，这种方式很少见，主要用于一个客户向多个服务器发送请求情况。
(二)连接方式
1.长连接
    Client方与Server方先建立通讯连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在，可以用下面命令查看连接是否建立：
    netstat –f inet|grep 端口号(如5678)。
    此种方式常用于点对点通讯。
2.短连接
    Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server.
(三)发送接收方式
1.异步
    报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况：
    (1)异步双工：接收和发送在同一个程序中，有两个不同的子进程分别负责发送和接收 
    (2)异步单工：接收和发送是用两个不同的程序来完成。

2.同步
    报文发送和接收是同步进行，即报文发送后等待接收返回报文。同步方式一般需要考虑超时问题，即报文发上去后不能无限等待，需要设定超时时间，
    超过该时间发送方不再等待读返回报文，直接通知超时返回。 


实际通信方式是这三类通信方式的组合。比如一般书上提供的TCP/IP范例程序大都是同步短连接的SERVER/CLIENT程序。有的组合是基本不用的，比较常用的有价值的组合是以下几种：

同步短连接Server/Client 
同步长连接Server/Client 
异步短连接Server/Client 
异步长连接双工Server/Client 
异步长连接单工Server/Client

其中异步长连接双工是最为复杂的一种通信方式，有时候经 常会出现在不同银行或不同城市之间的两套系统之间的通信。 
比如金卡工程。由于这几种通信方式比较固定，所以可以预 先编制这几种通信方式的模板程序。

}

protocol(报文格式){
通信报文格式多样性更多，相应地就必须设计对应的读写报文的接收和发送报文函数。
(一)阻塞与非阻塞方式　
    1.非阻塞方式
    读函数不停地进行读动作，如果没有报文接收到，等待一段时间后超时返回，这种情况一般需要指定超时时间。
    2.阻塞方式
    如果没有报文接收到，则读函数一直处于等待状态，直到有报文到达。

(二)循环读写方式 
    1.一次直接读写报文
    在一次接收或发送报文动作中一次性不加分别地全部读取或全部发送报文字节。
    
    2.不指定长度循环读写
    这一般发生在短连接进程中，受网络路由等限制，一次较长的报 文可能在网络传输过程中被分解成了好几个包。一次读取可能不 
    能全部读完一次报文，这就需要循环读报文，直到读完为止。

    3.带长度报文头循环读写
    这种情况一般是在长连接进程中，由于在长连接中没有条件能够判断循环读写什么时候结束，所以必须要加长度报文头。读函数 
    先是读取报文头的长度，再根据这个长度去读报文.实际情况中， 报头的码制格式还经常不一样，如果是非ASCII码的报文头，还必须 
    转换成ASCII,常见的报文头码制有： 
    (1)n个字节的ASCII码 
    (2)n个字节的BCD码 
    (3)n个字节的网络整型码

以上是几种比较典型的读写报文方式，可以与通信方式模板一起 预先提供一些典型的API读写函数。当然在实际问题中，可能还 必须编写与对方报文格式配套的读写API.

在实际情况中，往往需要把我们自己的系统与别人的系统进行连接，有了以上模板与API,可以说连接任何方式的通信程序都不存在问题。
}


sessionid(){

}

seq(){

}

auth(){


}

state(){
[http]
状态码：
    1xx：指示信息–表示请求已接收，继续处理。
    2xx：成功–表示请求已被成功接收、理解、接受。
    3xx：重定向–要完成请求必须进行更进一步的操作。
    4xx：客户端错误–请求有语法错误或请求无法实现。
    5xx：服务器端错误–服务器未能实现合法的请求。
    

}

version(){

}
longshort_connect_struct(){
什么是"长连接"和"短连接"？
解释1
    所谓长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差，   
    所谓短连接指建立SOCKET连接后发送后接收完数据后马上断开连接，一般银行都使用短连接
解释2
    长连接就是指在基于tcp的通讯中，一直保持连接，不管当前是否发送或者接收数据。   
    而短连接就是只有在有数据传输的时候才进行连接，客户－服务器通信/传输数据完毕就关闭连接。
解释3
    长连接和短连接这个概念好像只有移动的CMPP协议中提到了，其他的地方没有看到过。   
短连接：比如http的，只是连接、请求、关闭，过程时间较短,服务器若是一段时间内没有收到请求即可关闭连接。   
长连接：有些服务需要长时间连接到服务器，比如CMPP，一般需要自己做在线维持。
}

longshort_connect_object(){
应用场景：
     长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，
 如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就
 OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 
 创建也是对资源的浪费。
     而像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），
因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省
一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，
但每个用户无需频繁操作情况下需用短连好；
     在长连接中一般是没有条件能够判断读写什么时候结束，所以必须要加长度报文头。读函数先是读取报文头的长度，
再根据这个长度去读相应长度的报文。

[http]
    短连接过程： client 向 server 发起连接请求，server 接到请求，然后双方建立连接。client 向 server 发送消息，
server 回应 client，然后一次请求就完成了。这时候双方任意都可以发起 close 操作，不过一般都是 client 先发起 close 操作。
也就是说，短连接一般只会在 client 和 server 间进行一次请求操作。
优点： 管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。
缺点： 如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费时间和带宽。
    长连接过程： client 向 server 发起连接，server 接受 client 连接，双方建立连接，client 与 server完成一次请求后，
它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。
    TCP 的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而
服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。
    如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测 4 个客户端状态：
  客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
  客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应 TCP。服务端将无法收到客户端对探测的响应。
服务器总共发送 10 个这样的探测，每个间隔 75 秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。
  客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
  客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。
    优点： 对于请求比较频繁客户来说，可以节省在 TCP 的建立和关闭操作上浪费时间和带宽。
    缺点： 存活探测周期太长，而且 client 端一般不会主动关闭它与服务器之间的连接，如果 client 与 server 之间的连接
一直不关闭的话，随着客户端连接越来越多，server 早晚有扛不住的时候 ，这时候 server 端需要采取一些策略，如关闭一些
长时间没有读写事件发生的连接，以避免一些恶意连接导致 server 端服务受损；如果条件再允许就可以以客户端机器为颗粒度，
限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
}

proto(Redis 协议){
https://redis.io/topics/protocol
https://redis.io/topics/pipelining
https://www.redisgreen.net/blog/beginners-guide-to-redis-protocol/

1. Redis 客户端和服务端交互的协议叫做 RESP(REdis Serialization Protocol)，Redis集群中节点交互用的不是这协议
2. RESP是二进制安全的， 支持多种数据格式
3. RESP工作在TCP层，基于文本的协议，服务端默认端口是6379
4. 基本是基于请求-响应的模式， piplining和sub/pub两个除外.

协议描述
---------------------------------------
RESP协议中，数据类型依赖于第一个字节

1. Simple String 第一个字节是 "+"
2. Error 第一个字节是 "-"
3. Integers 第一个字节是 ":"
4. Bulk String 第一个字节是 "$"
5. Arrays 第一个字节是 "*"
6. 不同数据块之间使用 \r\n(CRLF) 来分割


Simple String
---------------------------------------
简单字符串类型： 编码格式如下，一个 "+" 号，后面跟着字符串（但是不包含 \n或者 \r）, 结尾是 \r\n。
主要用来传输，比较短的非二进制安全字符串, 例如传递 "OK"。
+OK\r\n

4 总结
---------------------------------------
数据格式非常简单
基于文本的协议，可读性好
协议中控制字段非常少，很简洁，解析高效
协议本身是明文，公网使用注意加密传输
}

proto(moosefs){

}

proto(libubox){

}

proto(c-json){

}
