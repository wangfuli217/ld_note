!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADDFILE_TEST	regress_buffer.c	2538;"	d	file:
ADDFILE_TEST_GROUP	regress_buffer.c	2542;"	d	file:
ALLOC	regress_bufferevent.c	/^		ALLOC, FREE,$/;"	e	enum:__anon1::__anon2	file:
ARRAY_SIZE	regress_dns.c	75;"	d	file:
B	test-ratelim.c	213;"	d	file:
B	test-ratelim.c	220;"	d	file:
BACKLOG_SIZE	regress_http.c	1362;"	d	file:
BAD	regress_http.c	2481;"	d	file:
BAD	regress_http.c	2837;"	d	file:
BAD	regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	e	enum:entry_status	file:
BASIC	regress.h	102;"	d
BASIC	regress_http.c	/^	BASIC = 1,$/;"	e	enum:http_cancel_test_type	file:
BASIC_REQUEST_BODY	regress_http.c	/^static char const BASIC_REQUEST_BODY[] = "This is funny";$/;"	v	file:
BIO_TYPE_LIBEVENT_RWCOUNT	regress_ssl.c	631;"	d	file:
BIO_new_rwcount	regress_ssl.c	/^BIO_new_rwcount(int close_flag)$/;"	f	file:
BIO_s_rwcount	regress_ssl.c	/^BIO_s_rwcount(void)$/;"	f	file:
BY_HOST	regress_http.c	/^	BY_HOST = 2,$/;"	e	enum:http_cancel_test_type	file:
CANONICAL	regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	e	enum:entry_status	file:
CAN_CHECK_ERR	regress_util.c	503;"	d	file:
CB_COUNT	regress_thread.c	389;"	d	file:
CHUNKS	regress_http.c	/^static char const* const CHUNKS[] = {$/;"	v	file:
DEC	regress_http.c	2861;"	d	file:
DEC	regress_http.c	2946;"	d	file:
DNS_LEGACY	regress_dns.c	2117;"	d	file:
ENC	regress_http.c	2847;"	d	file:
ENC	regress_http.c	2945;"	d	file:
END_OF_ALIASES	tinytest.h	73;"	d
END_OF_GROUPS	tinytest.h	67;"	d
END_OF_TESTCASES	tinytest.h	60;"	d
EVBUFFER_INITIAL_LENGTH	regress_buffer.c	1545;"	d	file:
EVRPC_STRUCT	regress_rpc.c	/^MessageCb(EVRPC_STRUCT(Message)* rpc, void *arg)$/;"	f	file:
EVRPC_STRUCT	regress_rpc.c	/^NeverReplyCb(EVRPC_STRUCT(NeverReply)* rpc, void *arg)$/;"	f	file:
FAIL	tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
FORK_BREAKS_GCOV	regress_main.c	39;"	d	file:
FORK_BREAKS_GCOV	tinytest.c	48;"	d	file:
FREE	regress_bufferevent.c	/^		ALLOC, FREE,$/;"	e	enum:__anon1::__anon2	file:
FREEZE_EQ	regress_buffer.c	2300;"	d	file:
GAIC_MAGIC	regress_dns.c	1732;"	d	file:
GotErrorCb	regress_rpc.c	/^GotErrorCb(struct evrpc_status *status,$/;"	f	file:
GotKillCb	regress_rpc.c	/^GotKillCb(struct evrpc_status *status,$/;"	f	file:
GotKillCbTwo	regress_rpc.c	/^GotKillCbTwo(struct evrpc_status *status,$/;"	f	file:
HTTP	regress_http.c	4523;"	d	file:
HTTPS	regress_http.c	4524;"	d	file:
HTTP_BIND_IPV6	regress_http.c	86;"	d	file:
HTTP_BIND_SSL	regress_http.c	87;"	d	file:
HTTP_CAST_ARG	regress_http.c	4518;"	d	file:
HTTP_LEGACY	regress_http.c	4514;"	d	file:
HTTP_N	regress_http.c	4521;"	d	file:
HTTP_OFF_N	regress_http.c	4519;"	d	file:
HTTP_SSL_FILTER	regress_http.c	88;"	d	file:
I64_FMT	bench_httpclient.c	219;"	d	file:
I64_TYP	bench_httpclient.c	220;"	d	file:
IMPL_DBG_LEAK_RESUME	regress_dns.c	1945;"	d	file:
INACTIVE_SERVER	regress_http.c	/^	INACTIVE_SERVER = 8,$/;"	e	enum:http_cancel_test_type	file:
KEY	regress_ssl.c	/^static const char KEY[] =$/;"	v	file:
LEGACY	regress.h	105;"	d
LOCAL_SOCKETPAIR_AF	regress.c	404;"	d	file:
LOCAL_SOCKETPAIR_AF	regress_et.c	71;"	d	file:
LOCAL_SOCKETPAIR_AF	regress_et.c	73;"	d	file:
LOCAL_SOCKETPAIR_AF	test-dumpevents.c	91;"	d	file:
LOGEQ	regress_util.c	564;"	d	file:
LOGEQ	regress_util.c	634;"	d	file:
LONGEST_TEST_NAME	tinytest.c	62;"	d	file:
MAGIC_EXITCODE	tinytest.c	116;"	d	file:
MANY	regress.c	3021;"	d	file:
MANY	regress.c	3070;"	d	file:
MAX_CALLS	regress_iocp.c	56;"	d	file:
MAX_REQUESTS	test-fdleak.c	54;"	d	file:
MAX_REQUESTS	test-fdleak.c	56;"	d	file:
NCF	regress_http.c	2486;"	d	file:
NDEBUG	regress_bufferevent.c	30;"	d	file:
NDEBUG	regress_rpc.c	29;"	d	file:
NDEBUG	regress_thread.c	29;"	d	file:
NDEBUG	regress_zlib.c	28;"	d	file:
NEVENT	test-time.c	48;"	d	file:
NI_MAXSERV	regress_http.c	164;"	d	file:
NORMAL	regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	e	enum:entry_status	file:
NO_NS	regress_http.c	/^	NO_NS = 4,$/;"	e	enum:http_cancel_test_type	file:
NO_PYTHON_EXISTS	regress.gen.h	1;"	d
NS_TIMEOUT	regress_http.c	/^	NS_TIMEOUT = 32,$/;"	e	enum:http_cancel_test_type	file:
NUM_ITERATIONS	regress_thread.c	94;"	d	file:
NUM_THREADS	regress_thread.c	257;"	d	file:
NUM_THREADS	regress_thread.c	258;"	d	file:
NUM_THREADS	regress_thread.c	93;"	d	file:
N_EVENTS	test-dumpevents.c	69;"	d	file:
N_REQUESTS	bench_httpclient.c	/^const int N_REQUESTS = 20000;$/;"	v
OK	tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
OLD_DEC	regress_http.c	2870;"	d	file:
OLD_DEC	regress_http.c	2947;"	d	file:
PARALLELISM	bench_httpclient.c	/^const int PARALLELISM = 200;$/;"	v
POST_DATA	regress_http.c	1919;"	d	file:
PUT_DATA	regress_http.c	2058;"	d	file:
QUEUE_THREAD_COUNT	regress_thread.c	390;"	d	file:
REGRESS_H_INCLUDED_	regress.h	28;"	d
REGRESS_OPENSSL_CLIENT	regress_ssl.c	/^	REGRESS_OPENSSL_CLIENT = 64,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_CLIENT_WRITE	regress_ssl.c	/^	REGRESS_OPENSSL_CLIENT_WRITE = 2048,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_DIRTY_SHUTDOWN	regress_ssl.c	/^	REGRESS_OPENSSL_DIRTY_SHUTDOWN = 16,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_FD	regress_ssl.c	/^	REGRESS_OPENSSL_FD = 32,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_FILTER	regress_ssl.c	/^	REGRESS_OPENSSL_FILTER = 2,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_FREED	regress_ssl.c	/^	REGRESS_OPENSSL_FREED = 256,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_OPEN	regress_ssl.c	/^	REGRESS_OPENSSL_OPEN = 8,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_RENEGOTIATE	regress_ssl.c	/^	REGRESS_OPENSSL_RENEGOTIATE = 4,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_SERVER	regress_ssl.c	/^	REGRESS_OPENSSL_SERVER = 128,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_SLEEP	regress_ssl.c	/^	REGRESS_OPENSSL_SLEEP = 1024,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_SOCKETPAIR	regress_ssl.c	/^	REGRESS_OPENSSL_SOCKETPAIR = 1,$/;"	e	enum:regress_openssl_type	file:
REGRESS_OPENSSL_TIMEOUT	regress_ssl.c	/^	REGRESS_OPENSSL_TIMEOUT = 512,$/;"	e	enum:regress_openssl_type	file:
REGRESS_TESTUTILS_H_INCLUDED_	regress_testutils.h	28;"	d
REGRESS_THREAD_H_INCLUDED_	regress_thread.h	28;"	d
RESET	regress_util.c	559;"	d	file:
RESET	regress_util.c	633;"	d	file:
RPC_LEGACY	regress_rpc.c	883;"	d	file:
RPC_LEGACY	regress_rpc.c	890;"	d	file:
SERVER_TIMEOUT	regress_http.c	/^	SERVER_TIMEOUT = 16,$/;"	e	enum:http_cancel_test_type	file:
SETENV_OK	regress.c	2582;"	d	file:
SETENV_OK	regress.c	2590;"	d	file:
SKIP	tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
SLEEP_MS	regress_thread.c	/^SLEEP_MS(int ms)$/;"	f	file:
T	check-dumpevents.py	/^T = float(T)$/;"	v
T	regress_ssl.c	737;"	d	file:
T	regress_ssl.c	811;"	d	file:
TEST	regress_finalize.c	334;"	d	file:
TEST	regress_thread.c	567;"	d	file:
TEST1	regress.c	94;"	d	file:
TEST_MAX_INT	regress.c	2354;"	d	file:
TEST_STR	regress_bufferevent.c	625;"	d	file:
TEST_TRIM	regress_util.c	440;"	d	file:
THREAD_FN	regress_thread.h	32;"	d
THREAD_FN	regress_thread.h	39;"	d
THREAD_JOIN	regress_thread.h	36;"	d
THREAD_JOIN	regress_thread.h	45;"	d
THREAD_RETURN	regress_thread.h	33;"	d
THREAD_RETURN	regress_thread.h	40;"	d
THREAD_START	regress_thread.h	34;"	d
THREAD_START	regress_thread.h	41;"	d
THREAD_T	regress_thread.h	31;"	d
THREAD_T	regress_thread.h	38;"	d
TINYTEST_H_INCLUDED_	tinytest.h	27;"	d
TINYTEST_MACROS_H_INCLUDED_	tinytest_macros.h	27;"	d
TT_BLATHER	tinytest_macros.h	52;"	d
TT_DECLARE	tinytest_macros.h	41;"	d
TT_DIE	tinytest_macros.h	57;"	d
TT_ENABLED_	tinytest.h	34;"	d
TT_ENABLE_IOCP	regress.h	96;"	d
TT_ENABLE_IOCP_FLAG	regress.h	95;"	d
TT_EXIT_TEST_FUNCTION	tinytest_macros.h	36;"	d
TT_FAIL	tinytest_macros.h	64;"	d
TT_FIRST_USER_FLAG	tinytest.h	38;"	d
TT_FORK	tinytest.h	30;"	d
TT_GRIPE	tinytest_macros.h	49;"	d
TT_ISOLATED	regress.h	99;"	d
TT_LEGACY	regress.h	92;"	d
TT_NEED_BASE	regress.h	90;"	d
TT_NEED_DNS	regress.h	91;"	d
TT_NEED_SOCKETPAIR	regress.h	89;"	d
TT_NEED_THREADS	regress.h	93;"	d
TT_NO_LOGS	regress.h	94;"	d
TT_OFF_BY_DEFAULT	tinytest.h	36;"	d
TT_SKIP	tinytest.h	32;"	d
TT_STMT_BEGIN	tinytest_macros.h	30;"	d
TT_STMT_END	tinytest_macros.h	31;"	d
TT_URI	regress_http.c	2468;"	d	file:
TT_URI	regress_http.c	2836;"	d	file:
UNSETENV_OK	regress.c	2594;"	d	file:
UNSETENV_OK	regress.c	2602;"	d	file:
URI_PARSE	regress_http.c	2465;"	d	file:
URI_PARSE	regress_http.c	2835;"	d	file:
WIN32_LEAN_AND_MEAN	bench.c	44;"	d	file:
WIN32_LEAN_AND_MEAN	bench_cascade.c	36;"	d	file:
WIN32_LEAN_AND_MEAN	regress_iocp.c	42;"	d	file:
WIN32_LEAN_AND_MEAN	regress_iocp.c	45;"	d	file:
WIN32_LEAN_AND_MEAN	test-fdleak.c	30;"	d	file:
_FILE_OFFSET_BITS	regress_zlib.c	75;"	d	file:
_LARGEFILE64_SOURCE	regress_zlib.c	69;"	d	file:
_LFS64_LARGEFILE	regress_zlib.c	72;"	d	file:
__attribute__	tinytest.c	56;"	d	file:
a	regress_util.c	/^	const char *a;$/;"	m	struct:example_struct	file:
acceptcb	regress_listener.c	/^acceptcb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:
acceptcb	regress_ssl.c	/^acceptcb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:
acceptcb_deferred	regress_ssl.c	/^acceptcb_deferred(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
activate_cb	regress.c	/^activate_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
activate_other_event_cb	regress.c	/^activate_other_event_cb(evutil_socket_t fd, short what, void *other_)$/;"	f	file:
addfile_test_done_writing	regress_buffer.c	/^static int addfile_test_done_writing;$/;"	v	file:
addfile_test_event_base	regress_buffer.c	/^static struct event_base *addfile_test_event_base;$/;"	v	typeref:struct:event_base	file:
addfile_test_readcb	regress_buffer.c	/^addfile_test_readcb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
addfile_test_total_read	regress_buffer.c	/^static int addfile_test_total_read;$/;"	v	file:
addfile_test_total_written	regress_buffer.c	/^static int addfile_test_total_written;$/;"	v	file:
addfile_test_writecb	regress_buffer.c	/^addfile_test_writecb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
addr	regress_util.c	/^	const char *addr;$/;"	m	struct:ipv4_entry	file:
addr	regress_util.c	/^	const char *addr;$/;"	m	struct:ipv6_entry	file:
addr	regress_util.c	/^	const char *addr;$/;"	m	struct:sa_port_ent	file:
addrs	regress_dns.c	/^	void *addrs;$/;"	m	struct:generic_dns_callback_result	file:
addrs_buf	regress_dns.c	/^	char addrs_buf[256];$/;"	m	struct:generic_dns_callback_result	file:
addrs_len	regress_dns.c	/^	size_t addrs_len;$/;"	m	struct:generic_dns_callback_result	file:
ai	regress_dns.c	/^	struct evutil_addrinfo *ai;$/;"	m	struct:gai_outcome	typeref:struct:gai_outcome::evutil_addrinfo	file:
ai_find_by_family	regress_util.c	/^ai_find_by_family(struct evutil_addrinfo *ai, int family)$/;"	f
ai_find_by_protocol	regress_util.c	/^ai_find_by_protocol(struct evutil_addrinfo *ai, int protocol)$/;"	f
alerted_at	regress_thread.c	/^	struct timeval alerted_at;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::timeval	file:
alerted_record	regress_thread.c	/^struct alerted_record {$/;"	s	file:
allocated_chunks	regress_dns.c	/^static int allocated_chunks = 0;$/;"	v	file:
alltests	regress_main.c	/^const char *alltests[] = { "+..", NULL };$/;"	v
announce	test.sh	/^announce () {$/;"	f
announce_n	test.sh	/^announce_n () {$/;"	f
ans	regress_testutils.h	/^	const char *ans;$/;"	m	struct:regress_dns_server_table
anstype	regress_testutils.h	/^	const char *anstype;$/;"	m	struct:regress_dns_server_table
async_readcb	regress_iocp.c	/^async_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
b	regress_util.c	/^	const char *b;$/;"	m	struct:example_struct	file:
bad_reentrant_run_loop_cb	regress.c	/^bad_reentrant_run_loop_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:
base	bench_httpclient.c	/^struct event_base *base = NULL;$/;"	v	typeref:struct:event_base
base	regress.h	/^	struct event_base *base;$/;"	m	struct:basic_test_data	typeref:struct:basic_test_data::event_base
base	regress_dns.c	/^	struct event_base *base;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::event_base	file:
base	regress_dns.c	/^	struct event_base *base;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::event_base	file:
base	regress_http.c	/^	struct event_base *base;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::event_base	file:
base	regress_http.c	/^	struct event_base *base;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::event_base	file:
basic_cb_args	regress.c	/^struct basic_cb_args$/;"	s	file:
basic_read_cb	regress.c	/^basic_read_cb(evutil_socket_t fd, short event, void *data)$/;"	f	file:
basic_setup	regress_main.c	/^const struct testcase_setup_t basic_setup = {$/;"	v	typeref:struct:testcase_setup_t
basic_test_cleanup	regress_main.c	/^basic_test_cleanup(const struct testcase_t *testcase, void *ptr)$/;"	f	file:
basic_test_data	regress.h	/^struct basic_test_data {$/;"	s
basic_test_setup	regress_main.c	/^basic_test_setup(const struct testcase_t *testcase)$/;"	f	file:
basic_thread	regress_thread.c	/^basic_thread(void *arg)$/;"	f	file:
be_conn_hostname_result	regress_dns.c	/^struct be_conn_hostname_result {$/;"	s	file:
be_connect_hostname_base	regress_dns.c	/^static struct event_base *be_connect_hostname_base = NULL;$/;"	v	typeref:struct:event_base	file:
be_connect_hostname_event_cb	regress_dns.c	/^be_connect_hostname_event_cb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
be_getaddrinfo_server_cb	regress_dns.c	/^be_getaddrinfo_server_cb(struct evdns_server_request *req, void *data)$/;"	f	file:
bev	regress_http.c	/^	struct bufferevent *bev;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::bufferevent	file:
bev_timeout_event_cb	regress_bufferevent.c	/^bev_timeout_event_cb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
bev_timeout_write_cb	regress_bufferevent.c	/^bev_timeout_write_cb(struct bufferevent *bev, void *arg)$/;"	f	file:
bevs	test-ratelim.c	/^struct bufferevent **bevs;$/;"	v	typeref:struct:bufferevent
bio_rwcount_ctrl	regress_ssl.c	/^bio_rwcount_ctrl(BIO *b, int cmd, long num, void *ptr)$/;"	f	file:
bio_rwcount_free	regress_ssl.c	/^bio_rwcount_free(BIO *b)$/;"	f	file:
bio_rwcount_new	regress_ssl.c	/^bio_rwcount_new(BIO *b)$/;"	f	file:
bio_rwcount_puts	regress_ssl.c	/^bio_rwcount_puts(BIO *b, const char *s)$/;"	f	file:
bio_rwcount_read	regress_ssl.c	/^bio_rwcount_read(BIO *b, char *out, int outlen)$/;"	f	file:
bio_rwcount_write	regress_ssl.c	/^bio_rwcount_write(BIO *b, const char *in, int inlen)$/;"	f	file:
both	regress.c	/^struct both {$/;"	s	file:
break_cb	regress.c	/^break_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
bufferevent_connect_test_flags	regress_bufferevent.c	/^static int bufferevent_connect_test_flags = 0;$/;"	v	file:
bufferevent_filter_data_stuck	regress_bufferevent.c	/^struct bufferevent_filter_data_stuck {$/;"	s	file:
bufferevent_filter_data_stuck_inputcb	regress_bufferevent.c	/^bufferevent_filter_data_stuck_inputcb($/;"	f	file:
bufferevent_filter_data_stuck_readcb	regress_bufferevent.c	/^bufferevent_filter_data_stuck_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
bufferevent_input_filter	regress_bufferevent.c	/^bufferevent_input_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:
bufferevent_iocp_testcases	regress_bufferevent.c	/^struct testcase_t bufferevent_iocp_testcases[] = {$/;"	v	typeref:struct:testcase_t
bufferevent_openssl_check_fd	regress_ssl.c	/^bufferevent_openssl_check_fd(struct bufferevent *bev, int filter)$/;"	f	file:
bufferevent_openssl_check_freed	regress_ssl.c	/^bufferevent_openssl_check_freed(struct bufferevent *bev)$/;"	f	file:
bufferevent_output_filter	regress_bufferevent.c	/^bufferevent_output_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:
bufferevent_testcases	regress_bufferevent.c	/^struct testcase_t bufferevent_testcases[] = {$/;"	v	typeref:struct:testcase_t
bufferevent_trigger_test_flags	regress_bufferevent.c	/^static int bufferevent_trigger_test_flags = 0;$/;"	v	file:
c	regress_util.c	/^	long c;$/;"	m	struct:example_struct	file:
cache_time_cb	regress.c	/^cache_time_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
cached_time_base	regress.c	/^static struct event_base *cached_time_base = NULL;$/;"	v	typeref:struct:event_base	file:
cached_time_reset	regress.c	/^static int cached_time_reset = 0;$/;"	v	file:
cached_time_sleep	regress.c	/^static int cached_time_sleep = 0;$/;"	v	file:
call_count	regress_iocp.c	/^	int call_count;$/;"	m	struct:dummy_overlapped	file:
callback1	test-dumpevents.c	/^callback1(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
callback2	test-dumpevents.c	/^callback2(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
callback_count	regress_thread.c	/^static unsigned callback_count = 0;$/;"	v	file:
callback_finalize_callback_1	regress_finalize.c	/^callback_finalize_callback_1(struct event_callback *evcb, void *arg)$/;"	f	file:
callcount	regress.c	/^	unsigned int callcount;$/;"	m	struct:basic_cb_args	file:
called	regress.c	/^int called;$/;"	v
called	test-eof.c	/^int called = 0;$/;"	v
called	test-time.c	/^int called = 0;$/;"	v
called	test-weof.c	/^int called = 0;$/;"	v
called_at	regress.c	/^	struct timeval called_at;$/;"	m	struct:common_timeout_info	typeref:struct:common_timeout_info::timeval	file:
cancel_event	regress_dns.c	/^	struct event cancel_event;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::event	file:
cancel_gai_cb	regress_dns.c	/^cancel_gai_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:
canceled	regress_dns.c	/^	int canceled;$/;"	m	struct:gaic_request_status	file:
cases	tinytest.h	/^	struct testcase_t *cases; \/** Array, ending with END_OF_TESTCASES *\/$/;"	m	struct:testgroup_t	typeref:struct:testgroup_t::testcase_t
cbs	regress_bufferevent.c	/^	struct evthread_lock_callbacks cbs;$/;"	m	struct:lock_unlock_base	typeref:struct:lock_unlock_base::evthread_lock_callbacks	file:
cbs	regress_thread.c	/^	struct event_callback cbs[CB_COUNT];$/;"	m	struct:deferred_test_data	typeref:struct:deferred_test_data::event_callback	file:
cfg_aliases	tinytest.c	/^const struct testlist_alias_t *cfg_aliases=NULL;$/;"	v	typeref:struct:testlist_alias_t
cfg_connlimit	test-ratelim.c	/^static int cfg_connlimit = 0;$/;"	v	file:
cfg_connlimit_tolerance	test-ratelim.c	/^static int cfg_connlimit_tolerance = -1;$/;"	v	file:
cfg_duration	test-ratelim.c	/^static int cfg_duration = 5;$/;"	v	file:
cfg_enable_iocp	test-ratelim.c	/^static int cfg_enable_iocp = 0;$/;"	v	file:
cfg_group_drain	test-ratelim.c	/^static int cfg_group_drain = 0;$/;"	v	file:
cfg_grouplimit	test-ratelim.c	/^static int cfg_grouplimit = 0;$/;"	v	file:
cfg_grouplimit_tolerance	test-ratelim.c	/^static int cfg_grouplimit_tolerance = -1;$/;"	v	file:
cfg_help	test-ratelim.c	/^static int cfg_help = 0;$/;"	v	file:
cfg_min_share	test-ratelim.c	/^static int cfg_min_share = -1;$/;"	v	file:
cfg_n_connections	test-ratelim.c	/^static int cfg_n_connections = 30;$/;"	v	file:
cfg_stddev_tolerance	test-ratelim.c	/^static int cfg_stddev_tolerance = -1;$/;"	v	file:
cfg_tick	test-ratelim.c	/^static struct timeval cfg_tick = { 0, 500*1000 };$/;"	v	typeref:struct:timeval	file:
cfg_tick_msec	test-ratelim.c	/^static int cfg_tick_msec = 1000;$/;"	v	file:
cfg_verbose	test-ratelim.c	/^static int cfg_verbose = 0;$/;"	v	file:
check_bucket_levels_cb	test-ratelim.c	/^check_bucket_levels_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
check_dummy_mem_ok	regress.c	/^check_dummy_mem_ok(void *mem_)$/;"	f	file:
check_error_logging	regress_util.c	/^check_error_logging(void (*fn)(void), int wantexitcode,$/;"	f	file:
check_group_bucket_levels_cb	test-ratelim.c	/^check_group_bucket_levels_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
check_heap	regress_minheap.c	/^check_heap(struct min_heap *heap)$/;"	f	file:
check_prepend	regress_buffer.c	/^check_prepend(struct evbuffer *buffer,$/;"	f	file:
child_pair	regress.c	/^int child_pair[2] = { -1, -1 };$/;"	v
chunk_req_state	regress_http.c	/^struct chunk_req_state {$/;"	s	file:
cleaned_inserted	check-dumpevents.py	/^cleaned_inserted = set( pat.sub(replace_time, s) for s in got_inserted$/;"	v
cleanup_fn	tinytest.h	/^	int (*cleanup_fn)(const struct testcase_t *, void *);$/;"	m	struct:testcase_setup_t
cleanup_passthrough	regress_buffer.c	/^cleanup_passthrough(const struct testcase_t *testcase, void *ptr)$/;"	f	file:
cleanup_test	regress.c	295;"	d	file:
client_event_cb	test-fdleak.c	/^client_event_cb(struct bufferevent *bev, short events, void *ctx)$/;"	f	file:
client_read_cb	test-fdleak.c	/^client_read_cb(struct bufferevent *bev, void *ctx)$/;"	f	file:
client_state	test-ratelim.c	/^struct client_state {$/;"	s	file:
close_detect_cb	regress_http.c	/^close_detect_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
close_detect_done	regress_http.c	/^close_detect_done(struct evhttp_request *req, void *arg)$/;"	f	file:
close_detect_launch	regress_http.c	/^close_detect_launch(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
close_socket_cb	regress_bufferevent.c	/^close_socket_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
closed_cb	test-closed.c	/^closed_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
cnt_free	regress_dns.c	/^cnt_free(void *ptr)$/;"	f	file:
cnt_malloc	regress_dns.c	/^cnt_malloc(size_t sz)$/;"	f	file:
cnt_realloc	regress_dns.c	/^cnt_realloc(void *old, size_t sz)$/;"	f	file:
combined_read_cb	regress.c	/^combined_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
combined_write_cb	regress.c	/^combined_write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
commandname	tinytest.c	/^static char commandname[MAX_PATH+1];$/;"	v	file:
common_timeout_cb	regress.c	/^common_timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
common_timeout_info	regress.c	/^struct common_timeout_info {$/;"	s	file:
cond	regress_thread.c	/^	struct cond_wait *cond;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::cond_wait	file:
cond	regress_thread.c	/^	void *cond;$/;"	m	struct:cond_wait	file:
cond_wait	regress_thread.c	/^struct cond_wait {$/;"	s	file:
conn_bucket_cfg	test-ratelim.c	/^static struct ev_token_bucket_cfg *conn_bucket_cfg = NULL;$/;"	v	typeref:struct:ev_token_bucket_cfg	file:
content	bench_http.c	/^static char *content;$/;"	v	file:
content_len	bench_http.c	/^static size_t content_len = 0;$/;"	v	file:
count	bench.c	/^static int count, writes, fired, failures;$/;"	v	file:
count	regress.c	/^	int count;$/;"	m	struct:common_timeout_info	file:
count	regress.c	/^	int count;$/;"	m	struct:foreach_helper	file:
count	regress.c	/^	int count;$/;"	m	struct:read_not_timeout_param	file:
count	regress.c	/^	int count;$/;"	m	struct:test_pri_event	file:
count	regress_dns.c	/^	int count;$/;"	m	struct:generic_dns_callback_result	file:
count	regress_finalize.c	/^	int count;$/;"	m	struct:event_and_count	file:
count	regress_iocp.c	/^static int count = 0;$/;"	v	file:
count	regress_thread.c	/^static int count;$/;"	v	file:
count_cond	regress_iocp.c	/^static void *count_lock = NULL, *count_cond = NULL;$/;"	v	file:
count_free	regress_iocp.c	/^count_free(void)$/;"	f	file:
count_incr	regress_iocp.c	/^count_incr(void)$/;"	f	file:
count_init	regress_iocp.c	/^count_init(void)$/;"	f	file:
count_lock	regress_iocp.c	/^static void *count_lock = NULL, *count_cond = NULL;$/;"	v	file:
count_lock	regress_thread.c	/^void *count_lock;$/;"	v
count_wait_for	regress_iocp.c	/^count_wait_for(int i, int ms)$/;"	f	file:
cpu_usage_timer	test-changelist.c	/^struct cpu_usage_timer {$/;"	s	file:
create_bev	regress_http.c	/^create_bev(struct event_base *base, int fd, int ssl_mask)$/;"	f	file:
create_tm_from_unix_epoch	regress_util.c	/^create_tm_from_unix_epoch(struct tm *cur_p, const time_t t)$/;"	f	file:
ctx	regress_rpc.c	/^	void *ctx;$/;"	m	struct:rpc_hook_ctx_	file:
cur_test_name	tinytest.c	/^const char *cur_test_name = NULL;$/;"	v
cur_test_outcome	tinytest.c	/^static enum outcome cur_test_outcome = 0;$/;"	v	typeref:enum:outcome	file:
cur_test_prefix	tinytest.c	/^const char *cur_test_prefix = NULL; \/**< prefix of the current test group *\/$/;"	v
current_base	regress.c	821;"	d	file:
current_req	regress_dns.c	/^static struct evdns_request *current_req = NULL;$/;"	v	typeref:struct:evdns_request	file:
date	regress_util.c	/^	char date[30];$/;"	m	struct:date_rfc1123_case	file:
date_rfc1123_case	regress_util.c	/^static struct date_rfc1123_case {$/;"	s	file:
date_rfc1123_cases	regress_util.c	/^} date_rfc1123_cases[] = {$/;"	v	typeref:struct:date_rfc1123_case	file:
dbg_leak_resume	regress_dns.c	/^dbg_leak_resume(void *env_, int cancel, int send_err_shutdown)$/;"	f	file:
deferred_callback	regress_thread.c	/^deferred_callback(struct event_callback *cb, void *arg)$/;"	f	file:
deferred_data	regress_thread.c	/^static struct deferred_test_data deferred_data[QUEUE_THREAD_COUNT];$/;"	v	typeref:struct:deferred_test_data	file:
deferred_test_data	regress_thread.c	/^struct deferred_test_data {$/;"	s	file:
del_wait_cb	regress.c	/^del_wait_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
del_wait_thread	regress.c	/^static void* del_wait_thread(void *arg)$/;"	f	file:
delay	regress_thread.c	/^	struct timeval delay;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::timeval	file:
delayed_client	regress_http.c	/^static struct evhttp_connection *delayed_client;$/;"	v	typeref:struct:evhttp_connection	file:
dfd_cb	regress.c	/^dfd_cb(evutil_socket_t fd, short e, void *data)$/;"	f	file:
disable_tls_11_and_12	regress_ssl.c	/^static int disable_tls_11_and_12 = 0;$/;"	v	file:
discard_readcb	test-ratelim.c	/^discard_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:
dns_base	regress_dns.c	/^	struct evdns_base *dns_base;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::evdns_base	file:
dns_base	regress_dns.c	/^	struct evdns_base *dns_base;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::evdns_base	file:
dns_client_fail_requests_getaddrinfo_test	regress_dns.c	/^dns_client_fail_requests_getaddrinfo_test(void *arg)$/;"	f	file:
dns_client_fail_requests_test	regress_dns.c	/^dns_client_fail_requests_test(void *arg)$/;"	f	file:
dns_disable_when_inactive_no_ns_test	regress_dns.c	/^dns_disable_when_inactive_no_ns_test(void *arg)$/;"	f	file:
dns_disable_when_inactive_test	regress_dns.c	/^dns_disable_when_inactive_test(void *arg)$/;"	f	file:
dns_err	regress_dns.c	/^static int dns_err = 0;$/;"	v	file:
dns_gethostbyaddr	regress_dns.c	/^dns_gethostbyaddr(void)$/;"	f	file:
dns_gethostbyname	regress_dns.c	/^dns_gethostbyname(void)$/;"	f	file:
dns_gethostbyname6	regress_dns.c	/^dns_gethostbyname6(void)$/;"	f	file:
dns_gethostbyname_cb	regress_dns.c	/^dns_gethostbyname_cb(int result, char type, int count, int ttl,$/;"	f	file:
dns_got_cancel	regress_dns.c	/^static int dns_got_cancel = 0;$/;"	v	file:
dns_inflight_test	regress_dns.c	/^dns_inflight_test(void *arg)$/;"	f	file:
dns_inflight_test_impl	regress_dns.c	/^dns_inflight_test_impl(void *arg, int flags)$/;"	f	file:
dns_ok	regress_dns.c	/^static int dns_ok = 0;$/;"	v	file:
dns_port	regress_testutils.c	/^static struct evdns_server_port *dns_port;$/;"	v	typeref:struct:evdns_server_port	file:
dns_reissue_disable_when_inactive_test	regress_dns.c	/^dns_reissue_disable_when_inactive_test(void *arg)$/;"	f	file:
dns_reissue_test	regress_dns.c	/^dns_reissue_test(void *arg)$/;"	f	file:
dns_reissue_test_impl	regress_dns.c	/^dns_reissue_test_impl(void *arg, int flags)$/;"	f	file:
dns_resolve_reverse	regress_dns.c	/^dns_resolve_reverse(void *ptr)$/;"	f	file:
dns_retry_disable_when_inactive_test	regress_dns.c	/^dns_retry_disable_when_inactive_test(void *arg)$/;"	f	file:
dns_retry_test	regress_dns.c	/^dns_retry_test(void *arg)$/;"	f	file:
dns_retry_test_impl	regress_dns.c	/^dns_retry_test_impl(void *arg, int flags)$/;"	f	file:
dns_search_cancel_test	regress_dns.c	/^dns_search_cancel_test(void *arg)$/;"	f	file:
dns_search_empty_test	regress_dns.c	/^dns_search_empty_test(void *arg)$/;"	f	file:
dns_search_lower_test	regress_dns.c	/^dns_search_lower_test(void *arg)$/;"	f	file:
dns_search_test	regress_dns.c	/^dns_search_test(void *arg)$/;"	f	file:
dns_search_test_impl	regress_dns.c	/^dns_search_test_impl(void *arg, int lower)$/;"	f	file:
dns_server	regress_dns.c	/^dns_server(void)$/;"	f	file:
dns_server_gethostbyname_cb	regress_dns.c	/^dns_server_gethostbyname_cb(int result, char type, int count, int ttl,$/;"	f	file:
dns_server_request_cb	regress_dns.c	/^dns_server_request_cb(struct evdns_server_request *req, void *data)$/;"	f	file:
dns_sock	regress_testutils.c	/^evutil_socket_t dns_sock = -1;$/;"	v
dns_testcases	regress_dns.c	/^struct testcase_t dns_testcases[] = {$/;"	v	typeref:struct:testcase_t
dnserr	regress_dns.c	/^	int dnserr;$/;"	m	struct:be_conn_hostname_result	file:
dnslogcb	regress_main.c	/^static void dnslogcb(int w, const char *m)$/;"	f	file:
do_test	test.sh	/^do_test() {$/;"	f
done_writing_cb	regress_ssl.c	/^done_writing_cb(struct bufferevent *bev, void *ctx)$/;"	f	file:
dummy_cb	regress_iocp.c	/^dummy_cb(struct event_overlapped *o, uintptr_t key, ev_ssize_t n, int ok)$/;"	f	file:
dummy_free	regress.c	/^dummy_free(void *mem_)$/;"	f	file:
dummy_malloc	regress.c	/^dummy_malloc(size_t len)$/;"	f	file:
dummy_overlapped	regress_iocp.c	/^struct dummy_overlapped {$/;"	s	file:
dummy_read_cb	regress.c	/^dummy_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
dummy_realloc	regress.c	/^dummy_realloc(void *mem_, size_t len)$/;"	f	file:
eb	regress.c	/^	struct event_base *eb;$/;"	m	struct:basic_cb_args	typeref:struct:basic_cb_args::event_base	file:
echo_eventcb	test-ratelim.c	/^echo_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
echo_listenercb	test-ratelim.c	/^echo_listenercb(struct evconnlistener *listener, evutil_socket_t newsock,$/;"	f	file:
echo_readcb	test-ratelim.c	/^echo_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:
echo_writecb	test-ratelim.c	/^echo_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:
edgetriggered_testcases	regress_et.c	/^struct testcase_t edgetriggered_testcases[] = {$/;"	v	typeref:struct:testcase_t
entry_status	regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	g	file:
eo	regress_iocp.c	/^	struct event_overlapped eo;$/;"	m	struct:dummy_overlapped	typeref:struct:dummy_overlapped::event_overlapped	file:
err	regress_dns.c	/^	int err;$/;"	m	struct:gai_outcome	file:
err_fn	regress_util.c	/^err_fn(void)$/;"	f	file:
errorcb	bench_httpclient.c	/^errorcb(struct bufferevent *b, short what, void *arg)$/;"	f	file:
errorcb	regress_bufferevent.c	/^errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
errorcb	regress_listener.c	/^errorcb(struct evconnlistener *lis, void *data_)$/;"	f	file:
errorcb	regress_zlib.c	/^errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
errorcb_invoked	regress_zlib.c	/^static int errorcb_invoked;$/;"	v	file:
errx_fn	regress_util.c	/^errx_fn(void)$/;"	f	file:
ev	regress.c	/^	const struct event *ev;$/;"	m	struct:foreach_helper	typeref:struct:foreach_helper::event	file:
ev	regress.c	/^	struct event **ev;$/;"	m	struct:read_not_timeout_param	typeref:struct:read_not_timeout_param::event	file:
ev	regress.c	/^	struct event *ev;$/;"	m	struct:basic_cb_args	typeref:struct:basic_cb_args::event	file:
ev	regress.c	/^	struct event ev;$/;"	m	struct:both	typeref:struct:both::event	file:
ev	regress.c	/^	struct event ev;$/;"	m	struct:common_timeout_info	typeref:struct:common_timeout_info::event	file:
ev	regress.c	/^	struct event ev;$/;"	m	struct:test_pri_event	typeref:struct:test_pri_event::event	file:
ev	regress_finalize.c	/^	struct event *ev;$/;"	m	struct:event_and_count	typeref:struct:event_and_count::event	file:
ev	test-time.c	/^struct event *ev[NEVENT];$/;"	v	typeref:struct:event
ev2	regress_finalize.c	/^	struct event *ev2;$/;"	m	struct:event_and_count	typeref:struct:event_and_count::event	file:
evbuffer_contains	regress_http.c	/^evbuffer_contains(struct evbuffer *buf, const char *s)$/;"	f	file:
evbuffer_datacmp	regress_http.c	/^evbuffer_datacmp(struct evbuffer *buf, const char *s)$/;"	f	file:
evbuffer_get_waste	regress_buffer.c	/^evbuffer_get_waste(struct evbuffer *buf, size_t *allocatedp, size_t *wastedp, size_t *usedp)$/;"	f	file:
evbuffer_testcases	regress_buffer.c	/^struct testcase_t evbuffer_testcases[] = {$/;"	v	typeref:struct:testcase_t
evbuffer_validate	regress_buffer.c	167;"	d	file:
evbuffer_validate_	regress_buffer.c	/^evbuffer_validate_(struct evbuffer *buf)$/;"	f	file:
event_and_count	regress_finalize.c	/^struct event_and_count {$/;"	s	file:
event_finalize_callback_1	regress_finalize.c	/^event_finalize_callback_1(struct event *ev, void *arg)$/;"	f	file:
event_finalize_callback_2	regress_finalize.c	/^event_finalize_callback_2(struct event *ev, void *arg)$/;"	f	file:
event_selfarg_cb	regress.c	/^event_selfarg_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
eventcb	regress_ssl.c	/^eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
events	bench.c	/^static struct event *events;$/;"	v	typeref:struct:event	file:
events	bench_cascade.c	/^static struct event *events;$/;"	v	typeref:struct:event	file:
events	regress.c	/^	int events;$/;"	m	struct:read_not_timeout_param	file:
events	regress.c	/^	short events[16];$/;"	m	struct:persist_active_timeout_called	file:
evtag_fuzz	regress.c	/^evtag_fuzz(void *ptr)$/;"	f	file:
evtag_int_test	regress.c	/^evtag_int_test(void *ptr)$/;"	f	file:
evtag_tag_encoding	regress.c	/^evtag_tag_encoding(void *ptr)$/;"	f	file:
evtag_test_peek	regress.c	/^evtag_test_peek(void *ptr)$/;"	f	file:
evtag_testcases	regress.c	/^struct testcase_t evtag_testcases[] = {$/;"	v	typeref:struct:testcase_t
example_struct	regress_util.c	/^struct example_struct {$/;"	s	file:
exit_base	regress_dns.c	/^static struct event_base *exit_base;$/;"	v	typeref:struct:event_base	file:
exit_base	regress_http.c	/^static struct event_base *exit_base;$/;"	v	typeref:struct:event_base	file:
exit_base	regress_ssl.c	/^static struct event_base *exit_base = NULL;$/;"	v	typeref:struct:event_base	file:
exit_base	regress_thread.c	/^static struct event_base *exit_base = NULL;$/;"	v	typeref:struct:event_base	file:
exit_base_on_no_pending_results	regress_dns.c	/^static struct event_base *exit_base_on_no_pending_results = NULL;$/;"	v	typeref:struct:event_base	file:
exit_failed	rpcgen_wrapper.sh	/^exit_failed() {$/;"	f
exit_port	regress_dns.c	/^static struct evdns_server_port *exit_port;$/;"	v	typeref:struct:evdns_server_port	file:
exit_reuse	rpcgen_wrapper.sh	/^exit_reuse() {$/;"	f
exit_updated	rpcgen_wrapper.sh	/^exit_updated() {$/;"	f
expect_active_pos	check-dumpevents.py	/^    expect_active_pos = text.index("Active:\\n")$/;"	v
expect_inserted_pos	check-dumpevents.py	/^    expect_inserted_pos = text.index("Inserted:\\n")$/;"	v
fail_cb	regress.c	/^fail_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
fail_server_cb	regress_dns.c	/^fail_server_cb(struct evdns_server_request *req, void *data)$/;"	f	file:
failing_malloc	regress_buffer.c	/^failing_malloc(size_t how_much)$/;"	f	file:
failures	bench.c	/^static int count, writes, fired, failures;$/;"	v	file:
fake_listener_create	regress_bufferevent.c	/^fake_listener_create(struct sockaddr_in *localhost)$/;"	f	file:
fatal_want_message	regress_util.c	/^static const char *fatal_want_message = NULL;$/;"	v	file:
fatal_want_severity	regress_util.c	/^static int fatal_want_severity = 0;$/;"	v	file:
fatalfn	regress_util.c	/^fatalfn(int exitcode)$/;"	f	file:
fd	regress_http.c	/^	evutil_socket_t fd;$/;"	m	struct:terminate_state	file:
fd	regress_ssl.c	/^	int fd;$/;"	m	struct:rwcount	file:
file_segment_cleanup_cb_called_count	regress_buffer.c	/^static int file_segment_cleanup_cb_called_count = 0;$/;"	v	file:
file_segment_cleanup_cb_called_with	regress_buffer.c	/^static struct evbuffer_file_segment const* file_segment_cleanup_cb_called_with = NULL;$/;"	v	file:
file_segment_cleanup_cb_called_with_arg	regress_buffer.c	/^static void* file_segment_cleanup_cb_called_with_arg = NULL;$/;"	v	file:
file_segment_cleanup_cb_called_with_flags	regress_buffer.c	/^static int file_segment_cleanup_cb_called_with_flags = 0;$/;"	v	file:
file_segment_cleanup_cp	regress_buffer.c	/^file_segment_cleanup_cp(struct evbuffer_file_segment const* seg, int flags, void* arg)$/;"	f	file:
filetime_diff	test-changelist.c	/^filetime_diff(const FILETIME *ftStart, const FILETIME *ftEnd)$/;"	f	file:
filetime_to_100nsec	test-changelist.c	/^filetime_to_100nsec(const FILETIME *ft)$/;"	f	file:
finalize_testcases	regress_finalize.c	/^struct testcase_t finalize_testcases[] = {$/;"	v	typeref:struct:testcase_t
finetimetests	regress_main.c	/^const char *finetimetests[] = {$/;"	v
fired	bench.c	/^static int count, writes, fired, failures;$/;"	v	file:
fired	bench_cascade.c	/^static int fired;$/;"	v	file:
flags	tinytest.h	/^	unsigned long flags; \/**< Bitfield of TT_* flags. *\/$/;"	m	struct:testcase_t
fn	tinytest.h	/^	testcase_fn fn; \/**< The function to run to implement this case. *\/$/;"	m	struct:testcase_t
foreach_count_cb	regress.c	/^foreach_count_cb(const struct event_base *base, const struct event *ev, void *arg)$/;"	f	file:
foreach_find_cb	regress.c	/^foreach_find_cb(const struct event_base *base, const struct event *ev, void *arg)$/;"	f	file:
foreach_helper	regress.c	/^struct foreach_helper {$/;"	s	file:
fork_signal_cb	regress.c	/^fork_signal_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
found_multi	regress_http.c	/^static int found_multi = 0;$/;"	v	file:
found_multi2	regress_http.c	/^static int found_multi2 = 0;$/;"	v	file:
free_lock_unlock_profiler	regress_bufferevent.c	/^static void free_lock_unlock_profiler(struct basic_test_data *data)$/;"	f	file:
frob_socket	bench_httpclient.c	/^frob_socket(evutil_socket_t sock)$/;"	f	file:
func_exec_program	bench	/^func_exec_program ()$/;"	f
func_exec_program	bench_cascade	/^func_exec_program ()$/;"	f
func_exec_program	bench_http	/^func_exec_program ()$/;"	f
func_exec_program	bench_httpclient	/^func_exec_program ()$/;"	f
func_exec_program	regress	/^func_exec_program ()$/;"	f
func_exec_program	test-changelist	/^func_exec_program ()$/;"	f
func_exec_program	test-closed	/^func_exec_program ()$/;"	f
func_exec_program	test-dumpevents	/^func_exec_program ()$/;"	f
func_exec_program	test-eof	/^func_exec_program ()$/;"	f
func_exec_program	test-fdleak	/^func_exec_program ()$/;"	f
func_exec_program	test-init	/^func_exec_program ()$/;"	f
func_exec_program	test-ratelim	/^func_exec_program ()$/;"	f
func_exec_program	test-time	/^func_exec_program ()$/;"	f
func_exec_program	test-weof	/^func_exec_program ()$/;"	f
func_exec_program_core	bench	/^func_exec_program_core ()$/;"	f
func_exec_program_core	bench_cascade	/^func_exec_program_core ()$/;"	f
func_exec_program_core	bench_http	/^func_exec_program_core ()$/;"	f
func_exec_program_core	bench_httpclient	/^func_exec_program_core ()$/;"	f
func_exec_program_core	regress	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-changelist	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-closed	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-dumpevents	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-eof	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-fdleak	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-init	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-ratelim	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-time	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test-weof	/^func_exec_program_core ()$/;"	f
func_fallback_echo	bench	/^func_fallback_echo ()$/;"	f
func_fallback_echo	bench_cascade	/^func_fallback_echo ()$/;"	f
func_fallback_echo	bench_http	/^func_fallback_echo ()$/;"	f
func_fallback_echo	bench_httpclient	/^func_fallback_echo ()$/;"	f
func_fallback_echo	regress	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-changelist	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-closed	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-dumpevents	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-eof	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-fdleak	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-init	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-ratelim	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-time	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test-weof	/^func_fallback_echo ()$/;"	f
func_lt_dump_args	bench	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	bench_cascade	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	bench_http	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	bench_httpclient	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	regress	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-changelist	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-closed	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-dumpevents	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-eof	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-fdleak	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-init	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-ratelim	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-time	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test-weof	/^func_lt_dump_args ()$/;"	f
func_parse_lt_options	bench	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	bench_cascade	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	bench_http	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	bench_httpclient	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	regress	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-changelist	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-closed	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-dumpevents	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-eof	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-fdleak	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-init	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-ratelim	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-time	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test-weof	/^func_parse_lt_options ()$/;"	f
gai_cb	regress_dns.c	/^gai_cb(int err, struct evutil_addrinfo *res, void *ptr)$/;"	f	file:
gai_outcome	regress_dns.c	/^struct gai_outcome {$/;"	s	file:
gaic_cancel_request_cb	regress_dns.c	/^gaic_cancel_request_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
gaic_getaddrinfo_cb	regress_dns.c	/^gaic_getaddrinfo_cb(int result, struct evutil_addrinfo *res, void *arg)$/;"	f	file:
gaic_launch	regress_dns.c	/^gaic_launch(struct event_base *base, struct evdns_base *dns_base)$/;"	f	file:
gaic_request_status	regress_dns.c	/^struct gaic_request_status {$/;"	s	file:
gaic_server_cb	regress_dns.c	/^gaic_server_cb(struct evdns_server_request *req, void *arg)$/;"	f	file:
generic_dns_callback	regress_dns.c	/^generic_dns_callback(int result, char type, int count, int ttl, void *addresses,$/;"	f	file:
generic_dns_callback_result	regress_dns.c	/^struct generic_dns_callback_result {$/;"	s	file:
get_cpu_usage	test-changelist.c	/^get_cpu_usage(struct cpu_usage_timer *timer, double *secElapsedOut,$/;"	f	file:
get_ssl_ctx	regress_ssl.c	/^get_ssl_ctx(void)$/;"	f
getaddrinfo_cb	regress_dns.c	/^getaddrinfo_cb(int err, struct evutil_addrinfo *res, void *ptr)$/;"	f	file:
getstate	regress_zlib.c	/^getstate(enum bufferevent_flush_mode state)$/;"	f	file:
global_base	regress.c	/^struct event_base *global_base;$/;"	v	typeref:struct:event_base
got_active	check-dumpevents.py	/^got_active = set(text[got_active_pos+1:])$/;"	v
got_active_pos	check-dumpevents.py	/^    got_active_pos = text.index("Active events:\\n")$/;"	v
got_close	regress_ssl.c	/^static int got_close = 0;$/;"	v	file:
got_error	regress_ssl.c	/^static int got_error = 0;$/;"	v	file:
got_inserted	check-dumpevents.py	/^got_inserted = set(text[got_inserted_pos+1:got_active_pos])$/;"	v
got_inserted_pos	check-dumpevents.py	/^    got_inserted_pos = text.index("Inserted events:\\n")$/;"	v
got_readcb	regress_iocp.c	/^static int got_readcb = 0;$/;"	v	file:
got_sigchld	regress_thread.c	/^static int got_sigchld = 0;$/;"	v	file:
got_timeout	regress_ssl.c	/^static int got_timeout = 0;$/;"	v	file:
gotclosecb	regress_http.c	/^	int gotclosecb: 1;$/;"	m	struct:terminate_state	file:
group	test-ratelim.c	/^struct bufferevent_rate_limit_group *group = NULL;$/;"	v	typeref:struct:bufferevent_rate_limit_group
group_bucket_cfg	test-ratelim.c	/^static struct ev_token_bucket_cfg *group_bucket_cfg = NULL;$/;"	v	typeref:struct:ev_token_bucket_cfg	file:
group_drain_cb	test-ratelim.c	/^group_drain_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
handle_option	test-ratelim.c	/^handle_option(int argc, char **argv, int *i, const struct option *opt)$/;"	f	file:
have_closed	regress.c	/^static int have_closed = 0;$/;"	v	file:
header_size	regress_bufferevent.c	/^	size_t header_size;$/;"	m	struct:bufferevent_filter_data_stuck	file:
hook_pause_cb_called	regress_rpc.c	/^static int hook_pause_cb_called=0;$/;"	v	file:
http	regress_http.c	/^	struct evhttp *http;$/;"	m	struct:http_server	typeref:struct:http_server::evhttp	file:
http_allowed_methods_eventcb	regress_http.c	/^http_allowed_methods_eventcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
http_allowed_methods_test	regress_http.c	/^http_allowed_methods_test(void *arg)$/;"	f	file:
http_autofree_connection_test	regress_http.c	/^http_autofree_connection_test(void *arg)$/;"	f	file:
http_bad_header_test	regress_http.c	/^http_bad_header_test(void *ptr)$/;"	f	file:
http_bad_request_test	regress_http.c	/^http_bad_request_test(void *arg)$/;"	f	file:
http_badreq_cb	regress_http.c	/^http_badreq_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_badreq_errorcb	regress_http.c	/^http_badreq_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
http_badreq_readcb	regress_http.c	/^http_badreq_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_badreq_successcb	regress_http.c	/^http_badreq_successcb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
http_base_test	regress_http.c	/^http_base_test(void *ptr)$/;"	f	file:
http_basic_cb	bench_http.c	/^http_basic_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_basic_cb	regress_http.c	/^http_basic_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_basic_test	regress_http.c	/^static void http_basic_test(void *arg)$/;"	f	file:
http_basic_test_impl	regress_http.c	/^http_basic_test_impl(void *arg, int ssl)$/;"	f	file:
http_bind	regress_http.c	/^http_bind(struct evhttp *myhttp, ev_uint16_t *pport, int mask)$/;"	f	file:
http_cancel_test	regress_http.c	/^http_cancel_test(void *arg)$/;"	f	file:
http_cancel_test_bad_request_new	regress_http.c	/^http_cancel_test_bad_request_new(enum http_cancel_test_type type,$/;"	f	file:
http_cancel_test_type	regress_http.c	/^enum http_cancel_test_type {$/;"	g	file:
http_chunk_out_test	regress_http.c	/^static void http_chunk_out_test(void *arg)$/;"	f	file:
http_chunk_out_test_impl	regress_http.c	/^http_chunk_out_test_impl(void *arg, int ssl)$/;"	f	file:
http_chunked_cb	regress_http.c	/^http_chunked_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_chunked_errorcb	regress_http.c	/^http_chunked_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
http_chunked_readcb	regress_http.c	/^http_chunked_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_chunked_request_done	regress_http.c	/^http_chunked_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_chunked_trickle_cb	regress_http.c	/^http_chunked_trickle_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
http_chunked_writecb	regress_http.c	/^http_chunked_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_close_detection_	regress_http.c	/^http_close_detection_(struct basic_test_data *data, int with_delay)$/;"	f	file:
http_close_detection_delay_test	regress_http.c	/^http_close_detection_delay_test(void *arg)$/;"	f	file:
http_close_detection_test	regress_http.c	/^http_close_detection_test(void *arg)$/;"	f	file:
http_complete_write	regress_http.c	/^http_complete_write(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
http_connect	regress_http.c	/^http_connect(const char *address, ev_uint16_t port)$/;"	f	file:
http_connection_async_test	regress_http.c	/^http_connection_async_test(void *arg)$/;"	f	file:
http_connection_fail_done	regress_http.c	/^http_connection_fail_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_connection_fail_test	regress_http.c	/^static void http_connection_fail_test(void *arg)$/;"	f	file:
http_connection_fail_test_impl	regress_http.c	/^http_connection_fail_test_impl(void *arg, int ssl)$/;"	f	file:
http_connection_retry_conn_address_test	regress_http.c	/^static void http_connection_retry_conn_address_test(void *arg)$/;"	f	file:
http_connection_retry_conn_address_test_impl	regress_http.c	/^http_connection_retry_conn_address_test_impl(void *arg, int ssl)$/;"	f	file:
http_connection_retry_done	regress_http.c	/^http_connection_retry_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_connection_retry_test	regress_http.c	/^http_connection_retry_test(void *arg)$/;"	f	file:
http_connection_retry_test_basic	regress_http.c	/^http_connection_retry_test_basic(void *arg, const char *addr, struct evdns_base *dns_base, int ssl)$/;"	f	file:
http_connection_retry_test_impl	regress_http.c	/^http_connection_retry_test_impl(void *arg, int ssl)$/;"	f	file:
http_connection_test	regress_http.c	/^http_connection_test(void *arg)$/;"	f	file:
http_connection_test_	regress_http.c	/^http_connection_test_(struct basic_test_data *data, int persistent,$/;"	f	file:
http_data_length_constraints_test	regress_http.c	/^static void http_data_length_constraints_test(void *arg)$/;"	f	file:
http_data_length_constraints_test_done	regress_http.c	/^http_data_length_constraints_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_data_length_constraints_test_impl	regress_http.c	/^http_data_length_constraints_test_impl(void *arg, int read_on_write_error)$/;"	f	file:
http_delay_cb	regress_http.c	/^http_delay_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_delay_reply	regress_http.c	/^http_delay_reply(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
http_delete_cb	regress_http.c	/^http_delete_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_delete_test	regress_http.c	/^http_delete_test(void *arg)$/;"	f	file:
http_dispatcher_cb	regress_http.c	/^http_dispatcher_cb(struct evhttp_request *req, void *arg)$/;"	f
http_dispatcher_test	regress_http.c	/^http_dispatcher_test(void *arg)$/;"	f	file:
http_dispatcher_test_done	regress_http.c	/^http_dispatcher_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_do_cancel	regress_http.c	/^http_do_cancel(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
http_errorcb	regress_http.c	/^http_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
http_expectation_failed_done	regress_http.c	/^http_expectation_failed_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_failed_request_done	regress_http.c	/^http_failed_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_failure_readcb	regress_http.c	/^http_failure_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_failure_test	regress_http.c	/^http_failure_test(void *arg)$/;"	f	file:
http_fill_backlog	regress_http.c	/^http_fill_backlog(struct event_base *base, int port)$/;"	f	file:
http_free_evcons	regress_http.c	/^http_free_evcons(struct evhttp_connection **evcons)$/;"	f	file:
http_get_addr_test	regress_http.c	/^http_get_addr_test(void *arg)$/;"	f	file:
http_highport_test	regress_http.c	/^http_highport_test(void *arg)$/;"	f	file:
http_incomplete_errorcb	regress_http.c	/^http_incomplete_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
http_incomplete_readcb	regress_http.c	/^http_incomplete_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_incomplete_test	regress_http.c	/^static void http_incomplete_test(void *arg)$/;"	f	file:
http_incomplete_test_	regress_http.c	/^http_incomplete_test_(struct basic_test_data *data, int use_timeout, int ssl)$/;"	f	file:
http_incomplete_timeout_test	regress_http.c	/^static void http_incomplete_timeout_test(void *arg)$/;"	f	file:
http_incomplete_writecb	regress_http.c	/^http_incomplete_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_ipv6_for_domain_test	regress_http.c	/^http_ipv6_for_domain_test(void *arg)$/;"	f	file:
http_ipv6_for_domain_test_impl	regress_http.c	/^http_ipv6_for_domain_test_impl(void *arg, int family)$/;"	f	file:
http_large_cb	regress_http.c	/^http_large_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_large_delay_cb	regress_http.c	/^http_large_delay_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_large_entity_test_done	regress_http.c	/^http_large_entity_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_lingering_close_test	regress_http.c	/^static void http_lingering_close_test(void *arg)$/;"	f	file:
http_lingering_close_test_impl	regress_http.c	/^http_lingering_close_test_impl(void *arg, int lingering)$/;"	f	file:
http_make_web_server	regress_http.c	/^http_make_web_server(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
http_make_web_server_base	regress_http.c	/^static struct event_base *http_make_web_server_base=NULL;$/;"	v	typeref:struct:event_base	file:
http_multi_line_header_test	regress_http.c	/^http_multi_line_header_test(void *arg)$/;"	f	file:
http_negative_content_length_test	regress_http.c	/^http_negative_content_length_test(void *arg)$/;"	f	file:
http_no_write	regress_http.c	/^http_no_write(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg)$/;"	f	file:
http_non_lingering_close_test	regress_http.c	/^static void http_non_lingering_close_test(void *arg)$/;"	f	file:
http_on_complete_cb	regress_http.c	/^http_on_complete_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_on_complete_test	regress_http.c	/^http_on_complete_test(void *arg)$/;"	f	file:
http_parse_query_test	regress_http.c	/^http_parse_query_test(void *ptr)$/;"	f	file:
http_parse_uri_test	regress_http.c	/^http_parse_uri_test(void *ptr)$/;"	f	file:
http_persist_connection_test	regress_http.c	/^http_persist_connection_test(void *arg)$/;"	f	file:
http_post_cb	regress_http.c	/^http_post_cb(struct evhttp_request *req, void *arg)$/;"	f
http_post_test	regress_http.c	/^http_post_test(void *arg)$/;"	f	file:
http_postrequest_done	regress_http.c	/^http_postrequest_done(struct evhttp_request *req, void *arg)$/;"	f
http_primitives	regress_http.c	/^http_primitives(void *ptr)$/;"	f	file:
http_put_cb	regress_http.c	/^http_put_cb(struct evhttp_request *req, void *arg)$/;"	f
http_put_test	regress_http.c	/^http_put_test(void *arg)$/;"	f	file:
http_putrequest_done	regress_http.c	/^http_putrequest_done(struct evhttp_request *req, void *arg)$/;"	f
http_read_on_write_error_test	regress_http.c	/^static void http_read_on_write_error_test(void *arg)$/;"	f	file:
http_readcb	regress_http.c	/^http_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
http_ref_cb	bench_http.c	/^http_ref_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_bad	regress_http.c	/^http_request_bad(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_done	regress_http.c	/^http_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_empty_done	regress_http.c	/^http_request_empty_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_error_cb_with_cancel	regress_http.c	/^http_request_error_cb_with_cancel(enum evhttp_request_error error, void *arg)$/;"	f	file:
http_request_expect_error	regress_http.c	/^http_request_expect_error(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_get_addr_on_close	regress_http.c	/^http_request_get_addr_on_close(struct evhttp_connection *evcon, void *arg)$/;"	f	file:
http_request_never_call	regress_http.c	/^http_request_never_call(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_no_action_done	regress_http.c	/^http_request_no_action_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_request_own_test	regress_http.c	/^http_request_own_test(void *arg)$/;"	f	file:
http_sent_cb	regress_http.c	/^http_sent_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
http_server	regress_http.c	/^struct http_server$/;"	s	file:
http_set_family_ipv4_test	regress_http.c	/^http_set_family_ipv4_test(void *arg)$/;"	f	file:
http_set_family_ipv6_test	regress_http.c	/^http_set_family_ipv6_test(void *arg)$/;"	f	file:
http_set_family_test	regress_http.c	/^http_set_family_test(void *arg)$/;"	f	file:
http_setup	regress_http.c	/^http_setup(ev_uint16_t *pport, struct event_base *base, int mask)$/;"	f	file:
http_setup	regress_rpc.c	/^http_setup(ev_uint16_t *pport)$/;"	f	file:
http_simple_test	regress_http.c	/^static void http_simple_test(void *arg)$/;"	f	file:
http_simple_test_impl	regress_http.c	/^http_simple_test_impl(void *arg, int ssl, int dirty)$/;"	f	file:
http_stream_in_cancel_chunk	regress_http.c	/^http_stream_in_cancel_chunk(struct evhttp_request *req, void *arg)$/;"	f	file:
http_stream_in_cancel_done	regress_http.c	/^http_stream_in_cancel_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_stream_in_cancel_test	regress_http.c	/^http_stream_in_cancel_test(void *arg)$/;"	f	file:
http_stream_in_chunk	regress_http.c	/^http_stream_in_chunk(struct evhttp_request *req, void *arg)$/;"	f	file:
http_stream_in_done	regress_http.c	/^http_stream_in_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_stream_in_test	regress_http.c	/^http_stream_in_test(void *arg)$/;"	f	file:
http_stream_in_test_	regress_http.c	/^http_stream_in_test_(struct basic_test_data *data, char const *url,$/;"	f	file:
http_stream_out_test	regress_http.c	/^static void http_stream_out_test(void *arg)$/;"	f	file:
http_stream_out_test_impl	regress_http.c	/^http_stream_out_test_impl(void *arg, int ssl)$/;"	f	file:
http_terminate_chunked_oneshot_test	regress_http.c	/^http_terminate_chunked_oneshot_test(void *arg)$/;"	f	file:
http_terminate_chunked_test	regress_http.c	/^http_terminate_chunked_test(void *arg)$/;"	f	file:
http_terminate_chunked_test_impl	regress_http.c	/^http_terminate_chunked_test_impl(void *arg, int oneshot)$/;"	f	file:
http_testcases	regress_http.c	/^struct testcase_t http_testcases[] = {$/;"	v	typeref:struct:testcase_t
http_timed_out_request_done	regress_http.c	/^http_timed_out_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:
http_uriencode_test	regress_http.c	/^http_uriencode_test(void *ptr)$/;"	f	file:
http_virtual_host_test	regress_http.c	/^http_virtual_host_test(void *arg)$/;"	f	file:
http_write_during_read	regress_http.c	/^http_write_during_read(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
http_write_during_read_test	regress_http.c	/^static void http_write_during_read_test(void *arg)$/;"	f	file:
http_write_during_read_test_impl	regress_http.c	/^http_write_during_read_test_impl(void *arg, int ssl)$/;"	f	file:
http_writecb	regress_http.c	/^http_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:
https_basic_test	regress_http.c	/^static void https_basic_test(void *arg)$/;"	f	file:
https_bev	regress_http.c	/^https_bev(struct event_base *base, void *arg)$/;"	f	file:
https_chunk_out_test	regress_http.c	/^static void https_chunk_out_test(void *arg)$/;"	f	file:
https_connection_fail_test	regress_http.c	/^static void https_connection_fail_test(void *arg)$/;"	f	file:
https_connection_retry_conn_address_test	regress_http.c	/^static void https_connection_retry_conn_address_test(void *arg)$/;"	f	file:
https_connection_retry_test	regress_http.c	/^static void https_connection_retry_test(void *arg)$/;"	f	file:
https_connection_test	regress_http.c	/^static void https_connection_test(void *arg)$/;"	f	file:
https_filter_basic_test	regress_http.c	/^static void https_filter_basic_test(void *arg)$/;"	f	file:
https_filter_chunk_out_test	regress_http.c	/^static void https_filter_chunk_out_test(void *arg)$/;"	f	file:
https_incomplete_test	regress_http.c	/^static void https_incomplete_test(void *arg)$/;"	f	file:
https_incomplete_timeout_test	regress_http.c	/^static void https_incomplete_timeout_test(void *arg)$/;"	f	file:
https_persist_connection_test	regress_http.c	/^static void https_persist_connection_test(void *arg)$/;"	f	file:
https_simple_dirty_test	regress_http.c	/^static void https_simple_dirty_test(void *arg)$/;"	f	file:
https_simple_test	regress_http.c	/^static void https_simple_test(void *arg)$/;"	f	file:
https_stream_out_test	regress_http.c	/^static void https_stream_out_test(void *arg)$/;"	f	file:
https_write_during_read_test	regress_http.c	/^static void https_write_during_read_test(void *arg)$/;"	f	file:
i	regress_http.c	/^	int i;$/;"	m	struct:chunk_req_state	file:
ignore_log_cb	regress_main.c	/^ignore_log_cb(int s, const char *msg)$/;"	f	file:
immediate_called_twice_cb	regress.c	/^immediate_called_twice_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
in_legacy_test_wrapper	regress_main.c	/^int in_legacy_test_wrapper = 0;$/;"	v
in_tinytest_main	tinytest.c	/^static int in_tinytest_main = 0; \/**< true if we're in tinytest_main().*\/$/;"	v	file:
incr_arg_cb	regress.c	/^static void incr_arg_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
infilter_calls	regress_zlib.c	/^static int infilter_calls;$/;"	v	file:
init_ssl	regress_ssl.c	/^init_ssl(void)$/;"	f
internal_error_table	regress_dns.c	/^static struct regress_dns_server_table internal_error_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
iocp_testcases	regress_iocp.c	/^struct testcase_t iocp_testcases[] = {$/;"	v	typeref:struct:testcase_t
ipv4_entries	regress_util.c	/^} ipv4_entries[] = {$/;"	v	typeref:struct:ipv4_entry	file:
ipv4_entry	regress_util.c	/^static struct ipv4_entry {$/;"	s	file:
ipv6_entries	regress_util.c	/^} ipv6_entries[] = {$/;"	v	typeref:struct:ipv6_entry	file:
ipv6_entry	regress_util.c	/^static struct ipv6_entry {$/;"	s	file:
ipv6_search_table	regress_http.c	/^static struct regress_dns_server_table ipv6_search_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
is_loopback	regress_util.c	/^	int is_loopback;$/;"	m	struct:sa_pred_ent	file:
isbool	test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:
kerneltimeBegin	test-changelist.c	/^	FILETIME kerneltimeBegin;$/;"	m	struct:cpu_usage_timer	file:
keys	regress_iocp.c	/^	uintptr_t keys[MAX_CALLS];$/;"	m	struct:dummy_overlapped	file:
last_wrote_at	regress_bufferevent.c	/^	struct timeval last_wrote_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:
launch_request	bench_httpclient.c	/^launch_request(void)$/;"	f	file:
legacy_setup	regress_main.c	/^const struct testcase_setup_t legacy_setup = {$/;"	v	typeref:struct:testcase_setup_t
legacy_test_cleanup	regress_main.c	/^legacy_test_cleanup(const struct testcase_t *testcase, void *ptr)$/;"	f	file:
legacy_test_fn	regress.h	/^	void (*legacy_test_fn)(void);$/;"	m	struct:basic_test_data
legacy_test_setup	regress_main.c	/^legacy_test_setup(const struct testcase_t *testcase)$/;"	f	file:
libevent_tests_running_in_debug_mode	regress_main.c	/^int libevent_tests_running_in_debug_mode = 0;$/;"	v
listen_cb	regress_bufferevent.c	/^listen_cb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:
listener_accept_cb	test-fdleak.c	/^listener_accept_cb(struct evconnlistener *listener, evutil_socket_t sock,$/;"	f	file:
listener_iocp_testcases	regress_listener.c	/^struct testcase_t listener_iocp_testcases[] = {$/;"	v	typeref:struct:testcase_t
listener_testcases	regress_listener.c	/^struct testcase_t listener_testcases[] = {$/;"	v	typeref:struct:testcase_t
livenettests	regress_main.c	/^const char *livenettests[] = {$/;"	v
load_deferred_queue	regress_thread.c	/^load_deferred_queue(void *arg)$/;"	f	file:
load_threads	regress_thread.c	/^static THREAD_T load_threads[QUEUE_THREAD_COUNT];$/;"	v	file:
lock	regress_bufferevent.c	/^	void *lock;$/;"	m	struct:__anon1	file:
lock	regress_iocp.c	/^	void *lock;$/;"	m	struct:dummy_overlapped	file:
lock	regress_thread.c	/^	void *lock;$/;"	m	struct:cond_wait	file:
lock_unlock_base	regress_bufferevent.c	/^struct lock_unlock_base$/;"	s	file:
lock_unlock_free_thread_cbs	regress_bufferevent.c	/^static void lock_unlock_free_thread_cbs(void)$/;"	f	file:
lock_wrapper	regress_bufferevent.c	/^} lock_wrapper;$/;"	t	typeref:struct:__anon1	file:
locked	regress_bufferevent.c	/^	size_t locked \/** allow recursive locking *\/;$/;"	m	struct:__anon1	file:
locks	regress_bufferevent.c	/^	lock_wrapper *locks;$/;"	m	struct:lock_unlock_base	file:
log_change_callback	regress_buffer.c	/^log_change_callback(struct evbuffer *buffer,$/;"	f	file:
logfn	regress_util.c	/^logfn(int severity, const char *msg)$/;"	f	file:
logmsg	regress_util.c	/^static char *logmsg = NULL;$/;"	v	file:
logsev	regress_util.c	/^static int logsev = 0;$/;"	v	file:
loud_writecb	test-ratelim.c	/^loud_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:
lower	regress_testutils.h	/^	int lower;$/;"	m	struct:regress_dns_server_table
lu_base	regress_bufferevent.c	/^} lu_base = {$/;"	v	typeref:struct:lock_unlock_base
lu_find	regress_bufferevent.c	/^static lock_wrapper *lu_find(void *lock_)$/;"	f	file:
magic	regress_dns.c	/^	int magic;$/;"	m	struct:gaic_request_status	file:
main	bench.c	/^main(int argc, char **argv)$/;"	f
main	bench_cascade.c	/^main(int argc, char **argv)$/;"	f
main	bench_http.c	/^main(int argc, char **argv)$/;"	f
main	bench_httpclient.c	/^main(int argc, char **argv)$/;"	f
main	regress_main.c	/^main(int argc, const char **argv)$/;"	f
main	test-changelist.c	/^main(int argc, char **argv)$/;"	f
main	test-closed.c	/^main(int argc, char **argv)$/;"	f
main	test-dumpevents.c	/^main(int argc, char **argv)$/;"	f
main	test-eof.c	/^main(int argc, char **argv)$/;"	f
main	test-fdleak.c	/^main(int argc, char **argv)$/;"	f
main	test-init.c	/^main(int argc, char **argv)$/;"	f
main	test-ratelim.c	/^main(int argc, char **argv)$/;"	f
main	test-time.c	/^main(int argc, char **argv)$/;"	f
main	test-weof.c	/^main(int argc, char **argv)$/;"	f
main	test.sh	/^main()$/;"	f
main_testcases	regress.c	/^struct testcase_t main_testcases[] = {$/;"	v	typeref:struct:testcase_t
many_event_cb	regress.c	/^many_event_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
math	check-dumpevents.py	/^import math$/;"	i
max_bucket_level	test-ratelim.c	/^static ev_int64_t max_bucket_level=EV_INT64_MIN;$/;"	v	file:
methodname_to_envvar	regress.c	/^methodname_to_envvar(const char *mname, char *buf, size_t buflen)$/;"	f	file:
methods_rwcount	regress_ssl.c	/^static BIO_METHOD *methods_rwcount;$/;"	v	file:
min	test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:
min_bucket_level	test-ratelim.c	/^static ev_int64_t min_bucket_level=EV_INT64_MAX;$/;"	v	file:
minheap_testcases	regress_minheap.c	/^struct testcase_t minheap_testcases[] = {$/;"	v	typeref:struct:testcase_t
ms100_common	test-ratelim.c	/^static const struct timeval *ms100_common=NULL;$/;"	v	typeref:struct:timeval	file:
multiple_read_cb	regress.c	/^multiple_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
multiple_write_cb	regress.c	/^multiple_write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
my_perror	test-fdleak.c	/^my_perror(const char *s)$/;"	f	file:
n	regress.c	/^	int n;$/;"	m	struct:persist_active_timeout_called	file:
n_activate_other_event_cb	regress.c	/^static int n_activate_other_event_cb=0;$/;"	v	file:
n_bad	tinytest.c	/^static int n_bad = 0; \/**< Number of tests that have failed. *\/$/;"	v	file:
n_connected	regress_ssl.c	/^static int n_connected = 0;$/;"	v	file:
n_echo_conns_open	test-ratelim.c	/^static int n_echo_conns_open = 0;$/;"	v	file:
n_errors	bench_httpclient.c	/^int n_errors = 0;$/;"	v
n_events_invoked	regress_bufferevent.c	/^static int n_events_invoked = 0;$/;"	v	file:
n_gai_results_pending	regress_dns.c	/^static int n_gai_results_pending = 0;$/;"	v	file:
n_ok	tinytest.c	/^static int n_ok = 0; \/**< Number of tests that have passed *\/$/;"	v	file:
n_pai_calls	regress.c	/^static int n_pai_calls = 0;$/;"	v	file:
n_read	bench_httpclient.c	/^	size_t n_read;$/;"	m	struct:request_info	file:
n_read_and_drain_cb	regress.c	/^static int n_read_and_drain_cb=0;$/;"	v	file:
n_read_timeouts	regress_bufferevent.c	/^	int n_read_timeouts;$/;"	m	struct:timeout_cb_result	file:
n_reads_invoked	regress_bufferevent.c	/^static int n_reads_invoked = 0;$/;"	v	file:
n_replies_left	regress_dns.c	/^static int n_replies_left;$/;"	v	file:
n_server_responses	regress_dns.c	/^static int n_server_responses = 0;$/;"	v	file:
n_skipped	tinytest.c	/^static int n_skipped = 0; \/**< Number of tests that have been skipped. *\/$/;"	v	file:
n_strings_read	regress_bufferevent.c	/^static int n_strings_read = 0;$/;"	v	file:
n_write_a_byte_cb	regress.c	/^static int n_write_a_byte_cb=0;$/;"	v	file:
n_write_timeouts	regress_bufferevent.c	/^	int n_write_timeouts;$/;"	m	struct:timeout_cb_result	file:
name	test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:
name	tinytest.h	/^	const char *name; \/**< An identifier for this case. *\/$/;"	m	struct:testcase_t
name	tinytest.h	/^	const char *name;$/;"	m	struct:testlist_alias_t
need_input_hook	regress_rpc.c	/^static int need_input_hook = 0;$/;"	v	file:
need_output_hook	regress_rpc.c	/^static int need_output_hook = 0;$/;"	v	file:
nil_accept_cb	regress_dns.c	/^nil_accept_cb(struct evconnlistener *l, evutil_socket_t fd, struct sockaddr *s,$/;"	f	file:
nil_setup	regress_buffer.c	/^static const struct testcase_setup_t nil_setup = {$/;"	v	typeref:struct:testcase_setup_t	file:
no_cleanup	regress_buffer.c	/^no_cleanup(const void *data, size_t datalen, void *extra)$/;"	f	file:
note_time_cb	regress_thread.c	/^note_time_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
notification_fd_used	regress_thread.c	/^static int notification_fd_used = 0;$/;"	v	file:
notify_fd_cb	regress_thread.c	/^notify_fd_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
nr_locks	regress_bufferevent.c	/^	size_t nr_locks;$/;"	m	struct:lock_unlock_base	file:
nread	regress.c	/^	int nread;$/;"	m	struct:both	file:
num_active	bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
num_pipes	bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
num_requests	test-fdleak.c	/^static int num_requests;$/;"	v	file:
num_writes	bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
off64_t	regress_zlib.c	78;"	d	file:
oneshot	regress_http.c	/^	int oneshot: 1;$/;"	m	struct:terminate_state	file:
open_ssl_bufevs	regress_ssl.c	/^open_ssl_bufevs(struct bufferevent **bev1_out, struct bufferevent **bev2_out,$/;"	f	file:
opt_forked	tinytest.c	/^static int opt_forked = 0; \/**< True iff we're called from inside a win32 fork*\/$/;"	v	file:
opt_nofork	tinytest.c	/^static int opt_nofork = 0; \/**< Suppress calls to fork() for debugging. *\/$/;"	v	file:
opt_verbosity	tinytest.c	/^static int opt_verbosity = 1; \/**< -==quiet,0==terse,1==normal,2==verbose *\/$/;"	v	file:
option	test-ratelim.c	/^static struct option {$/;"	s	file:
options	test-ratelim.c	/^} options[] = {$/;"	v	typeref:struct:option	file:
outcome	tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	g	file:
outfilter_calls	regress_zlib.c	/^static int outfilter_calls;$/;"	v	file:
pai_events	regress.c	/^static struct event pai_events[3];$/;"	v	typeref:struct:event	file:
pair	regress.c	/^evutil_socket_t pair[2];$/;"	v
pair	regress.h	/^	evutil_socket_t pair[2];$/;"	m	struct:basic_test_data
pair	test-weof.c	/^evutil_socket_t pair[2];$/;"	v
pair_flush_eventcb	regress_bufferevent.c	/^pair_flush_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
pair_is_in	regress_iocp.c	/^pair_is_in(struct dummy_overlapped *o, uintptr_t key, ev_ssize_t n)$/;"	f	file:
parse	regress_util.c	/^	const char *parse;$/;"	m	struct:sa_port_ent	file:
parse	regress_util.c	/^	const char *parse;$/;"	m	struct:sa_pred_ent	file:
pat	check-dumpevents.py	/^pat = re.compile(r'Timeout=([0-9\\.]+)')$/;"	v
pending	regress_dns.c	/^static int pending = 0;$/;"	v	file:
pending_connect_events	regress_ssl.c	/^static int pending_connect_events = 0;$/;"	v	file:
periodic_timeout_cb	regress.c	/^periodic_timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
persist_active_timeout_called	regress.c	/^struct persist_active_timeout_called {$/;"	s	file:
persist_active_timeout_cb	regress.c	/^persist_active_timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
pipes	bench.c	/^static evutil_socket_t *pipes;$/;"	v	file:
pipes	bench_cascade.c	/^static evutil_socket_t *pipes;$/;"	v	file:
port	regress_http.c	/^	ev_uint16_t port;$/;"	m	struct:http_server	file:
port	regress_util.c	/^	int port;$/;"	m	struct:sa_port_ent	file:
prefix	tinytest.h	/^	const char *prefix; \/**< Prefix to prepend to testnames. *\/$/;"	m	struct:testgroup_t
premature_event	regress.c	/^static int premature_event = 0;$/;"	v	file:
prio_active_inversion_cb	regress.c	/^prio_active_inversion_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
process_test_alias	tinytest.c	/^process_test_alias(struct testgroup_t *groups, const char *test)$/;"	f	file:
process_test_option	tinytest.c	/^process_test_option(struct testgroup_t *groups, const char *test)$/;"	f	file:
ptr	test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:
q	regress_testutils.h	/^	const char *q;$/;"	m	struct:regress_dns_server_table
queue	regress_thread.c	/^	struct event_base *queue;$/;"	m	struct:deferred_test_data	typeref:struct:deferred_test_data::event_base	file:
queued	test-ratelim.c	/^	size_t queued;$/;"	m	struct:client_state	file:
r	regress_dns.c	/^	struct generic_dns_callback_result r;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::generic_dns_callback_result	file:
rand_int	test-time.c	/^rand_int(int n)$/;"	f	file:
ratelim_group	test-ratelim.c	/^struct bufferevent_rate_limit_group *ratelim_group = NULL;$/;"	v	typeref:struct:bufferevent_rate_limit_group
rbuf	regress.c	/^static char rbuf[4096];$/;"	v	file:
rbuf	regress_iocp.c	/^static struct evbuffer *rbuf = NULL, *wbuf = NULL;$/;"	v	typeref:struct:evbuffer	file:
re	check-dumpevents.py	/^import re$/;"	i
re_add_read_cb	regress.c	/^re_add_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
read	regress.c	98;"	d	file:
read	regress_ssl.c	/^	size_t read;$/;"	m	struct:rwcount	file:
read	regress_ssl.c	64;"	d	file:
read_and_drain_cb	regress.c	/^read_and_drain_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
read_called_once_cb	regress.c	/^read_called_once_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
read_cb	bench.c	/^read_cb(evutil_socket_t fd, short which, void *arg)$/;"	f	file:
read_cb	bench_cascade.c	/^read_cb(evutil_socket_t fd, short which, void *arg)$/;"	f	file:
read_cb	regress_et.c	/^read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
read_cb	test-eof.c	/^read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
read_complete	regress_iocp.c	/^read_complete(struct event_overlapped *eo, uintptr_t key,$/;"	f	file:
read_not_timeout_cb	regress.c	/^static void read_not_timeout_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
read_not_timeout_param	regress.c	/^struct read_not_timeout_param$/;"	s	file:
read_once_cb	regress.c	/^read_once_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
read_timeout_at	regress_bufferevent.c	/^	struct timeval read_timeout_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:
readcb	bench_httpclient.c	/^readcb(struct bufferevent *b, void *arg)$/;"	f	file:
readcb	regress_bufferevent.c	/^readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
readcb	regress_zlib.c	/^readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
readcb_finished	regress_zlib.c	/^static int readcb_finished;$/;"	v	file:
readd_test_event_last_added	regress.c	/^static struct event *readd_test_event_last_added = NULL;$/;"	v	typeref:struct:event	file:
reader_eventcb	regress_bufferevent.c	/^reader_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
reader_eventcb_simple	regress_bufferevent.c	/^reader_eventcb_simple(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
reader_readcb	regress_bufferevent.c	/^reader_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:
received	test-ratelim.c	/^	ev_uint64_t received;$/;"	m	struct:client_state	file:
record_event_cb	regress.c	/^record_event_cb(evutil_socket_t s, short what, void *ptr)$/;"	f	file:
reentrant_cb_run	regress.c	/^static int reentrant_cb_run = 0;$/;"	v	file:
ref_done_cb	regress_buffer.c	/^static void ref_done_cb(const void *data, size_t len, void *info)$/;"	f	file:
ref_done_cb_called_count	regress_buffer.c	/^static int ref_done_cb_called_count = 0;$/;"	v	file:
ref_done_cb_called_with	regress_buffer.c	/^static void *ref_done_cb_called_with = NULL;$/;"	v	file:
ref_done_cb_called_with_data	regress_buffer.c	/^static const void *ref_done_cb_called_with_data = NULL;$/;"	v	file:
ref_done_cb_called_with_len	regress_buffer.c	/^static size_t ref_done_cb_called_with_len = 0;$/;"	v	file:
reference_cb	regress_buffer.c	/^reference_cb(const void *data, size_t len, void *extra)$/;"	f	file:
reference_cb_called	regress_buffer.c	/^static int reference_cb_called;$/;"	v	file:
register_events_subthread	regress_thread.c	/^register_events_subthread(void *arg)$/;"	f	file:
regress_bufferevent_openssl	regress_ssl.c	/^regress_bufferevent_openssl(void *arg)$/;"	f	file:
regress_bufferevent_openssl_connect	regress_ssl.c	/^regress_bufferevent_openssl_connect(void *arg)$/;"	f	file:
regress_clean_dnsserver	regress_testutils.c	/^regress_clean_dnsserver(void)$/;"	f
regress_dns_server_cb	regress_testutils.c	/^regress_dns_server_cb(struct evdns_server_request *req, void *data)$/;"	f
regress_dns_server_table	regress_testutils.h	/^struct regress_dns_server_table {$/;"	s
regress_dnsserver	regress_testutils.c	/^regress_dnsserver(struct event_base *base, ev_uint16_t *port,$/;"	f
regress_fork	regress_main.c	/^regress_fork(void)$/;"	f
regress_get_dnsserver	regress_testutils.c	/^regress_get_dnsserver(struct event_base *base,$/;"	f
regress_get_listener_addr	regress_testutils.c	/^regress_get_listener_addr(struct evconnlistener *lev,$/;"	f
regress_get_socket_port	regress_testutils.c	/^regress_get_socket_port(evutil_socket_t fd)$/;"	f
regress_ipv4_parse	regress_util.c	/^regress_ipv4_parse(void *ptr)$/;"	f	file:
regress_ipv6_parse	regress_util.c	/^regress_ipv6_parse(void *ptr)$/;"	f	file:
regress_listener_error	regress_listener.c	/^regress_listener_error(void *arg)$/;"	f	file:
regress_listener_error_unlock	regress_listener.c	/^regress_listener_error_unlock(void *arg)$/;"	f	file:
regress_make_tmpfile	regress_main.c	/^regress_make_tmpfile(const void *data, size_t datalen, char **filename_out)$/;"	f
regress_openssl_type	regress_ssl.c	/^enum regress_openssl_type$/;"	g	file:
regress_pick_a_port	regress_listener.c	/^regress_pick_a_port(void *arg)$/;"	f	file:
regress_sockaddr_port_format	regress_util.c	/^regress_sockaddr_port_format(void *ptr)$/;"	f	file:
regress_sockaddr_port_parse	regress_util.c	/^regress_sockaddr_port_parse(void *ptr)$/;"	f	file:
reissue_table	regress_dns.c	/^static struct regress_dns_server_table reissue_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
remove_timers_cb	regress.c	/^static void remove_timers_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
renegotiate_at	regress_ssl.c	/^static int renegotiate_at = -1;$/;"	v	file:
replace_time	check-dumpevents.py	/^def replace_time(m):$/;"	f
req	regress_dns.c	/^	struct evdns_request *req;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::evdns_request	file:
req	regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::evhttp_request	file:
req	regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::evhttp_request	file:
request	regress_dns.c	/^	struct evdns_getaddrinfo_request *request;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::evdns_getaddrinfo_request	file:
request_count	regress_dns.c	/^static int request_count = 0;$/;"	v	file:
request_info	bench_httpclient.c	/^struct request_info {$/;"	s	file:
res	regress_util.c	/^	ev_uint32_t res;$/;"	m	struct:ipv4_entry	file:
res	regress_util.c	/^	ev_uint32_t res[4];$/;"	m	struct:ipv6_entry	file:
resource	bench_httpclient.c	/^const char *resource = NULL;$/;"	v
respond_to_number	regress_ssl.c	/^respond_to_number(struct bufferevent *bev, void *ctx)$/;"	f	file:
result	regress_dns.c	/^	int result;$/;"	m	struct:generic_dns_callback_result	file:
roff	regress.c	/^static int roff;$/;"	v	file:
rpc_basic_client	regress_rpc.c	/^rpc_basic_client(void)$/;"	f	file:
rpc_basic_client_with_pause	regress_rpc.c	/^rpc_basic_client_with_pause(void)$/;"	f	file:
rpc_basic_message	regress_rpc.c	/^rpc_basic_message(void)$/;"	f	file:
rpc_basic_queued_client	regress_rpc.c	/^rpc_basic_queued_client(void)$/;"	f	file:
rpc_basic_test	regress_rpc.c	/^rpc_basic_test(void)$/;"	f	file:
rpc_client_timeout	regress_rpc.c	/^rpc_client_timeout(void)$/;"	f	file:
rpc_hook_add_header	regress_rpc.c	/^rpc_hook_add_header(void *ctx, struct evhttp_request *req,$/;"	f	file:
rpc_hook_add_meta	regress_rpc.c	/^rpc_hook_add_meta(void *ctx, struct evhttp_request *req,$/;"	f	file:
rpc_hook_ctx_	regress_rpc.c	/^struct rpc_hook_ctx_ {$/;"	s	file:
rpc_hook_pause	regress_rpc.c	/^rpc_hook_pause(void *ctx, struct evhttp_request *req, struct evbuffer *evbuf,$/;"	f	file:
rpc_hook_pause_cb	regress_rpc.c	/^rpc_hook_pause_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
rpc_hook_remove_header	regress_rpc.c	/^rpc_hook_remove_header(void *ctx, struct evhttp_request *req,$/;"	f	file:
rpc_pool_with_connection	regress_rpc.c	/^rpc_pool_with_connection(ev_uint16_t port)$/;"	f	file:
rpc_postrequest_done	regress_rpc.c	/^rpc_postrequest_done(struct evhttp_request *req, void *arg)$/;"	f	file:
rpc_postrequest_failure	regress_rpc.c	/^rpc_postrequest_failure(struct evhttp_request *req, void *arg)$/;"	f	file:
rpc_setup	regress_rpc.c	/^rpc_setup(struct evhttp **phttp, ev_uint16_t *pport, struct evrpc_base **pbase)$/;"	f	file:
rpc_teardown	regress_rpc.c	/^rpc_teardown(struct evrpc_base *base)$/;"	f	file:
rpc_test	regress_rpc.c	/^rpc_test(void)$/;"	f	file:
rpc_testcases	regress_rpc.c	/^struct testcase_t rpc_testcases[] = {$/;"	v	typeref:struct:testcase_t
run_legacy_test_fn	regress_main.c	/^run_legacy_test_fn(void *ptr)$/;"	f
run_once	bench.c	/^run_once(void)$/;"	f	file:
run_once	bench_cascade.c	/^run_once(int num_pipes)$/;"	f	file:
run_tests	test.sh	/^run_tests () {$/;"	f
rwcount	regress_ssl.c	/^struct rwcount$/;"	s	file:
sa_port_ent	regress_util.c	/^static struct sa_port_ent {$/;"	s	file:
sa_port_ents	regress_util.c	/^} sa_port_ents[] = {$/;"	v	typeref:struct:sa_port_ent	file:
sa_pred_ent	regress_util.c	/^static struct sa_pred_ent {$/;"	s	file:
sa_pred_entries	regress_util.c	/^} sa_pred_entries[] = {$/;"	v	typeref:struct:sa_pred_ent	file:
saddr	test-fdleak.c	/^static struct sockaddr_in saddr;$/;"	v	typeref:struct:sockaddr_in	file:
safamily	regress_util.c	/^	int safamily;$/;"	m	struct:sa_port_ent	file:
search_cancel_server_cb	regress_dns.c	/^search_cancel_server_cb(struct evdns_server_request *req, void *data)$/;"	f	file:
search_table	regress_dns.c	/^static struct regress_dns_server_table search_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
search_table	regress_http.c	/^static struct regress_dns_server_table search_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
seconds_per_tick	test-ratelim.c	/^static double seconds_per_tick = 0.0;$/;"	v	file:
seen	regress_testutils.h	/^	int seen;$/;"	m	struct:regress_dns_server_table
self_draining_callback	regress_buffer.c	/^self_draining_callback(struct evbuffer *evbuffer, size_t old_len,$/;"	f	file:
send_a_byte_cb	regress.c	/^static void send_a_byte_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
sender_errorcb	regress_bufferevent.c	/^sender_errorcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
sender_writecb	regress_bufferevent.c	/^sender_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:
server_event_cb	test-fdleak.c	/^server_event_cb(struct bufferevent *bev, short events, void *ctx)$/;"	f	file:
server_read_cb	test-fdleak.c	/^server_read_cb(struct bufferevent *bev, void *ctx)$/;"	f	file:
set_random_timeout	regress_minheap.c	/^set_random_timeout(struct event *ev)$/;"	f	file:
setenv	regress.c	/^static void setenv(const char *k, const char *v, int o_)$/;"	f	file:
setup	test.sh	/^setup () {$/;"	f
setup	tinytest.h	/^	const struct testcase_setup_t *setup; \/**< Optional setup\/cleanup fns*\/$/;"	m	struct:testcase_t	typeref:struct:testcase_t::testcase_setup_t
setup_data	regress.h	/^	void *setup_data;$/;"	m	struct:basic_test_data
setup_data	tinytest.h	/^	void *setup_data; \/**< Extra data usable by setup function *\/$/;"	m	struct:testcase_t
setup_fn	tinytest.h	/^	void *(*setup_fn)(const struct testcase_t *);$/;"	m	struct:testcase_setup_t
setup_passthrough	regress_buffer.c	/^setup_passthrough(const struct testcase_t *testcase)$/;"	f	file:
setup_test	regress.c	289;"	d	file:
sigchld_cb	regress_thread.c	/^sigchld_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
signal_cb	regress.c	/^signal_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
signal_cb_sa	regress.c	/^signal_cb_sa(int sig)$/;"	f	file:
signal_cb_swp	regress.c	/^signal_cb_swp(int sig, short event, void *arg)$/;"	f	file:
signal_testcases	regress.c	/^struct testcase_t signal_testcases[] = {$/;"	v	typeref:struct:testcase_t
simple_callback	regress_finalize.c	/^simple_callback(struct event_callback *evcb, void *arg)$/;"	f	file:
simple_child_read_cb	regress.c	/^simple_child_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
simple_read_cb	regress.c	/^simple_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
simple_write_cb	regress.c	/^simple_write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
simpleclose_close_fd_cb	regress.c	/^simpleclose_close_fd_cb(evutil_socket_t s, short what, void *ptr)$/;"	f	file:
simpleread_multiple_cb	regress.c	/^simpleread_multiple_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
sizes	regress_iocp.c	/^	ev_ssize_t sizes[MAX_CALLS];$/;"	m	struct:dummy_overlapped	file:
snprintf	tinytest_local.h	10;"	d
snprintf	tinytest_local.h	12;"	d
sock_err_fn	regress_util.c	/^sock_err_fn(void)$/;"	f	file:
sock_perror	test-dumpevents.c	/^sock_perror(const char *s)$/;"	f	file:
ssl	regress_http.c	/^	int ssl;$/;"	m	struct:http_server	file:
ssl_getcert	regress_ssl.c	/^ssl_getcert(void)$/;"	f
ssl_getkey	regress_ssl.c	/^ssl_getkey(void)$/;"	f
ssl_testcases	regress_ssl.c	/^struct testcase_t ssl_testcases[] = {$/;"	v	typeref:struct:testcase_t
start_client	test-fdleak.c	/^start_client(struct event_base *base)$/;"	f	file:
start_cpu_usage_timer	test-changelist.c	/^start_cpu_usage_timer(struct cpu_usage_timer *timer)$/;"	f	file:
start_loop	test-fdleak.c	/^start_loop(void)$/;"	f	file:
start_threads_callback	regress_thread.c	/^start_threads_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
started	bench_httpclient.c	/^	struct timeval started;$/;"	m	struct:request_info	typeref:struct:request_info::timeval	file:
states	test-ratelim.c	/^struct client_state *states;$/;"	v	typeref:struct:client_state
status	regress_bufferevent.c	/^	} status;$/;"	m	struct:__anon1	typeref:enum:__anon1::__anon2	file:
status	regress_util.c	/^	enum entry_status status;$/;"	m	struct:ipv4_entry	typeref:enum:ipv4_entry::entry_status	file:
status	regress_util.c	/^	enum entry_status status;$/;"	m	struct:ipv6_entry	typeref:enum:ipv6_entry::entry_status	file:
stop_when_connected	regress_ssl.c	/^static int stop_when_connected = 0;$/;"	v	file:
strtolower	regress_testutils.c	/^static void strtolower(char *s)$/;"	f	file:
sys	check-dumpevents.py	/^import sys$/;"	i
t	regress_util.c	/^	time_t t;$/;"	m	struct:date_rfc1123_case	file:
tabf_cb	regress.c	/^tabf_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
tcalled	regress.c	/^static struct timeval tcalled;$/;"	v	typeref:struct:timeval	file:
terminate_chunked_cb	regress_http.c	/^terminate_chunked_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
terminate_chunked_client	regress_http.c	/^terminate_chunked_client(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
terminate_chunked_close_cb	regress_http.c	/^terminate_chunked_close_cb(struct evhttp_connection *evcon, void *arg)$/;"	f	file:
terminate_chunked_trickle_cb	regress_http.c	/^terminate_chunked_trickle_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
terminate_readcb	regress_http.c	/^terminate_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
terminate_state	regress_http.c	/^struct terminate_state {$/;"	s	file:
test_active_by_fd	regress.c	/^test_active_by_fd(void *arg)$/;"	f	file:
test_active_later	regress.c	/^test_active_later(void *ptr)$/;"	f	file:
test_ai_eq	regress.h	115;"	d
test_ai_eq_	regress_util.c	/^test_ai_eq_(const struct evutil_addrinfo *ai, const char *sockaddr_port,$/;"	f
test_bad_assign	regress.c	/^test_bad_assign(void *ptr)$/;"	f	file:
test_bad_reentrant	regress.c	/^test_bad_reentrant(void *ptr)$/;"	f	file:
test_base_environ	regress.c	/^test_base_environ(void *arg)$/;"	f	file:
test_base_features	regress.c	/^test_base_features(void *arg)$/;"	f	file:
test_bufferevent	regress_bufferevent.c	/^static void test_bufferevent(void) { test_bufferevent_impl(0, -1); }$/;"	f	file:
test_bufferevent_connect	regress_bufferevent.c	/^test_bufferevent_connect(void *arg)$/;"	f	file:
test_bufferevent_connect_fail	regress_bufferevent.c	/^test_bufferevent_connect_fail(void *arg)$/;"	f	file:
test_bufferevent_connect_fail_eventcb	regress_bufferevent.c	/^test_bufferevent_connect_fail_eventcb(void *arg)$/;"	f	file:
test_bufferevent_connect_hostname	regress_dns.c	/^test_bufferevent_connect_hostname(void *arg)$/;"	f	file:
test_bufferevent_filter_data_stuck	regress_bufferevent.c	/^test_bufferevent_filter_data_stuck(void *arg)$/;"	f	file:
test_bufferevent_filters	regress_bufferevent.c	/^static void test_bufferevent_filters(void)$/;"	f	file:
test_bufferevent_filters_disable	regress_bufferevent.c	/^static void test_bufferevent_filters_disable(void)$/;"	f	file:
test_bufferevent_filters_impl	regress_bufferevent.c	/^test_bufferevent_filters_impl(int use_pair, int disable)$/;"	f	file:
test_bufferevent_flush_finished	regress_bufferevent.c	/^static void test_bufferevent_flush_finished(void) { test_bufferevent_impl(0, BEV_FINISHED); }$/;"	f	file:
test_bufferevent_flush_flush	regress_bufferevent.c	/^static void test_bufferevent_flush_flush(void) { test_bufferevent_impl(0, BEV_FLUSH); }$/;"	f	file:
test_bufferevent_flush_normal	regress_bufferevent.c	/^static void test_bufferevent_flush_normal(void) { test_bufferevent_impl(0, BEV_NORMAL); }$/;"	f	file:
test_bufferevent_impl	regress_bufferevent.c	/^test_bufferevent_impl(int use_pair, int flush)$/;"	f	file:
test_bufferevent_pair	regress_bufferevent.c	/^static void test_bufferevent_pair(void) { test_bufferevent_impl(1, -1); }$/;"	f	file:
test_bufferevent_pair_filters	regress_bufferevent.c	/^static void test_bufferevent_pair_filters(void)$/;"	f	file:
test_bufferevent_pair_filters_disable	regress_bufferevent.c	/^static void test_bufferevent_pair_filters_disable(void)$/;"	f	file:
test_bufferevent_pair_flush	regress_bufferevent.c	/^test_bufferevent_pair_flush(void *arg)$/;"	f	file:
test_bufferevent_pair_flush_finished	regress_bufferevent.c	/^static void test_bufferevent_pair_flush_finished(void) { test_bufferevent_impl(1, BEV_FINISHED); }$/;"	f	file:
test_bufferevent_pair_flush_flush	regress_bufferevent.c	/^static void test_bufferevent_pair_flush_flush(void) { test_bufferevent_impl(1, BEV_FLUSH); }$/;"	f	file:
test_bufferevent_pair_flush_normal	regress_bufferevent.c	/^static void test_bufferevent_pair_flush_normal(void) { test_bufferevent_impl(1, BEV_NORMAL); }$/;"	f	file:
test_bufferevent_pair_release_lock	regress_bufferevent.c	/^static void test_bufferevent_pair_release_lock(void *arg)$/;"	f	file:
test_bufferevent_pair_watermarks	regress_bufferevent.c	/^test_bufferevent_pair_watermarks(void)$/;"	f	file:
test_bufferevent_socket_filter_inactive	regress_bufferevent.c	/^test_bufferevent_socket_filter_inactive(void *arg)$/;"	f	file:
test_bufferevent_timeouts	regress_bufferevent.c	/^test_bufferevent_timeouts(void *arg)$/;"	f	file:
test_bufferevent_trigger	regress_bufferevent.c	/^test_bufferevent_trigger(void *arg)$/;"	f	file:
test_bufferevent_watermarks	regress_bufferevent.c	/^test_bufferevent_watermarks(void)$/;"	f	file:
test_bufferevent_watermarks_impl	regress_bufferevent.c	/^test_bufferevent_watermarks_impl(int use_pair)$/;"	f	file:
test_bufferevent_zlib	regress_zlib.c	/^test_bufferevent_zlib(void *arg)$/;"	f
test_combined	regress.c	/^test_combined(void)$/;"	f	file:
test_common_timeout	regress.c	/^test_common_timeout(void *ptr)$/;"	f	file:
test_dbg_leak_cancel	regress_dns.c	/^test_dbg_leak_cancel(void *env_)$/;"	f	file:
test_dbg_leak_shutdown	regress_dns.c	/^test_dbg_leak_shutdown(void *env_)$/;"	f	file:
test_del_wait	regress.c	/^test_del_wait(void)$/;"	f	file:
test_dup_fd	regress.c	/^test_dup_fd(void *arg)$/;"	f	file:
test_edgetriggered	regress_et.c	/^test_edgetriggered(void *et)$/;"	f	file:
test_edgetriggered_mix_error	regress_et.c	/^test_edgetriggered_mix_error(void *data_)$/;"	f	file:
test_evbuffer	regress_buffer.c	/^test_evbuffer(void *ptr)$/;"	f	file:
test_evbuffer_add1	regress_buffer.c	/^test_evbuffer_add1(void *ptr)$/;"	f	file:
test_evbuffer_add2	regress_buffer.c	/^test_evbuffer_add2(void *ptr)$/;"	f	file:
test_evbuffer_add_buffer_with_empty	regress_buffer.c	/^test_evbuffer_add_buffer_with_empty(void *ptr)$/;"	f	file:
test_evbuffer_add_buffer_with_empty2	regress_buffer.c	/^test_evbuffer_add_buffer_with_empty2(void *ptr)$/;"	f	file:
test_evbuffer_add_file	regress_buffer.c	/^test_evbuffer_add_file(void *ptr)$/;"	f	file:
test_evbuffer_add_iovec	regress_buffer.c	/^test_evbuffer_add_iovec(void * ptr)$/;"	f	file:
test_evbuffer_add_reference	regress_buffer.c	/^test_evbuffer_add_reference(void *ptr)$/;"	f	file:
test_evbuffer_callbacks	regress_buffer.c	/^test_evbuffer_callbacks(void *ptr)$/;"	f	file:
test_evbuffer_copyout	regress_buffer.c	/^test_evbuffer_copyout(void *dummy)$/;"	f	file:
test_evbuffer_expand	regress_buffer.c	/^test_evbuffer_expand(void *ptr)$/;"	f	file:
test_evbuffer_expand_overflow	regress_buffer.c	/^test_evbuffer_expand_overflow(void *ptr)$/;"	f	file:
test_evbuffer_file_segment_add_cleanup_cb	regress_buffer.c	/^test_evbuffer_file_segment_add_cleanup_cb(void* ptr)$/;"	f	file:
test_evbuffer_find	regress_buffer.c	/^test_evbuffer_find(void *ptr)$/;"	f	file:
test_evbuffer_freeze	regress_buffer.c	/^test_evbuffer_freeze(void *ptr)$/;"	f	file:
test_evbuffer_iterative	regress_buffer.c	/^test_evbuffer_iterative(void *ptr)$/;"	f	file:
test_evbuffer_multicast	regress_buffer.c	/^test_evbuffer_multicast(void *ptr)$/;"	f	file:
test_evbuffer_multicast_drain	regress_buffer.c	/^test_evbuffer_multicast_drain(void *ptr)$/;"	f	file:
test_evbuffer_peek	regress_buffer.c	/^test_evbuffer_peek(void *info)$/;"	f	file:
test_evbuffer_peek_first_gt	regress_buffer.c	/^test_evbuffer_peek_first_gt(void *info)$/;"	f	file:
test_evbuffer_prepend	regress_buffer.c	/^test_evbuffer_prepend(void *ptr)$/;"	f	file:
test_evbuffer_ptr_set	regress_buffer.c	/^test_evbuffer_ptr_set(void *ptr)$/;"	f	file:
test_evbuffer_readln	regress_buffer.c	/^test_evbuffer_readln(void *ptr)$/;"	f	file:
test_evbuffer_reference	regress_buffer.c	/^test_evbuffer_reference(void *ptr)$/;"	f	file:
test_evbuffer_reference2	regress_buffer.c	/^test_evbuffer_reference2(void *ptr)$/;"	f	file:
test_evbuffer_remove_buffer_with_empty	regress_buffer.c	/^test_evbuffer_remove_buffer_with_empty(void *ptr)$/;"	f	file:
test_evbuffer_remove_buffer_with_empty2	regress_buffer.c	/^test_evbuffer_remove_buffer_with_empty2(void *ptr)$/;"	f	file:
test_evbuffer_remove_buffer_with_empty3	regress_buffer.c	/^test_evbuffer_remove_buffer_with_empty3(void *ptr)$/;"	f	file:
test_evbuffer_reserve2	regress_buffer.c	/^test_evbuffer_reserve2(void *ptr)$/;"	f	file:
test_evbuffer_reserve_many	regress_buffer.c	/^test_evbuffer_reserve_many(void *ptr)$/;"	f	file:
test_evbuffer_search	regress_buffer.c	/^test_evbuffer_search(void *ptr)$/;"	f	file:
test_evbuffer_search_eol	regress_buffer.c	/^test_evbuffer_search_eol(void *ptr)$/;"	f	file:
test_event_assign_selfarg	regress.c	/^test_event_assign_selfarg(void *ptr)$/;"	f	file:
test_event_base_get_max_events	regress.c	/^test_event_base_get_max_events(void *ptr)$/;"	f	file:
test_event_base_get_num_events	regress.c	/^test_event_base_get_num_events(void *ptr)$/;"	f	file:
test_event_base_new	regress.c	/^test_event_base_new(void *ptr)$/;"	f	file:
test_event_calloc	regress_util.c	/^test_event_calloc(void *arg)$/;"	f	file:
test_event_closed_fd_poll	regress.c	/^test_event_closed_fd_poll(void *arg)$/;"	f	file:
test_event_foreach	regress.c	/^test_event_foreach(void *arg)$/;"	f	file:
test_event_malloc	regress_util.c	/^test_event_malloc(void *arg)$/;"	f	file:
test_event_new_selfarg	regress.c	/^test_event_new_selfarg(void *ptr)$/;"	f	file:
test_event_once	regress.c	/^test_event_once(void *ptr)$/;"	f	file:
test_event_once_never	regress.c	/^test_event_once_never(void *ptr)$/;"	f	file:
test_event_pending	regress.c	/^test_event_pending(void *ptr)$/;"	f	file:
test_event_remove_timeout	regress.c	/^test_event_remove_timeout(void *ptr)$/;"	f	file:
test_event_strdup	regress_util.c	/^test_event_strdup(void *arg)$/;"	f	file:
test_evutil_casecmp	regress_util.c	/^test_evutil_casecmp(void *ptr)$/;"	f	file:
test_evutil_date_rfc1123	regress_util.c	/^test_evutil_date_rfc1123(void *arg)$/;"	f	file:
test_evutil_getaddrinfo	regress_util.c	/^test_evutil_getaddrinfo(void *arg)$/;"	f	file:
test_evutil_getaddrinfo_live	regress_util.c	/^test_evutil_getaddrinfo_live(void *arg)$/;"	f	file:
test_evutil_integers	regress_util.c	/^test_evutil_integers(void *arg)$/;"	f	file:
test_evutil_loadsyslib	regress_util.c	/^test_evutil_loadsyslib(void *arg)$/;"	f	file:
test_evutil_log	regress_util.c	/^test_evutil_log(void *ptr)$/;"	f	file:
test_evutil_monotonic_prc	regress_util.c	/^test_evutil_monotonic_prc(void *data_)$/;"	f	file:
test_evutil_monotonic_res	regress_util.c	/^test_evutil_monotonic_res(void *data_)$/;"	f	file:
test_evutil_rand	regress_util.c	/^test_evutil_rand(void *arg)$/;"	f	file:
test_evutil_rtrim	regress_util.c	/^test_evutil_rtrim(void *ptr)$/;"	f	file:
test_evutil_snprintf	regress_util.c	/^test_evutil_snprintf(void *ptr)$/;"	f	file:
test_evutil_sockaddr_predicates	regress_util.c	/^test_evutil_sockaddr_predicates(void *ptr)$/;"	f	file:
test_evutil_strlcpy	regress_util.c	/^test_evutil_strlcpy(void *arg)$/;"	f	file:
test_evutil_strtoll	regress_util.c	/^test_evutil_strtoll(void *ptr)$/;"	f	file:
test_evutil_upcast	regress_util.c	/^test_evutil_upcast(void *arg)$/;"	f	file:
test_evutil_usleep	regress_util.c	/^test_evutil_usleep(void *arg)$/;"	f	file:
test_fin_cb_invoked	regress_finalize.c	/^test_fin_cb_invoked(void *arg)$/;"	f	file:
test_fin_free_finalize	regress_finalize.c	/^test_fin_free_finalize(void *arg)$/;"	f	file:
test_fin_within_cb	regress_finalize.c	/^test_fin_within_cb(void *arg)$/;"	f	file:
test_fork	regress.c	/^test_fork(void)$/;"	f	file:
test_free_active_base	regress.c	/^test_free_active_base(void *ptr)$/;"	f	file:
test_get_assignment	regress.c	/^test_get_assignment(void *arg)$/;"	f	file:
test_getaddrinfo_async	regress_dns.c	/^test_getaddrinfo_async(void *arg)$/;"	f	file:
test_getaddrinfo_async_cancel_stress	regress_dns.c	/^test_getaddrinfo_async_cancel_stress(void *ptr)$/;"	f	file:
test_gettimeofday_cached	regress.c	/^test_gettimeofday_cached(void *arg)$/;"	f	file:
test_heap_randomized	regress_minheap.c	/^test_heap_randomized(void *ptr)$/;"	f	file:
test_immediatesignal	regress.c	/^test_immediatesignal(void)$/;"	f	file:
test_iocp_bufferevent_async	regress_iocp.c	/^test_iocp_bufferevent_async(void *ptr)$/;"	f	file:
test_iocp_evbuffer	regress_iocp.c	/^test_iocp_evbuffer(void *ptr)$/;"	f	file:
test_iocp_port	regress_iocp.c	/^test_iocp_port(void *ptr)$/;"	f	file:
test_is_done	regress_ssl.c	/^static int test_is_done = 0;$/;"	v	file:
test_loopbreak	regress.c	/^test_loopbreak(void)$/;"	f	file:
test_loopexit	regress.c	/^test_loopexit(void)$/;"	f	file:
test_loopexit_multiple	regress.c	/^test_loopexit_multiple(void)$/;"	f	file:
test_manipulate_active_events	regress.c	/^test_manipulate_active_events(void *ptr)$/;"	f	file:
test_many_events	regress.c	/^test_many_events(void *arg)$/;"	f	file:
test_methods	regress.c	/^test_methods(void *ptr)$/;"	f	file:
test_mm_functions	regress.c	/^test_mm_functions(void *arg)$/;"	f	file:
test_multiple	regress.c	/^test_multiple(void)$/;"	f	file:
test_multiple_cb	regress.c	/^test_multiple_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
test_multiple_events_for_same_fd	regress.c	/^test_multiple_events_for_same_fd(void)$/;"	f	file:
test_multiplesignal	regress.c	/^test_multiplesignal(void)$/;"	f	file:
test_nonpersist_readd	regress.c	/^test_nonpersist_readd(void)$/;"	f	file:
test_ok	regress.c	/^int test_ok;$/;"	v
test_okay	test-eof.c	/^int test_okay = 1;$/;"	v
test_okay	test-weof.c	/^int test_okay = 1;$/;"	v
test_persistent	regress.c	/^test_persistent(void)$/;"	f	file:
test_persistent_active_timeout	regress.c	/^test_persistent_active_timeout(void *ptr)$/;"	f	file:
test_persistent_timeout	regress.c	/^test_persistent_timeout(void)$/;"	f	file:
test_persistent_timeout_jump	regress.c	/^test_persistent_timeout_jump(void *ptr)$/;"	f	file:
test_pri_event	regress.c	/^struct test_pri_event {$/;"	s	file:
test_priorities	regress.c	/^test_priorities(void)$/;"	f	file:
test_priorities_cb	regress.c	/^test_priorities_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
test_priorities_impl	regress.c	/^test_priorities_impl(int npriorities)$/;"	f	file:
test_priority_active_inversion	regress.c	/^test_priority_active_inversion(void *data_)$/;"	f	file:
test_ratelimiting	test-ratelim.c	/^test_ratelimiting(void)$/;"	f	file:
test_signal_assert	regress.c	/^test_signal_assert(void)$/;"	f	file:
test_signal_dealloc	regress.c	/^test_signal_dealloc(void)$/;"	f	file:
test_signal_pipeloss	regress.c	/^test_signal_pipeloss(void)$/;"	f	file:
test_signal_restore	regress.c	/^test_signal_restore(void)$/;"	f	file:
test_signal_switchbase	regress.c	/^test_signal_switchbase(void)$/;"	f	file:
test_signal_while_processing	regress.c	/^test_signal_while_processing(void)$/;"	f	file:
test_simpleclose	regress.c	/^test_simpleclose(void *ptr)$/;"	f	file:
test_simpleread	regress.c	/^test_simpleread(void)$/;"	f	file:
test_simpleread_multiple	regress.c	/^test_simpleread_multiple(void)$/;"	f	file:
test_simplesignal	regress.c	/^test_simplesignal(void)$/;"	f	file:
test_simplesignal_impl	regress.c	/^test_simplesignal_impl(int find_reorder)$/;"	f	file:
test_simplestsignal	regress.c	/^test_simplestsignal(void)$/;"	f	file:
test_simpletimeout	regress.c	/^test_simpletimeout(void)$/;"	f	file:
test_simplewrite	regress.c	/^test_simplewrite(void)$/;"	f	file:
test_struct_event_size	regress.c	/^test_struct_event_size(void *arg)$/;"	f	file:
test_timeval_diff_eq	regress.h	123;"	d
test_timeval_diff_leq	regress.h	120;"	d
test_version	regress.c	/^test_version(void *arg)$/;"	f	file:
test_want_only_once	regress.c	/^test_want_only_once(void)$/;"	f	file:
test_weakrand	regress.h	58;"	d
test_weakrand_state	regress_main.c	/^struct evutil_weakrand_state test_weakrand_state;$/;"	v	typeref:struct:evutil_weakrand_state
testaliases	regress_main.c	/^struct testlist_alias_t testaliases[] = {$/;"	v	typeref:struct:testlist_alias_t
testcase_fn	tinytest.h	/^typedef void (*testcase_fn)(void *);$/;"	t
testcase_run_bare_	tinytest.c	/^testcase_run_bare_(const struct testcase_t *testcase)$/;"	f	file:
testcase_run_forked_	tinytest.c	/^testcase_run_forked_(const struct testgroup_t *group,$/;"	f	file:
testcase_run_one	tinytest.c	/^testcase_run_one(const struct testgroup_t *group,$/;"	f
testcase_setup_t	tinytest.h	/^struct testcase_setup_t {$/;"	s
testcase_t	tinytest.h	/^struct testcase_t {$/;"	s
testgroup_t	tinytest.h	/^struct testgroup_t {$/;"	s
testgroups	regress_main.c	/^struct testgroup_t testgroups[] = {$/;"	v	typeref:struct:testgroup_t
testleak_cleanup	regress_dns.c	/^testleak_cleanup(const struct testcase_t *testcase, void *env_)$/;"	f	file:
testleak_env_t	regress_dns.c	/^struct testleak_env_t {$/;"	s	file:
testleak_funcs	regress_dns.c	/^static struct testcase_setup_t testleak_funcs = {$/;"	v	typeref:struct:testcase_setup_t	file:
testleak_setup	regress_dns.c	/^testleak_setup(const struct testcase_t *testcase)$/;"	f	file:
testlist_alias_t	tinytest.h	/^struct testlist_alias_t {$/;"	s
tests	tinytest.h	/^	const char **tests;$/;"	m	struct:testlist_alias_t
text	check-dumpevents.py	/^text = sys.stdin.readlines()$/;"	v
tfff_free	regress_finalize.c	/^tfff_free(void *p)$/;"	f	file:
tfff_malloc	regress_finalize.c	/^tfff_malloc(size_t n)$/;"	f	file:
tfff_p1	regress_finalize.c	/^static void *tfff_p1=NULL, *tfff_p2=NULL;$/;"	v	file:
tfff_p1_freed	regress_finalize.c	/^static int tfff_p1_freed=0, tfff_p2_freed=0;$/;"	v	file:
tfff_p2	regress_finalize.c	/^static void *tfff_p1=NULL, *tfff_p2=NULL;$/;"	v	file:
tfff_p2_freed	regress_finalize.c	/^static int tfff_p1_freed=0, tfff_p2_freed=0;$/;"	v	file:
tfff_realloc	regress_finalize.c	/^tfff_realloc(void *p, size_t sz)$/;"	f	file:
the_ssl_ctx	regress_ssl.c	/^static SSL_CTX *the_ssl_ctx = NULL;$/;"	v	file:
thread	test-changelist.c	/^	HANDLE thread;$/;"	m	struct:cpu_usage_timer	file:
thread_basic	regress_thread.c	/^thread_basic(void *arg)$/;"	f	file:
thread_conditions_simple	regress_thread.c	/^thread_conditions_simple(void *arg)$/;"	f	file:
thread_deferred_cb_skew	regress_thread.c	/^thread_deferred_cb_skew(void *arg)$/;"	f	file:
thread_no_events	regress_thread.c	/^thread_no_events(void *arg)$/;"	f	file:
thread_testcases	regress_main.c	/^struct testcase_t thread_testcases[] = {$/;"	v	typeref:struct:testcase_t
thread_testcases	regress_thread.c	/^struct testcase_t thread_testcases[] = {$/;"	v	typeref:struct:testcase_t
timeBegin	test-changelist.c	/^	struct timeval timeBegin;$/;"	m	struct:cpu_usage_timer	typeref:struct:cpu_usage_timer::timeval	file:
time_cb	test-time.c	/^time_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
time_events	regress_thread.c	/^static struct event time_events[5];$/;"	v	typeref:struct:event	file:
timed_out	regress_thread.c	/^	int timed_out;$/;"	m	struct:alerted_record	file:
timeout	test-closed.c	/^struct timeval timeout = {3, 0};$/;"	v	typeref:struct:timeval
timeout	test-eof.c	/^struct timeval timeout = {60, 0};$/;"	v	typeref:struct:timeval
timeout_called_once_cb	regress.c	/^timeout_called_once_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
timeout_cb	regress.c	/^timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
timeout_cb	test-changelist.c	/^timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
timeout_cb_result	regress_bufferevent.c	/^struct timeout_cb_result {$/;"	s	file:
timeout_cb_swp	regress.c	/^timeout_cb_swp(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
timer_callback	regress_finalize.c	/^timer_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
timer_callback	regress_thread.c	/^timer_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
timer_callback_2	regress_finalize.c	/^timer_callback_2(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
timer_end	regress_thread.c	/^static struct timeval timer_end = {0,0};$/;"	v	typeref:struct:timeval	file:
timer_start	regress_thread.c	/^static struct timeval timer_start = {0,0};$/;"	v	typeref:struct:timeval	file:
times	regress_thread.c	/^static struct timeval times[5];$/;"	v	typeref:struct:timeval	file:
timeval_msec_diff	regress_main.c	/^timeval_msec_diff(const struct timeval *start, const struct timeval *end)$/;"	f
tinytest_format_hex_	tinytest.c	/^tinytest_format_hex_(const void *val_, unsigned long len)$/;"	f
tinytest_get_verbosity_	tinytest.c	/^tinytest_get_verbosity_(void)$/;"	f
tinytest_main	tinytest.c	/^tinytest_main(int c, const char **v, struct testgroup_t *groups)$/;"	f
tinytest_set_aliases	tinytest.c	/^tinytest_set_aliases(const struct testlist_alias_t *aliases)$/;"	f
tinytest_set_flag_	tinytest.c	/^tinytest_set_flag_(struct testgroup_t *groups, const char *arg, int set, unsigned long flag)$/;"	f
tinytest_set_test_failed_	tinytest.c	/^tinytest_set_test_failed_(void)$/;"	f
tinytest_set_test_skipped_	tinytest.c	/^tinytest_set_test_skipped_(void)$/;"	f
tinytest_skip	tinytest.h	88;"	d
total_calls	regress_bufferevent.c	/^	int total_calls;$/;"	m	struct:timeout_cb_result	file:
total_connected_or_failed	regress_dns.c	/^static int total_connected_or_failed = 0;$/;"	v	file:
total_group_rbucket_level	test-ratelim.c	/^static ev_int64_t total_group_rbucket_level = 0;$/;"	v	file:
total_group_wbucket_level	test-ratelim.c	/^static ev_int64_t total_group_wbucket_level = 0;$/;"	v	file:
total_max_to_read	test-ratelim.c	/^static ev_int64_t total_max_to_read=0;$/;"	v	file:
total_max_to_write	test-ratelim.c	/^static ev_int64_t total_max_to_write=0;$/;"	v	file:
total_n_accepted	regress_dns.c	/^static int total_n_accepted = 0;$/;"	v	file:
total_n_bev_checks	test-ratelim.c	/^static int total_n_bev_checks = 0;$/;"	v	file:
total_n_bytes	bench_httpclient.c	/^size_t total_n_bytes = 0;$/;"	v
total_n_errors	bench_httpclient.c	/^int total_n_errors = 0;$/;"	v
total_n_group_bev_checks	test-ratelim.c	/^static int total_n_group_bev_checks = 0;$/;"	v	file:
total_n_handled	bench_httpclient.c	/^int total_n_handled = 0;$/;"	v
total_n_launched	bench_httpclient.c	/^int total_n_launched = 0;$/;"	v
total_rbucket_level	test-ratelim.c	/^static ev_int64_t total_rbucket_level=0;$/;"	v	file:
total_read	regress_bufferevent.c	/^	size_t total_read;$/;"	m	struct:bufferevent_filter_data_stuck	file:
total_time	bench_httpclient.c	/^struct timeval total_time = {0,0};$/;"	v	typeref:struct:timeval
total_wbucket_level	test-ratelim.c	/^static ev_int64_t total_wbucket_level=0;$/;"	v	file:
trace_lock_alloc	regress_bufferevent.c	/^static void *trace_lock_alloc(unsigned locktype)$/;"	f	file:
trace_lock_free	regress_bufferevent.c	/^static void trace_lock_free(void *lock_, unsigned locktype)$/;"	f	file:
trace_lock_lock	regress_bufferevent.c	/^static int trace_lock_lock(unsigned mode, void *lock_)$/;"	f	file:
trace_lock_unlock	regress_bufferevent.c	/^static int trace_lock_unlock(unsigned mode, void *lock_)$/;"	f	file:
trigger_eventcb	regress_bufferevent.c	/^trigger_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
trigger_failure_cb	regress_bufferevent.c	/^trigger_failure_cb(evutil_socket_t fd, short what, void *ctx)$/;"	f	file:
trigger_readcb	regress_bufferevent.c	/^trigger_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:
trigger_readcb_triggered	regress_bufferevent.c	/^trigger_readcb_triggered(struct bufferevent *bev, void *ctx)$/;"	f	file:
tset	regress.c	/^static struct timeval tset;$/;"	v	typeref:struct:timeval	file:
tt_abort	tinytest_macros.h	74;"	d
tt_abort_msg	tinytest_macros.h	73;"	d
tt_abort_perror	tinytest_macros.h	72;"	d
tt_abort_printf	tinytest_macros.h	71;"	d
tt_assert	tinytest_macros.h	111;"	d
tt_assert_msg	tinytest_macros.h	105;"	d
tt_assert_op_type	tinytest_macros.h	153;"	d
tt_assert_test_fmt_type	tinytest_macros.h	113;"	d
tt_assert_test_type	tinytest_macros.h	143;"	d
tt_assert_test_type_opt	tinytest_macros.h	147;"	d
tt_fail	tinytest_macros.h	80;"	d
tt_fail_msg	tinytest_macros.h	79;"	d
tt_fail_perror	tinytest_macros.h	78;"	d
tt_failprint_f	tinytest_macros.h	77;"	d
tt_int_op	tinytest_macros.h	157;"	d
tt_iov_eq	regress_buffer.c	2164;"	d	file:
tt_line_eq	regress_buffer.c	1205;"	d	file:
tt_mem_op	tinytest_macros.h	180;"	d
tt_nstr_op	tinytest_macros.h	170;"	d
tt_ptr_op	tinytest_macros.h	165;"	d
tt_skip	tinytest_macros.h	83;"	d
tt_str_op	tinytest_macros.h	175;"	d
tt_uint_op	tinytest_macros.h	161;"	d
tt_want	tinytest_macros.h	109;"	d
tt_want_	tinytest_macros.h	89;"	d
tt_want_int_op	tinytest_macros.h	190;"	d
tt_want_msg	tinytest_macros.h	101;"	d
tt_want_ptr_op	tinytest_macros.h	197;"	d
tt_want_str_op	tinytest_macros.h	201;"	d
tt_want_uint_op	tinytest_macros.h	193;"	d
ttl	regress_dns.c	/^	int ttl;$/;"	m	struct:generic_dns_callback_result	file:
tvs	regress.c	/^	struct timeval tvs[16];$/;"	m	struct:persist_active_timeout_called	typeref:struct:persist_active_timeout_called::timeval	file:
type	regress_dns.c	/^	char type;$/;"	m	struct:generic_dns_callback_result	file:
unsetenv	regress.c	/^static void unsetenv(const char *k)$/;"	f	file:
usage	test-ratelim.c	/^usage(void)$/;"	f	file:
usage	test.sh	/^usage()$/;"	f
usage	tinytest.c	/^usage(struct testgroup_t *groups, int list_groups)$/;"	f	file:
use_lock_unlock_profiler	regress_bufferevent.c	/^static int use_lock_unlock_profiler(void)$/;"	f	file:
usepersist	regress.c	/^static int usepersist;$/;"	v	file:
usertimeBegin	test-changelist.c	/^	FILETIME usertimeBegin;$/;"	m	struct:cpu_usage_timer	file:
util_testcases	regress_util.c	/^struct testcase_t util_testcases[] = {$/;"	v	typeref:struct:testcase_t
validate_header	regress_http.c	/^static int validate_header($/;"	f	file:
vbase	regress_rpc.c	/^	void *vbase;$/;"	m	struct:rpc_hook_ctx_	file:
verbosity_flag	tinytest.c	/^const char *verbosity_flag = "";$/;"	v
wait_for_condition	regress_thread.c	/^wait_for_condition(void *arg)$/;"	f	file:
wake_all_timeout	regress_thread.c	/^wake_all_timeout(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
wake_one_timeout	regress_thread.c	/^wake_one_timeout(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
want_active	check-dumpevents.py	/^want_active = set(text[expect_active_pos+1:got_inserted_pos-1])$/;"	v
want_fail_eventcb	regress_bufferevent.c	/^want_fail_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
want_inserted	check-dumpevents.py	/^want_inserted = set(text[expect_inserted_pos+1:expect_active_pos])$/;"	v
was_et	regress_et.c	/^static int was_et = 0;$/;"	v	file:
wbuf	regress.c	/^static char wbuf[4096];$/;"	v	file:
wbuf	regress_iocp.c	/^static struct evbuffer *rbuf = NULL, *wbuf = NULL;$/;"	v	typeref:struct:	file:
weakrand_state	test-ratelim.c	/^static struct evutil_weakrand_state weakrand_state;$/;"	v	typeref:struct:evutil_weakrand_state	file:
weakrand_state	test-time.c	/^struct evutil_weakrand_state weakrand_state;$/;"	v	typeref:struct:evutil_weakrand_state
what	regress_dns.c	/^	int what;$/;"	m	struct:be_conn_hostname_result	file:
which	regress.c	/^	int which;$/;"	m	struct:common_timeout_info	file:
wm_errorcb	regress_bufferevent.c	/^wm_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:
wm_readcb	regress_bufferevent.c	/^wm_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:
wm_writecb	regress_bufferevent.c	/^wm_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:
woff	regress.c	/^static int woff;$/;"	v	file:
write	regress.c	97;"	d	file:
write	regress_ssl.c	/^	size_t write;$/;"	m	struct:rwcount	file:
write	regress_ssl.c	65;"	d	file:
write_a_byte_cb	regress.c	/^write_a_byte_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
write_cb	test-changelist.c	/^write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
write_cb	test-weof.c	/^write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
write_complete	regress_iocp.c	/^write_complete(struct event_overlapped *eo, uintptr_t key,$/;"	f	file:
write_on_connectedcb	test-ratelim.c	/^write_on_connectedcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:
write_timeout_at	regress_bufferevent.c	/^	struct timeval write_timeout_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:
writecb	regress_bufferevent.c	/^writecb(struct bufferevent *bev, void *arg)$/;"	f	file:
writecb	regress_zlib.c	/^writecb(struct bufferevent *bev, void *arg)$/;"	f	file:
writecb_finished	regress_zlib.c	/^static int writecb_finished;$/;"	v	file:
writes	bench.c	/^static int count, writes, fired, failures;$/;"	v	file:
zlib_deflate_free	regress_zlib.c	/^zlib_deflate_free(void *ctx)$/;"	f	file:
zlib_inflate_free	regress_zlib.c	/^zlib_inflate_free(void *ctx)$/;"	f	file:
zlib_input_filter	regress_zlib.c	/^zlib_input_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:
zlib_output_filter	regress_zlib.c	/^zlib_output_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:
