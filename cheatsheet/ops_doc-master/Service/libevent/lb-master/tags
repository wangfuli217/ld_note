!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AUTHOR	lb.c	49;"	d	file:
BSD_COMP	cb.c	81;"	d	file:
BUFFERS	nb.c	222;"	d	file:
BUFFERS	utils.c	121;"	d	file:
BUFFERSIZE	nb.c	223;"	d	file:
BUFFERSIZE	utils.c	122;"	d	file:
CBUFFSIZE	cb.c	153;"	d	file:
CONCURRENT	slurp.c	37;"	d	file:
COPYRIGHT	lb.c	50;"	d	file:
DEFAULT_ACCEPT	lb.h	69;"	d
DEFAULT_CONCURRENCY	lb.h	57;"	d
DEFAULT_DURATION_TIMEOUT	lb.h	65;"	d
DEFAULT_INITIAL_TIMEOUT	lb.h	63;"	d
DEFAULT_MAX_RETRY	lb.h	60;"	d
DEFAULT_PATH	uri.c	37;"	d	file:
DEFAULT_PORT	uri.c	36;"	d	file:
DEFAULT_PORT	wsl.c	46;"	d	file:
DEFAULT_PROXY_PORT	lb.h	72;"	d
DEFAULT_REPLY_TIMEOUT	lb.h	64;"	d
DEFAULT_REQUESTS	lb.h	54;"	d
DEFAULT_SERVERS_FILE	lb.h	51;"	d
DEFAULT_SIZE	wsl.c	47;"	d	file:
DEFAULT_USERAGENT	lb.h	68;"	d
LICENCE	lb.c	51;"	d	file:
MAX	lb.h	43;"	d
MAX	lb.h	47;"	d
MAXLINE	slurp.c	61;"	d	file:
MAXRETRY	slurp.c	38;"	d	file:
MAX_REQUESTS	cb.c	145;"	d	file:
MIN	cb.c	107;"	d	file:
MIN	lb.h	42;"	d
MIN	lb.h	46;"	d
MIN	wsl.c	43;"	d	file:
MSEC_PER_SEC	time.c	37;"	d	file:
NMATCHES	uri.c	40;"	d	file:
N_REQUESTS	nb.c	/^int N_REQUESTS = 20000;$/;"	v
OPTSTRING	lb.c	232;"	d	file:
OPTSTRING	nb.c	290;"	d	file:
OPTSTRING	wsl.c	153;"	d	file:
PARALLELISM	nb.c	/^int PARALLELISM = 200;$/;"	v
RELEASE_DATE	lb.c	53;"	d	file:
REPLY_TIMEOUT	slurp.c	39;"	d	file:
REQUESTS	slurp.c	36;"	d	file:
SANE	cb.c	663;"	d	file:
SECS_PER_DAY	time.c	40;"	d	file:
SECS_PER_HOUR	time.c	39;"	d	file:
SECS_PER_MIN	time.c	38;"	d	file:
STATE_CONNECTED	cb.c	150;"	d	file:
STATE_CONNECTING	cb.c	149;"	d	file:
STATE_READ	cb.c	151;"	d	file:
STATE_UNCONNECTED	cb.c	148;"	d	file:
TEMPLATE	lb.c	54;"	d	file:
URIREGEX	uri.c	34;"	d	file:
URL	lb.c	52;"	d	file:
USEC_PER_HOUR	time.c	36;"	d	file:
USEC_PER_MIN	time.c	35;"	d	file:
USEC_PER_SEC	time.c	34;"	d	file:
USE_S_WRITE	cb.c	278;"	d	file:
VERSION	cb.c	76;"	d	file:
VPCOLS	time.c	128;"	d	file:
VPCOLS	time.c	204;"	d	file:
VPROWS	time.c	127;"	d	file:
VPROWS	time.c	203;"	d	file:
_LB_H	lb.h	25;"	d
_rnd	cb.c	194;"	d	file:
ab_close	cb.c	267;"	d	file:
ab_close	cb.c	271;"	d	file:
ab_read	cb.c	268;"	d	file:
ab_read	cb.c	272;"	d	file:
ab_write	cb.c	269;"	d	file:
ab_write	cb.c	273;"	d	file:
ap_max	cb.c	193;"	d	file:
ap_min	cb.c	192;"	d	file:
ap_select	cb.c	109;"	d	file:
ap_snprintf	cb.c	111;"	d	file:
ap_sprintf	cb.c	110;"	d	file:
argsadd	varrays.c	/^char ** argsadd (char * argv [], char * item)$/;"	f
argsfind	varrays.c	/^char * argsfind (char * argv [], char * item)$/;"	f
argsfree	varrays.c	/^char ** argsfree (char * argv [])$/;"	f
argv	lb.h	/^  req_t ** argv;                     \/* The array of requests for this server               *\/$/;"	m	struct:server_t
asap	callbacks.c	/^static struct timeval asap = { 0, 0 };$/;"	v	typeref:struct:timeval	file:
ato64	utils.c	/^void ato64 (char * s, char * d)$/;"	f
atomsec	time.c	/^time_t atomsec (char * value)$/;"	f
auth	cb.c	/^     auth[1024],		\/* optional (basic\/uuencoded)$/;"	v
authproxy	lb.h	/^  char * authproxy;                  \/* Basic proxy authentication (user:password)          *\/$/;"	m	struct:__anon3
authproxy	lb.h	/^  char * authproxy;                  \/* Basic proxy authentication (user:password)          *\/$/;"	m	struct:server_t
bad	cb.c	/^long good = 0, bad = 0;		\/* number of good and bad requests *\/$/;"	v
bad	lb.h	/^  counter_t bad;                     \/* Total # of HTTP requests completed with errors      *\/$/;"	m	struct:server_t
base	lb.h	/^  struct event_base * base;          \/* Libevent main base                                  *\/$/;"	m	struct:__anon3	typeref:struct:__anon3::event_base
base	nb.c	/^struct event_base *base = NULL;$/;"	v	typeref:struct:event_base
base64	utils.c	/^static unsigned char base64 [] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v	file:
begin	lb.h	/^  struct timeval begin;              \/* The time benchmark was initiated                    *\/$/;"	m	struct:__anon3	typeref:struct:__anon3::timeval
beginread	cb.c	/^            beginread,		\/* First byte of input *\/$/;"	m	struct:connection	typeref:struct:connection::	file:
bench_evt	lb.h	/^  struct event bench_evt;$/;"	m	struct:__anon3	typeref:struct:__anon3::event
benchmark_cb	callbacks.c	/^void benchmark_cb (int unused, const short event, void * none)$/;"	f
bread	cb.c	/^    int bread;			\/* amount of body read *\/$/;"	m	struct:connection	file:
buffer	cb.c	/^char buffer[8192];$/;"	v
cbuff	cb.c	/^    char cbuff[CBUFFSIZE];	\/* a buffer to store server response header *\/$/;"	m	struct:connection	file:
cbx	cb.c	/^    int cbx;			\/* offset in cbuffer *\/$/;"	m	struct:connection	file:
cleanupreq	requests.c	/^req_t ** cleanupreq (req_t * argv [], void (* rmitem) (void *))$/;"	f
cleanupserver	servers.c	/^server_t ** cleanupserver (server_t * argv [], void (* rmitem) (void *))$/;"	f
close_connection	cb.c	/^static void close_connection(struct connection * c)$/;"	f	file:
colonport	cb.c	/^char colonport[1024];$/;"	v
complete_connect	cb.c	/^complete_connect(struct connection *c)$/;"	f	file:
compradre	cb.c	/^static int compradre(struct data * a, struct data * b)$/;"	f	file:
comprando	cb.c	/^static int comprando(struct data * a, struct data * b)$/;"	f	file:
compri	cb.c	/^static int compri(struct data * a, struct data * b)$/;"	f	file:
compwait	cb.c	/^static int compwait(struct data * a, struct data * b)$/;"	f	file:
con	cb.c	/^struct connection *con;		\/* connection array *\/$/;"	v	typeref:struct:connection
concurrency	cb.c	/^int concurrency = 1;		\/* Number of multiple requests to make *\/$/;"	v
concurrency	lb.h	/^  unsigned concurrency;              \/* # of concurrent requests to perform at a time       *\/$/;"	m	struct:__anon3
concurrency	lb.h	/^  unsigned concurrency;              \/* # of concurrent requests to perform at a time       *\/$/;"	m	struct:server_t
confidence	cb.c	/^int confidence = 1;		\/* Show confidence estimator and warnings *\/$/;"	v
conn_armtimer	cb.c	/^conn_armtimer(struct connection *c)$/;"	f	file:
connect	cb.c	/^            connect,		\/* Connected, start writing *\/$/;"	m	struct:connection	typeref:struct:connection::	file:
connection	cb.c	/^struct connection {$/;"	s	file:
content_size	wsl.c	/^static unsigned content_size = DEFAULT_SIZE;$/;"	v	file:
content_type	cb.c	/^char content_type[1024];	\/* content type to put in POST header *\/$/;"	v
cookie	cb.c	/^char cookie[1024],		\/* optional cookie line *\/$/;"	v
cookies	lb.h	/^  char ** cookies;$/;"	m	struct:__anon3
copyright	cb.c	/^static void copyright(void)$/;"	f	file:
counter_t	lb.h	/^typedef uint64_t counter_t;$/;"	t
counter_t	nb.c	/^typedef uint64_t counter_t;$/;"	t	file:
csvperc	cb.c	/^char *csvperc;			\/* CSV Percentile file *\/$/;"	v
ctime	cb.c	/^    long ctime;			\/* time in ms to connect *\/$/;"	m	struct:data	file:
ctx	cb.c	/^SSL_CTX *ctx;$/;"	v
data	cb.c	/^struct data {$/;"	s	file:
days	time.c	/^static time_t days (time_t t)$/;"	f	file:
defaultrun	utils.c	/^runtime_t * defaultrun (char * progname)$/;"	f
delta_msecs	time.c	/^time_t delta_msecs (struct timeval * t2, struct timeval * t1)$/;"	f
delta_secs	time.c	/^time_t delta_secs (struct timeval * t2, struct timeval * t1)$/;"	f
delta_usecs	time.c	/^time_t delta_usecs (struct timeval * t2, struct timeval * t1)$/;"	f
destroy_connection	cb.c	/^destroy_connection(struct connection *c)$/;"	f	file:
doclen	cb.c	/^int doclen = 0;			\/* the length the document should be *\/$/;"	v
done	cb.c	/^            done;		\/* Connection closed *\/$/;"	m	struct:connection	typeref:struct:connection::	file:
done	cb.c	/^long done = 0;			\/* number of requests we have done *\/$/;"	v
done	lb.h	/^  counter_t done;                    \/* Total # of HTTP replies received                    *\/$/;"	m	struct:server_t
doneka	cb.c	/^long doneka = 0;		\/* number of keep alive connections done *\/$/;"	v
dropped	lb.h	/^  counter_t dropped;                 \/* Total # of HTTP connections dropped by the remote   *\/$/;"	m	struct:server_t
dt_days	time.c	/^static int dt_days (time_t t1, time_t t2)$/;"	f	file:
dt_hours	time.c	/^static int dt_hours (time_t t1, time_t t2)$/;"	f	file:
dt_mins	time.c	/^static int dt_mins (time_t t1, time_t t2)$/;"	f	file:
dt_secs	time.c	/^static int dt_secs (time_t t1, time_t t2)$/;"	f	file:
duration_tv	lb.h	/^  struct timeval duration_tv;        \/* Duration timeout before to stop benchmarking        *\/$/;"	m	struct:__anon3	typeref:struct:__anon3::timeval
end	lb.h	/^  struct timeval end;                \/* The time benchmark was completed                    *\/$/;"	m	struct:__anon3	typeref:struct:__anon3::timeval
endtime	cb.c	/^struct timeval start, endtime;$/;"	v	typeref:struct:
endwrite	cb.c	/^            endwrite,		\/* Request written *\/$/;"	m	struct:connection	typeref:struct:connection::	file:
epipe	cb.c	/^long epipe = 0;			\/* number of broken pipe writes *\/$/;"	v
err	cb.c	/^static void err(char *s)$/;"	f	file:
err_conn	cb.c	/^int err_length = 0, err_conn = 0, err_except = 0;$/;"	v
err_except	cb.c	/^int err_length = 0, err_conn = 0, err_except = 0;$/;"	v
err_length	cb.c	/^int err_length = 0, err_conn = 0, err_except = 0;$/;"	v
err_response	cb.c	/^int err_response = 0;$/;"	v
errorcb	nb.c	/^errorcb(struct bufferevent *b, short what, void *arg)$/;"	f	file:
ev_read	cb.c	/^    struct event ev_read, ev_write;$/;"	m	struct:connection	typeref:struct:connection::event	file:
ev_timer	cb.c	/^    struct event ev_timer;$/;"	m	struct:connection	typeref:struct:connection::event	file:
ev_write	cb.c	/^    struct event ev_read, ev_write;$/;"	m	struct:connection	typeref:struct:connection::	file:
evcon	lb.h	/^  struct evhttp_connection * evcon;  \/* The HTTP connection over which the request is made  *\/$/;"	m	struct:__anon2	typeref:struct:__anon2::evhttp_connection
evreq	lb.h	/^  struct evhttp_request * evreq;     \/* The HTTP request itself                             *\/$/;"	m	struct:__anon2	typeref:struct:__anon2::evhttp_request
failed	lb.h	/^  counter_t failed;                  \/* Total # of HTTP requests failed to send             *\/$/;"	m	struct:server_t
fd	cb.c	/^    int fd;$/;"	m	struct:connection	file:
finished	servers.c	/^int finished (server_t * argv [])$/;"	f
firstrecv	lb.h	/^  struct timeval firstrecv;          \/* Time first HTTP reply was received                  *\/$/;"	m	struct:server_t	typeref:struct:server_t::timeval
firstsent	lb.h	/^  struct timeval firstsent;          \/* Time first HTTP request was sent                    *\/$/;"	m	struct:server_t	typeref:struct:server_t::timeval
fqname	utils.c	/^static char * fqname (char * name)$/;"	f	file:
fqname	wsl.c	/^static char * fqname (char * name)$/;"	f	file:
freeuri	uri.c	/^void freeuri (uri_t * uri)$/;"	f
frob_socket	nb.c	/^frob_socket(evutil_socket_t sock)$/;"	f	file:
ftoa	time.c	/^char * ftoa (double t)$/;"	f
ftotv	time.c	/^struct timeval * ftotv (double usecs)$/;"	f
full	lb.h	/^  char * full;                        \/* Server identifier as given by user (read from file) *\/$/;"	m	struct:server_t
fullurl	cb.c	/^char fullurl[1024];$/;"	v
getmatch	uri.c	/^static char * getmatch (regmatch_t m, const char * input)$/;"	f	file:
gnuplot	cb.c	/^char *gnuplot;			\/* GNUplot file *\/$/;"	v
good	cb.c	/^long good = 0, bad = 0;		\/* number of good and bad requests *\/$/;"	v
gotheader	cb.c	/^    int gotheader;		\/* non-zero if we have the entire header in$/;"	m	struct:connection	file:
hdrs	cb.c	/^     hdrs[4096];		\/* optional arbitrary headers *\/$/;"	v
head	lb.h	/^  u_char head;                       \/* Boolean to enable HTTP requests                     *\/$/;"	m	struct:__anon3
head	lb.h	/^  u_char head;                       \/* Boolean to enable HTTP requests                     *\/$/;"	m	struct:server_t
headers	lb.h	/^  char ** headers;$/;"	m	struct:__anon3
heartbeatres	cb.c	/^int heartbeatres = 100;		\/* How often do we say we're alive *\/$/;"	v
helloworld	lb.c	/^static void helloworld (char * progname, char * nodename)$/;"	f	file:
home_cb	wsl.c	/^static void home_cb (struct evhttp_request * req, void * arg)$/;"	f	file:
hostname	cb.c	/^char hostname[1024];		\/* host name *\/$/;"	v
hostname	lb.h	/^  char * hostname;$/;"	m	struct:__anon1
hours	time.c	/^static time_t hours (time_t t)$/;"	f	file:
httpargc	lb.h	/^  unsigned httpargc;                 \/* # of HTTP servers currently benchmarked             *\/$/;"	m	struct:__anon3
httpargv	lb.h	/^  server_t ** httpargv;              \/* Array of HTTP servers currently benchmarked         *\/$/;"	m	struct:__anon3
ident	Autogen.sh	/^ident ( ) {$/;"	f
initial_tv	lb.h	/^  struct timeval initial_tv;         \/* Initial delay timeout before to start benchmarking  *\/$/;"	m	struct:__anon3	typeref:struct:__anon3::timeval
initialize	Autogen.sh	/^initialize ( ) {$/;"	f
initialize	lb.c	/^static int initialize (char * argv [])$/;"	f	file:
initreq	requests.c	/^void initreq (req_t * request, struct event_base * base, server_t * server)$/;"	f
is_ipv6	cb.c	/^int is_ipv6 = 0;		\/* ipv4 by default *\/$/;"	v
isnumeric	time.c	/^static int isnumeric (char * s)$/;"	f	file:
isproxy	cb.c	/^int isproxy = 0;$/;"	v
issued	lb.h	/^  counter_t issued;                  \/* Total # of HTTP requests issued                     *\/$/;"	m	struct:server_t
keepalive	cb.c	/^    int keepalive;		\/* non-zero if a keep-alive request *\/$/;"	m	struct:connection	file:
keepalive	cb.c	/^int keepalive = 0;		\/* try and do keepalive connections *\/$/;"	v
keepalive	lb.h	/^  u_char keepalive;                  \/* Boolean to enable keep-alive requests               *\/$/;"	m	struct:__anon3
keepalive	lb.h	/^  u_char keepalive;                  \/* Boolean to enable keep-alive requests               *\/$/;"	m	struct:server_t
lastrecv	lb.h	/^  struct timeval lastrecv;           \/* Time last HTTP reply was received                   *\/$/;"	m	struct:server_t	typeref:struct:server_t::timeval
lastsent	lb.h	/^  struct timeval lastsent;           \/* Time last HTTP request was sent                     *\/$/;"	m	struct:server_t	typeref:struct:server_t::timeval
launch_request	nb.c	/^launch_request(char * server, int port)$/;"	f	file:
lbstat	servers.c	/^static void lbstat (server_t * s)$/;"	f	file:
lbstats	servers.c	/^void lbstats (server_t * argv [])$/;"	f
length	cb.c	/^    int length;			\/* Content-Length value used for keep-alive *\/$/;"	m	struct:connection	file:
length	lb.h	/^  uint64_t length;                   \/* Document length as returned in the HTTP reply       *\/$/;"	m	struct:server_t
length	nb.c	/^static int length = 0;$/;"	v	file:
lessreq	requests.c	/^req_t ** lessreq (req_t * argv [], req_t * item, void (* rmitem) (void *))$/;"	f
lessserver	servers.c	/^server_t ** lessserver (server_t * argv [], server_t * item, void (* rmitem) (void *))$/;"	f
libtool_failure	Autogen.sh	/^libtool_failure ( ) {$/;"	f
locate_configure_template	Autogen.sh	/^locate_configure_template ( ) {$/;"	f
main	cb.c	/^int main(int argc, char **argv)$/;"	f
main	lb.c	/^int main (int argc, char * argv [])$/;"	f
main	nb.c	/^int main (int argc, char **argv)$/;"	f
main	wsl.c	/^int main (int argc, char * argv [])$/;"	f
manual_autogen	Autogen.sh	/^manual_autogen ( ) {$/;"	f
max	lb.h	/^  double max;                        \/* Longest reply time                                  *\/$/;"	m	struct:server_t
maxretry	lb.h	/^  unsigned maxretry;                 \/* # of times a request should be resent - 0 no retry  *\/$/;"	m	struct:__anon3
maxretry	lb.h	/^  unsigned maxretry;                 \/* # of times a request should be resent - 0 no retry  *\/$/;"	m	struct:server_t
min	lb.h	/^  double min;                        \/* Shortest reply time                                 *\/$/;"	m	struct:server_t
mins	time.c	/^static time_t mins (time_t t)$/;"	f	file:
minstotv	time.c	/^void minstotv (time_t mins, struct timeval * tv)$/;"	f
mkreq	requests.c	/^req_t * mkreq (struct event_base * base, server_t * server)$/;"	f
mkserver	servers.c	/^server_t * mkserver (char * full, counter_t todo, unsigned concurrency, unsigned maxretry, time_t reply,$/;"	f
morereq	requests.c	/^req_t ** morereq (req_t * argv [], req_t * item)$/;"	f
moreserver	servers.c	/^server_t ** moreserver (server_t * argv [], server_t * item)$/;"	f
msecs	time.c	/^static time_t msecs (time_t t)$/;"	f	file:
msecstoa	time.c	/^char * msecstoa (time_t t)$/;"	f
msecstotv	time.c	/^void msecstotv (time_t msecs, struct timeval * tv)$/;"	f
n_errors	nb.c	/^int n_errors = 0;$/;"	v
n_read	nb.c	/^	size_t n_read;$/;"	m	struct:request_info	file:
next	lb.h	/^  unsigned next;                     \/* Index in the array of HTTP servers                  *\/$/;"	m	struct:__anon3
nextreq	requests.c	/^req_t * nextreq (req_t * argv [])$/;"	f
nodename	lb.h	/^  char * nodename;                   \/* The system the application was started on           *\/$/;"	m	struct:__anon3
nodename	wsl.c	/^static char * nodename = NULL;$/;"	v	file:
nomorerun	utils.c	/^void nomorerun (runtime_t * rc)$/;"	f
nonblock	cb.c	/^static void nonblock(int fd)$/;"	f	file:
notfound_cb	wsl.c	/^static void notfound_cb (struct evhttp_request * req, void * arg)$/;"	f	file:
on_interrupt	lb.c	/^static void on_interrupt (int sig)$/;"	f	file:
open_postfile	cb.c	/^static int open_postfile(char *pfile)$/;"	f	file:
output_html_results	cb.c	/^static void output_html_results(void)$/;"	f	file:
output_results	cb.c	/^static void output_results(void)$/;"	f	file:
parse_url	cb.c	/^int parse_url(char * purl)$/;"	f
passwd	lb.h	/^  char * passwd;            \/* Optional *\/$/;"	m	struct:__anon1
path	cb.c	/^char path[1024];		\/* path name *\/$/;"	v
path	lb.h	/^  char * path;              \/* Optional - default "\/" *\/$/;"	m	struct:__anon1
percentile	cb.c	/^int percentile = 1;		\/* Show percentile served *\/$/;"	v
pid	lb.h	/^  pid_t pid;                         \/* Process pid                                         *\/$/;"	m	struct:__anon3
port	cb.c	/^int port = 80;			\/* port number *\/$/;"	v
port	lb.h	/^  char * port;$/;"	m	struct:__anon1
port	nb.c	/^static int port = 1234;$/;"	v	file:
postdata	cb.c	/^char *postdata;			\/* *buffer containing data from postfile *\/$/;"	v
postfile	cb.c	/^char postfile[1024];		\/* name of file containing post data *\/$/;"	v
posting	cb.c	/^int posting = 0;		\/* GET by default *\/$/;"	v
postlen	cb.c	/^int postlen = 0;		\/* length of data to be POSTed *\/$/;"	v
ppbytes	nb.c	/^char * ppbytes (counter_t bytes)$/;"	f
ppbytes	utils.c	/^char * ppbytes (counter_t bytes)$/;"	f
ppcnt	nb.c	/^char * ppcnt (counter_t value)$/;"	f
ppcnt	utils.c	/^char * ppcnt (counter_t value)$/;"	f
progname	lb.h	/^  char * progname;                   \/* The name of the program                             *\/$/;"	m	struct:__anon3
progname	wsl.c	/^static char * progname = NULL;$/;"	v	file:
protect_from_clobber	Autogen.sh	/^protect_from_clobber ( ) {$/;"	f
protocol	lb.h	/^  char * protocol;          \/* Optional *\/$/;"	m	struct:__anon1
proxy	lb.h	/^  char * proxy;                      \/* Proxy server (hostname:port)                        *\/$/;"	m	struct:__anon3
proxyhost	cb.c	/^char proxyhost[1024];		\/* proxy host name *\/$/;"	v
proxyname	lb.h	/^  char * proxyname;                  \/* Proxy server hostname                               *\/$/;"	m	struct:server_t
proxyport	cb.c	/^int proxyport = 0;		\/* proxy port *\/$/;"	v
proxyport	lb.h	/^  int proxyport;                     \/* Proxy port                                          *\/$/;"	m	struct:server_t
push_cb	callbacks.c	/^void push_cb (int unused, const short event, void * server)$/;"	f
quiet	lb.h	/^  u_char quiet;                      \/* Quiet output                                        *\/$/;"	m	struct:__anon3
quiet	nb.c	/^static u_char quiet = 0;$/;"	v	file:
read	cb.c	/^    int read;			\/* amount of bytes read *\/$/;"	m	struct:connection	file:
read	cb.c	/^    int read;			\/* number of bytes read *\/$/;"	m	struct:data	file:
read_cb	cb.c	/^read_cb(int fd, short ev, void *args)$/;"	f	file:
read_connection	cb.c	/^static void read_connection(struct connection * c)$/;"	f	file:
readcb	nb.c	/^readcb(struct bufferevent *b, void *arg)$/;"	f	file:
recursive_manual_autogen	Autogen.sh	/^recursive_manual_autogen ( ) {$/;"	f
recursive_protect	Autogen.sh	/^recursive_protect ( ) {$/;"	f
recursive_restore	Autogen.sh	/^recursive_restore ( ) {$/;"	f
reply	lb.h	/^  time_t reply;                      \/* HTTP Reply timeout                                  *\/$/;"	m	struct:__anon3
reply_cb	callbacks.c	/^void reply_cb (struct evhttp_request * evreq, void * req)$/;"	f
reply_tv	lb.h	/^  struct timeval reply_tv;           \/* HTTP Reply timeout                                  *\/$/;"	m	struct:server_t	typeref:struct:server_t::timeval
req_evt	lb.h	/^  struct event req_evt;              \/* Variable to benchmark HTTP server at given time     *\/$/;"	m	struct:server_t	typeref:struct:server_t::event
req_t	lb.h	/^} req_t;$/;"	t	typeref:struct:__anon2
reqlen	cb.c	/^int reqlen;$/;"	v
request	cb.c	/^char request[1024];$/;"	v
request_info	nb.c	/^struct request_info {$/;"	s	file:
requests	cb.c	/^long requests = 1;		\/* Number of requests to make *\/$/;"	v
resource	nb.c	/^const char *resource = NULL;$/;"	v
restore_clobbered	Autogen.sh	/^restore_clobbered ( ) {$/;"	f
rmreq	requests.c	/^void rmreq (void * req)$/;"	f
rmserver	servers.c	/^void rmserver (void * server)$/;"	f
run	lb.c	/^runtime_t * run = NULL;$/;"	v
runtime_t	lb.h	/^} runtime_t;$/;"	t	typeref:struct:__anon3
s_write	cb.c	/^static int s_write(struct connection * c, char *buff, int len)$/;"	f	file:
safedup	varrays.c	/^void * safedup (void * a, void * b)$/;"	f
safefree	varrays.c	/^void * safefree (void * a)$/;"	f
secs	time.c	/^static time_t secs (time_t t)$/;"	f	file:
secstoa	time.c	/^char * secstoa (time_t t)$/;"	f
secstotv	time.c	/^void secstotv (time_t secs, struct timeval * tv)$/;"	f
sentbytes	lb.h	/^  counter_t sentbytes;               \/* Total # of bytes sent                               *\/$/;"	m	struct:server_t
server	cb.c	/^struct addrinfo *server;$/;"	v	typeref:struct:addrinfo
server	lb.h	/^  struct server_t * server;          \/* HTTP server reference that this request belongs to  *\/$/;"	m	struct:__anon2	typeref:struct:__anon2::server_t
server	nb.c	/^static char * server = "127.0.0.1";$/;"	v	file:
server_cb	callbacks.c	/^void server_cb (int unused, const short event, void * server)$/;"	f
server_t	lb.h	/^typedef struct server_t$/;"	s
server_t	lb.h	/^} server_t;$/;"	t	typeref:struct:server_t
servername	cb.c	/^char servername[1024];		\/* name that server reports *\/$/;"	v
servername	lb.h	/^  char * servername;                 \/* Server name as returned in the HTTP reply           *\/$/;"	m	struct:server_t
serversfile	lb.h	/^  char * serversfile;                \/* Server file (in any)                                *\/$/;"	m	struct:__anon3
slurp	slurp.c	/^int slurp (char * serversfile)$/;"	f
splituri	uri.c	/^uri_t * splituri (char * name)$/;"	f
ssl	cb.c	/^    SSL *ssl;$/;"	m	struct:connection	file:
ssl	cb.c	/^int ssl = 0;$/;"	v
start	cb.c	/^    struct timeval start,	\/* Start of connection *\/$/;"	m	struct:connection	typeref:struct:connection::timeval	file:
start	cb.c	/^struct timeval start, endtime;$/;"	v	typeref:struct:timeval
start_connect	cb.c	/^static void start_connect(struct connection * c)$/;"	f	file:
started	lb.h	/^  struct timeval started;            \/* The time program was started                        *\/$/;"	m	struct:__anon3	typeref:struct:__anon3::timeval
started	lb.h	/^  struct timeval started;            \/* Time the request has been started                   *\/$/;"	m	struct:__anon2	typeref:struct:__anon2::timeval
started	nb.c	/^	struct timeval started;$/;"	m	struct:request_info	typeref:struct:request_info::timeval	file:
starttime	cb.c	/^    long starttime;		\/* start time of connection in seconds since$/;"	m	struct:data	file:
state	cb.c	/^    int state;$/;"	m	struct:connection	file:
stats	cb.c	/^struct data *stats;		\/* date for each request *\/$/;"	v	typeref:struct:data
sum	lb.h	/^  double sum;                        \/* Sum of reply times                                  *\/$/;"	m	struct:server_t
tablestring	cb.c	/^char *tablestring;$/;"	v
tdstring	cb.c	/^char *tdstring;$/;"	v
terminate	lb.c	/^static void terminate (struct event_base * base)$/;"	f	file:
test	cb.c	/^static void test(void)$/;"	f	file:
time	cb.c	/^    long time;			\/* time in ms for connection *\/$/;"	m	struct:data	file:
timedif	cb.c	/^static int timedif(struct timeval a, struct timeval b)$/;"	f	file:
timeout_conn	cb.c	/^int timeout_conn = 0;$/;"	v
timer_cb	cb.c	/^timer_cb(int fd, short ev, void *args)$/;"	f	file:
tlimit	cb.c	/^int tlimit = 0;			\/* time limit in cs *\/$/;"	v
todo	lb.h	/^  counter_t todo;                    \/* # of requests to perform                            *\/$/;"	m	struct:server_t
todo	lb.h	/^  unsigned todo;                     \/* # of requests to perform foreach server             *\/$/;"	m	struct:__anon3
total_n_bytes	nb.c	/^size_t total_n_bytes = 0;$/;"	v
total_n_errors	nb.c	/^int total_n_errors = 0;$/;"	v
total_n_handled	nb.c	/^int total_n_handled = 0;$/;"	v
total_n_launched	nb.c	/^int total_n_launched = 0;$/;"	v
total_time	nb.c	/^struct timeval total_time = {0,0};$/;"	v	typeref:struct:timeval
totalbread	cb.c	/^uint64_t totalbread = 0;	\/* total amount of entity body read *\/$/;"	v
totalbread	lb.h	/^  counter_t totalbread;              \/* Total amount HTML entity body read                  *\/$/;"	m	struct:server_t
totalposted	cb.c	/^long totalposted = 0;		\/* total number of bytes posted, inc. headers *\/$/;"	v
totalread	cb.c	/^uint64_t totalread = 0;		\/* total number of bytes read *\/$/;"	v
totalread	lb.h	/^  counter_t totalread;               \/* Total # of bytes received                           *\/$/;"	m	struct:server_t
trstring	cb.c	/^char *trstring;$/;"	v
tvdelta	time.c	/^void tvdelta (struct timeval * t2, struct timeval * t1, struct timeval * t)$/;"	f
tvtoa	time.c	/^char * tvtoa (struct timeval * tv)$/;"	f
tvtodate	time.c	/^char * tvtodate (struct timeval * tv)$/;"	f
tvtof	time.c	/^double tvtof (const struct timeval * tv)$/;"	f
tvtomsecs	time.c	/^double tvtomsecs (struct timeval * tv)$/;"	f
tvtouptime	time.c	/^char * tvtouptime (struct timeval * tv)$/;"	f
untrap_abnormal	Autogen.sh	/^untrap_abnormal ( ) {$/;"	f
uri	lb.h	/^  uri_t * uri;$/;"	m	struct:server_t
uri_t	lb.h	/^} uri_t;$/;"	t	typeref:struct:__anon1
url	cb.c	/^char url[1024];$/;"	v
usage	Autogen.sh	/^usage ( ) {$/;"	f
usage	cb.c	/^static void usage(char *progname)$/;"	f	file:
usage	lb.c	/^static void usage (char * progname)$/;"	f	file:
usage	wsl.c	/^static void usage (char * progname)$/;"	f	file:
use_html	cb.c	/^int use_html = 0;		\/* use html in the report *\/$/;"	v
usecs	time.c	/^static time_t usecs (time_t t)$/;"	f	file:
usecstotv	time.c	/^void usecstotv (double usecs, struct timeval * tv)$/;"	f
userid	lb.h	/^  char * userid;            \/* Optional *\/$/;"	m	struct:__anon1
vacleanup	varrays.c	/^void ** vacleanup (void * argv [], void (* rmitem) (void *))$/;"	f
vadup	varrays.c	/^void ** vadup (void * argv [], int size)$/;"	f
valen	varrays.c	/^int valen (void * argv [])$/;"	f
valess	varrays.c	/^void ** valess (void * argv [], void * item, void (* rmitem) (void *))$/;"	f
valookup	varrays.c	/^int valookup (void * argv [], void * item)$/;"	f
vamore	varrays.c	/^void ** vamore (void * argv [], void * item)$/;"	f
verbosity	cb.c	/^int verbosity = 0;		\/* no verbosity by default *\/$/;"	v
version	lb.c	/^static void version (char * progname)$/;"	f	file:
version_check	Autogen.sh	/^version_check ( ) {$/;"	f
version_error	Autogen.sh	/^version_error ( ) {$/;"	f
waittime	cb.c	/^    long waittime;		\/* Between writing request and reading$/;"	m	struct:data	file:
write_cb	cb.c	/^write_cb(int fd, short ev, void *args)$/;"	f	file:
write_request	cb.c	/^static void write_request(struct connection * c)$/;"	f	file:
