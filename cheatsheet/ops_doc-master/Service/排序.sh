sort(排序)
{
排序，就是整理文件中的记录，使之按照关键字递增（或递减）的顺序排列起来。

排序算法的基本操作：
（1）     比较关键字的大小；（比较）
（2）     改变指向记录的指针或移动记录本身。（交换）
待排文件的常用存储方式：
（1）     以顺序表存储——排序过程：对记录本身进行物理重排，即通过关键字之间的比较判定，将记录移动到合适的位置
（2）     以链表作为存储结构——排序过程：无需移动记录，仅需修改指针。
（3）     用顺序表的方式存储待排序的记录，但同时建立一个辅助表——排序过程：只需要对辅助表的表目进行物理重排。
          适用于难于在链表上实现，但扔需避免排序过程中移动记录的排序方法。

什么是稳定的排序？
在待排序的文件中，若存在关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，该排序算法是稳定的。反之是不稳定的。
性能评价：
（1）     执行时间和所需的辅助时间。
（2）     算法本身的复杂程度。
空间复杂度：若排序算法所需的辅助空间并不依赖于问题的规模n，即辅助空间是O(1),则称为就地排序。
排序的时间开销：主要是关键字之间的比较和记录的移动。
排序算法可以分为5类：
插入排序、选择排序、交换排序、归并排序、分配排序。


在计算机科学所使用的排序算法通常被分类为：
a)计算的复杂度（最差、平均、和最好性能），依据列表（list）的大小（n）。一般而言，好的性能是O(nlog n)，且坏的性能是O(n平方)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(nlog n)。
b)存储器使用量（空间复杂度）（以及其他电脑资源的使用）
c)稳定度：稳定排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。
d)一般的方法：插入、交换、选择、合并等等。交换排序包含冒泡排序和快速排序。插入排序包含希尔排序，选择排序包括堆排序等。
}


sort(内部排序与外部排序)
{
1. 内部排序与外部排序的区别：
在排序过程中，若整个文件都是放在内存中处理，排序时不涉及数据的内外存交换，就为内部排序。
反之，若排序过程中要进行数据的内外存交换，则称为外部排序。

2. 适用条件：
内部排序适用于记录个数不很多的小文件。
外排序则适用于记录个数太多，不能一次将其全部记录放入内存的大文件。

}

sort(插入排序)
{
1. 插入排序分为：直接插入排序（稳定）、希尔(shell)排序（不稳定）
2. 排序思想：每次将一个待排序的记录，按其关键字大小插入到前面已排好的子数组中的适当位置，直到全部记录插入完成为止。

3. 直接插入排序
时间复杂度O(n*n)空间复杂度：O(1)

4. 直接插入排序思想：
    假设待排记录存放在数组R[1…n]中，初始时，R[1]自成一个有序区，无序区为R[2…n]。从i=2开始到i=n结束，一次将R[i]插入到
当前有序区R[1…i-1]中，生成含n个记录的有序区。
    第(i-1)次直接插入排序：通常将记录R[i](i=2…n-1)插入到当前的有序区，使得插入后仍保证该区间里的记录是按关键字有序地操作，称为第i-1次直接插入排序。
方法：查找比较和记录移动操作交替进行，将待插记录R[i]的关键字从右向左依次与有序区中记录R[j](j=i-1,i-2,…1)的关键字进行比较。
}

sort(希尔排序)
{
为什么引入希尔排序？
在直接插入排序算法中，，每次插入一个数，使有序序列只增加一个节点，并且对插入下一个数没有提供任何帮助。如果比较相隔远的距离数，使得数移动时能够跨过多个元素，则进行一次比较就能消除多个元素交换。
1. 当数组初始状态基本有序时，直接插入排序所需的比较和移动次数均较少；
2. 当n值较小时，n和n*n的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度O()差别不大。
3. 在shell排序开始时增量较大，分组较多，每组的记录数目少，故个分组内直接插入较快，后来增量d逐渐减少，分组数逐渐减少，而各组记录逐渐增多，但由于已经按d-1作为距离完成排序，使数组较接近于有序状态，所以新的一次排序过程也较快。综上：shell排序在效率上比直接插入排序有较大的改进。
}

交换排序分为：冒泡排序（稳定）、快速排序（不稳定）
交换排序的基本思想：两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。

sort(冒泡排序)
{
1、冒泡排序：
时间复杂度O(n*n)空间复杂度：O(1)
冒泡排序算法：依次比较相邻的两个数，将小数放在前面，大数放在后面。
在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。
在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。
如此下去，重复以上过程，直至最终完成排序。
由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。

}

sort(快速排序算法)
{
2、快速排序算法：快速排序是冒泡排序的一种改进
时间复杂度O(nlogn)空间复杂度：O(logn)
基本思想：通过一趟排序将待排记录分割成独立的2部分，其中一部分记录的关键字均比另一部分记录的关键字小，则分别对这两部分记录进行排序，以达到整个序列有序。
一趟快速排序的做法：附设2个指针low和high，设枢轴记录关键字为key，则先从高位起（high）向前搜素找到第一个关键字小于key的记录和枢轴记录交换，然后从低位（low）所指的位置向后搜索，找到第一个关键字大于key的记录和枢轴记录交换，重复这两部，直至low=high为止。
}

sort(直接选择排序)
{
选择排序分为：直接选择排序、堆排序

选择排序思想：每次从待序排记录中选出关键字最小的记录，顺序放在已排好的子文件最后，直到全部记录排序完毕。

一、直接选择排序思想：n个记录的直接选择排序可以经过n-1次直接选择排序得到有序结果。

时间复杂度：O(n*n)  空间复杂度：O(1)    不稳定

步骤：

（1） 初始状态，无序区为A[1…n]，有序区为空；

（2） 第一次排序：在无序区为A[1…n]中选出最小的记录A[k],将它与无序区的第一个记录A[1]交换，使A[1…1]和A[2…n]分别成为记录个数增加1个的新的有序区和记录个数减少1个的新无序区。

（3） 第i次排序：第i次排序开始时，当前有序区和无序区分别为A[1…i-1]和A[i…n]，该次从当前无序区中选出关键字最小的记录A[k],将它与无序区的第1个记录A[i]交换，使A[1…i]和A[i…n]分别为记录个数增加1个的新的有序区和记录个数较少1个的新的无序区。

（4）这样，n个记录的文件的直接选择排序经过(n-1)次直接选择排序得到有序结果。
}

sort()
{
三、堆排序：
定义：n个序列，A1，A2,…,An称为堆。
2种不同类型的堆：
小根堆：所有子节点都大于其父节点。即：Ai<A2i且Ai<=A2i+1
大根堆：所有子节点都小于父节点。即：Ai>A2i且Ai>=A2i+1
堆排序是一种树形选择排序，在排序过程中，将R[1…n]看成一颗完全二叉树的顺序存储结构。利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或最小）的记录。
时间复杂度：O(n*logn)  空间复杂度：O(1)    不稳定
基本步骤：
（1）     先初始化A[1…n]建成一个大根堆，此堆为初始的无序区。
（2）     将关键字最大的记录A[1]和无序区的最后一个记录A[n]交换，由此得到新的无序区A[1…(n-1)]和有序区A[n]，且满足A[1…(n-1)]<=A[n]。
（3）     由于交换后新的根A[1]可能违反堆性质，故应将当前无序区A[1…(n-1)]调整为堆；然后再将A[1…(n-1)]中关键字最大的记录A[1]和该区间的最后一个记录A[n-1]交换，由此得到新的无序区A[1…(n-2)]和有序区A[(n-1)…n]，且满足：A[1…(n-2)]<= A[(n-1)…n]；同样将A[1…(n-2)]调整为堆。
（4）     对调整的堆重复进行上面的交换，知道无序区只有一个元素为止。
}

sort(归并排序)
{
归并排序是将若干个已排序的文件合成一个有序的文件。

两路归并排序算法的思路：设两个有序的文件放在同一向量中相邻的位置上，即A[low…m]与A[m+1…high]，先将它们合并到一个局部暂存向量Temp中，待合并完成后将Temp复制回A[low…high]中。

自顶向下归并排序步骤：设归并排序的当前区间是A[low…high]
（1）     分解：将当前区间一分为二，即求分割点
（2）     求解：递归这两个子区间A[low…mid] 和A[mid+1…high]进行归并排序。
（3）      组合：将已排好的两个子区间A[low…mid] 和A[mid+1…high]归并为一个有序的区间A[low…high]
（4）     递归的终点条件是：子区间长度为1
}
