1. 没有编写测试的代码是糟糕的代码，不管我们有多细心地去编写它们，不管它们有多漂亮、
   面向对象或封装良好，只要没有编写测试，我们实际上就不知道修改后的代码是变得更好了还是更糟了。
   反之，有了测试，我们就能够迅速、可验证地修改代码的行为。

code(修改软件的四个主要起因){
1.添加新特性
2.修正 bug
3.改善设计
4.优化资源使用
}
code(带着反馈工作){
    单元测试是用于对付遗留代码的极其重要的组件之一。系统层面的回归测试地区很棒，然而相比之下，
小巧而局部性的测试才是无价之宝，它们能够在进行改动的过程中不断给你反馈，是重构工作的安全性大大增强。
}

progam(){
• 面对对象编程 - 解决事物具象与抽象的问题
• 面向接口编程 - 解决事物定义与行为的问题
• 面向切面编程 - 解决业务离散与聚合的问题
• 多线程的编程 - 解决做什么与何时做的问题。同时也解决资源的共享与互斥，线程的并发与调度的问题。
                 对象是过程(任务)的抽象，线程是调度（时间）的抽象。
• 设计模式编程 - 解决对象是如何创建的，对象的结构是怎样的，对象是如何交互的问题。
• 通用解决思路 - 空间换时间，时间换空间，复杂问题简单化，大型问题分解化
• 软件硬件相通 - 把程序设计的像计算机一样（输入、输出、运算、控制、内存、外存）
• 软件设计过程 - 整体到局部 局部到整体 相互迭代；设计模式对应常态设计 技术选择对应框架设计
                 业务需求对应功能设计；
• 没有适用于任何软件系统的唯一方法，结合实际总结适用于当前工作环境，人员结构，技术水平的开发模式；
做到降低开发成本，提高工作效率，模块易于扩展，性能可以调整，代码可以复用。


}

good(有意义的命名){
好名字的简单规则

名副其实
避免误导
别用 accountList 来指一组帐号，除非它真的是 List 类型
提防使用不同之处较小的名称
做有意义的区分
使用读得出来的名称
使用可搜索的名称（单字母名称和数字常量很难在一大篇文字中找出来）
避免使用编码
避免使用思维映射
类名不应当是动词
方法名应当是动词或动词短语
别扮可爱
每个概念对应一个词
别用双关语
使用解决方案领域名称
使用源自所涉问题领域的名称
添加有意义的语境（实在不行可以添加前缀）
不要添加没用的语境
}
good(函数){
短小
只做一件事
每个函数一个抽象层级
switch 语句
如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍
使用描述性的名称
函数参数
尽量避免三个或三个以上参数
无副作用
分隔指令与询问
使用异常替代返回错误码
错误处理代码就能从主路径代码中分离出来
抽离 Try/Catch 代码块：最好把 try 和 catch 代码块的主题部分抽离出来，另外形成函数
错误处理就是一件事
返回错误码通常暗示有某个类或是枚举，定义了所有错误码，这样的类就是一块依赖磁铁(dependency magnet)，其他许多类都得导入和使用它
别重复自己
结构化编程

    每个系统都是使用某种领域特定语言搭建的，而这种语言是程序员设计来描述那个系统的。函数是语言的动词，
类是名词。编程艺术是且一直就是语言设计的艺术。

    大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富
且更具表达力的语言，用来讲那个故事。
}

good(注释){
尽管有时也需要注释，我们也该多花心思尽量减少注释量

注释不能美化糟糕的代码
用代码来阐述
好注释
    法律信息
    提供信息的注释
    对意图的解释
    阐释
    警示
    TODO 注释
    放大
    公共 API 中的 Javadoc
坏注释
    喃喃自语
    多余的注释
    误导性注释
    循规式注释
    日志式注释
    废话注释
    可怕的废话（Javadoc 也可能是废话）
    能用函数或变量时就别用注释
    位置标记
    括号后面的注释
    归属与署名（有源代码控制系统）
    注释掉的代码
    HTML 注释
    非本地信息
    信息过多
    不明显的联系
    函数头
    非公共代码中的 Javadoc（八股）
}
good(格式){
数据抽象
数据、对象的反对称性
得墨忒耳律：模块不应了解它所操作对象的内部情形
    火车失事：连串的调用通常被认为是肮脏的风格
    混杂
    隐藏结构
数据传送对象
    最为精炼的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，
    或 DTO(Data Transfer Objects)。DTO 是非常有用的结构，尤其是在与数据库通信、或解析套接字
    传递的消息之类的场景中
}
good(错误处理){
错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。

使用异常而非返回码
先写 Try-Catch-Finally 语句
使用不可控异常（可控异常的代价就是违反开放/闭合原则）
给出异常发生的环境说明（创建信息充分的错误消息，并和异常一起传递出去）
依调用者需要定义异常类
定义常规流程
别返回 null 值
    返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控
别传递 null 值

    整洁代码是可读的，但也要强固。可读与强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于
主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性。

}

good(单元测试){
TDD 三定律
    在编写不能通过的单元测试前，不可编写生产代码
    只可编写刚好无法通过的单元测试，不能编译也算不通过
    只可编写刚好足以通过当前失败测试的生产代码
保持测试整洁
    测试代码和生产代码一样重要
整洁的测试
    三要素：可读性、可读性和可读性。
    明确、简洁，还有足够的表达力
每个测试一个断言
    FIRST 原则
    快速 Fast
    独立 Independent
    可重复 Repeatable
    自足验证 Self-Validating
    及时 Timely
}
good(并发编程){
对象是过程的抽象，线程是调度的抽象
---------------------------------------
    编写整洁的并发程序很难——非常难。并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。
在单线程应用中，目的与时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序的状态。

    解耦目的与时机能明显地改进应用程序的吞吐量和结构。从结构的角度看，应用程序看起来更像是许多台协同工作
的计算机，而不是一个大循环。系统因此会更易于被理解，给出了许多切分关注面的有力手段。

并发防御原则
    单一权责原则：建议分离并发相关代码与其他代码
    限制数据作用域：谨记数据封装；严格限制对可能被共享的数据的访问
    使用数据副本
    线程应尽可能地独立

其他需要注意的
    警惕同步方法之间的依赖
    保持同步区域微小
    
测试线程代码的方法：
    将伪失败看作可能的线程问题
    先使非线程代码科工作
    编写可插拔的线程代码
    编写可调整的线程代码
    运行多于处理器数量的线程
    在不同平台上运行
    调整代码并强迫错误发生
}