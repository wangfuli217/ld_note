V:\rtu\otdr\crosstool\cheatsheet\ops_doc-master\Service\10Cproject\TCPIP高效编程.sh # 对TCP有进一步详细说明
V:\rtu\otdr\crosstool\cheatsheet\ops_doc-master\Service\IO处理参考说明.sh           # 对socket编程有些反思
V:\rtu\otdr\crosstool\cheatsheet\firewall\firewall.sh                               # 从防火墙角度理解TCP ICMP和UDP

1. 协议
    底层协议和硬件差异会对上层协议的设计具有多方面的影响，这些影响直接反映在已设计协议的理解难易上，
间接反映在软件编码的复杂度上，最终反映在软件的可维护性上。

    底层协议的差异包括: 是否提供数据校验，单双工，受限数据报文长度，底层报文提供的关键字，超时处理，异常
    
    @是否提供数据校验
    TCP提供数据校验，接收端底层可以通知发送端重发校验错误的数据报文。所以上层不需要校验，更不需要标识头，标识尾.
    CAN提供数据校验，控制器底层在链路正常情况下可以重发发送失败的报文(发送端可以判断接收端是否正常接收)，
所以不需要校验，更不需要标识头，标识尾.
    UDP提供有限的数据校验，估计可以配置内核，确定严格的进行UDP校验，从协议上，UDP校验不是必须的。
    串口协议不提供数据校验。多数都会在协议内设计1～2位校验值。
    这使得基于TCP和CAN协议的协议设计不需要设计校验码，而UDP和串口协议最好提供校验码，保证数据正确性。
串口协议是单向流的(不能同时收发)，所以要考虑标识头，标识尾和校验码，如果环境很差就要考虑纠错码。

    @单双工
    TCP双工通信，一个socket既可以发送数据，也可以接收数据。使得对一个数据报文的处理不影响后续报文处理。
网络连接的超时处理不以报文处理超时为限，而是以接收报文间隔为限 -- 即多久未接收到报文就主动断链。
    UDP双工通信，一个socket可以同时收发，对服务器端而言，一个socket可以对应到多个客户端。正常情况下，
客户端通过接收超时判断是否重发，client和server不能觉察到数据报文出错，甚至报文丢失。
    CAN和串口单工通信，CAN通过can.id可以得到数据包的来源，也可以过滤接收数据报文的范围; 串口关于数据报文的
来源只能在数据包中标识。这两种通信方式同时只能有一个占用链路，CAN在发送出错底层控制器会重试，而串口则直接丢弃。

    @受限数据报文长度
    TCP协议没有数据报文长度限制，CAN协议报文长度为8，UDP协议报文长度为底层链路受限，以太网长度1490大小
串口协议虽然没有长度限制，由于收发双发共享底层物理链路，所以收发报文最好不要太长。

    长度没限制使得TCP协议的协议设计面向流处理策略，且数据接收和数据发送是两条独立的流，两条独立的流使得发送和接收可能异步，
异步: 发送请求和接收请求的顺序不一样，即请求A, 请求B, 请求C响应可能是响应C，响应A，响应B。
基于流的，于是存在粘包问题，发送队列满而发送失败，接收队列空而接收失败，对端关闭连接而结束等连接维护相关问题。

    报文长度为8使得CAN协议的协议设计，要处理分包问题: 协议上的一个报文包括多个CAN协议报文，将多个CAN报文合并成一个
报文增加了处理复杂度；又由于CAN协议是多对多的，使得需要合并的后续报文，不一定是余下数据而是一个新报文。因此
CAN协议上的id就很重要。

    受底层链路限制使得UDP协议的协议设计，限制报文的长度，又由于UDP存在丢包和乱序问题，所以需要考虑重发和同步问题。
UDP服务器端也是多对多的处理模式，使得数据处理依赖底层报文提供的关键字，最好在设计报文中增加随机数关键字。

    共享链路使得串口协议的协议设计，限制报文的长度，由于噪声干扰，需要考虑重发问题。串口协议可以是多对多的，
在一些中要考虑板卡类型，对于RS232而言，是1对1的，对于RS485而言是1对n的，对双路485而言是n对n的。

    @底层报文提供的关键字
    TCP协议的关键字是协议五元组(源IP 源端口 协议 目的IP 目的端口)，getpeername()和getsockname() 可以获得五元组
中的源IP 源端口 目的IP 目的端口，这四个值可以唯一标识一个收发链接，在服务器可以通过fd即可确定数据报文关联的客户端
    UDP协议的关键字也是协议五元组(源IP 源端口 协议 目的IP 目的端口)，通过sendto 和 recvfrom 可以确定数据发往那个
客户端，通过recvfrom 可以确定数据从那个客户端来。即使这样，像DNS协议那样，会在协议内部携带一个随机值，标识报文的
唯一性。 ---- 客户端bind情况下发送多个报文时，协议五元组不再能唯一标识一个数据包。
    udp在发送前绑定端口之后，发送报文的源端口固定下来。

    CAN协议的关键字是can.id，该值确定自身能接收的报文范围，该值也能标识插入板自身。在处理多个CAN数据报文合并成
协议报文时尤为重要。

    @超时处理
    TCP的超时处理是接收端多久未接收到报文，该报文可以是心跳也可以是其他报文，超时之后TCP会关闭套接字。
    UDP的超时处理是接收端多久未接收到报文，该报文是请求需要的应答报文，超时之后UDP只能重试已发送请求报文。
    CAN的超时处理是受链路和接收端处理能力限制的。即要保证链路不拥塞，但有要保证业务正常运行。有些报文在指定超时内即可响应。
有些报文需要很久一段时间才响应。设计时要考虑发送数据报文的响应超时问题，也要考虑发送数据报文之间的时间间隔。
    串口的超时处理与CAN遇到的问题基本一样。
    
    @异常
    接收数据报文格式异常，内容不正确
    接收到错误数据报文，指定请求报文个数，内容不正确
    接收数据报文超时，
    发送数据报文出错，can协议中存在。
    接收到数据报文中内容或状态不合要求。
    
    # 协议设计的难度在错误处理
    
    @ 交互方式 
    一次请求一次响应 : 最简单的方式
    一次请求多次响应 : 较复杂的方式
    多次请求一次响应 : 很少见这种方式
    无请求有响应     : 多见数据上报方式(下层设备出现故障时或者监测到故障后上报)

1.1 TCP协议
    TCP协议是有连接的，且连接断连超时时间较长，1) 连接的建立需要较长时间connect，连接的关闭也需要一定时间close，
当读取连接的时候，返回值为0的时候，说明对端调用了close函数结束了此TCP连接。2) 客户端为确认服务器存在，服务器为
确认客户端存在，则要求客户端向服务器发送心跳；要求服务器向客户端发送心跳。
    TCP连接是有收发缓冲区的，使得接收和发送系统调用 send|recv 函数存在发送缓冲区满和接收缓冲区空的问题。即
send|recv时收到 EAGAIN EWOULDBLOCK错误的状况。

    对于大并发TCP连接而言，服务器端要考虑TCP建立半连接和TCP关闭半连接问题。
    
    TLV格式:  见moosefs协议，其client和server的连接存在随机数id，而client和dataserver dataserver和master之间不存在随机数。
在master端使用masterconn实例地址是为连接关联对象，保证数据在master多个模块之间的传递的唯一标识(关键字)。
    OTDR格式: 字符串格式，字段和字段之间使用空格分隔，命名和命名之间使用\r\n分隔。为了获得数据，也掺杂了TLV近似协议
如data和getfile命令，返回值是 length+data...
    memcached格式: 字符串格式。字段和字段之间使用空格
    set key flags exptime bytes [noreply] 
value 
参数说明如下：
    key：键值 key-value 结构中的 key，用于查找缓存值。
    flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。
    exptime：在缓存中保存键值对的时间长度(以秒为单位，0 表示永远)
    bytes：在缓存中存储的字节数
    noreply (可选)： 该参数告知服务器不需要返回数据
    value：存储的值(始终位于第二行) (可直接理解为key-value结构中的value)


1.2 CAN协议
    CAN协议是无连接的，有优先级，长度8位受限的协议。
    
    
1.3 串口协议

1.4 UDP协议


CAN协议，串口协议和UDP协议都需要考虑的是物理链路的容量问题。即在链路上传输数据接近满载的时候，数据包丢失、冲突使得
物理链路承载数据容量降低，程序出现异常处理的情况增加，甚至出现程序崩溃的异常情况。
-------------------------------------------------------------------------------------------------------------------------
2. 任务
    就rtud程序而言，就是网管一个对rtud的测试请求，需要rtud多个请求才能完成网管请求的事情。更复杂一些的情况是
网管的一个请求占用了测试资源之后，对后续的请求如何处理? 等等此类问题。

2.1 直接管理转发板
    网管获取MCU板内存信息，蜂鸣器，日期等信息，网管获取RTU或LMS设备中其他板卡序列号，版本，年月日和灯状态。
2.1.1 直接管理转发板自身
    谨记: 如果MCU板创建文件，打开文件或者写入，读取文件错误，也要将这些错误码上报给网管

2.1.2 直接管理转发板收集到其他板卡信息
    谨记: 将收集到的信息分成维护表和扫描表两个链表，
    谨记: 封装对维护表和扫描表的数据对象，减少直接对全局变量的访问。

2.2 间接转发
    任务抽象，子任务抽象，通过配置表方式构建任务(像shunit和bats测试一样，即可单项测试有可以多项组合测试) -- 比较理想。
更难的，OSW和OTDR两种协议之间组合测试，最好提升一个文件otdr_task来管理任务。

2.2.1 请求OPM|OSL|ILM|TPWU状态和检测值
    网管获取OPM板配置，当前值；网管获取OLS接口状态值，网管获取ILM测试板配置信息。
    在moosefs和dns都是缓存请求实现的，即为每一个请求建立一份请求缓存，当OPM，OLS和ILM响应rtud请求之后，创建响应报文释放缓存信息。
维护缓存: 网络连接断链，请求数据报文超时，底层响应报文回调(底层处理超时，底层处理失败，底层处理成功)。粘合层需要考虑多种情况。


2.2.2 请求ILM测试
    在ilm-test命令执行前要执行 ilm-info-get ilm-status-get 命令，
    
    

2.2.3 请求OSW和OTDR测试
    otdr测试任务有三种类型: 周期测试，告警测试和点名测试；其中告警测试优先级最高，点名测试优先级次之，周期测试优先级最低。
高优先级任务可以中断正在执行的低优先级任务，同优先级任务不能中断正在执行的同等级优先级任务。由于任务调度复杂，所以将otdr测试
独立出来一个任务管理模块，由ldproxy.c通过接口调用启动测试任务，otdr_task.c模块进行任务调度。
    由于otdr_main管理模块就一个功能，所以，otdr_task.c只需调用一个接口就可以实现otdr测试。rtu_tty.c 模块实现osw开关的跳转，
由于这个模块还有很多其他任务，但是，就otdr_task.c 而言就执行一个接口即可。





