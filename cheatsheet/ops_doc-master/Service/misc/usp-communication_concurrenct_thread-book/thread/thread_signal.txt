linux 多线程信号总结(一)

1. 在多线程环境下，产生的信号是传递给整个进程的，一般而言，所有线程都有机会收到这个信号，
进程在收到信号的的线程上下文执行信号处理函数，具体是哪个线程执行的难以获知。也就是说，
信号会随机发个该进程的一个线程。

2 signal函数BSD/Linux的实现并不在信号处理函数调用时，恢复信号的处理为默认，而是在信号处理时阻塞此信号，
直到信号处理函数返回。其他实现可能在调用信号处理函数时，恢复信号的处理为默认方式，因而需要在信号处理
函数中重建信号处理函数为我们定义的处理函数，在这些系统中，较好的方法是使用sigaction来建立信号处理函数。


3 发送信号给进程，哪个线程会收到？APUE说，在多线程的程序中，如果不做特殊的信号阻塞处理，
当发送信号给进程时，由系统选择一个线程来处理这个信号。

4 如果进程中，有的线程可以屏蔽了某个信号，而某些线程可以处理这个信号，则当我们发送这个信号
给进程，进程中不能处理这个信号的线程时，系统会将这个信号投递到进程号最小的那个可以处理这个信号的线程中去处理。

5 如果我们同时注册了信号处理函数，同时又用sigwait来等待这个信号，谁会取到信号？
经过实验，Linux上sigwait的优先级高。

6 在Linux中的posix线程模型中，线程拥有独立的进程号，可以通过getpid()得到线程的进程号，
而线程号保存在pthread_t的值中。而主线程的进程号就是整个进程的进程号，因此向主进程发送信号
只会将信号发送到主线程中去。如果主线程设置了信号屏蔽，则信号会投递到一个可以处理的线程中去。

7 当调用SYSTEM函数去执行SHELL命令时，可以放心的阻塞SIGCHLD，因为SYSTEM会自己处理子进程终止的问题。

8 使用sleep()时，要以放心的去阻塞SIGALRM信号，目前sleep函数都不会依赖于ALRM函数的SIGALRM信号来工作。

 
linux 多线程信号总结(二)

1. 默认情况下，信号将由主进程接收处理，就算信号处理函数是由子线程注册的

2. 每个线程均有自己的信号屏蔽字，可以使用sigprocmask函数来屏蔽某个线程对该信号的响应处理，
仅留下需要处理该信号的线程来处理指定的信号。

3. 对某个信号处理函数，以程序执行时最后一次注册的处理函数为准，即在所有的线程里，
同一个信号在任何线程里对该信号的处理一定相同

4. 可以使用pthread_kill对指定的线程发送信号

APUE的说法:每个线程都有自己的信号屏蔽字,但是信号的处理是进程中所有的线程共享的,
这意味着尽管单个线程可以阻止某些信号,但当线程修改了与某个信号相关的处理行为后,所
有的线程都共享这个处理行为的改变。这样如果一个线程选择忽略某个信号，而其他线程可
以恢复信号的默认处理行为，或者为信号设置一个新的处理程序，从而可以撤销上述线程的
信号选择。

进程中的信号是送到单个线程的，如果信号与硬件故障或者计时器超时有关，该型号就被发
送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程。

sigprocmask的行为在多线程的进程中没有定义，线程必须使用pthread_sigmask
总结：一个信号可以被没屏蔽它的任何一个线程处理，但是在一个进程内只有一个多个线程共用的处理函数。......

 
linux 多线程信号总结(三)

1 Linux 多线程应用中，每个线程可以通过调用pthread_sigmask() 设置本线程的信号掩码。
一般情况下，被阻塞的信号将不能中断此线程的执行，除非此信号的产生是因为程序运行出错如SIGSEGV；
另外不能被忽略处理的信号SIGKILL 和SIGSTOP 也无法被阻塞。

2 当一个线程调用pthread_create() 创建新的线程时，此线程的信号掩码会被新创建的线程继承。

3 信号安装最好采用sigaction方式，sigaction，是为替代signal 来设计的较稳定的信号处理，signal的使用比较简单。signal(signalNO,signalproc);

不能完成的任务是：
　　1.不知道信号产生的原因；
　　2.处理信号中不能阻塞其他的信号
　　而signaction，则可以设置比较多的消息。尤其是在信号处理函数过程中接受信号，进行何种处理。
　　sigaction函数用于改变进程接收到特定信号后的行为。

4 sigprocmask函数只能用于单线程，在多线程中使用pthread_sigmask函数。
5 信号是发给进程的特殊消息，其典型特性是具有异步性。
6 信号集代表多个信号的集合，其类型是sigset_t。
7 每个进程都有一个信号掩码（或称为信号屏蔽字），其中定义了当前进程要求阻塞的信号集。
8 所谓阻塞，指Linux内核不向进程交付在掩码中的所有信号。于是进程可以通过修改信号掩码来暂时阻塞特定信号的交付，被阻塞的信号不会影响进程的行为直到该信号被真正交付。
9 忽略信号不同于阻塞信号，忽略信号是指Linux内核已经向应用程序交付了产生的信号，只是应用程序直接丢弃了该信号而已。