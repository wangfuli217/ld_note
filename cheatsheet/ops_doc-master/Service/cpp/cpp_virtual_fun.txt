# C++ 虚函数
## C++ 虚函数表解析
virtial_fun(){
1.C++中的虚函数的作用主要是实现了多态的机制,多态是用父类型的指针指向其子类的实例,然后通过父类的指针调用
  实际子类的成员函数(运行时多态),这种技术可以让父类的指针有"多种形态"，这是一种泛型技术,
    泛型技术是试图使用不变的代码来实现可变的算法,比如：模板技术，RTTI技术，虚函数技术，
  要么是在编译时决议，要么在运行时决议。
  
2.虚函数表
    (1) 虚函数(Virtual Function)是通过一张虚函数表(Virtual Table)来实现的,简称为V-Table.
        类的每个虚成员占据虚函数表中的一行,如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小,
        在这个表中,主要是一个类的虚函数的地址表,这张表解决了继承、覆盖的问题,保证其内容对应实际的函数
        在有虚函数的类的实例中这张表被分配在这个实例的内存中(每一个实例都有一张虚函数表(只继承了一个基类),
        如果是多重继承,则有多张虚函数表)
        当我们用父类的指针来操作一个子类的时候,这张虚函数表指明了实际所应该调用的函数
        
    (2) C++的编译器 保证虚函数表的指针 至于对象实例中最前面的位置(起始地址)(这是为了保证取到虚函数表时有最高的性能——
        如果有多层继承或是多重继承的情况下）我们可以通过对象实例的地址得到这张虚函数表,然后就可以遍历其中函数指针,
        并调用相应的函数
        
3.一般继承
    (1) 子类没有函数覆盖基类的虚函数
            一般在真实项目中子类都会覆盖基类的虚函数(每一个子类都有对应的业务逻辑)
            例如:
                基类base的虚函数为 virtual f(), virtual g(), virtual h()
                子类driver的虚函数为 virtual k(), virtual i() (它没有覆盖基类的虚函数)
                则在派生类driver中实例,其虚函数表的顺序为 
                    virtual f(), virtual g(), virtual h(), virtual k(), virtual i() 
                注意:
                     A.虚函数按照其声明顺序放于表中
                     B.父类的虚函数在子类的虚函数前面
                     
    (2) 子类有函数覆盖基类的虚函数
            基类base的虚函数为 virtual f(), virtual g(), virtual h()
            子类driver的虚函数为 virtual f() (这里子类覆盖了基类的f()虚函数), virtual i() 
            则在派生类driver中实例,其虚函数表的顺序为 
             virtual f()(这里f函数是子类实现的业务逻辑), virtual g(), virtual h(), virtual i() 
            注意:
                (1) 子类的f()函数被放到虚表中原来父类虚函数的位置
            代码:
                Base *b = new Derive();
                b->f();
                由b所指的内存中的虚函数表的f()的位置已经 被Derive::f()函数地址所取代,在实际调用发生时,
                是Derive::f()被调用了。这就实现了多态
                
4.多重继承
    (1) 子类继承了多个不同的基类,并且其子类没有函数覆盖基类的虚函数
            例如:
                基类1 base1 的虚函数 virtual f(), virtual g(), virtual h()
                基类2 base2 的虚函数  virtual f(), virtual g(), virtual h()
                其中基类1和基类2定义的虚函数的函数名都一样
                
                子类继承base1和base2,子类自己本身有自己的虚函数
                子类 driver 的虚函数 virtual k(), virtual i() (它没有覆盖基类的虚函数)
                
                注意:
                    (1) 子类中每个基类都有自己的虚函数表(这时在派生类driver中实例有2张虚拟表)
                    (2) 子类实例调用第一个基类的虚函数(第一个父类是按照声明顺序来判断的)
                    
    (2) 子类继承了多个不同的基类,并且其子类有函数覆盖基类的虚函数
                基类1 base1 的虚函数 virtual f(), virtual g(), virtual h()
                基类2 base2 的虚函数  virtual f(), virtual g(), virtual h()
                其中基类1和基类2定义的虚函数的函数名都一样
                
                子类 driver 的虚函数 virtual f()(这里f函数是子类实现的业务逻辑), virtual i() 
                
                那么两个基类虚函数表中的f()都被被替换成了子类的f()函数
                 
5.安全问题
       (1) 通过基类类型的指针访问子类自己定义的虚函数
                Base1 *b1 = new Derive();
                b1->f1();  //编译出错,因为 f1()函数是子类自己定义的虚函数,不能通过父类指针调用
                何妄图通过基类指针调用子类中未覆盖基类的成员函数的行为都会被编译器视为非法，所以，
                这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为
                
       (2) 访问non-public的虚函数
                如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，
                我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数
}

virtual_fun(基类的析构函数为什么要用virtual虚析构函数-跟多态有关系){
    1.只有当一个类被用来作为基类的时候，才把析构函数写成虚函数,主要是针对用基类指针指向派生类对象,delete 基类指针　
    　动态调用派生类的析构函数,再调用基类的析构函数．
    　
    2.C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，
       如果派生类中申请了内存空间,并在其析构函数中对这些内存空间进行释放.
       假设基类中采用的是非虚析构函数,当删除基类指针指向的派生类对象时就不会触发动态绑定,
       因而只会调用基类的析构函数,而不会调用派生类的析构函数。
       那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，
       为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数
       
    3.虚函数是动态绑定的基础
    4.实例代码
        
        class Base {
             public:
                    ~Base() {
                      cout << "~Base()" << endl;
                    }
        };
        
        
        class Derived : public Base {
             public:
              Derived():name_(new string("NULL")) {}
              Derived(const string& n):name_(new string(n)) {}
             
              ~Derived() {
                delete name_;
                cout << "~Derived(): name_ has been deleted." << endl;
              }
             
             private:
              string* name_;
         
         }
         
         Derived　*d = new Derived();
         delete d;  //这种情况下不需要考虑基类析构函数是否为虚函数, 是派生类对象指针,析构时调用相应派生类的析构函数
         
         Base　*b = new Derived();
         delete b;   // 这时需要基类析构函数定义为虚函数,动态调用派送类的析构函数
}