1. 一个容器就是一些特定类型对象的集合。
2. 顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。
   这种顺序不依赖于元素的值，而是与**元素加入容器时的位置**相对应。
3. 与之相对的，有序和无序关联容器，则根据关键字的值来存储元素。
4. 所有顺序容器都提供了快速顺序访问元素的能力，但是，这些容器在以下方面都有不同的性能折中：
    向容器添加或从容器中删除元素的代价。
    非顺序访问容器中元素的代价。
    
5. 标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。

seq(顺序容器类型){
  vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
  deque：双端队列。支持快速随机访问。在头尾位置插入／删除元素速度很快。
  list：双向链表。只支持双向顺序访问。在list中任何位置进行插入／删除操作速度都很快。
  forward_list：单向链表。只支持单向顺序访问。在链表任何位置进行插入／删除操作速度都很快。
  array：固定大小数组。支持快速随机访问。不能添加或删除元素。（相比内置数组更安全、更容易使用）
  string：与vector相似的容器，专门用于保存字符。
  
  forward_list和array是C++11新增类型。与内置数组相比，array更安全易用。forward_list没有size操作。
}

seq(容器选择原则){
1. 除非有合适的理由选择其他容器，否则应该使用vector。
2. 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。
3. 如果程序要求随机访问容器元素，则应该使用vector或deque。
4. 如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用deque。
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则：
    先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向vector追加数据，再调用标准库的sort函数重排元素，从而避免在中间位置添加元素。
    如果必须在中间位置插入元素，可以在输入阶段使用list。输入完成后将list中的内容拷贝到vector中。
6. 不确定应该使用哪种容器时，可以先只使用vector和list的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择vector或list都很方便。
}