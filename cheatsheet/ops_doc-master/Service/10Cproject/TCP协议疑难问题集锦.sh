不看tcp/ip的实现,永远都不会真正了解tcp/ip,许多人都想通过一些定性描述的文章来掌握tcp/ip,但是你总能发现有些问题怎么也搞不清楚.

https://blog.csdn.net/dog250/article/details/6612496

TCP(网络协议设计){
    TCP/IP的漂亮之处在于：协议越往上层越复杂。我们把网络定义为互相连接在一起的设备，网络的本质作用还是“端到端”的通信，
然而希望互相通信的设备并不一定要“直接”连接在一起，因此必然需要一些中间的设备负责转发数据，因此就把连接这些中间设备的
线缆上跑的协议定义为链路层协议，实际上所谓链路其实就是始发于一个设备，通过一根线，终止于另一个设备。我们把一条链路称
为“一跳”。因此一个端到端的网络包含了“很多跳”。
}
TCP(TCP和IP协议){ 
    IP层提供的核心基本功能有两点，第一点是地址管理，第二点就是路由选路。
    终止于IP协议，我们已经可以完成一个端到端的通信，为何还需要TCP协议？
    1. TCP的作用是传输控制，也就是控制端到端的传输，那为何这种控制不在IP协议中实现的。答案很简单，那就是这会增加IP
协议的复杂性，而IP协议需要的就是简单。
    2. IP协议设计为分组转发协议，每一跳都要经过一个中间节点，路由的设计是TCP/IP网络的另一大创举，这样，IP协议就无需
方向性，路由信息和协议本身不再强关联，它们仅仅通过IP地址来关联。
    3. 由于IP协议不提供保证，TCP也不能提供依赖于IP下层链路的这种保证，比如带宽，比如时延，这些都是链路层决定的，既然IP
协议无法修补，TCP也不能，然而它却能修正始于IP层的一些“不可保证性质”，这些性质包括IP层的不可靠，IP层的不按顺序，IP层
的无方向/无连接。
}
TCP(TCP协议){ 
    分层网络协议模型的基本定义(两类接口，一类和下层接口，另一类和对等层接口)。
    TCP协议有两重身份，
    作为网络协议，它弥补了IP协议尽力而为服务的不足，实现了有连接，可靠传输，报文按序到达。
    作为一个主机软件，它和UDP以及左右的传输层协议隔离了主机服务和网络，它们可以被看做是一个多路复用/解复用器，将诸多
的主机进程数据复用/解复用到IP层。

    TCP要点有四，1.有连接，2.可靠传输，3.数据按照到达，4.端到端流量控制。
}
TCP(有连接，可靠传输，数据按序到达的TCP){
    [有连接]
    IP尽力让单独的数据报到达对端，那么TCP就可以在这种尽力而为的网络上实现其它的更加严格的控制功能。TCP给无连接的IP
网络通信增加了连接性，确认了已经发送出去的数据的状态，并且保证了数据的顺序。
    [可靠性]
    基本上传输可靠性是靠确认号实现的，也就是说，每发送一个分段，接下来接收端必然要发送一个确认，发送端收到确认后才
可以发送下一个字节。怎么知道数据到达对端呢？那就是对端发送一个确认，但是如果一直收不到对端的确认，发送端等多久呢？
如果一直等下去，那么将无法发现数据的丢失，协议将不可用，如果等待时间过短，可能确认还在路上，因此等待时间是个问题，
另外如何去管理这个超时时间也是一个问题。

}
TCP(有连接:3次握手和4次挥手){
    TCP被设计成一种基于流的协议，既然TCP需要事先建立连接，之后传输多少数据就无所谓了，只要是同一连接的数据能识别出来即可。
    TCP使用3次握手建立一条连接，该握手初始化了传输可靠性以及数据顺序性必要的信息，这些信息包括两个方向的初始序列号，
确认号由初始序列号生成，使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息，该握手的第3次实际上
并不是需要单独传输的，完全可以和数据一起传输。
    3次握手的目的很简单，就是分配资源，初始化序列号，这时还不涉及数据传输，3次就足够做到这个了，而4次挥手的目的是终止
数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，
不像初始化时那么简单发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。
}
TCP(有连接:TIME_WAIT状态){
    为何要有这个状态，原因很简单，那就是每次建立连接的时候序列号都是随机产生的，并且这个序列号是32位的，会回绕。
    现在我们考虑终止连接时的被动方发送了一个FIN，然后主动方回复了一个ACK，然而这个ACK可能会丢失，这会造成被动方
重发FIN，这个FIN可能会在互联网上存活MSL。
    如果没有TIME_WAIT的话，假设连接1已经断开，然而其被动方最后重发的那个FIN(或者FIN之前发送的任何TCP分段)还在网络上，
然而连接2重用了连接1的所有的5元素(源IP，目的IP，TCP，源端口，目的端口)，刚刚将建立好连接，连接1迟到的FIN到达了，
这个FIN将以比较低但是确实可能的概率终止掉连接2.
    因此终止连接的主动方必须在接受了被动方且回复了ACK之后等待2*MSL时间才能进入CLOSE状态，之所以乘以2是因为这是保守的算法，
最坏情况下针对被动方的ACK在以最长路线(经历一个MSL)经过互联网马上到达被动方时丢失。

    要知道，很多人很不喜欢看到服务器上出现大量的TIME_WAIT状态的连接，因此他们将TIME_WAIT的值设置的很低，这虽然在大多数
情况下可行，然而确实也是一种冒险行为。最好的方式就是，不要重用一个连接。
}
TCP(有连接:重用一个连接和重用一个套接字){
    这是根本不同的，单独重用一个套接字一般不会有任何问题，因为TCP是基于连接的。比如在服务器端出现了一个TIME_WAIT连接，
那么该连接标识了一个五元素，只要客户端不使用相同的源端口，连接服务器是没有问题的，因为迟到的FIN永远不会到达这个连接。
记住，一个五元素标识了一个连接，而不是一个套接字(当然，对于BSD套接字而言，服务端的accept套接字确实标识了一个连接)。
}
TCP(可靠性:超时时间的计算){
    一个TCP分段的回复到达的时间就是一个数据报往返的时间，因此标准定义了一个新的名词RTT，代表一个TCP分段的往返时间。
然而我们知道，IP网络是尽力而为的，并且路由是动态的，且路由器会毫无先兆的缓存或者丢弃任何的数据报，因此这个RTT是需要
动态测量的，也就是说起码每隔一段时间就要测量一次，如果每次都一样，万事大吉，然而世界并非如你所愿，因此我们需要找到的
恰恰的一个“平均值”，而不是一个准确值。
    除了考虑每两次测量值的偏差之外，其变化率也应该考虑在内，如果变化率过大，则通过以变化率为自变量的函数为主计算RTT
(如果陡然增大，则取值为比较大的正数，如果陡然减小，则取值为比较小的负数，然后和平均值加权求和)，反之如果变化率很小，
则取测量平均值。
}
TCP(可靠性:超时计时器的管理-每连接单一计时器){
设计单一计时器有两个原则：
1.每一个报文在长期收不到确认都必须可以超时；
2.这个长期收不到中长期不能和测量的RTT相隔太远。因此RFC2988定义一套很简单的原则：
  a.发送TCP分段时，如果还没有重传定时器开启，那么开启它。
  b.发送TCP分段时，如果已经有重传定时器开启，不再开启它。
  c.收到一个非冗余ACK时，如果有数据在传输中，重新开启重传定时器。 # 为了不会出现过早重传，才添加了规则c
  d.收到一个非冗余ACK时，如果没有数据在传输中，则关闭重传定时器。
}
TCP(可靠性:何时测量RTT){
    目前很多TCP实现了时间戳，这样就方便多了，发送端再也不需要保存发送分段的时间了，只需要将其放入协议头的时间戳字段，
然后接收端将其回显在ACK即可，然后发送端收到ACK后，取出时间戳，和当前时间做算术差，即可完成一次RTT的测量。
}
TCP(数据顺序性:确认号和超时重传){
    确认号是一个很诡异的东西，因为TCP的发送端对于发送出去的一个数据序列，它只要收到一个确认号就认为确认号前面的数据
都被收到了，即使前面的某个确认号丢失了，也就是说，发送端只认最后一个确认号。这是合理的，因为确认号是接收端发出的，
接收端只确认按序到达的最后一个TCP分段。
    另外，发送端重发了一个TCP报文并且接收到该TCP分段的确认号，并不能说明这个重发的报文被接收了，也可能是数据早就被
接收了，只是由于其ACK丢失或者其ACK延迟到达导致了超时。值得说明的是，接收端会丢弃任何重复的数据，即使丢弃了重复的数据，
其ACK还是会照发不误的。
}
TCP(可靠性:乱序数据缓存以及选择确认){
    TCP是保证数据顺序的，但是并不意味着它总是会丢弃乱序的TCP分段，具体会不会丢弃是和具体实现相关的，RFC建议如果
内存允许，还是要缓存这些乱序到来的分段，然后实现一种机制等到可以拼接成一个按序序列的时候将缓存的分段拼接，这就
类似于IP协议中的分片一样，但是由于IP数据报是不确认的，因此IP协议的实现必须缓存收到的任何分片而不能将其丢弃，因为
丢弃了一个IP分片，它就再也不会到来了。
    现在，TCP实现了一种称为选择确认的方式，接收端会显式告诉发送端需要重传哪些分段而不需要重传哪些分段。这无疑
避免了重传风暴。
}
TCP(可靠性:TCP序列号的回绕的问题){
    TCP的序列号回绕会引起很多的问题，比如序列号为s的分段发出之后，m秒后，序列号比s小的序列号为j的分段发出，
只不过此时的j比上一个s多了一圈，这就是回绕问题，
}
TCP(流量控制的真实意义){
1. 端到端的流量控制使用滑动窗口来实现。滑动窗口的原理非常简单，基本就是一个生产者/消费者模型
    很多人以为流量控制会很有效的协调两端的流量匹配，确实是这样，但是如果你考虑到网络的利用率问题，TCP的流量控制机制
就不那么完美了，造成这种局面的原因在于，滑动窗口只是限制了最大发送的数据，却没有限制最小发送的数据，结果导致一些很小
的数据被封装成TCP分段，报文协议头所占的比例过于大，造成网络利用率下降，这就引出了接下来的内容，那就是端到端意义的TCP
协议效率。


}
TCP(TCP协议效率:接收端处理慢，导致接收窗口被填满){ -> 窗口通告
    考虑此时接收窗口已然被填满，慢速的应用程序慢腾腾的读取了一个字节，空出一个位置，然后通告给TCP的发送端，发送端得知
空出一个位置，马上发出一个字节，又将接收端填满，然后接收应用程序又一次慢腾腾...这就是糊涂窗口综合症，一个大多数人都很
熟悉的词。
  对于糊涂窗口综合症问题，很显然问题出在接收端，我们没有办法限制发送端不发送小分段，但是却可以限制接收端通告小窗口，
这是合理的，这并不影响应用程序，此时经典的延迟/吞吐量反比律将不再适用，因为接收窗口是满的，其空出一半空间表示还有一半
空间有数据没有被应用读取，和其空出一个字节的空间的效果是一样的，因此可以限制接收端当窗口为0时，直接通告给发送端以阻止
其继续发送数据，只有当其接收窗口再次达到MSS的一半大小的时候才通告一个不为0的窗口，此前对于所有的发送端的窗口probe分段
(用于探测接收端窗口大小的probe分段，由TCP标准规定)，全部通告窗口为0，这样发送端在收到窗口不为0的通告，那么肯定是一个
比较大的窗口，因此发送端可以一次性发出一个很大的TCP分段，包含大量数据.
     即，限制窗口通告时机，解决糊涂窗口综合症

}
TCP(TCP协议效率:发送端持续发送小包，导致窗口闲置){ -> Nagle算法
  这明显是发送端引起的问题，此时接收端的窗口开得很大，然而发送端却不积累数据，还是一味的发送小块数据分段。只要发送了
任何的分段，接收端都要无条件接收并且确认，这完全符合TCP规范，因此必然要限制发送端不发送这样的小分段。

Nagel算法很简单，标准的Nagle算法为：
IF 数据的大小和窗口的大小都超过了MSS
    Then 发送数据分段
ELSE
    IF 还有发出的TCP分段的确认没有到来
        Then 积累数据到发送队列的末尾的TCP分段
    ELSE
        发送数据分段
    EndIF
EndIF
可是后来，这个算法变了，变得更加灵活了，其中的：
    IF 还有发出的TCP分段的确认没有到来
变成了
    IF 还有发出的不足MSS大小的TCP分段的确认没有到来
这样如果发出了一个MSS大小的分段还没有被确认，后面也是可以随时发送一个小分段的，这个改进降低了算法对延迟时间的影响。
}

TCP(TCP协议效率:确认号(ACK)本身就是不含数据的分段，因此大量的确认号消耗了大量的带宽){ -> 延迟的ACK
    这是TCP为了确保可靠性传输的规范，然而大多数情况下，ACK还是可以和数据一起捎带传输的。如果没有捎带传输，那么就只能
单独回来一个ACK，如果这样的分段太多，网络的利用率就会下降。
    RFC建议了一种延迟的ACK，也就是说，ACK在收到数据后并不马上回复，而是延迟一段可以接受的时间，延迟一段时间的目的是
看能不能和接收方要发给发送方的数据一起回去，因为TCP协议头中总是包含确认号的，如果能的话，就将ACK一起捎带回去，这样
网络利用率就提高了。

RFC建议，延迟的ACK最多等待两个分段的积累确认。
}

TCP(糊涂窗口解决方案和Nagle算法){

}

TCP(Nagle算法和延迟ACK){

}

TCP(到底何时可以发送数据){

}


TCP(拥塞控制的本质){

}

TCP(影响拥塞的因素){

}
TCP(拥塞控制的策略){

}
TCP(拥塞控制的策略:超时重传和收到3个冗余ACK后重传){

}
TCP(拥塞控制的策略:为何收到3个冗余ACK后才重传){

}
TCP(拥塞控制的策略:乘性减和加性增的深层含义){

}
TCP(拥塞控制的策略:TCP连接的传输稳定状态是什么){

}
TCP(主动的拥塞避免:路由器和TCP的互动){

}
TCP(如何学习TCP){

}
TCP(Linux，Windows和网络编程){

}
TCP(总结){
    TCP协议是一个端到端的协议，虽然话说它是一个带流量控制，拥塞控制的协议，然而正是因为这些所谓的控制才
导致了TCP变得复杂。同时这些特性是互相杂糅的，流量控制带来了很多问题，解决这些问题的方案最终又带来了新的
问题，这些问题在解决的时候都只考虑了端到端的意义，但实际上TCP需要尽力而为的IP提供的网络，因此拥塞成了
最终的结症，拥塞控制算法的改进也成了一个单独的领域。
}

