https://github.com/amix/vimrc
所有的程序设计语言大概有3个源流：结构化编程；面向对象编程；数据驱动编程。
数据驱动编程的本质是"参数化抽象"的思想，不同于OO的"规范化抽象"的思想。

将复杂的易变的逻辑作为数据或更高层代码抛给上层

深入一种语言去编程，而不是在一种语言之上去编程。
其间的区别是，在一种语言之上去编程，思想受限于语言特性的限制；
深入一种语言去编程，放在首位的是我们的思想，我们首先要确定我们的思想，之后，要用语言特性去实现它。不要将我们的思想局限于语言特性。
无论是c，c++，c#，我们都可以编写出优秀的代码，这其中，最重要的因素，是你的思想，你的思路，而不是你使用的语言。

<中共是这样的政党 -- 既千方百计阻止你知道真相, 又千方百计指责你不明真相 :)>
<这些(监狱的)围墙很有趣。起初你痛恨它; 然后你逐渐习惯它; 足够长时间后, 你开始依赖它 -- 这就是体制化!>

正确的方式是让简单的事情简单的完成，复杂的事情通过复杂的方式完成

a: 软件设计就像做爱, 一次犯错, 你要用余下的一生来维护。
b: 程序必须首先让人类可以理解, 然后顺便让机器能执行。
c: 用代码行数测算软件开发进度如同按重量测算飞机的制造进度
d: 在理论上, 理论和实践是没有差异的; 但在实践中, 是有的。
e: 在进度落后的项目中增加人手只会导致进度更加落后
f: 乐观主义是软件开发的职业病, 用户反馈则是其治疗方法。
g: 要在自己的代码里找出一个bug是十分困难的。而当你认为你的代码没有错误时, 那就更难了。
h: 调试代码比新编写代码更困难。
    因此, 如果你尽自己所能写出了最复杂的代码, 你将没有更大的智慧去调试它。

1. 不止于方法，更重乎理念。
2. Unix哲学是自下而上的，而不是自上而下的。
3. Unix哲学注重实效，立足于丰富的经验。
4. 保持简单和笨拙

1. 先做对,再做快；先使其可靠,再让其更快；先把代码弄干净,再让它变快

Unix哲学时这样的：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。
抽象 - 简化 - 归纳 [完美之道, 不在无可增加, 而在无可删减. —- 安东尼]
1. Unix 风格程序设计所面临的主要挑战就是如何将分离法的优点(将问题从原始的场景中简化、归纳)
同代码和设计的薄胶合、浅平透层次结构的优点相结合。

OO: 当问题域真的很复杂、确实需要大量抽象时，这可能是好事，但如果编码员到头来用复杂的办法来做简单的事情?

注：'大教堂'(集权、封闭、受控、保密)和 '集市'(分权、公开、精细的同僚复审)两种开发模式。
unix_e_cii(){  cat - <<'unix_e_cii'
[C语言接口与实现]
方法很简单，就是按如下五点原则来提问(注意，这五点原则不仅适用于技术问题，也适用于其他问题)：
1，描述你需要完成的需求以及目的(目的就是为什么要做这个需求)
2，描述你的想法或思路
3，描述具体的实现过程
4，描述遇到的问题，包括正确信息，报错信息或得到的不正确的信息
5，有条件则贴出具体实现代码
unix_e_cii
}
unix_e_Bob(){  cat - <<'unix_e_Bob'
我们招聘的不是"经历丰富"的人，而是"有职业素养"的人。
你遇到的问题可能很容易也可能很难，但我看重的并不是问题的难度，而是解决问题的方式、步骤以及反思的深度。

素养强调的并不是天赋的神秘，也不是技艺的高深，而是持续积淀的结晶。
一方面，体现了能力和素质；另一方面，又强调持续的积累和养成。

坚决抵制各种不专业的需求(一些无关紧要但成本巨大的需求)；抵制各种 不专业的行为(为了赶工期而降低程序质量的需求)

客户对功能的设想，其实经不起电脑前真刀真枪的考验，问题在于，东西画在纸上与真正做出来，是不一样的。
unix_e_Bob
}

misc(){
1)行为的最终逻辑被尽可能推后到使用端；
2)最终用户永远比操作系统设计人员更清楚他们究竟需要什么；
3)用错误的方式解决正确的问题 总比用正确的方法解决错误的问题好 # 注：正确提出问题等于正确解决问题的一半。

13)Unix世界中来自于实践的具体规定：
  1>只要可行，一切都应该做成与来源和目标无关的过滤器。
  2>数据流应尽可能文本化(这样可以使用标准工具来查看和过滤)。
  3>数据库部署和应用协议应尽可能文本化(让人可以阅读和编辑)。
  4>复杂的前端(用户界面)和后端应该泾渭分明。
  5>如果可能，用 C 编写前，先用解释性语言搭建原型。
  6>当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。
  7>宽收严发(对接收的东西要包容，对输出的东西要严格)。
  8>过滤时，不需要丢弃的信息决不丢。
  9>小就是美，在确保完成任务的基础上，程序功能尽可能少。
}
advice(隔离是方向，起名是关键，测试是主角，调试是补充，版本控制是后悔药){
1、重构是程序员的主力技能。
2、工作日志能提升脑容量。
3、先用profiler调查，才有脸谈优化。
4、注释贵精不贵多。杜绝大姨妈般的“例注”。漫山遍野的碎碎念注释，实际就是背景噪音。
5、普通程序员+google=超级程序员。
6、单元测试总是合算的。
7、不要先写框架再写实现。最好反过来，从原型中提炼框架。
8、代码结构清晰，其它问题都不算事儿。
9、好的项目作风硬派，一键测试，一键发布，一键部署；烂的项目生性猥琐，口口相传，不立文字，神神秘秘。
10、编码不要畏惧变化，要拥抱变化。
11、常充电。程序员只有一种死法：土死的。
12、编程之事，隔离是方向，起名是关键，测试是主角，调试是补充，版本控制是后悔药。
13、一行代码一个兵。形成建制才能有战斗力。单位规模不宜过大，千人班，万人排易成万人坑。
14、重构/优化/修复Bug，同时只能做一件。
15、简单模块注意封装，复杂模块注意分层。
16、人脑性能有限，整洁胜于杂乱。读不懂的代码，尝试整理下格式；不好用的接口，尝试重新封装下。
17、迭代速度决定工作强度。想多快好省，就从简化开发流程，加快迭代速度开始。
18、忘掉优化写代码。过早优化等同恶意破坏；忘掉代码做优化。优化要基于性能测试，而不是纠结于字里行间。
19、最好的工具是纸笔；其次好的是markdown。
20、Leader问任务时间，若答不上来，可能是任务拆分还不够细。
21、宁可多算一周，不可少估一天。过于“乐观”容易让boss受惊吓。
22、最有用的语言是English。其次的可能是Python。
23、百闻不如一见。画出结果，一目了然。调试耗时将大大缩短。
24、资源、代码应一道受版本管理。资源匹配错误远比代码匹配错误更难排查。
25、不要基于想象开发， 要基于原型开发。原型的价值是快速验证想法，帮大家节省时间。
26、序列化首选明文文本 。诸如二进制、混淆、加密、压缩等等有需要时再加。
27、编译器永远比你懂微观优化。只能向它不擅长的方向努力。
28、不要定过大、过远、过细的计划。即使定了也没有用。
29、至少半数时间将花在集成上。时间，时间，时间总是不够。
30、与主流意见/方法/风格/习惯相悖时，先检讨自己最可靠。
31、出现bug主动查，不管是不是你的。这能让你业务能力猛涨、个人形象飙升；如果你的bug被别人揪出来…..呵呵，那你会很被动～≧﹏≦
32、不知怎么选技术书时就挑薄的。起码不会太贵，且你能看完。
33、git是最棒的。简单，可靠，免费。
34、仅对"可预测的非理性"抛断言。
35、Log要写时间与分类。并且要能重定向输出。
36、注释是稍差的文档。更好的是清晰的命名。让代码讲自己的故事。
37、造轮子是很好的锻炼方法。前提是你见过别的轮子。
38、code review最好以小组/结对的形式。对业务有一定了解，建议会更有价值(但不绝对)。而且不会成为负担。管理员个人review则很容易成team的瓶颈。
39、提问前先做调研。问不到点上既被鄙视，又浪费自己的时间。
40、永远别小看程序媛(╯3╰)
}
readme(怎样写readme){
1. 剪短的项目描述
2. 指向项目站点的链接
3. 开发者编译环境的注意事项以及潜在的可移植性性问题
4. 描述重要文件和子目录的路标
5. 安装指南
6. 开发者列表
7. 社区以及联系方式等
预测未来的最好方法就是创造未来
}
unix(资源泄露往往比内存泄露要严重得多啊){
1. 进程死都死了，对象没销毁又有什么关系捏？其实大有关系啊！虽然操作系统会在进程死后帮它收尸
    (也就是把某些资源，比如内存进行回收)，基本不用担心内存泄露的问题。但是别忘了，除了内存资源，
    进程中可能还包含有其它业务层面的资源，而这些资源，操作系统是不会帮你自动回收的。所以我要再啰嗦一次：
    【资源泄露往往比内存泄露要严重得多啊】。
---------------------------------------
◇自然死亡
　　望文生义，自然死亡就是最自然的进程退出方法。具体表现为通过return语句结束main函数。由于这种方法最优雅(
    后面会说)，如果没有其它特殊原因，强烈建议采用这种死法。
◇自杀
　　所谓的自杀，就是进程自己调用某些 API 来自行了断。在标准 C++ 中，这几个函数(exit、abort、terminate、
   unexpected)可以用于进程自杀。如果没有额外设置，unexpected 函数默认会调用 terminate 函数，terminate 
   函数默认会调用 abort 函数。所以自杀的方式基本上也就是 exit 和 abort 两种。exit 相对 abort 来说温和一些，
   所以下文称 exit 为温和自杀；相对地，把 abort 称为激进自杀。
◇它杀
　　它杀其实也挺好理解，就是当前进程被其它进程杀死。标准 C++ 没有提供用于它杀的 API 函数，因此常用的方法
    是通过某些跨平台的库(如 ACE)提供的 API 函数或者调用某些外部命令(如 Posix 系统的 kill 命令)来实现。

    首先把类对象分为三种：局部非静态对象、局部静态对象、非局部对象(出于习惯，以下简称全局对象)。对于
尚不清楚这几种对象差异的同学，请先找本 C++ 入门书拜读一下。
　　进程不同的死法对于这几种对象是否能销毁会有很大的影响。请看如下的对照表：
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
｜　　　　　｜　局部非静态对象　｜　局部静态对象　｜　全局对象　｜
｜自然死亡　｜　能　　　　　　　｜　能　　　　　　｜　能　　　　｜
｜温和自杀　｜　不能　　　　　　｜　能　　　　　　｜　能　　　　｜
｜激进自杀　｜　不能　　　　　　｜　不能　　　　　｜　不能　　　｜
｜它杀　　　｜　不能　　　　　　｜　不能　　　　　｜　不能　　　｜
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
综上所述，最正经、最靠谱的死法就是第一种：自然死亡。

class CFoo
{
public:
    CFoo()
    {
#        cout << "CFoo" << endl;
    }

    virtual ~CFoo()
    {
#        cout << "~CFoo" << endl;
    }
};
    对于用户定义的全局对象，在 C++ 标准中并【没有】规定它们构造和析构的先后顺序；对于诸如标准输入输出流的 
cout、cerr 等全局对象，在 C++ 03 标准中(27.4.2.1.6章节)有提及如何保证它们在最后析构。但由于某些老式编译器
并未完全遵照标准实现，导致标准输入输出流的几个全局对象【有可能】被提前析构。
    另外，在 C++ 经典名著《Modern C++ Design》的第6章详细描述了关于单键/单例(Singleton)销毁的一些细节、
场景及解决方法。大伙儿可以去拜读一下。
}
unix(UNIX的设计理念){
    最终用户永远比操作系统设计人员更清楚他们究竟需要什么。它提供的是机制，而非策略。
虽然这种自由放纵主义风格会让它失去很多非技术型用户。但从长远来看，这是个优势，因为策略相对短寿，而机制才会长存。
}
unix(对windows的批评){
    在这样的操作系统中，完成操作系统预见的任务很容易，但是完成其没有预料到的任务，
用户不是无计可施就是痛苦不堪。但UNIX却具有非常彻底的灵活性。
}
unix(UNIX的hack之趣){
1. 对于程序员和开发人员来说，如果完成某项任务所需付出的努力对他们是个挑战却又恰好又在力所能及的范围内，
    他们就会觉得很有乐趣。
2. 趣味性是一个峰值效率的标志。充满痛苦的开发环境只会浪费劳动力和创造力；只会在无形中耗费大量时间、资金、机会。
}
unix(管道设计：Doug Mcllroy){
1>让每个程序就做好一件事。
   如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。
2>假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。
   1.输出中不要有无关的信息干扰。
   2.避免使用严格的分栏格式和二进制格式输入。
   3.不要坚持使用交互式输入。
3>尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外。
   理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。
4>优先使用工具而不是拙劣的帮助来减轻编程任务的负担。
---------------------------------------
定义过滤器的一些原则：
1. 宽进严出，尽可能自由宽松地接受输入格式，并输出结构良好的严谨输出格式；
2. 在过滤时，不需要的信息也决不丢弃；
3. 在过滤时，决不增加无用数据
---------------------------------------
1.一个程序只做一件事，并做好。
2.程序要能协作。
3.程序要能处理文本流，因为这是最通用的接口。
}

unix("开—闭"原则){
    面向对象设计的基石是'开—闭'原则。'开一闭'原则讲的是：一个软件实体应当对扩展开放，对修改关闭。
    这个规则说的是，在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。从另外一个角度讲，
就是所谓的'对可变性封装原则'。'对可变性封装原则'意味着两点：
1.一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里面。同一种可变性的不同表象意味着
  同一个继承等级结构中的具体子类。
2.一种可变性不应当与另一种可变性混合在一起。即类图的继承结构一般不应超过两层。
做到'开—闭'原则不是一件容易的事，但是也有很多规律可循，这些规律同样也是设计原则，它们是实现开—闭原则的工具。
}

unix(接口设计:小巧、简洁和正交){
在 Unix 接口设计的传统中，我们会反复涉及到两个主题：
1. 与其它程序通讯的前瞻性设计；
2. 最小立异原则；
使用五种度量标准对接口风格进行分类：
1. 简洁：        一个事务处理需要的动作时间及复杂度有较低的上限；
2. 表现力：      接口可以触发相当广泛的行为；
3. 易用：        与要求用户记忆的东西成反比；
4. 透明：        用户在使用接口时，几乎没有什么问题、数据或程序的相关状态需要记忆，
                  一个高度透明的接口，对于用户动作的效果，能够自然在给出中间结果、有用反馈和错误通知。
5. 脚本化能力 ：接口能够容易地为其它程序所使用；

Qt(API设计原则){
1. API应该极简(minimal)且完备(complete)
   极简的API是指每个class的public成员尽可能少，public的class也尽可能少。这样的API更易理解、记忆、
调试和变更。
   完备：完备的API是指期望有的功能都包含了。这点会和保持API极简有些冲突。如果一个成员函数放在错误
的类中，那么这个函数的潜在用户就会找不到，这也是违反完备性的。
2. 语义清晰简单  
   就像其他的设计一样，我们应该遵守最少意外原则(the principle of least surprise)。好的API应该可以
让常见的事完成的更简单，并有可以完成不常见的事的可能性，但是却不会关注于那些不常见的事。解决的是具体
问题；当没有需求时不要过度通用化解决方案。(举个例子，在Qt 3中，如果不是考虑到『解决具体问题』这点，
QMimeSourceFactory就会命名成QImageLoader并有不一样的API。)
3. 符合直觉
    就像计算机里的其他事物一样，API应该符合直觉。对于什么是符合直觉的什么不符合，不同经验和背景的
人会有不同的看法。API符合直觉的测试方法：经验不很丰富的用户不用阅读API文档就能搞懂API，而且程序员
不用了解API就能看明白使用API的代码。
4. 易于记忆
    为使API易于记忆，API的命名约定应该具有一致性和精确性。使用易于识别的模式和概念，并且避免用缩写。
5. 引导API使用者写出可读代码
    代码只写一次，却要多次的阅读(还有调试和修改)。写出可读性好的代码有时候要花费更多的时间，但对于
产品的整个生命周期来说是节省了时间的。

}
避免常见陷阱
7.1 简化的陷阱
1. 一个常见的误解是：实现需要写的代码越少，API就设计得越好。应该记住：代码只会写上几次，却要被
   反复阅读并理解。
7.2 布尔参数的陷阱
2. 布尔类型的参数总是带来无法阅读的代码。给现有的函数增加一个bool型的参数几乎永远是一种错误的行为。
}
unix(模块实例){
日志记录
文件读写
本地参数读写(Android中为SharedPreferences)
配置文件读写(如xml、ini等)
数据加解密(AES、DES、MD5等)
http协议类(POST/GET)
图片操作
二维码生成
其他等等
}
unix(正交性){
API,命令集，协议和其他计算机工作方式。
}
unix(STOP - 数据结构){
任何一个知识点在系统内都应当有一个唯一、明确、权威的表述。
无垃圾，无混淆(No junk， no confusion)
1. 无垃圾时说数据结构应该最小化，比如，不要让数据结构太通用，居然还能表示不可能存在的情况。
2. "无混淆"是指在其真实世界中绝对明确清晰的状态在模型中也应该同样明确清晰。
简言之，SPOT原则就是提倡寻找一种数据结构，使得模型中的状态个真实世界系统的状态能够一一对应。
}
unix(模块设计原则){
0. 封装和最佳模块大小
1. 紧凑性 就是一个设计是否能装进人的大脑。 甚至不需要手册就能使用
2. 正交性 操作无副作用，只做好一件事(利于开发和测试)
3. STOP原则 真理的单点性类似于DRY原则 (例如代码生成器)
4. 解决一个定义明确的问题
5. 分离的价值:不要在意工具，在意是否适用

不要重复自身(Do not Repeat Yourself)：任何一个知识点在系统内都应当有一个唯一、明确、权威 的表述。
要提高设计的紧凑性，有一个精妙但强大的方法：就是围绕"解决一个定义明确的问题"的强核心算法组织设计，避免臆断和捏造。
---------------------------------------
模块化代码的首要特质就是封装，封装良好的模块：
1. 不会过多向外部披露自身的细节，
2. 不会直接调用其它模块的实现码，
3. 不会胡乱共享全局数据。
模块之间通过应用程序编程接口(API)，一组严密且定义良好的程序调用 和 数据结构来通信。
---------------------------------------
应用程序编程接口(API)在模块间扮演双重角色：
1. 在实现层面，阻止各自的内部细节被相邻模块知晓；
2. 在设计层面，真正定义了整个体系；
---------------------------------------
以功能(解决具体的一个事情)为大模块(相对其它功能模块独立)，
1. 并提供调用API(完成这个事情所需的说明就是参数)，
2. 内嵌处理具体步骤的小模块(这些小模块之间会存在很多的联系)。
3. 模块以可重复利用为原则定义编写。
---------------------------------------
软件系统应设计成由层次分明的嵌套模块组成，而且每个层面上的模块粒度应降至最低。

# 因此实际代码往往是自顶向下和自底向上的的综合产物。
自底向上的设计者通常先考虑封装具体的任务，以后再按某种相关次序把这些东西粘合在一起。
自顶向下的设计者通常先考虑程序的主事件循环，以后才插入具体的事件。
程序员尽量双管齐下：
  1>一方面以自顶向下的应用逻辑来表达抽象规范；
  注：应用逻辑：完成某一功能、操作或事物的流程描述。
      抽象规范：应用逻辑中按某种相关次序粘合在一起的模块的调用或沟通方式。
  2>一方面以自底向上的函数或库来收集底层的域原语；
  注：  域：范围。
      原语：由若干多机器指令构成的完成某种特定功能的一段程序，具有不可分割性。
            即原语的执行必须是连续的，在执行过程中不允许被中断。
这样，当高层设计变化时，这些域原语仍然可以重用。
}
unix(模块设计陷阱){
模块性体现在良好的代码中，但首先来自良好的设计：

以下这些问题，可能会有助于提高代码的模块性：
1>有多少全局变量？全局变量对模块化是毒药，很容易使各模块轻率、混乱地互相泄漏信息。
2>单个模块的大小是否在hatton的"最佳范围"内(即最佳物理行数建议应在400至800行之间)？
    如果回答是"不，很多都超过"的话，就可能产生长期的维护问题。
    知道与你合作的其他程序员的最佳范围是多少吗？
    如果不知道，最好保守点儿，坚持Hatton最佳范围的下限。
3>模块内的单个函数是不是太大了？
  与其说这是一个行数计算问题，还不如说是一个内部复杂性问题。
  如果不能用一句话来简单描述一个函数与其调用程序之间的约定，这个函数可能太大了。
  ken Thompson 说：就我个人而言，
      如果局部变量太多，我倾向于拆分子程序。
      另一个办法是看代码行是否存在太多缩进。
4>代码是不是有内部API -- 即可作为单元向其他人描述的函数调用集和数据结构集，
  并且每一个单元都封装了某一层次的函数，不受其它代码的影响？
  好的API应是意义清楚，不用看具体如何实现就能够理解的。
  一个经典的测试方法：
    通过电话向另一个程序员描述。
    如果说不清楚，API很可能就是太复杂，设计太糟糕了。
5>API的入口点是不是超过七个？
  有没有哪个类有七个以上的方法？
  数据结构的成员是不是超过七个？
6>整个项目中每个模块的入口点数量如何分布？
  是不是不均匀？
  有很多入口点的模块真的需要这么多入口点吗？
  模块复杂性往往和入口点数量的平方成正比，这也是简单API优于复杂API的另一个原因。
}
unix(模块原则：使用简洁的接口拼合简单的部件){
1. 计算机编程的本质就是控制复杂度。                                           # 思想
   ?用复杂的方法解决简单的问题；
   ?用简单但错误的方法解决复杂的问题；
   ?用不恰当的复杂方法解决复杂的问题。

2. 用清晰的接口把若干简单的模块组合成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么就
   还有希望对局部进行改进而不至牵动全身。                                     # 思想
3. 模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 # 策略
}
unix(清晰原则：清晰胜于机巧--业务数据字典){
    维护如此重要而成本如此高昂；在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——
将来阅读维护源码的人，包括你自己——看的。                                      # 思想
}

# 可以组合的基础是文本化。
unix(组合原则：设计时考虑拼接组合){
在输入输出方面，Unix传统极力提倡采用简单化、文本化、面向流、设备无关的格式。  # 策略 
每个部分单独成为一块，然后用一个简单的命令流或者是应用协议将其组合在一起。    # 策略
}
unix(协议和存储：文本化.VS.二进制){
1) 序列化(保存)操作有时也称为列集(marshaling)，其反向操作(载入)称为散集(unmarshaling)。
2)  互用性、透明性、可扩展性和存储/事务处理的经济性， 这些都是设计文件格式和应用协议时需要考虑的重要方面。
    2.1 互用性和透明性要求我们在此类设计中要重点考虑数据表达的清晰问题，
        而不是首先考虑实现的方便性和可能达到的最高性能。
    2.2 既然二进制协议很难扩展和干净地抽取子集，可扩展性当然也青睐文本化协议。
    2.3 事务处理的经济性有时则会提出相反的要求，但我们应看到，
    首先考虑这个标准就是一种过早优化，不这么做往往是明智选择。
3)  正是文本流的限制帮助了强化封装：
    因为文本流不鼓励内容丰富、编码结构密集的复杂表达，也不提倡程序互相干涉内部状态。
3.1 协议中字符串无需字节序转换，因为，文本协议更容易交互些。
4)  使用二进制协议的正当理由如下两点：
  1)  如果要处理大批量的数据集，因而确实关注能否在介质上获得最大位(bit)密度；
      如果数据传输性能敏感的，如moosefs,tfs或者其他类型的文件系统。
      例如：大图像和多媒体数据的格式有时可以算这种情况的例子。
  2)  如果非常关心将数据转化为芯片核心结构所必须的时间或指令开销；
      底层的设备，需要前导码，校验和结束符，或者RS算法以进行校验数据正确性的。RS232，RS485
      例如：对延时有严格要求的网络协议有时则可以算是这种情况的例子；
---------------------------------------
文本化设计：Unix口令文件格式(透明性) # 很少读和很少修改，经济性不是主要因素；文件中的不同数据不会从原始机器搬移出去，互用性也不是问题。
            .newsrc格式(透明性和可操作性) # 经济性不无道理，来避免启动等待。但机器速度的提高和存储价格的下降，选择更加明智。
可移植网络图形 PNG(互用性) # PNG格式指定了字节顺序、整数的字长、优先顺序和字段间的填充。 -- 优先考虑传输的经济性

数据文件元格式: DSV风格 (Delimiter-Separated Values 分隔符分割值): #1冒号: 2管道 | 3ASCII　NUL 4Unix旧学派 Tab
# /etc/passwd(/etc/group;/etc/inittab) 通过反斜杠符转移数据域中包含冒号。通过反斜杠符嵌入非打印字符数据。
# Window: (comma-separated values)CSV格式的每个字段可以加上双引号。
    DSV格式的主要设计目的就是为了简化CSV语法，生成和解析只需要replace, join, split这3个基本的字符串操作，
而不需要进行语法分析。
RFC 822格式     # 
Cookie-JAR格式  # 
Record-Jar格式  # 
XML格式         # 
Windows INI格式 # 
}
unix(文本文件设计){
1. 如果可能，以新行符结束的每一行只存一个记录 # 文本流工具提取记录就非常容易
2. 如果可能，每行不超过80个字符               # 普通尺寸的终端上视窗上浏览。
3. 使用 "#" 来注释                            # 能在数据文件中嵌入注释和说明会非常好
4. 支持反斜杠约定，主要是一些转义问题         # 支持嵌入不可打印字符的最自然方法，就是解析C语言风格的反斜杠转义
# \nnn或\onnn或\0nnn 表示八进制值为nnn的字符
# \xnn 表示十六进制值为nn的字符；
# \dnnn表示十进制为nnn的字符
# \unnn表示十六进制的unicode子面值
5. 在每一行记录的格式中，使用冒号或任何连续的空白作为字段分隔符。
5. 不要过分区分tab和whitespace # tab可能设置不同，眼睛很难区分tab和whitespace
6. 优先使用16进制而不是8进制   # 两位或四位的十六进制数字更容易直观地与字节以及今天的32和64位子对应起来。
6. 对于复杂的记录，使用'节'格式：一个记录若有多行，就使用%%\n或%\n作为记录分隔符。
   # 在人们肉眼检查文件时，这种分隔符时非常有用而且直观的边界标志。
7. 在节格式中，要么每行一个记录字段，要么让记录格式和RFC822电子邮件头类似用冒号终止的字段名关键字作为引导手段。
   # 当字段经常空缺或者超过80个字符，或则当记录很稀疏时，使用第二种方案。
7. 在节格式中，支持连续行。
8. 要么包含一个版本号，要么将格式设置成相互独立的自描述字节块。  # 扩展性要求
9. 注意浮点数取整问题
10. 不要仅对文件的一部分进行压缩或者二进制编码；

纯文本、纯二进制或压缩文本都可能是最佳方案，
     具体取决于对存储经济性、可显性或让浏览工具编写起来尽可能简单等问题的权衡考虑。
---------------------------------------
文件压缩的利：空间的经济性和文本格式的一些优势。
文件压缩的弊：透明性，file命令不能确认数据真实类型。
}
unix(配置文件设计){
首先，对于能够可靠地进行自动检测的东西，就不要提供配置开关。
其次，用户不应该看到优化开关。
最后，能用脚本包装器或简单管道实现的任务，就不要用配置开关实现。能简单利用其它程序完成的任务，
      就不要增加本程序的复杂度。

**无论何时想增加配置选项，请考虑以下这些比较普通的问题：**
	能省掉这个功能么？为什么在加厚手册之外还要加重用户负担？
	能否用某种无伤大雅的方式改变程序的常规行为从而无需这个选项？
	这个选项是否花哨没用？是否应该少考虑用户界面的可配置性而多考虑正确性
	这个选项附加的行为是否应该用一个独立的程序来代替
}
unix(何时使用环境变量){
**何时使用环境变量**
变量值根据共享点文件或父进程需要向多个子进程传递信息的上下午环境的不同而变化
变量值随点文件不同而频繁改变，但每次启动都不变化。
进程唯一的覆盖必须以不要求改变命令行调用的方式来表述
}
# 给定模型，如STMP、BEEP或者XML-RPC，则在应用协议语法中运用良好的风格并不难。真正的挑战不是协议语法而是协议逻辑
# 设计一个协议，既有充分的表达能力又有防范死锁的能力。几乎同样重要的是，协议必须看得出很有表现力并可防范死锁。
# 也就是说人们必须能够在头脑中尝试对通信协议的行为建模并验证其正确性。

# 通信各方设计状态机的问题。

unix(应用协议设计){
1. 互联网协议的行结束符通常是CR-LF，而不是Unix的单LF，这就是这段前Unix历史的遗留痕迹。
2. 经典的互联网元协议是文本格式，使用单行请求和响应，但是有效数据载荷可以多行。有效数据载荷
   要么是8位组数据作为前导，要么是以'\r\n'行作为结束符。在后一种情况下，有效数据载荷在字节上已被补齐；
3. 所有以句号'.'开始的行前面需要另一个句点，接收方既负责识别结束符又负责去除字节补齐。
   应答由状态码和后接入可识别的消息构成。
---------------------------------------
SMTP：一个简单的套接字协议
POP3：邮局协议
IMAP：互联网协议访问协议
HTTP： 见TCP|IP高效编程
BEEP：块可扩展交换协议
XML-RPC SOAP和Jabber
---------------------------------------

}
unix(第二版系统效应){
一个系统设计师在设计第一版系统时，往往出于较弱的自信心以及量力而行的考虑，
   会尽量剪裁要实现的功能数量。
   而当第一版系统成功发布，开始第二版的设计时，随着自信心的增强，
   大量以前被压制的提议都会重现，设计师在塞入新的功能时也会不再那么保守。
   这很可能导致产生一个 臃肿 而 缺乏概念完整性 的第二版系统
}
unix(端到端协议设计：代价和性能){
http://blog.csdn.net/collier/article/details/3547200
? 重要问题是如何在功能之间进行合适的划分，如何将功能安置到合适的层中。
? 通讯系统设计的主要目标是要让传输中各种错误发生的概率降低到一个可以接受的水平。

1. 设置功能时要考虑两个因素的权衡：代价和性能。
2. 某些功能的不完全实现往往是提高系统功能的好办法。
3. 通常底层的功能可以提高系统的性能(如底层的校验机制)，但全局的代价较大(overall cost)

'端到端'的原则：根据这一原则，网络的'智能'位于网格的端部，而不是在网络的中心部位，因为信息处理的'高级'功能是
由处在网络端部的计算机(和用户)的来完成的。
采用了'端
到端'原则的网络是'中性'的，它的作用只局限于传输信息，而不改变信息(所以这一原则也被称之为'中性'原则)。于是
网络便成了一个公共表达的平台，一种'公共的资产'，可以使所有的使用者在上面开发新的内容和新的服务。
}
unix_i_Mechanism_Policy(){  cat - <<'unix_i_Mechanism_Policy'
[分离原则：策略同机制分离，接口同引擎分离]
机制，是指实现某一功能的具体执行机构。
策略，是在机制基础上，借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。
通常，机制处于一个系统的基层，而策略则处于系统的高层。
在代码大全中提到"隔离变化"的概念，以及设计模式中提到的将易变化的部分和不易变化的部分分离也是这个思路。


1. 通信协议
将应用程序分成协作的前端和后端进程，这些进程通过套接字上的专用应用程序协议进行通信；前端执行策略，后端实现机制。
这样的全局复杂性通常远低于实现相同功能的单进程单体的复杂性，从而减少您对错误的脆弱性并降低生命周期成本(提高健壮性)。
2. 嵌入式语言
将应用程序编写为由嵌入式脚本语言驱动的 C服务例程库，应用程序控制流是用脚本语言而不是 C 编写的。这种模式是Emacs编辑器，它使用嵌入式 Lisp解释器来控制用 C 编写的编辑原语。
3. MVC模式的核心思想是数据层(Domain)与表现层(Presentation)的隔离
    模型(Model): 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。Model 有对数据直接访问的权力，例如对数据库的访问。
"Model"不依赖"View"和"Controller"，也就是说， Model 不关心它会被如何显示或是如何被操作。
但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。

    视图(View): 能够实现数据有目的的显示(理论上，这不是必需的)。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，
View 需要访问它监视的数据模型(Model)，因此应该事先在被它监视的数据那里注册。
    控制器(Controller)起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。
View，Model属于策略，在系统中属于可变部分，Controller属于机制，不会随着view的变化而变化，属于系统中不变的部分，构建一个系统要尽肯能分离可变部分和不可变部分。
4. netfilter框架
5. TCP拥塞控制框架
Linux系统中的TCP拥塞控制采用面向对象的设计思想，提供拥塞控制接口用于实现不同的拥塞控制策略，成功把拥塞控制解耦了
6. eBPF框架
内核实现BPF虚拟机执行核心引擎，属于机制部分；
用户态可以编写各种BPF程序，实现不同策略功能；

机制可以认为是业务通用的核心模型(框架)，不易变化；策略可以认为是某个功能的具体实现方案，可以被框架使用；
机制关联一个抽象的策略(也就是接口)，用不同的具体策略初始化抽象策略，就能调用具体策略的处理流程。


也就是说将 逻辑控制 与 功能实现 分开。
---------------------------------------
机制，可以理解为实现某个功能需要的原语操作和结构；
策略，可以理解为某个功能的直接实现。
'提供机制，而不是策略'意味着我们应该提供实现某个功能需要的原语操作，而不是直接去实现这个功能。
这样的好处是，这个'机制'的用户可以根据自己的需要去定制这个'机制'的表现形式，即自己的'策略'，
并且我们很容易去更换一个'策略'，而不用修改'机制'。
---------------------------------------
机制是接口，策略是数据流。

1. AWK的读入行循环是机制，各种正则式与后附的处理操作是策略;
2. 输入法是机制，码表是策略;
3. 乐高积木的凸点与凹槽是机制，各种拼接方式是策略;
4. 管道是机制，应用管道处理各种数据是策略;
5. 游戏开发中，程序主要负责各种机制实现，具体策略则是策划通过数据表或编辑工具去进行控制。
---------------------------------------
一是，逻辑控制->用脚本语言来撰写。功能实现->用编译语言来撰写。
二是，将应用程序分成可以协作的前端进程(实现策略) 和 后端进程(实现机制)，
      通过套接字上层的专用应用协议进行通讯。

unix_i_Mechanism_Policy
}
unix(简洁原则：设计要简洁，复杂度能低则低){
1. 来自多方面的压力常常会使程序变得复杂，其中一种就是来自技术上的虚荣心理。
2. 过度的复杂性往往来自项目的要求，而这些要求常常基于当月的推销热点，而不是给予顾客的需求和
   软件实际能提供的功能。
3. 要避免这些陷阱，唯一的办法就是鼓励另一种软件文化，以简洁为美，人人对庞大复杂的东西群起而攻之——
   这是一个非常看重简单解决方案的工程传统，总是设法将程序系统分解为几个能够协作的小部分，并本能的
   抵制任何用过多噱头来粉饰程序的企图。
}
unix(吝啬原则：除非别无他法，不要编写庞大的程序){
1. 能拆就拆，不能拆就叠。这似乎是模块原则和分离原则的最佳实践。
2. 尽可能少干活，让数据塑造代码；依靠工具，把机制从策略中分离。
}
unix(透明性原则：设计要可见，以便审查和调试){
1. 因为调试通常会占用四分之三甚至更多的开发时间，所以一开始就多做点工作以减少日后调试的工作量会很划算。
   一个特别有效的减少调试工作量的方法就是设计时充分考虑透明性和显见性。
2. 透明性的目的是为了维护与调试。调试工具、数据可视化都是实现透明性原则的利器。
3. 要追求代码的透明，最有效的方法很简单，就是不要在具体操作上叠放太多的抽象层。

4. 不要让调试工具仅仅成为一种事后追加或者用过之后就束之高阁的东西，它们是通往代码的窗口：不要在墙上凿出粗糙
   的洞，要修整这些洞并安装上窗。如果打算让代码一直可被维护，就始终必须让光照进去。
5. 可显性降低进入门槛；透明性则减少代码中的存在成本。

Linux内核源码相当透明(相对其行为的内在复杂而言)，但根本不具备可显性--要获得必要的知识以便融入代码中
并理解开发者的惯语相当困难。而一旦做到，一切就豁然开朗。
Emacs Lisp 库是可显的，但却不透明。要获得足够的知识来领会一件事情很容易，但要理解整个系统却相当困难。
1)这个设计能行吗？
  注：能行的几点要求：
      1>能否实现目地?
      2>是否存在致命缺陷？
      3>是否优大于弊？
      4>是否便于维护和可以扩展？
2)别人能读懂这个设计吗？
3)这个设计优雅吗？
}
unix(透明性和可显性设计){
1. 可显性降低进入门槛；透明性则减少代码中的存在成本。
2. Linux内核源码相当透明(相对其行为的内在复杂性而言)，但是不具备可显性。要获得必要的知识以便融入代码中并理解开发者的惯用语相当困难。
   Emacs Lisp库是可显的，但不透明，需要足够的知识来领会一件事情很容易，但理解整个系统却相当困难
---------------------------------------
 以下这些问题需要好好思考：
1>程序调用层次中最大的静态深度是多少？
   也就是说，不考虑递归，为了建立心理模型来理解代码的操作，人们将要调用多少层？
   提示：如果大于四，就要当心了！！！
2>代码是否具有强大、明显的不变性质？
  不变性质帮助人们推演代码和发现有问题的情况。
  注：不变性质是指一个软件设计中各个操作都保持不变的特性。
      如：在大多数数据库中，两个记录的关键字不能相同，这就是不变性。
3>每个API中的各个函数调用是否正交？
  或者是否存在太多的特征标志(Magic Flags)和模式位，使得一个调用要完成多个任务？
  完全避免模式标志会导致混乱的API，里面包括太多几乎一模一样的函数，
  但是频繁使用模式标志更容易产生错误(很多易忘并且易混的模式标记)。
4>是否存在一些顺手可用的关键数据结构或全局唯一的记录器(Scoreboard)，
  捕获了系统的高层级状态？
  这个状态是否容易被形象化和检验，还是分布在数目众多的各个全局变量或对象中，
  而难以找到？
5>程序的数据结构或分类和它们所代表的外部实体之间，是否存在清晰的一对一映射？
6>是否容易找到给定函数的代码部分？
  不仅单个函数、模块，还有整个代码，需要花多少精力才能读懂？
7>代码增加了特殊情况还是避免了特殊情况？
  每一个特殊情况可能对任何其它特殊情况产生影响；
  所有隐含的冲突都是Bug滋生的温床。
  然而更重要的是，特殊情况使得代码更难理解。
8>代码中有多少个Magic Number(意义含糊的常量)?
  通过审查是否很容易查出实现代码中的限制(比如关键缓冲区的大小)?
如果代码很好地解决了上述问题，则代码也可以复杂，且不会对维护人员造成认知负担。

audacity
fetchmail -v
GCC
SNG
---------------------------------------
**隐藏细节和无法访问细节有着重要区别。不要过度保护。**
    无论何时碰到涉及编辑某类复杂二进制对象的设计问题时，UNIX传统都提倡首先考虑，是否能够编写一个能够在
可编辑的文本格式和二进制格式之间来回进行无损转换的工具？这类工具可称为文本化器(textualizer).
    宁愿抛弃、重建代码也不愿修补那些蹩脚的代码。
    '代码是活代码、睡代码还是死代码？'活代码周围存在一个非常活跃的开发社团。睡代码之所以'睡着'，
经常是因为对作者而言，维护代码的痛苦超过了代码本身的效用。死代码则是睡得太久，重新实现一段等价代码更容易。
}

unix(为可维护性而设计){
1. 你将会花费职业生涯里的大量时间在维护代码上面，而且要远比你写新代码的时间长得多。
    首先，你需要知道如何正确的维护代码从而保证它不会随着时间的推移变得越来越糟糕知道最终崩溃。
    其次，你要学会如何编写容易维护的良好代码，
2.  影响代码可维护性最重要的一个因素是其可读性。
    重构本质上就是在提高现有代码的设计。
3. 你进行修改并测试的越快，你就会拥有更好的安全网，这样能够使你不会给已有的代码库引入新的bug和错误。
4. 如果你一定要写注释的话，请确保他们是非常良好的。
   神秘的注释有的时候比神秘代码一样糟糕，甚至更糟糕，
---------------------------------------
学习编写可维护代码的资源
Robert Martin的《整洁的代码 Clean Code》 
Steve McConnell的《代码大全 Code Complete》
Michael Feathers的《修改代码的艺术 Working Effectively With Legacy Code》 
Martin Fowler的《重构 Refactoring》
}

unix(面向对象的可维护指标){
1.WMC (weighted methods per class) : 基于类的加权方法，说直接点就是给定类中的方法数目，方法越多则该类WMC越大
  ——其实对于过程语言这点也可借用，类相当于过程语言中的文件(我们一般都称其是模块)，所以说文件中的函数越多，
  则维护性越难—— 我曾经参与过一个操作系统开发项目，其编程规范要求每一个函数一个文件。虽然有些极端，但也不失
  为一种维护策略。
2.DIT ( Depth of Inheritance Tree) ：继承树深度度量，继承是面向对象语言的优点之一，可提高代码重用性。可是
  层层继承也势必带来风险——牵一发而动全身，父类的改动对子类影不可避免，因此过深的继承关系对代码维护性会产生
  不良影响。
3.NOC (Number of children) ： 子女数，一个类的子女数应该适当，而不能太多。太多时应再重新划分子类——这里要强调
  一点接口或者抽象类是我们推荐的方式；而采用继承则需要扩充父类方法，也就势必增加了模块的耦合性，削弱了灵活性。
4.CBO (Coupling Between Object Classes)  类之间的耦合系数。我们都知道避免耦合性的开发原则——耦合会降低代码
 重用，增加单元测试难度和代码维护性。耦合系数其实就是给定类依赖于其他类的数目——所谓代码依赖有方法调用中，
 属性访问，继承，参数，返回值，以及异常等。CBO我认为是一个很重要的度量，一定要尽可能降低耦合性。
5.RFC (Response for a class)  类响应度量，指当类的对象接受到一个消息时，执行的方法总数。显然该值越大，
则越难理解，调式和测试。
6.LCOM (lack of cohesion in Methods) 欠内聚量度，统计完全没有共享属性的方法个数。简单的计算方法就是用没有
  共享属性的方法个数，减去所有有共享属性方法个数，结果为负数则按0计算。 内聚值越高说明方法之间的关联性不强，
  因此可以继续差分子类，如果LCOM很低则说明类封装的很内聚——这点可以说是强内聚的标准定义。
  
  关于如何使用这些度量没有标准法则， NASA有一个建议值：WMC>100,CBO>5,RFC>100,RFC>5*NOM ,NOM>40 (NOM是类中
方法个数)，一旦有2个以上指标达到上述阀值，则需引起重视。
}
unix(健壮性：健壮源于透明和简洁){
透明化：就是指一眼就能够看出来是怎么回事。
简洁化：即人们不需要绞尽脑汁就能够推断出所有可能的情况。
避免在代码中出现特例，
    BUG通常隐藏在处理特例的代码以及处理不同特殊情况的交互操作部分的代码中。

}
unix(表示原则：把知识[逻辑]叠入数据以求逻辑质朴而健壮){
1. 数据要比编程逻辑更容易驾驭。所以接下来，如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。
2. 在设计中，你应该主动将代码的复杂度转移到数据之中去。
}
unix(表示原则：数据压倒一切){
如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。
编程的核心是数据结构，而不是算法。
}
unix(表示原则：什么是数据驱动编程){
1. 数据驱动程序是数据本身控制程序的流程，而不是程序逻辑。它是一个模型，您可以通过向程序提供不同
   的数据集来控制流程，其中程序逻辑是某种通用形式的流或状态变化。
   程序代码保持相同，但是数据集(其不是动态输入类型，而是静态地给予计算机)控制流。
2. 就我的理解而言，数据驱动编程就是将程序的可变部分转移到数据上，程序功能由外部数据来决定，
   而程序的内部逻辑是比较稳定的。数据驱动编程往往代码精简，结构清晰，易于重构，开发效率极高。
   
# 数据驱动编程中(对比面向对象)：数据不仅仅是某个对象的状态，实际上还定义了程序的控制流；
OO首先考虑封装，数据变成更看重编写尽可能少的固定代码。
最重要的是把程序逻辑从硬编定的控制结构转移到数据中。

    将变和不变的部分分离，策略和机制分离，由此联想到的还有(数据和代码的分离，微语言和解释器的分离，
被生成代码和代码生成器的分离)更近一步：(微内核插件式体系结构)

    元编程 应该说是更加泛化的 数据驱动编程，元编程 不是新加入一个间接层，而是退居一步，使得当前的层变成一个间接层。
元编程 分为 静态元编程(编译时)和 动态元编程(运行时)，
    静态元编程本质上是一种 代码生成技术 或者 编译器技术； 
    动态元编程一般通过 解释器(或虚拟机)加以实现。
    
    数据驱动编程当然也不应该说是“反抽象的”，但的确与 “OO抽象”的思维方式是迥然不同，泾渭分明的，
如TAOUP一书中所述：“在Unix的模块化传统 和 围绕OO语言发展起来的使用模式之间，存在着紧张的对立关系”
应该说 数据驱动编程的思路与 结构化编程 和 OO 是正交的，更类似一种”跳出三界外，不在五行中”的做法。

    将复杂的易变的逻辑作为数据或更高层代码抛给上层!
    
    程序员束手无策只有跳脱代码，直起腰，仔细思考数据才是最好的行动。表达式编程的精髓。
    
    数据比程序逻辑更易驾驭。尽可能把设计的复杂度从代码转移至数据是个好实践。
}

unix(通俗原则：接口设计避免标新立异){
1. 最易用的程序就是用户需要学习新东西最少的程序——或者，换句话说，最易用的程序就是最切合用户已有知识的程序
}
unix(缄默原则：如果一个程序没有什么好说的，就保持沉默){}
unix(补救原则：出现异常时，马上退出并给出足量错误信息){
1. 软件要尽可能从容的应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易
   诊断错误的方式终止。
}
unix(经济原则：宁花机器一分，不花程序员一秒){}
unix(生成原则：避免手工hack，尽量编写程序去生成程序){}
unix(优化原则：雕琢前先得有原型，跑之前先学会走){
1. 90%的功能现在能实现，比100%的功能永远实现不了强。做好原型设计可以帮助你避免为蝇头小利而投入过多的时间。
2. 先制作原型，再精雕细琢。优化之前先确保能用。
3. 先给你的设计做个未优化的、运行缓慢、很耗内存但是正确的实现，然后进行系统地调整，寻找那些可以通过牺牲
   最小局部简洁性而获得较大性能提升的地方。
   
4. 产品界有个概念叫最小可行性产品(MVP)，是说在产品设计时，先做出仅包含产品设计者最想要的功能的产品，
  投放市场后看用户反应，再来决定接下来的设计方向。同样的，软件开发实践中也有敏捷开发一说。两者和这里
  的优化原则有异曲同工之妙。
}
unix(多样原则：决不相信所谓的'不二法门'的断言){}
unix(扩展原则：设计着眼未来，未来总比预想快){
1. 要为数据格式和代码留下扩展的空间。
2. 设计协议或者文件格式时，应使其具有充分的自描述性以便可以扩展。
}

unix(应用Unix哲学){
1. 只要可行，一切都应该做成与来源和目标无关的过滤器
2. 数据流尽可能文本化(这样可以使用标准工具来查看和过滤)
3. 数据库部署和应用协议尽可能文本化(让人可以阅读和编辑)
4. 复杂的前端(用户界面)和后端应该泾渭分明
5. 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好
6. 宽收严发(对接收的东西要包容，对输出的东西要严格)
7. 过滤时，不需要丢失的信息决不丢
8. 小就是美。在确保完成任务的基础上，程序功能尽可能少。
}

unix(Unix 环境下的用户接口设计模式){
1. 过滤器模式：接受标准输入的数据，转换成某种格式后，再将结果发送到标准输出端。例子 tr, grep, cat
2. Cantrip 模式：没有输入，没有输出，只被调用一次，产生退出状态数值。一个 cantrip 程序的行为只能由启动条件来控制。例子 clear, rm, touch
3. 源模式：类似过滤器的程序，不需要输入；它的输出只能在启动条件中控制。例子 ls, who, ps
4. 接收器模式：类似过滤器的程序，只接纳标准输入而不发送任何东西到标准输出。同样，它对输入端数据的做用行为只能在启动条件中控制。较少用到，一个例子是 lpr
5. 编译器模式：既无标准输出也无标准输入；然而它们会将错误信息发送到标准错误端。例子 gcc
6. ed 模式：前面的模式交互能力极低。这种模式在启动之后需要由用户持续的会话来驱动，ed 来源于 Unix 的行编辑器 ed，其他例子 ftp, sh
7. Roguelike 模式：运行在系统控制台，X 终端模拟器或视频显示终端上的游戏，使用全屏幕、支持可视界面风格，但使用字符阵列显示，而非图形和鼠标界面。例子 vi, emacs(一般来说 hjkl 固定做光标键)
}

unix(env){
1. 什么应是可配置的
一切，只要可能，就建立机制而把决策权交给用户。
什么不应该可配置？
  1.1 对于能够可靠的进行自动检测的东西，就不要提供配置开关
  1.2 用户不应该看到优化开关，让程序经济运行是设计者的任务，不是用户的任务
  1.3 能用脚本包装器或简单管道实现的任务，不要用配置开关实现
无论何时想要增加配置时，思考：
  a. 能省掉这个功能吗？为什么在加厚手册之外还要加重用户负担？
  b. 能否以无伤大雅的方式改变程序的常规行为从而无需这个选项？
  c. 这个选项否花哨没用？能否少考虑可配置性，多考虑正确性？
  d. 这个选项附加的行为能否用一个独立的程序来代替？

2. 配置在哪里
传统上，一个Unix程序可以在启动环境的5个找到控制信息：
  2.1 /etc下的运行控制文件(或者系统中其他固有的位置)
  2.2 由系统设置的环境变量
  2.3 用户主目录的运行控制文件(或 .文件)
  2.4 由用户设置的环境变量
  2.5 启动程序的命令行说传递的开关和参数
后面(较局部)的设置会覆盖前面(较全面)的设置。
  a. 好的Unix实践要求使用相同参数选项预期寿命最匹配的机制。因此，对调用时可能发生变化的选项，使用命令行开关。
  b. 对改动很少但确实应该由各个用户控制的选项，使用用户主目录的运行控制文件。
  c. 对需要有系统管理员设置而不是由用户改变的整个系统级选项的数据，使用整个系统里的运行控制文件。

3. 运行控制文件
    运行控制文件存放与程序相关的声明或命令，在程序启动时解析。如果所有用户都在一处共享程序的系统级配置，
通常在/etc目录下由一个运行控制文件。
    用户专有的配置信息通常在用户主目录下一个隐藏的运行控制文件。通常叫“点文件”。
    程序也可以拥有运行控制目录或点目录。每个目录包含了数个与程序相关的配置文件，但最好还是将这些配置分别对待。
运行控制语法的风格规定：
  3.1 支持说明性注释，以#开头
  3.2 不要区别隐匿的空白符
  3.3 把多个空行和注释视为单个空行
  3.4 词法上把文件视作简单的用空白分割的标记序列，或多行标记
  3.5 支持一字符串语法对待内嵌空白符的标记
  3.6 支持反斜杠语法以在字符串中嵌入不可打印字符或特殊字符

使用可执行文件名后加"rc"后缀代表"运行控制"。 monit -> monitrc  
monit -> ~/.monitrc /etc/monitrc /usr/local/etc/monitrc ./monitrc
                                             vim -> vimrc
vim   -> /usr/share/vim/vimrc  ~/.vimrc
如果程序是某种语言的解释器，那么人们就期望运行控制文件只是以该语言语法写成的并在运行时执行的命令文件。 lua

4. 环境变量
系统环境变量 USER LOGNAME HOME COLUMS LINES SHELL PATH TERM
用户环境变量 EDITOR MAILER PAGER BROWER
  4.1 变量值根据共享点文件或父进程需要向多个子进程传递信息的上下午环境的不同而变化 
  4.2 变量值随点文件不同而频繁改变，但每次启动都不变化。 
  4.3 进程唯一的覆盖必须以不要求改变命令行调用的方式来表述
  
5. 命令行
5.1 原始的 Unix 风格
命令行选项以连字符 “-” 开头的单个字符。
  如果 后面不带参数的模式标志选项可以组合在一起使用：例如，如果-a 和-b 是模式选项，-ab 或-ba 都正确而且启用了两个选项。
  如果选项有参数的话，这些参数紧接着选项后面(是否以空白分隔可选)。
  如果使用大写字符，把它们作为小写字符的选项的特殊变种是一种很好的做法。
5.2 GNU 风格
前面有两个连字符的选项关键字(而不是关键字母)。
  GNU风格的选项不用空白分隔就不能组合使用。
  选项参数既可以用空白分隔也可以用单个“=”来分隔。
5. getopt getopt_long
选项      含义
-4        ipv4
-6        ipv6
-a        all, append,alive, archive
-A        almost-all, addr
-b        buffer, block, batch, size, bytes, binary
-B        ignore-backups,backup,backoff
-c        command, check, columns,count, checksum, color, control file, 
-d        debug, delete, directory, diff, daemon 
-D        define
-e        excute, edit, exclude, expression, Ex, easy
-f        file, force
-g        generate, group, 
-h        header, help, human-readable 
-H        Host, ttl=N
-i        initialize, interactivem interval, inode, long listing, unique ID
-I        include, iface,  (needed for run from init)
-k        keep, kill
-l        list, long, load, login, length, lock, loop, logfile
-m        message, mail, mode, modification-time
-n        number, not, name, netdata, no, 
-o        output,order
-p        port, protocol, period
-p        port,pidfile,
-q        quite
-r(-R)    recurse, reverse, random, relative, readonly, Reset
-s        silent, subject, size, stats, statefile 
-S        src,
-t        tag,timeout,terminal, syntax check
-u        user
-v        verbose, version, Vi,Verbose
-V        version
-w        width, warning
-x        debug, extract
-y        yes
-z        zip
}

https://github.com/dearhwj/itbook
unix(复杂度){
复杂度的三个来源
    代码规模：一般就是代码的函数。
    实现复杂度：程序员为了理解一个程序从而建立其思维模型并调试该程序的困难程度。
    接口复杂度：主要是和用户接口的复杂度，比如用户界面，功能，操作等。

面对上面三个复杂度比较陷入三个陷阱：
    manularty(人力尺度)陷阱：主要是为了避免接口复杂度，而把许多底层人物抛给用户。
    blivet(硬撑)陷阱：主要是为了避免代码量复杂度，而使用极端晦涩复杂的算法。
    adhocity(过专用)陷阱：为了避免实现复杂度，不采用统一但是有些复杂的方案，而对每个问题都编写重复，专用的代码。
# 接口复杂度和实现复杂度的折中。
一种理念："差即是好"。这种理念强调实现的简单性，可以牺牲接口的简单性。 
# Unix思想中的一个主题就是强调工具小巧锐利，设计从零设计，接口简单一致。
# 良好品味和工程判断力要求，情况不同，则答案不同。重要的是培养斟酌每一种设计的习惯。

偶然复杂     违反SPOT原则   过早优化        非正交性
选择复杂度   方法学开销     别的一切        有效功能
本质复杂度   开发工具       核心数据结构    功能需求
             代码库规模     实现复杂度      接口复杂度
             
偶然复杂度经常来源于
    接口设计并非正交-- 即 没有仔细的分解接口操作以使得每个操作只完成一件事情。
    偶然代码复杂度(比能够完成工作所需要的更复杂)常常来自于：过早优化。
  违背SPOT原则，重复代码或者糟糕的组织，以至于重用机会渺茫。
  
本质接口复杂度： 通常无法去除，除非调整软件的基本功能需求，代码库的本质大小同选择的开发工具有关，
其中最重要的因素可能就是实现语言的选择。

复杂度的不同来源必须以不同的方法应对： 
代码库规模可以采用更好的工具来解决， 
实现复杂度可以选择更好的算法来处理，
接口的复杂度必须着眼于更好的交互设计。

处理各种复杂度： 必然更依赖于见识而非方法，通过发现更简单的方法，可以去除偶然复杂度，依赖上下文环境判断哪些功能值得去做，
可以去除选择复杂度。而要去除本质复杂度， 只能依赖于对现实真谛的洞察和顿悟，从根本上重新定义所要解决的问题。

最简原则：尽可能简单，而不过于简单。选择需要管理的上下文环境，并且按照边界所允许的最小化方式构建程序。
}
计算资源以及人类的思考，同财富一样，不是靠储藏而是靠消费来证明其价值的。  --- 当简洁不能胜任

“时间总是淡化痛苦，让一切变得比实际情况更轻松。但是谁说生活一定是轻松的？
痛苦造就性格。(也许还造就产品。)”

unix(Brook定律预言道){
1. 对一个已经延期的项目，增加程序员只会使该项目更加延期。
2. 项目成本和错误率按程序员人数的平方增长。
}
unix(Hatton的经验数据表明){
假设其它所有因素(如程序员能力)都相同，
1. 200到400之间逻辑行的代码是"最佳点"，可能的缺陷密度达到最小。
2. 根据分析人员对逻辑行的理解以及其它偏好(比如注释是否剔除)的不同，
3. 代码行的统计方法会有较大差别。
4. Hatton建议逻辑行与物理行之间为两倍的折算率，即最佳物理行数建议应在400至800行之间。
5. 这个大小与所用的语言无关，即尽可能用最强大的语言和工具编程。
}
unix(碰到重复数据这种情况时){
1>如果代码中含有重复数据是因为在两个不同的地方必须使用两个不同的表现形式，
  那么能否写个函数、工具或代码生成程序，让其中一个由另一个生成，
  或两者都来自同一个来源？
2>如果文档重复了代码中的知识点，能否从部分代码中生成部分文档，或者反之，
  或者两者都来自同一个更高级的表现形式？
3>如果头文件和接口声明重复了实现代码中的知识点，
  是否可以找到一种方法，从代码中生成文件和接口声明？
  
数据结构也存在类似的原则：'无垃圾，无混淆(No junk, no confusion)'。
 '无垃圾'是说数据结构(模型)应该最小化，比如：
   不要让数据结构太通用，居然还能表示不可能存在的情况。
 '无混淆'是指在真实世界中绝对明确清晰的状态在模型中也应该同样明确清晰。
  真理的单点性原则：就是提倡寻找一种数据结构，
                    使得模型中的状态跟真实世界系统的状态能够一一对应。
  真理的单点性原则得出以下推论：
  1>是不是因为缓存了某个计算或查找的中间结果而复制了数据？
    仔细考虑一下，这是不是一种过早优化；
    陈旧的缓存(以及保持缓存同步所必需的代码层)是滋生bug的温床，
    而且如果(实际经常是)缓存管理的开销比预想的要高，甚至可能降低整体性能。
  2>如果有大量的样板代码，是不是可以用单一的更高层表现形式生成这些代码，
    然后通过提供不同的细致的调制选项生成不同个例呢？
重构代码就是改变代码的结构和组织，而不改变其外在行为。
要提高设计的紧凑性，有一个精妙但强大的方法：就是围绕"解决一个定义明确的问题"的强核心算法组织设计，避免臆断和捏造。
}

unix(胶合层 into OO){
Padlipshy所说："如果你知道自己在做什么，三层就足够了；但如果你不知道自己在做什么，十七层也没用。"
OO语言鼓励"具有厚重的胶合和复杂层次"的体系。
     所有的OO语言都显示出某种使程序员陷入过度分层陷阱的倾向。
     
1. 顶层的应用逻辑和底层的域原语集必须用胶合逻辑层来进行 阻抗匹配(impedance match)
2. 胶合层是个挺讨厌的东西，必须尽可能 薄，它用来将东西粘一起，但不应该用来隐藏各层的裂痕和不平整。
3. 薄胶合层可看作是分离原则的升华，策略(应用逻辑)应与机制(域原语)清晰的分离，如果有许多代码即
   不属于策略又不属于机制，可能就有问题
   
Brian Beckman直截了当地说，C++语言主要是用来开发别的语言的。
如果改成 “C++语言主要是用来支持别的语言的”，那就大体没错了。
# 做系统软件开发的时候，重要的是理解系统的运作方式，那些漂亮的抽象手法和高级特性是次要的。
}

unix(Linux之父话糙理不糙 done OO){
C++的机制很丰富，很多机制是为了满足高层应用和框架的需求而准备的，在这个层次上发挥不出来，反而把清晰性给牺牲掉
了。很多时候，一个简单的语句，到底背后会发生什么，即使是老手也说不清。比如：
     std::string s("Linux Torvalds");
     std::string scopy = s;

    上面这段代码不过是创建两个内容相同的字符串副本，但是没有任何一个人能够在不了解更多信息的情况下清楚
地描述背后所发生的事情，因为不同的STL对于 string的实现方式不同，因此在copy assignment时表现也不同，有的
可能是简单地复制字符串对象，有的可能具有ref-counting机制，需要创建对象、设定对象值、增加引用计数，有的
没有考虑线程安全性，有的考虑了线程安全性，还得加锁解锁，对不起，加解锁也还有很多做法。创建新的string对象
时，有时还需要调用内存分配 器，而这个东西的实现又五花八门，有的直接new char[]，有的从内建的memory pool
申请，memeory pool是不是线程安全的？对不起，这次可能又要涉及加解锁问题。memeory pool会不会已经满了？
要不要次第调用new/malloc申请新的内存块？总之，后面的事情够多够复杂，没有相当功力，对平台了解不够深入，
很难说出个子午卯酉来。

    一个字符串复制尚且如此，别的高级特性就更不用说了。所以很多人宁可麻烦一点，也不愿意使用C++，这还是
可以理解的。
}

unix(库和工具包 vs 框架){
1. 库和工具包是为程序员带来 自由 的，框架是为程序员带来 约束 的
2. 宏观管理 上选取一些框架以控制整体的结构的流程。利用控制反转(IOC)等机制实现对各模块的统一调度
3. 微观实现 上利用库和工具包来解决具体的细节问题
}

unix(声明式与命令式区别){
1. 声明式编程由若干规范(specification)的声明组成，即一系列陈述句'已知这，求解那'，强调'做什么'，
   而非'怎么做'，声明式编程是人脑思维方式的抽象，利用数理逻辑或既定规范对已知条件进行推理或运算
2. 命令式编程是 行动导向 的，因而算法是显性而目标是隐性的；声明式编程(declarative programming)是 
   目标驱动 的，因而目标是显性而算法是隐性的。
3. 声明式语言擅长于 数理逻辑的应用，如人工智能、符号处理、数据库、编译器等，对 基于业务逻辑 的，
   尤其交互式或事件驱动型的应用，显然命令式语言更有用武之地
}

unix(Unix接口的设计模式){
1、过滤器模式
    牢记Postel原则：宽进严出
    在过滤时，不需要的信息也决不丢弃
    在过滤时，绝不增加无用数据
2、Cantrip模式
    如：clear 没有输入没有输出，只被调用一次，产生退出状态数值
3、源模式
    不需要输入，它的输出只能在启动条件中控制。如：ls(1)，ps(1)，who(1)
4、接收器模式
    只接纳标准输入而不发送任何东西到标准输出
5、编译器模式
    既无标准输入也无标准输出，会将错误信息发送到标准错误端
6、ed模式
    具有简单的交互设计模式：sh，ftp
7、Roguelike模式
    Roguelike程序是设计来运行系统控制台、X终端模拟器或视频显示终端上的游戏，使用全屏幕、支持可视化界面风格，但使用字符阵列显示，而非图形和鼠标界面。
8、'引擎和接口分离'模式
    配置者/执行者组合
    假脱机/守护进程组合
    驱动/引擎组合
    客户端/服务器组合
    CLI服务器组合
9、基于语音的接口模式
}
link(13种提高系统伸缩性的最佳实践){
1, 尽可能地使用异步通信.
2, 为提供不同服务的硬件引入故障隔离 .
3, 在多层系统中, 使用Cache .
4, 从用户角度监控 你的系统性能.
5, 使用数据库复制 , 降低单点读压力.
6, 根据用户和业务的不同, 将应用或数据库分片 .
7, 减少使用关系型数据库 的复杂特性. 尽可能把它当做是一个持久存储设备.
8, 以循序渐进的方式升级系统 , 先升级小部分servers, 然后逐步升级所有servers.
9, 在一个应用进入生产环境前, 一定要做性能和负载测试 .
10, 设计系统时, 应该要做容量规划与扩容方案 .
11, 使系统具备回滚 能力.
12, 确保团队具备根本问题分析能力 .这样, 当出现问题时, 才可以方便快速的定位, 解决问题.
13, 质量是设计出来的, 不是靠测出来的.
}
unix(自下而上的做 VS 自上而下的思考){
    很多人都赞同自上而下的设计方法，把问题逐步分解，再分而治之。而我喜欢至下而上的设计方法。先把绝对
要做的模块做了，再考虑怎么把他们搭起来。但是我在实际操作的时候往往是，自下而上的做，自上而下的思考。
书这里对两种方法的优缺点的总结非常精辟。我特别同意最后的结论，这两种方法并不是互相排斥的——你会受益于
二者的相互协作。
}

RootlessRoot(){

无名师与万行码
    Unix传统上认为，一行shell脚本胜过万行C程序。
    你需要多长时间来实现和调试那个C程序？傻子才会干这个而不去完成更有价值的任务。

无名师的双路论
    简单的实现往往对边缘情况有欠考虑，比如资源耗竭、无法关闭竞争窗口以及在未完成事务中超时等等。
    发生边缘情况时，软件行为往往不规律、难以猜测。这当然不是Unix传统。

    另一方面，大家都知道精巧的程序很脆弱。更进一步说，每个对边缘情况的修正往往牵扯到程序的核心算法，还牵扯处理其它边缘情况的代码。
    于是，对边缘情况防患于未然、确保描述的简单性，反而会使得代码过分复杂、bug成堆、根本无法发售。这当然不是Unix传统。

无名师与Unix狂
    当尊者Thompson发明Unix时，他并不理解它。随后他理解了，受益了，不再发明了。
    当尊者McIlroy发明管道时，他只知道它将传递软件，并不知道它能传递思想。
    当尊者Ritchie发明C时，他将程序员放到缓冲溢出、堆损坏和烂指针bug的地狱中惩罚。
    这些尊者之智，无名师说，就是了解自身之愚。
}
# 黑客搞建设，骇客搞破坏。

church_and_market(大教堂和集市){
只要眼睛多，bug容易捉。
1. 好的软件作品，往往源自于开发者的个人需要。
2. 优秀的程序员知道写什么，卓越的程序员知道改写(和重用)什么。
    以Linus Torvalds为例，他并没有尝试从零开始写Linux，而是以重用Minix(一个用于PC机的迷你型UNIX类操作系统)
的代码和理念作为开始，虽然Linux中所有Minix代码最终都被移除或重写，但它在Linux成长初期确实起到了类似脚手架的作用。
3. 计划好扔掉一个吧，迟早你会这么做的。或者可以这么说：在你第一次把问题解决的时候，你往往并不了解这个问题，
   第二次你才可能知道怎么把事情做好。所以，如果你想做对事情，至少要再做一次。
4. 如果你有正确的态度，有趣的事情自然会找到你。
5. 当你对一个程序不再感兴趣时，你最后的责任就是把它交给一个可以胜任的接棒者。
6. 把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径。
   尽早和尽量频繁发布是Linux开发模式中至关重要的一部分
7. 早发布，常发布，倾听用户的反馈。
   Linus不是(至少现在还不是)一个富有创造性的设计天才，他更像是一个工程实施上的天才，他具备一种避免bug和防范开发走入死胡同的第六感，
   而且有一种能发现从A点到B点最省力路径的真本事，事实上，Linux的整个设计，都透露着这种特质，并反映了Linus那种本质上保守而简洁的设计取向。
8. "只要眼睛多，bug容易捉。"我把它称为"Linus定律"。
9. 聪明的数据结构配上愚笨的代码，远比反过来要好得多。
10. 如果你把beta测试者当做最珍贵的资源对待，他们就会成为你最珍贵的资源。
11. 仅次于拥有好主意的是，识别来自用户的好主意，有时后者会更好。
12. 通常，那些最有突破性和最有创新力的解决方案来自于你认识到你对问题的基本观念是错的。
13. 设计上的完美不是没有东西可以再加，而是没有东西可以再减。
14. 任何工具都应具备预期内的功能，但一个伟大的工具能给你带来预期外的功能。
15. 写网关类软件时，尽可能不要干扰数据流，而且绝不要扔掉信息，除非接收方强迫你这么做。
16. 当你的语言还远不是图灵完备(Turing-complete)的时候，语法糖[4]会让你受益良多。
17. 系统的安全性只取决于它所拥有的秘密。谨防虚假的秘密。

# 黑客解决问题并做出东西，他们相信自由，并自愿地互相帮助。要想被别人认可是一名黑客，你的行为必须要表现出你拥有这种态度。
}

callback(回调函数){
回调函数：数据处理过程中，阻塞在特定位置的数据被回调处理的过程。
1. 回调是一种数据接收和数据处理分离的机制；数据处理过程的阻塞点。
2. 回调形如面向对象的多态，将不同的调用函数抽象成相同的接口。
avl_tree和qsort之类的回调函数。设定了回调函数的数值和回调函数的返回值。

注意：1. 回调以数据为中心；体现出不同数据关联不同回调函数；
      2. 以更加模块化为向导；
      3. 回调函数以协议语义为内外部逻辑。同时涉及参数返回值和函数返回值两方面。
      
优点
    DRY，避免重复代码。
    可以将通用的逻辑抽象。
    加强代码可维护性。
    加强代码可读性。
    分离专职的函数。
    
使用场景
    异步编程。
    事件监听、处理。
    setTimeout、setInterval方法。
    通用功能，简化逻辑。
    
回调函数使用的场合：
1. 异步数据处理
2. 上下层之间的数据交换
}
callback(hooking){
callback技术相当于底层函数留了接口(比如函数参数有一个函数指针)，然后这个底层的函数在适宜的时候调用应用传入的函数。这个传入的函数称为回调函数。
而hooking技术可以更为底层，可能是系统留有后门可以让我们用自己定义的函数代替系统的特定函数，来修改或增加相应底层函数的功能。
总的来说，callback没有改变底层，只是上层告诉了底层一个方法，底层会在适宜的时候进行调用运行；而hooking改变了底层，底层的函数以某种方式被程序员重新定义了，从根本上影响了上层调用相应底层函数的所有应用。
}

link(en|zh){
http://www.faqs.org/docs/artu/ch01s06.html
http://book.csdn.net/bookfiles/34/10034992.shtml
}
OO(过程式 VS 面向对象){
1. 过程式代码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新的函数。
2. 面向对象代码便于在不改动既有函数的前提下添加新类。反

3. 过来讲也说的通,过程式代码难以添加新数据结构，因为必须修改所有函数，
4. 面向对象代码难以添加新函数，因为必须修改所有类。
}
OO(封装:继承:多态){
封装：使公民拥有 个体 身份，须对自己负责
继承：使公民拥有 家庭 身份，须对家庭负责
多态：使公民拥有 社会 身份，须对社会负责
}
OO(MVC){
MVC 是 Model、View、Controller 的缩写(如上图):
1.模型(Model):
  是应用程序的主体部分，所有的业务逻辑都应该在此体现。

2.视图(View):
  是应用程序中负责生成用户界面的部分。
  也是在整个 MVC 架构中用户唯一可以看得见的一层，接收用户的输入，显示处理结果。

3.控制器(Control):
  根据用户的输入，选择相应的模型，并将用户的输入数据交给相应的模型处理，
  最后将模型处理的结果(及数据)交给相应的视图显示。

注：视图和模型与控制器的关系是多对一，视图和模型可以一或多个，而控制器仅且只有一个。
}
OO("开-闭"原则Open-Closed principle){
一个软件实体应当对扩展开放，对修改关闭。
  这个原则说的是，在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。
  换言之，应当可以在不必修改源代码的情况下改变这个模块的行为。
}
OO(里氏替换原则Liskov Substitution Principle){
只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常，
  我们根本不需要知道是父类还是子类。
  需要注意的是：有子类出现的地方，父类未必就能适应。
  采用里氏替换原则目的是增强程序的健壮性，版本升级时也可以保持非常好的兼容性，
  即使增加新子类，原有的子类还可以继续运行。
}
OO(依赖倒转原则DIP){
要依赖于抽象，不要依赖于具体。
# 要依赖于接口，不要依赖于实现。
  在实际编程中，我们一般需要做到如下三点：
  1)低层模块尽量都要有抽象类或接口，或者两者都有。
  2)变量的声明类型尽量是抽象类或接口。
  3)使用继承时遵循里氏替换原则。
见"代码大全"之"不要让 ADT 依赖于储存介质"
}
OO(接口隔离原则Interface Segregation Principle){
使用多个专门的接口比使用单一的总接口要好。
  一个类对另外一个类的依赖性应当是建立在最小的接口上的。
  即不要强迫一个类使用它不用的方法，如果强迫一个类使用它们不使用的方法，
  那么这个类就会面临由于这些不使用的方法的改变所带来的改变。
  注：
  冗余就是灵活性和健壮性的杀手！
  无论软件接口设计还是数据库表设计，一切设计不要冗余！
}
OO(合成/聚合复用原则Composite/Aggregate Reuse Principle){
又称合成复用原则(CRP)，就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；
  新的对象通过向这些对象的委派达到复用已有功能的目的。
  要尽量使用合成/聚合，而尽量不使用继承。
  应首先使用合成/聚合，合成/聚合则使系统灵活，其次才考虑继承，达到复用的目的。
  使用继承时，要严格遵循里氏替换原则。
  有效地使用继承会有助于对问题的理解，降低复杂度，
  而滥用继承会增加系统构建、维护时的难度及系统的复杂度。
  注：
  合成：由部分组成整体。
  　　　合成表示一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。
  聚合：分散的聚集到一起。
  　　　聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但是B对象并不是A对象的一部分。
  在设计中，聚合不应该频繁出现，这样会增大设计的耦合度。
  耦合度(Coupling)是对模块间关联程度的度量。
  耦合的强弱取决与模块间接口的复杂性、调用模块的方式以及通过接口传送数据的多少。
}
OO(迪米特法则Law of Demeter){
又称最少知识原则(Least Knowledge Principle)，就是说一个对象应当对其他对象尽可能少的了解。
  1)每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；
  2)每个单元只能和它的朋友交谈：不能和陌生单元交谈；
  3)只和自己直接的朋友交谈。
  信息的隐藏非常重要的原因在于，它可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用、阅读以及修改。
}
ThoughtWorks(程序员书单){
Coding Practice  | 编程实践
-------------------------------------------------------------------------------
基础篇
Clean Code《代码整洁之道》
Pragmatic Unit Testing《单元测试之道》
The Productive Programmer《卓有成效的程序员》
Test-Driven Development By Example《测试驱动开发》
Clean Coder《程序员的职业修养》
The Art of Readable Code《编写可读代码的艺术》

进阶篇
Refactoring to Patterns《重构与模式》
Implementation Patterns《实现模式》
Code Complete《代码大全》
The Pragmatic Programmer《程序员修炼之道》

高级篇
Structure and Interpretation of Computer Programs《计算机程序的构造和解释》
Working Effectively with Legacy Code《修改代码的艺术》

Architecture & Design | 架构与设计
-------------------------------------------------------------------------------
基础篇
Agile Software Development 《敏捷软件开发：原则、实践与模式》
Head First Design Patterns《深入浅出设计模式》
Design Patterns 《设计模式》

进阶篇
The Art of UNIX Programming 《Unix编程艺术》
Practical API Design 《框架设计的艺术》
Domain Specific Languages 《领域特定语言》
Patterns of Enterprise Application Architecture 《企业应用架构模式》

高级篇
Release It Domain-Driven Design 《领域驱动设计》
Enterprise Integration Patterns《企业集成模式》
Beautiful Architecture《架构之美》
Pattern-Oriented Software Architecture《面向模式的软件架构》

Methodology | 方法学
-------------------------------------------------------------------------------
基础篇
User Stories Applied《用户故事与敏捷方法》
The Gold Mine《金矿》
Scrum and XP From the Trenches《硝烟中的Scrum和XP》
Continuous Integration《持续集成》
Extreme Programming Explained《解析极限编程》

进阶篇
Lean Thinking《精益思想》
Continuous Delivery《持续交付》
How Google Tests Software Agile Testing Extreme Programming Refactored《重构极限编程》

高级篇
Specification By Example

Thought & Leadership | 思想与领导力
-------------------------------------------------------------------------------
基础篇
The Effective Executive《卓有成效的管理者》
Are Your Lights On?《你的灯亮着吗》
Becoming A Technical Leader《成为技术领导者》

进阶篇
The Fifth Discipline《第五项修炼》
The Design Of Business Management 3.0《管理3.0：培养和提升敏捷领导力》
Presentation To Win The McKinsey Way《麦肯锡方法》

高级篇
Thinking, Fast and Slow《思考快与慢》
}

ThroughWork(状态){
习惯用快捷键不喜欢用鼠标，
习惯用JetBrains系列的IDE，
习惯重构，
习惯TDD，
习惯了交换键盘，
CI红了要修，
看不惯浪费，
不喜欢无所事事，
喜欢分享，
喜欢读书，
对技术和新东西有热情。
}

project(Brooks定律){
1. Fred Brooks观察到程序员的工作时间是不可替代的：在一个误了工期的软件项目中增加开发人员只会让它拖得更久，
2. 项目的复杂度和通讯开销以开发人员的平方增长，而工作成绩只是以线性增长，
---------------------------------------
    Weinberg观察到在开发人员不顽固保守自己的代码，鼓励其他人寻找错误和发展潜力的地方，
软件的改进的速度会比其他地方有戏剧性的提高。
}

Weinberg(理解并接受自己会犯错的事实){
1. 理解并接受自己会犯错的事实 – 犯错无法避免，关键要在错误进入生成环境前及时找出。幸好除了一小部分需要在 
   JPL(喷气推进实验室)开发火箭指导软件的程序员外，大部分程序员都不会因错误招致生命危险。所以我们要从
   错误中学习，改过并继续前行。
}
Weinberg(公正地处理代码){
1. 公正地处理代码 – 要记住，代码审查是为了找出问题，并且最终一定会发现问题所在。不要因为代码中的某一
   错误而对人产生偏见。
}
Weinberg(山外有山，人外有人){
1. 不管你怀揣了多少"秘笈"，都不要低估了别人的水平。只要你愿意开口请教，一定会有人教你你所不知道的东西。
   当你认为某件事没有必要做的时候，不凡问问他人的建议。
}
Weinberg(不在没有协商的情况下重写代码){
1. "修复代码"和"重写代码"有明显的区别。要了解它们之间的差异，并在代码审查的框架内进行程式化的变更，
而不是孤军奋战。
}
Weinberg(尊重求教者，并耐心待之){
1. 与技术人员打过交道的非技术人员通常会认为：这些专业人士虽技术知识过硬，但妄自尊大。因此，
   我们要用耐心和谦和来消除他们对技术人员的误解。
}
Weinberg(世界唯一的不变就是改变){
1. 对世界敞开胸怀，微笑着拥抱变化。把每次需求、平台或者工具的变化看做是一次挑战，而不是一堆麻烦。
}
Weinberg(真正的权威来源于才能，而非职位){
1. 知识造就权威，权威带来尊重。所以，如果你想在一个无我的环境中得到尊重，先积累知识吧。
}
Weinberg(坚定自己的立场，优雅地面对挫折){
1. 你的想法有时候会被推翻。即使你能证明它是对的，也不用试图报复反对它的人，不要大声嚷嚷：
"我早就说过……"。不要把被推翻的想法看做是牺牲品，也不要把它当初战败的哀嚎。
}
Weinberg(不要封闭自己 ){
1. 不要成为一个在小黑屋写代码的人，只在买可乐的时候才出来一下。这样你会失去与外界的联系，
    淡出人们的视线，失去控制。在开放的协作环境里，你会失去自己的位置。
}
Weinberg(对"码"不对人){
1. 批评代码，而不是编码的人。尽可能的让你的言论积极向上，带动代码质量的提升。
   多多谈及局部标准、程序规范和更好的性能等。
}

RFC(RFC 822){
信头字段 目的
From 邮件作者
Sender 发信人
Reply-To 回邮地址
To 收信人地址
CC 抄送：另一个收信人地址
BCC 密送：收信人地址，但其它收信人看不到这个收信人的地址。
Subject 主题
Comments 备注
Keywords 关键字，用来进一步搜索邮件
In-Reply-To 被当前邮件回复的邮件的ID
References 几乎同In-Reply-To一样
Encrypted 加密邮件的加密类型
Date 发信日期
# 在这种元格式中，记录属性每行存放一个，以类似邮件头字段名的标记命名，用冒号后接空白作为结束。
# 字段名不得包含空格；通常用横线代替空格。
# 该行的其余部分都是属性值，除了结尾的空格和换行。
# 以tab(制表符)或whitespace(空格符)开始的物理行被解释为当前逻辑行的延续。
# 空行可能被解释为记录的结束，也可能表明接下来是非结构化的文本。
}
RFC(RFC 2822){
MIME:Multipurpose Internet Mail Extension 多用途网际邮件扩充协议。
提供了在RCC822格式信息中嵌入类型化二进制数据的方法。

}
# 那些类似DSV文件，但又有可变字段数据而且可能伴随无结构文本的字段属性关系集合。
Cookie-jar(cookie-jar 保存的数据只是一个列表){
CookieJar就是一个cookie文件,在其他语言中就是实现保存cookie的包。
cookie-jar格式是fortune程序为随机引用数据库而使用的一种格式。这种很适用记录只是一堆非结构化文本的情况。


# 简单适用跟随%%的新行符(或者有时只有一个%)作为记录分隔符。
# 寻找记录分隔符时接受%后的空格是个好做法，有助于解决人为编辑的错误。更好的做法就是使用%%，并忽略%%到行结束处的所有文本。

如果要保存的数据只是一个列表(List)，cookie-jar文件显然是很合适的。
cookie-jar & record-jar
---------------------------------------
some text
%
some text 2
some text 2.2

用两个'%'字符会显得更醒目一些。
---------------------------------------
some text
%%
some text 2
some text 2.2

加一个键值
如果要把他变成字典，可以试试下面这样：
---------------------------------------
%% key1
some text
%% key2
some text 2
some text 2.2
%%
最后一个'%%'为了方便判断记录结束(否则需要判断文件结束)。
}

ini(ini文件适合用来保存配置数据){
这样的格式.适合场景：数据围绕指定的记录或部分能够自然分成'名称-属性对'两层组织结构。

ini文件适合用来保存配置数据。
---------------------------------------
dir = /some/path/to/dir

[cache]
cache.dir = cache_dir

[db/mysql]
user = root
passwd = notell
; comment line

ini文件所表示的信息，以数据结构来说，可以认为是一个字典(dict 或 map)。
注释行可以用特殊字符';'(分号)或者'#'来标识。

多维字典
---------------------------------------
根据需要也可以解析为一个多维字典。
每一个section的标题可以近作为注释或分类用，也可以作为二维字典的键值
section的标题和字段名可以通过分隔字符(比如'.'或'/')进一步划分层次，从而表示多维数组。

数组
---------------------------------------
借鉴PHP的做法，可以用带[]的关键字来描述数组。
path[] = path_1
path[] = path_2
}
xml(利弊){
    XML格式，适合复杂递归和嵌套数据结构的格式，并且经常可以在无需知道数据语义的情况下仅通过语法检查就能
发现形式不良损坏或错误生成的数据。缺点在于无法跟传统unix工具协作。
    选择xml可以简化问题，也可能使问题复杂化。对它的大肆捧吹很多，但不要不加批判地采用或拒绝，
否则就会成为时尚的牺牲品。请谨慎选择牢记KISS原则。
}

Concurrency(并发编程的 15 条建议){
1. Know your cold paths from your hot paths. 弄清楚代码里的热门执行路径和冷门执行路径。
对冷门路径，用粗粒度的锁即可。对热门路径——也就是那些必须高度并发才能实现所期望的高吞吐量的代码，应该更加小心，加锁的策略必须简单明了且细粒度。

2. Intuition is frequently wrong—be data intensive. 直觉常常是错的，要靠数据说话。
【陈硕】比如线程切换到底有多大开销，普通 mutex 加锁到底有多大代价，系统调用的开销如何，gettimeofday() 在 x86-64 Linux 是不是真的系统调用等等，都要靠数据说话。

3. Know when—and when not—to break up a lock. 知道什么时候把一个锁拆成多个，并知道什么时候不必这样做。
除了把全局锁拆成多个锁，另外一种常用的避免线程争用 (contention) 的办法是减少加锁的范围。比方说从共享的数据结构里移除 (remove and delete) 元素，其实 delete 这一步可以放到锁外面。

4. Be wary of readers/writer locks. 警惕读写锁。
初学者常犯的一个错误是，见到某个数据结构频繁读而很少写，那么就把 mutex 替换为 rwlock。这不见得是正确的。
【陈硕】这条深得我心，muduo thread lib 目前就没有提供读写锁的封装。另外，这一条也能鉴别另一篇关于线程争用的文章不靠谱。
5. Consider per-CPU locking. 考虑用每个 CPU 用一个锁。

6. Know when to broadcast—and when to signal. 知道什么时候用单个唤醒，什么时候用广播唤醒。
notifyAll() 通常表示状态变更，而 notify() 通常表示资源变得可用。滥用 notifyAll() 会导致惊群现象。
【陈硕】 muduo thread lib 的 ThreadPool 区分使用 notify() 和 notifyAll()，可作参考。

7. Learn to debug postmortem. 学会验尸。
【陈硕】 在程序中只使用 Scoped locking 来加锁的话，很容易从 call stack 查出死锁。参考《多线程服务器的常用编程模型》第 6 节 线程间同步。

8. Design your systems to be composable. 设计系统(s)，使之能相互组合。
【陈硕】 比方说，把对对象的修改操作都挪到同一个线程，这样就不必加锁。参考 muduo 的 EventLoop::runInLoop()。
9. Don’t use a semaphore where a mutex would suffice. 如果 Mutex 就能解决问题的话，不要使用信号量 semaphore。
【陈硕】muduo thread lib 有意识地不提供信号量的封装。

10. Consider memory retiring to implement per-chain hash-table locks. 
考虑用内存“退休”法来实现哈希表的按桶加锁。

11. Be aware of false sharing. 知道什么是伪共享。
跟多 CPU 的 Cache 有关，值得了解。

12. Consider using nonblocking synchronization routines to monitor contention. 
考虑使用非阻塞的加锁来观察线程争用。

13. When reacquiring locks, consider using generation counts to detect state change. 
在重新加锁时，考虑使用版本号来检测状态变更。

14. Use wait- and lock-free structures only if you absolutely must. 
只在别无它法时才使用无锁数据结构。

15. Prepare for the thrill of victory—and the agony of defeat. 
准备接受成功的喜悦和失败的痛苦。
}
http://www.jianshu.com/p/9b57bb2be18e
https://segmentfault.com/
https://www.stackoverflow.com

[编程范式与OOP思想(郑晖).md]
https://github.com/zyxstar/md_note/blob/master/docs/DesignE7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E4%B8%8EOOP%E6%80%9D%E6%83%B3(%E9%83%91%E6%99%96).md
[类级别设计原则]
https://github.com/zyxstar/md_note/blob/master/docs/Design/OOD_principles(RobertC.Martin).md
