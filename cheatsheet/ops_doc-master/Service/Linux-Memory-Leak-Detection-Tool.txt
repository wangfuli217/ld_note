http://www.cnblogs.com/LittleHann/p/4353145.html

1. 内存使用情况分析
    0x1: 系统总内存的分析

可以从proc目录下的meminfo文件了解到当前系统内存的使用情况汇总，其中
可用的物理内存 = memfree + buffers + cached
当memfree不够时，内核会通过回写机制(pdflush线程)把cached和buffered内存回写到后备存储器，从而释放相关内存供进程使用，或者通过手动方式显式释放cache内存：
echo 3 > /proc/sys/vm/drop_caches

    0x2: 进程使用内存统计
在32位操作系统中，每个进程拥有4G的虚拟内存空间，其中0~3GB是每个进程的私有用户空间，这个空间对系统中其他进程是不可见的。3~4GB是linux内核空间，由系统所有的进程以及内核所共享的。通过访问/proc/{pid}/下相关文件，可以了解每个线程(进程)虚拟内存空间的使用情况，从而了解每个线程(进程)所消耗内存的多少
可以通过查看/proc/{pid}/maps文件来获取相关的虚拟地址空间内容


2. 内存泄漏(memory leak)
内存泄漏(memory leak)，指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况
在编程时进行动态内存分配是非常必要的，它可以在程序运行的过程中帮助分配所需的内存，而不是在进程启动的时候就进行分配。然而有效地管理这些内存同样也是非常重要的
在大型的、复杂的应用程序中，内存泄漏是常见的问题，当以前分配的一片内存不再需要使用或无法访问时，但是却并没有释放它，那么对于该进程来说，会因此导致总可用内存的减少，这时就出现了内存泄漏

    0x1: 内存泄漏的发生方式
        1. 常发性内存泄漏
        发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏 
        
        2. 偶发性内存泄漏
        发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要
        
        3. 一次性内存泄漏
        发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅有一块内存发生泄漏
        
        4. 隐式内存泄漏
        程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏

    0x2: 常用内存泄漏检测工具
        1. Valgrind: Debugging and profiling Linux programs, aiming at programs written in C and C++ 
        2. ccmalloc: Linux和Solaris下对C和C++程序的简单的使用内存泄漏和malloc调试库 
        3. LeakTracer: Linux、Solaris和HP-UX下跟踪和分析C++程序中的内存泄漏 
        4. Electric Fence: Linux分发版中由Bruce Perens编写的malloc()调试库 
        5. Leaky: Linux下检测内存泄漏的程序 
        6. Dmalloc: Debug Malloc Library 
        7. MEMWATCH: 由Johan Lindh编写，是一个开放源代码C语言内存错误检测工具，主要是通过gcc的precessor来进行 
        8. KCachegrind: A visualization tool for the profiling data generated by Cachegrind and Calltree

Valgrind使用

Valgrind是一套Linux下，开放源代码(GPL V2)的仿真调试工具的集合。Valgrind由内核(core)以及基于内核的其他调试工具组成。内核类似于一个框架(framework)，它模拟了一个CPU环境，并提供服务给其他工具: 而其他工具则类似于插件(plug-in)，利用内核提供的服务完成各种特定的内存调试任务
Valgrind包括如下一些工
    1. Memcheck
    这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分，Valgrind 中包含的 Memcheck 工具可以检查以下的程序错误
        1) 使用未初始化的内存 (Use of uninitialised memory)
    　　    2) 使用已经释放了的内存 (Reading/writing memory after it has been free’d)
    　　    3) 使用超过malloc分配的内存空间(Reading/writing off the end of malloc’d blocks)
    　　    4) 对堆栈的非法访问 (Reading/writing inappropriate areas on the stack)
    　　    5) 申请的空间是否有释放 (Memory leaks – where pointers to malloc’d blocks are lost forever)
    　　    6) malloc/free/new/delete申请和释放内存的匹配(Mismatched use of malloc/new/new [] vs free/delete/delete [])
    　　    7) src和dst的重叠(Overlapping src and dst pointers in memcpy() and related functions)
    　　    8) 重复free
    
    2. Callgrind
    它主要用来检查程序中函数调用过程中出现的问题
    
    3. Cachegrind
    它主要用来检查程序中缓存使用出现的问题
    
    4. Helgrind
    它主要用来检查多线程程序中出现的竞争问题
    
    5. Massif
    它主要用来检查程序中堆栈使用中出现的问题
    
    6. Extension
    可以利用core提供的功能，自己编写特定的内存调试工具
    
valgrind --tool=memcheck --leak-check=full /home/zhenghan.zh/memcheck/sample

https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/
http://blog.csdn.net/hnlyyk/article/details/49176501