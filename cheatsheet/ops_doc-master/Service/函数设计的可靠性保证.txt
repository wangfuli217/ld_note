函数设计的可靠性保证
    函数大概是程序设计中最小的组织单位，也是至为关键的组织单位，怎么设计好函数及
函数之间的关系，才能提高函数及整个程序的可靠性？
    下文探讨函数错误处理设计的一些理念、要求及方法，以满足不同的可靠性要求。
    
一、可靠性保证级别的分类
    函数调用过程中可能发生错误，根据错误发生时系统状态破坏程度和错误的严重程度，
可能采用不同的处理措施，不同的处理措施可以达到不同的可靠性保证级别。
大致可以把函数调用的可靠性保证级别分为这么几个级别：
    绝对成功保证；
    事务级别；
    系统可恢复；
    错误不可知；

二、可靠性保证级别的区分方法
1. 绝对成功保证
函数运行过程中不会发生错误，或者发生的错误已经使用了备用措施解决。
比如：读取配置失败时，自动赋予了一个默认值。

2. 事务级别
    调用要么完全成功，要么没有变化，系统状态跟函数没调用一样。调用过程中破坏的系统状态，
自动恢复到调用函数时那个状态或与之等价的状态。
比如：给若干个指针分配内存，当其中一个分配失败时，自动把其它几个也释放掉，系统状态回到调用时。

3. 系统可恢复
    系统无法精确恢复到调用时的状态，但是调用者可以检测到错误，并通过错误恢复手段恢复
到函数调用之前的某一个确定状态。
根据系统状态的破坏程度和恢复手段又可分为3类：
  可自动恢复的确定状态
    系统状态发生了不可逆变化，但是这种状态影响范围是确定的。这种变化产生的副作用可以通过程序自动消除，但是系统可能损失部分已有信息。
    比如：往数组中拷贝一段数据过程中失败了，原有数据已经被破坏，此时状态是确定的，通过重新载入数据，或重新初始化为0一类的手段，程序还可以继续运行。

  可自动恢复的不确定状态
    系统处于一种不确定状态，无法明确系统状态的破坏的具体情况。系统需要通过重启程序，或者通过重启系统才能重新运行。
    比如：内存拷贝溢出，破坏了堆栈，程序必须重启；消息处理状态机出现异常情况，影响到相互通讯的若干个程序，而且这些程序无法恢复到一个一致状态，只好重启系统或子系统。
    
  人工干预
    系统处于一种不确定状态，而且函数调用副作用必须通过人工干预才能恢复正常。
    比如：系统配置文件被破坏，需要重新安装；磁盘分区失败，需要重新格式化，或者更换硬件。
    
4. 错误不可知
该函数没有任何错误信息返回，调用者没有任何手段知道该函数是否运行正常。这种情况可以明确为一种bug。
比如：多线程同时访问了公共资源，但没做好同步措施，导致系统已经处于不一致，而调用者根本无法检测出来。

三、各类程序应该达到的可靠性保证级别
    对于长时间运行的服务程序来说，每个函数都应该做到“事务级别”的可靠性保证。
如果实在无法做到，那也应该达到“系统可恢复”中的自动恢复级别，
对于仅能达到这个级别的函数调用，设计文档中应该明确说明，并且在代码中注释。
任何程序都不应该出现“错误不可知”的情况。


四、满足可靠性保证的措施
程序运行过程中，由于环境限制、用户意外操作等原因，总是可能发生各种各样的错误，怎么应对这些错误，保证函数能够满足必要的可靠性保证级别？
常见的措施大概有几种：
    事先检测正常运行的条件是否满足，不满足则不执行；
    事先把正常运行需要的资源都申请好，不成功则不执行；
    事先备份可能被破坏的数据结构，一旦发生错误则执行恢复；
    发生错误后，尝试替代方案；
    发生错误后，执行逆向运算；
    发生错误后，尝试再次运行；
    发生错误后，丢失部分信息，恢复到之前的某个状态或默认态；
    发生错误后，提示用户手动干预；
其中前6种可以达到事务级可靠性，第7种只能达到可恢复级的可靠性；


程序逻辑是一层层的函数调用组成的。错误处理很多时候需要调用者和被调用者合作完成，这两者之间又应该遵从什么协定，保证错误处理能够和谐完成？
  1. 底层函数检测错误，上层函数处理错误；
    底层函数缺少必要的上下文，所以不能做合理的错误处理，具体的错误处理决策应该由上层函数完成。
    比如：同样是文件打开失败，上层函数可以根据需要选择退出程序、终止尝试、打开另一个文件，恢复默认等等措施，文件打开函数fopen本身是不知道应该选择哪种措施的，所以它应该返回错误信息供调用者决策。
    有一个著名的反例：在DOS中，打开一个存放于软盘的文件，如果软盘损坏或不存在，DOS系统会打印提示信息，然后等待用户“Abort,Retry,Fail”，这种错误处理措施非常粗暴，对于无人监控设备或者图形程序来说，简直是一场灾难。

  2. 函数破坏的现场应该自己恢复，不将责任转移给调用者；
    比如：函数分配的内存需要自己释放，注册的钩子需要反注册，等等。极少的情况下，可以例外，比如，上层已经提供了回收或簿记机制，上层在出错时会统一进行错误处理。比如大家都很熟悉的在程序退出时自动回收资源的机制。有了这种机制，出错时退出程序就万事大吉、不用一一处理。
    
  3. 早检查、早处理；
    在最早可以检测出错误的地方进行检测，并截断错误的传播，防止错误的进一步扩大。如果不能做到无副作用的处理这个错误，必须把错误上下文信息记录下来，供后续调试排障。在最早可以检测出错误的时机检测并记录信息，更容易定位出现问题的第一因。
    比如，如果接受到的消息有错误，马上打印错误信息，那么很容易定位这个问题的责任人。但是，如果没有检查消息的有效性，允许数据进入后续计算环节，那就很难断定到底是后续计算过程出错，还是消息本身不正确了。这会给问题定位带来很大的副作用。
    
    