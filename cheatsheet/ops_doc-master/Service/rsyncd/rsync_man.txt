https://www.cnblogs.com/f-ck-need-u/p/7220009.html
# 增量拷贝算法 + quick-check算法 + pipeline管道模型传输文件 + exclude和exclude-from选项 + 支持匿名或可身份认证的rsync daemon模式
# 快速且功能非常丰富的文件拷贝工具(可以在本地和远程之间通过shell或rsync服务互相拷贝文件)
rsync的原始目的是实现两端主机的文件同步(可以保持原来文件的权限、时间、软硬链接等附加信息)
rsync以其增量拷贝算法而出名，只拷贝源和目标不同的文件部分，因此减少网络.

增量拷贝算法.txt
quick-check算法.txt
web代理.txt

yum install -y lua lua-devel lsyncd # 配置，参考：https://github.com/axkibe/lsyncd/wiki (lsyncd(rsync+inotify))
lsyncd下载：https://github.com/axkibe/lsyncd/releases
lsyncd文档：https://github.com/axkibe/lsyncd/wiki
双向同步：http://www.cis.upenn.edu/~bcpierce/unison/ unison文档


       间要传输的数据。Rsync每天都被广泛用于做备份、镜像和当作升级版拷贝命令。
-------------------- 定时同步 间隔同步 触发同步 --------------------
    rsync是可以实现增量备份的工具。配合任务计划，rsync能实现定时或间隔同步，配合inotify或sersync，
可以实现触发式的实时同步。
    rsync可以实现scp的远程拷贝(rsync不支持远程到远程的拷贝，但scp支持)、cp的本地拷贝、rm删除和
"ls -l"显示文件列表等功能。但需要注意的是，rsync的最终目的或者说其原始目的是实现两端主机的文件同步，
因此实现的scp/cp/rm等功能仅仅只是同步的辅助手段，且rsync实现这些功能的方式和这些命令是不一样的。
    事实上，rsync有一套自己的算法，其算法原理以及rsync对算法实现的机制可能比想象中要复杂一些。
平时使用rsync实现简单的备份、同步等功能足以，没有多大必要去深究这些原理性的内容。
    但是想要看懂rsync命令的man文档、使用"-vvvv"分析rsync执行过程，以及实现rsync更强大更完整的功能，
没有这些理论知识的支持是绝对不可能实现的。

# rsync 和 scp 之间差别
rsync的目的是实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，
       也可以实现本地不同路径下文件的同步，
       但不能实现远程路径1到远程路径2之间的同步(scp可以实现)。

# rsync 和 cp 之间差别
文件同步，在同步过程中必然会涉及到源和目标两文件之间版本控制的问题，例如
1. 是否要删除源主机上没有但目标上多出来的文件，
2. 目标文件比源文件更新(newer than source)时是否仍要保持同步，
3. 遇到软链接时是拷贝软链接本身还是拷贝软链接所指向的文件，
4. 目标文件已存在时是否要先对其做个备份等等。

-------------------- 检查模式 同步模式 --------------------
# rsync同步过程中由两部分模式组成：决定哪些文件需要同步的检查模式以及文件同步时的同步模式。
(1).检查模式是指按照指定规则来检查哪些文件需要被同步，例如哪些文件是明确被排除不传输的。
默认情况下，rsync使用"quick check"算法快速检查源文件和目标文件的大小、mtime(修改时间)是否一致，如果不一致则需要传输。
当然，也可以通过在rsync命令行中指定某些选项来改变quick check的检查模式，
比如"--size-only"选项表示"quick check"将仅检查文件大小不同的文件作为待传输文件。
rsync支持非常多的选项，其中检查模式的自定义性是非常有弹性的。

(2).同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作。
例如上文所说的是否要先删除源主机上没有但目标主机上有的文件，
              是否要先备份已存在的目标文件，
              是否要追踪链接文件等额外操作。
rsync也提供非常多的选项使得同步模式变得更具弹性。

-------------------- 本地同步 shell命令同步 后台任务同步 --------------------
Local:  rsync [OPTION...] SRC... [DEST]                           本地同步
 
Access via remote shell:                                          shell命令同步
  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]               拉 
  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST                 推
 
Access via rsync daemon:                                          后台任务同步 
  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]              拉
        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]拉
  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST                推
        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST  推
        
由此语法可知，rsync有三种工作方式：
(1).本地文件系统上实现同步。命令行语法格式为上述"local"段的格式。
(2).本地主机使用远程shell和远程主机通信。命令行语法格式为上述"Access via remote shell"段的格式。
(3).本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述"Access via rsync daemon"段的格式。
前两者的本质是通过管道通信，即使是远程shell。而方式(3)则是让远程主机上运行rsync服务，使其监听在一个端口上，
等待客户端的连接。

但是，还有第四种工作方式：通过远程shell也能临时启动一个rsync daemon，这不同于方式(3)，
它不要求远程主机上事先启动rsync服务，而是临时派生出rsync daemon，它是单用途的一次性daemon，
仅用于临时读取daemon的配置文件，当此次rsync同步完成，远程shell启动的rsync daemon进程也会自动消逝。
此通信方式的命令行语法格式同"Access via rsync daemon"，但要求options部分必须明确指定"--rsh"选项或其短选项"-e"。

-------------------- 源文件路径 目标文件路径 文件路径格式定义 --------------------
第一个路径参数一定是源文件路径，即作为同步基准的一方，可以同时指定多个源文件路径。
最后一个路径参数则是目标文件路径，也就是待同步方。
  路径的格式可以是本地路径，也可以是使用user@host:path或user@host::path的远程路径，
  如果主机和path路径之间使用单个冒号隔开，表示使用的是远程shell通信方式，而使用双冒号隔开的则表示的是连接rsync daemon。
  另外，连接rsync daemon时，还提供了URL格式的路径表述方式rsync://user@host/path。
  
# 如果仅有一个SRC或DEST参数，则将以类似于"ls -l"的方式列出源文件列表(只有一个路径参数，总会认为是源文件)，而不是复制文件。
如果对rsync不熟悉，可暂先只了解本地以及远程shell格式的user@host:path路径格式。例如：
  
-------------------- 本地同步 命令远程同步实例 --------------------
rsync -r /etc/fstab /tmp             # 在本地同步

rsync -r /etc 172.16.10.5:/tmp       # 将本地/etc目录拷贝到远程主机的/tmp下，以保证远程/tmp目录和本地/etc保持同步
rsync -r 172.16.10.5:/etc /tmp       # 将远程主机的/etc目录拷贝到本地/tmp下，以保证本地/tmp目录和远程/etc保持同步

rsync /etc/                          # 列出本地/etc/目录下的文件列表
rsync 172.16.10.5:/tmp/              # 列出远程主机上/tmp/目录下的文件列表

-------------------- 源路径带不带斜线 --------------------
# 源路径如果是一个目录的话，带上尾随斜线和不带尾随斜线是不一样的，
  不带尾随斜线表示的是整个目录包括目录本身，
  带上尾随斜线表示的是目录中的文件，不包括目录本身。
rsync -a /etc /tmp       # 在/tmp目录下创建etc目录
rsync -a /etc/ /tmp      # 不会在/tmp目录下创建etc目录，源路径/etc/中的所有文件都直接放在/tmp目录下。

-------------------- -R相对路径 --------------------
rsync /etc/fstab /tmp           # 将/etc/fstab拷贝到/tmp目录下。
rsync -r /etc/cron.d /tmp       # 将/etc/cron.d目录拷贝到/tmp下。
rsync -R -r /etc/cron.d /tmp    # 将/etc/cron.d目录拷贝到/tmp下，但要求在/tmp下也生成etc子目录。
# "-R"选项表示使用相对路径，此相对路径是以目标目录为根的。
表示在目标上的/tmp下创建etc/cron.d目录，即/tmp/etc/cron.d，etc/cron.d的根"/"代表的就是目标/tmp。

如果要拷贝的源路径较长，但只想在目标主机上保留一部分目录结构，例如要拷贝/var/log/anaconda/*到/tmp下，
但只想在/tmp下保留从log开始的目录，如何操作？
# 使用一个点代表相对路径的起始位置即可，也就是将长目录进行划分。
rsync -R -r /var/./log/anaconda /tmp  # .表示从/log开始作为拷贝目录

-------------------- --backup备份已存在文件 --------------------
rsync -R -r --backup /var/./log/anaconda /tmp  # 对远程目录下已存在文件做一个备份。
# 这样在目标目录下，已存在的文件就被做一个备份，备份文件默认使用"~"做后缀，可以使用"--suffix"指定备份后缀。
ll log/anaconda/
total 3112
-rw------- 1 root root    6668 Jul 14 12:45 anaconda.log
-rw------- 1 root root    6668 Jul 14 11:44 anaconda.log~
-rw------- 1 root root    3826 Jul 14 12:45 ifcfg.log
-rw------- 1 root root    3826 Jul 14 11:44 ifcfg.log~

-------------------- --backup备份已存在文件 --backup-dir备份文件目录 --suffix备份文件前缀--------------------
# 可以使用"--backup-dir"指定备份文件保存路径，但要求保存路径必须存在。
mkdir /tmp/log_back
rsync -R -r --backup --backup-dir=/tmp/log_back /var/./log/anaconda /tmp
指定备份路径后，默认将不会加备份后缀，除非使用"--suffix"显式指定后缀，如"--suffix=~"。

指定ssh连接参数，如端口、连接的用户、ssh选项等。
>~/.ssh/known_hosts   # 先清空host key以便下面的测试
rsync -e "ssh -p 22 -o StrictHostKeyChecking=no" /etc/fstab 172.16.10.5:/tmp

-------------------- 选项说明和示例 avz --------------------  
-v：显示rsync过程中详细信息。可以使用"-vvvv"获取更详细信息。
-q, --quiet 忽略非错误信息
--no-motd 忽略daemon模式的MOTD信息 (see manpage caveat)
-c, --checksum 基于checksum校验，而非mod-time和size
-P：显示文件传输的进度信息。(实际上"-P"="--partial --progress"，其中的"--progress"才是显示进度信息的)。
-n --dry-run  ：仅测试传输，而不实际传输。常和"-vvvv"配合使用来查看rsync是如何工作的。
-a --archive  ：归档模式，表示递归传输并保持文件属性。等同于"-rtopgDl"。
-A, --acls 保留ACLs (implies --perms)
-X, --xattrs 保留扩展属性
-r --recursive：递归到目录中去。
-d, --dirs 仅传输文件而非递归
-t --times：保持mtime属性。 
# 强烈建议任何时候都加上"-t"，否则目标文件mtime会设置为系统时间，导致下次更新检查出mtime不同从而导致增量传输无效。
-o --owner：保持owner属性(属主)。
-g --group：保持group属性(属组)。
-p --perms：保持perms属性(权限，不包括特殊权限)。
-E, --executability 保留文件的可执行性
--chmod=CHMOD 改变文件或者目录的权限
-D        ：是"--device --specials"选项的组合，即也拷贝设备文件和特殊文件。
-l --links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。
-L, --copy-links 拷贝链接对应的文件或者目录而非链接本身
--copy-unsafe-links 仅不安全的链接才被拷贝
--safe-links 忽略那些链接到目录树外的链接
-k, --copy-dirlinks 将链接翻译成其链接的目录
-K, --keep-dirlinks 将目录链接在接收端转换成目录
-H, --hard-links 保留硬链接
-z        ：传输时进行压缩提高效率。
-R --relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。
--no-implied-dirs 不发送制定目录的属性，避免在目标使用--relative删除连接重新传输文件
--size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。
-u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。
-d --dirs   ：以不递归的方式拷贝目录本身。默认递归时，如果源为"dir1/file1"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。
--max-size  ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如："--max-size=1.5m")
--min-size  ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。
--exclude   ：指定排除规则来排除不需要传输的文件。
--delete    ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意"--delete"是在接收端执行的，所以它是在
            ：exclude/include规则生效之后才执行的。
-b --backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用"~"做后缀。
--backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。
--suffix=SUFFIX 制定备份的后最 (default ~ w/o --backup-dir)
-u, --update 跳过接受端较新的文件
--inplace 直接在文件上更新(SEE MAN PAGE)
--append 直接追加文件
--append-verify 和--append很像, 只是用文件的较旧的那部份做checksum
-e          ：指定所要使用的远程shell程序，默认为ssh。
--port      ：连接daemon时使用的端口号，默认为873端口。
--password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。
                 注意，这不是远程shell认证的密码，而是rsync模块认证的密码。
-W --whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。
--existing  ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。
--ignore-existing：要求只更新目标端不存在的文件。和"--existing"结合使用有特殊功能，见下文示例。
--remove-source-files：要求删除源端已经成功传输的文件。

# 虽然选项非常多，但最常用的选项组合是"avz"，即压缩和显示部分信息，并以归档模式传输。

--------------------  --existing --ignore-existing 检查模式 -------------------- 
"--existing"是只更新目标端已存在的文件。
"--ignore-existing"是更新目标端不存在的文件。
"--remove-source-files"删除源端文件。
     # "--existing"和"--ignore-existing"结合使用时，有个特殊功效，当它们结合"--delete"使用的时候，文件不会传输，
但会删除receiver端额外多出的文件。
  源端已经更新成功的文件都会被删除，源端所有未传输或未传输成功的文件都不会被移除。未传输成功的原因有多种，
  如exclude排除了，
  "quick check"未选项该文件，
  传输中断等等。

rsync -r -v --remove-source-files /tmp/a/anaconda /tmp/a/audit /tmp # 源端文件会被删除，但是目录会被留下
rsync -r -v --existing /tmp/a/ /tmp/b                  # 只更新目标端已存在的文件
rsync -r -v --ignore-existing /tmp/a/ /tmp/b           # 更新目标端不存在的文件
rsync -nrv --delete a/ b/                              # 同步a/ 和 b/ 两个目录之间的文件，保证两者相同，即 b目录有其他文件会被删除
rsync -nrv --existing --ignore-existing --delete a/ b/ # 不同步a/ 和 b/ 两个目录之间的文件，保证两个相同，同时 b目录有其他文件会被删除

"--exclude"排除规则
rsync -r -v --exclude="anaconda/*.log" /var/log/anaconda /var/log/audit /tmp  # 所有"*.log"的文件都不会被传输
注意，一个"--exclude"只能指定一条规则，要指定多条排除规则，需要使用多个"--exclude"选项，
或者将排除规则写入到文件中，然后使用"--exclude-from"选项读取该规则文件。

以下是rsync中的规则种类，不解之处请结合下文的"--delete"分析：
(1).exclude规则：即排除规则，只作用于发送端，被排除的文件不会进入文件列表(实际上是加上隐藏规则进行隐藏)。
(2).include规则：即包含规则，也称为传输规则，只作用于发送端，被包含的文件将明确记录到文件列表中。
(3).hide规则：即隐藏规则，只作用于发送端，隐藏后的文件对于接收端来说是看不见的，也就是说接收端会认为它不存在于源端。
(4).show规则：即显示规则，只作用于发送端，是隐藏规则的反向规则。
(5).protect规则：即保护规则，该规则只作用于接收端，被保护的文件不会被删除掉。
(6).risk规则：即取消保护规则。是protect的反向规则。
除此之外，还有一种规则是"clear规则"，作用是删除include/exclude规则列表。

-------------------- --delete族及exclude -------------------- 
使用"--delete"选项后，接收端的rsync会先删除目标目录下已经存在，但源端目录不存在的文件。也就是"多则删之，少则补之"。
rsync -r -v /etc/cron.d /tmp --delete

如果将"--delete"选项和"--exclude"选项一起使用，则被排除的文件不会被删除
rsync -r /var/log/anaconda /var/log/audit /tmp  # 先进行一次同步以便测试
cp /etc/fstab /tmp/anaconda/                    # 拷贝一个新文件到目标目录以便测试
rsync -r -v --exclude="anaconda/*.log" /var/log/anaconda /var/log/audit /tmp --delete

    在发送端将文件列表发送给接收端后，接收端的generator(要是不知道，你认为是某个就好了)
进程会扫描每个文件列表中的信息，然后对列表中的每个信息条目都计算数据块校验码，最后将数据块
校验码发给发送端，发送端通过校验码来匹配哪些数据块是否需要传输的，这样就实现了增量传输的功能
——只传输改变的部分，不会传输整个文件。而delete删除的时间点是generator进程处理每个文件列表时、
生成校验码之前进行的，先将目标上存在但源上不存在的多余文件删除，这样就无需为多余的文件生成校验码。
    delete动作是比"--exclude"规则更晚执行的，被"--exclude"规则排除的文件不会进入文件列表中，
在执行了delete时会认为该文件不存在于源端，从而导致目标端将这些文件删除。

    rsync为了防止众多误删除情况，提供了两种规则：保护规则(protect)和取消保护规则(risk)。默认情况下，
"--delete"和"--exclude"一起使用时，虽然发送端的exclude规则将文件标记为隐藏，使得接收端认为这些被排除
文件在源端不存在，但rsync会将这些隐藏文件标记为保护文件，使得它们不受delete行为的影响，这样delete就
删除不了这些被排除的文件。如果还是想要强行删除被exclude排除的文件，可以使用"--delete-excluded"选项
强制取消保护，这样即使被排除的文件也会被删除。

除了"--delete"，相关的选项还有"--delete-before"、"--delete-during"、"--delete-delay"等，
它们都隐含了"--delete"选项，
--delete-before 表示generator处理各个文件列表之前一次性全部删除待删除文件、
--delete-during 处理文件列表时处理到哪个文件列表就删除该文件列表中的待删除文件，
--delete-delay  以及同步完所有数据后一次性删除所有待删除文件。


举个例子，假如源端要传输3个目录a、b、c，
在目标端a目录中有a1、a2、a3共3个文件需要被删除，
        b目录中有b1、b2、b3需要删除，
        c目录也一样c1、c2、c3需要被删除。  

如果是"--delete-before"，则在目标端rsync刚启动时，
就会把a1-a3、b1-b3、c1-c3一次性删除，然后才会处理文件列表中的a目录，处理完a后处理b，再是c。
如果是"--delete-during"，则在目标端rsync刚启动时，
先处理文件列表中的a目录，处理a目录时发现此目录中有待删除文件a1-a3，顺手就删除它们，然后完成a目录的相关操作，
再处理文件列表中的b目录，发现也有待删除文件b1-b3，顺手删除它们，同理c1-c3也如此。
如果是"--delete-delay"，则同步完文件列表中的a/b/c目录后，最后一次性删除a1-a3、b1-b3、c1-c3。
其实"--delete"选项大多数情况下默认采用的就是"--delete-during"。

-------------------- -n只测试不传输 -i输出要传输文件的路径 -------------------- 
# 使用"-n"选项是dry run模式，也就是只测试不传输，"-i"选项是输出要传输文件的路径。
rsync -nr -i a b  # 测试从a到b要传输的内容，并显示出来， 这里提示并没有进行 "检查"
rsync -nr -i --exclude="etc"  a b/  # 不包含etc目录中的内容

-------------------- rsync daemon模式 -------------------- 
Linux内核官网www.kernel.org提供rsync的下载方式，官方给出的地址是rsync://rsync.kernel.org/pub，
可以根据这个地址找出你想下载的内核版本。例如要找出linux-3.0.15版本的内核相关文件。

服务器端：
rsync --no-motd -r -v -f "+ */" -f "+ linux-3.0.15*" -f "- *" -m rsync://rsync.kernel.org/pub/
通过rsync可以向外提供文件列表并提供相应的下载。
客户机端：
同样，你还可以根据路径，将rsync daemon上的文件拉取到本地实现下载的功能。
rsync --no-motd -avzP rsync://rsync.kernel.org/pub/linux/kernel/v3.x/linux-3.0.15.tar.bz2 /tmp

-------------------- rsync daemon端口873和--daemon -------------------- 
rsync daemon是"rsync --daemon"或再加上其他一些选项启动的，
它会读取配置文件，默认是/etc/rsyncd.conf，
并默认监听在873端口上。

rsync daemon的通信方式和传输通道与远程shell不同。
    远程shell连接的两端是通过管道完成通信和数据传输的，即使连接的一端是远程主机，当连接到目标端时，
将在目标端上根据远程shell进程fork出rsync进程使其成为rsync server。而rsync daemon是事先在server端上
运行好的rsync后台进程(根据启动选项，也可以设置为非后台进程)，它监听套接字等待client端的连接，连接
建立后所有通信方式都是通过套接字完成的。

注意，rsync中的server的概念从来就不代表是rsync daemon，server在rsync中只是一种通用称呼，只要不是
发起rsync请求的client端，就是server端，你可以认为rsync daemon是一种特殊的server，其实daemon更应该
称之为service。(之所以解释这一点，是避免各位初学的朋友在阅读man rsync过程中产生误解)
Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]                  拉
      rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
Push: rsync [OPTION...] SRC... [USER@]HOST::DEST                    推
      rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST
      
连接命令有两种类型，一种是rsync风格使用双冒号的"rsync user@host::src dest"，
                    一种是url风格的"rsync://user@host:port/src dest"。
对于rsync风格的连接命令，如果想要指定端口号，则需要使用选项"--port"。

其中daemon端的路径，如user@host::src，它的src代表的是模块名，而不是真的文件系统中的路径。

-------------------- daemon配置文件rsyncd.conf --------------------  man rsync | man rsyncd.conf
默认"rsync --daemon"读取的配置文件为/etc/rsyncd.conf，有些版本的系统上可能该文件默认不存在。
rsyncd.conf的配置见man rsyncd.conf。以下是部分内容：

[root@xuexi ~]# cat /etc/rsyncd.conf
# /etc/rsyncd: configuration file for rsync daemon mode
 
# See rsyncd.conf man page for more options.
 
# configuration example:
 
# uid = nobody                                                    全局选项
# gid = nobody                                                    全局选项
# use chroot = yes                                                全局选项
# max connections = 4                                             全局选项
# pid file = /var/run/rsyncd.pid                                  全局选项
# exclude = lost+found/                                           全局选项
# transfer logging = yes                                          全局选项
# timeout = 900                                                   全局选项
# ignore nonreadable = yes                                        全局选项
# dont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2    全局选项
 
# [ftp1]                                [ftp1] 模块; ftp1为模块ID，必须保证唯一，
#        path = /home/ftp               每个模块中必须定义一项"path"，path定义的是该模块代表的路径
#        comment = ftp export area
如果想请求ftp1模块，则在客户端使用"rsync user@host::ftp1"，这表示访问user@host上的/home/ftp目录，
如果要访问/home/ftp目录下的子目录www，则"rsync user@host::ftp1/www"。

-------------------- 配置项 (使用时删除注释)-------------------- 
######### 全局配置参数 ##########
port=888    # 指定rsync端口。默认873
uid = rsync # rsync服务的运行用户，默认是nobody，文件传输成功后属主将是这个uid
gid = rsync # rsync服务的运行组，默认是nobody，文件传输成功后属组将是这个gid
use chroot = no # rsync daemon在传输前是否切换到指定的path目录下，并将其监禁在内
max connections = 200 # 指定最大连接数量，0表示没有限制
timeout = 300         # 确保rsync服务器不会永远等待一个崩溃的客户端，0表示永远等待
motd file = /var/rsyncd/rsync.motd   # 客户端连接过来显示的消息
pid file = /var/run/rsyncd.pid       # 指定rsync daemon的pid文件
lock file = /var/run/rsync.lock      # 指定锁文件
log file = /var/log/rsyncd.log       # 指定rsync的日志文件，而不把日志发送给syslog
dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2  # 指定哪些文件不用进行压缩传输
 
###########下面指定模块，并设定模块配置参数，可以创建多个模块###########
[longshuai]        # 模块ID
path = /longshuai/ # 指定该模块的路径，该参数必须指定。启动rsync服务前该目录必须存在。rsync请求访问模块本质就是访问该路径。
ignore errors      # 忽略某些IO错误信息
read only = false  # 指定该模块是否可读写，即能否上传文件，false表示可读写，true表示可读不可写。所有模块默认不可上传
write only = false # 指定该模式是否支持下载，设置为true表示客户端不能下载。所有模块默认可下载
list = false       # 客户端请求显示模块列表时，该模块是否显示出来，设置为false则该模块为隐藏模块。默认true
hosts allow = 192.168.10.0/24 # 指定允许连接到该模块的机器，多个ip用空格隔开或者设置区间
hosts deny = 0.0.0.0/32   # 指定不允许连接到该模块的机器
auth users = rsync_backup # 指定连接到该模块的用户列表，只有列表里的用户才能连接到模块，用户名和对应密码保存在secrts file中，
                          # 这里使用的不是系统用户，而是虚拟用户。不设置时，默认所有用户都能连接，但使用的是匿名连接
secrets file = /etc/rsyncd.passwd # 保存auth users用户列表的用户名和密码，每行包含一个username:passwd。由于"strict modes"
                                  # 默认为true，所以此文件要求非rsync daemon用户不可读写。只有启用了auth users该选项才有效。
[xiaofang]    # 以下定义的是第二个模块
path=/xiaofang/
read only = false
ignore errors
comment = anyone can access


# 注意：
# (1).客户端推到服务端时，文件的属主和属组是配置文件中指定的uid和gid。但是客户端从服务端拉的时候，
#     文件的属主和属组是客户端正在操作rsync的用户身份，因为执行rsync程序的用户为当前用户。
# (2).auth users和secrets file这两行不是一定需要的，省略它们时将默认使用匿名连接。但是如果使用了它们，
#     则secrets file的权限必须是600。客户端的密码文件也必须是600。
# (3).关于secrets file的权限，实际上并非一定是600，只要满足除了运行rsync daemon的用户可读即可。
#     是否检查权限的设定是通过选项strict mode设置的，如果设置为false，则无需关注文件的权限。
#     但默认是yes，即需要设置权限。

-------------------- rsync daemon实例 --------------------  
useradd -r -s /sbin/nologin rsync
mkdir /{longshuai,xiaofang}
chown -R rsync.rsync /{longshuai,xiaofang}

提供模块longshuai身份验证文件，由于rsync daemon是以root身份运行的，
所以要求身份验证文件对非root用户不可读写，
所以设置为600权限。
echo "rsync_backup:123456" >> /etc/rsyncd.passwd
chmod 600 /etc/rsyncd.passwd 

然后启动rsync daemon，启动方式很简单
rsync --daemon

如果是CentOS 7，则自带启动脚本。
[root@xuexi ~]# systemctl start rsyncd

模块longshuai配置了身份验证功能，所以客户端连接时会询问密码。如果不想手动输入密码，
则可以使用"--password-file"选项提供密码文件，密码文件中只有第一行才是传递的密码，
其余所有的行都会被自动忽略。
echo "123456" > /tmp/rsync_passwd
rsync --list-only --port 888 rsync_backup@192.168.10.107::longshuai/a/b --password-file=/tmp/rsync_passwd
或者
rsync --list-only rsync://rsync_backup@192.168.10.107:888/longshuai/a/b --password-file=/tmp/rsync_passwd











-------------------- 远程shell方式连接使用daemon -------------------- 
本地同步模式、远程shell模式和rsync daemon模式。
前两者是使用管道进行通信和传输数据的，
后者是通过网络套接字进行通信和传输数据的，且rsync daemon要求在server端必须已经运行好rsync且监听在指定端口上。

第4种工作方式：通过远程shell方式连接rsync daemon。也就是将第二种和第三种方式结合起来。

远程shell daemon的方式严格地说是"远程shell通信方式+使用rsync daemon的功能"。
    所以它的通信方式和远程shell是一样的，在客户端发起远程shell连接，在server端fork远程
shell进程以启动rsync进程，但这个rsync进程是临时的rsync daemon，
它只读取配置文件中client所请求的模块部分，且只读取模块部分中的path和身份认证相关内容，
    当rsync操作完成，该rsync daemon就消逝并从内存中被清理。而且，远程shell daemon启动的
临时daemon不会和已经在server端运行的rsync daemon冲突，它们可以并存。由于远程shell连接的
最终目标是rsync模块，所以它只能使用rsync daemon语法。

rsync [options] --rsh=ssh auth_user@host::module
rsync [options] --rsh="ssh -l ssh_user" auth_user@host::module
rsync [options] -e "ssh -l ssh_user" auth_user@host::module
rsync [options] -e "ssh -l ssh_user" rsync://auth_user@host/module

    两个用户ssh_user和auth_user，由于使用的是远程shell通信方式，所以client要和server端建立ssh连接，
ssh_user就是ssh连接server的用户。
    auth_user则是模块中的身份认证用户。如果不指定"ssh_user"，则默认将使用auth_user，但很多时候
auth_user都只是一个虚拟用户，这样就建立不了ssh连接导致失败，所以建议明确指定ssh_user和auth_user。

以下是server端配置文件/etc/rsyncd.conf中的一个模块配置，稍后将从client端使用远程shell方式请求该模块。
[tmpdir]
path=/tmp
auth users=lisi
secrets file=/tmp/lisi_passwd
当前server端是没有rsync daemon在运行的。
[root@xuexi ~]# netstat -tnl
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN    
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN    
tcp6       0      0 :::22                   :::*                    LISTEN    
tcp6       0      0 ::1:25                  :::*                    LISTEN
在客户端上使用以下命令：
[root@xuexi ~]# rsync --list-only -e "ssh -l root" lisi@172.16.10.6::tmpdir
root@172.16.10.6's password:
 
Password:
    可以看到要求输入两次密码，第一次密码是root@XXX的密码，即建立ssh连接使用的密码，
只有建立了ssh连接，才能在server上启动临时rsync daemon。第二次输入的密码Password
是"auth users=lisi"对应的密码。

