单元测试
  功能未写，测试先行
    最理想的情况是在写一个功能的时候，先写一个fail的单元测试，功能完成的标准是看单元测试是否可以由fail变为pass。
    平时在做项目时，在项目紧张的时候一直坚持做到这一点实属不易，但我们至少可以在功能完成后，review一下哪个方法
    需要单元测试，经过单元测试的功能，我们会更有信心的交付这个功能。
    
  不仅仅是测试
    单元测试可以迫使我们的代码接口更加清晰
    易于测试的代码一般也是接口清晰的代码
    
  完善单元测试
    初次单元测试是目标是一些基础功能，当这个模块单元测试ok后仍然有bug，我们需要审视一下我们是否需要完善当前
    的单元测试，之后可以通过单元测试来验证该bug，而不是通过测试人员和最终用户
    
  自动化
    所有单元测试应该在每次功能交付之前自动的运行一次，比如Maven打包的时候会运行test目录下面的所以单元测试，
    有一个fail则打包失败
    
  框架
    测试框架可以提供Assert函数和Mock对象，方便统一运行测试和测试case的管理，常见的测试框架如下：
    Junit for Java
    gtest for C++
    
定义
-------------------
针对程序员的，由程序员完成，也由程序员受益
编写程序时，更多的 单元测试，意味着将来不会为莫明其妙的BUG进行 调试
单元测试是开发者编写一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确， 即一个单元测试用于判断某个特定条件下某个特定函数的行为

我们需要做什么
-------------------
它的行为和我的期望一致吗
它的行为在 特殊情况下 和我的期望一致吗
  参数可疑
  硬盘没有剩余空间
  网络掉线
  用于决定异常的抛出
  根测试驱动开发相结合，如果测试不支持某个用例，说明功能并不完备，所以它是一份好的执行文档

如何进行单元测试
-------------------
程序员编写方法签名
  测试员编写方法的测试用例，估计可能的异常，准备正常数据与异常数据
  程序员完成方法的编码
  测试员进行测试
  测试员与程序员沟通
  
测试框架
  各种断言
  [Suite]返回TestFixture集合,用于构建无人的自动化
  [Category]
  每个方法 [SetUp][TearDown]
  每个类 [TestFixtureSetUp][TestFixtureDown]
  [ExpectedException(typeof(...)]希望该被测试方法能够引发异常
  暂时忽略，将来不忽略[Ignore("...")]

测试内容
-------------------
结果是否正确
  使用测试的数据文件，同时包含预期结果
  
边界条件是否正确
-------------------
来自于职业的敏感，如：
  完全仿造或者不一致的输入数据
  格式错误的数据
  空值或不完整的值
  超出合理范围的值，类似数据库条件约束
  顺序的影响
  
CORRECT原则
-------------------
Conformance 是否符合预期格式
Ordering 一组值是有序的还是无序的
Range 合理的最大值与最小值之间
  开始索引和结束索引
  索引值是负的
  索引值大于允许值
Count不能匹配确切的索引个数
Reference 代码是否引用了不受代码本身直接控制的外部因素
  前条件：
    系统必须处于什么状态下，该方法才能运行
    前提不能满足时，程序的行为仍然是正确的（如没的权限不能阅读的行为发生，特定情况下是忽略请求）
  后条件：执行后相关方法，会保证哪些状态发生
Existence　非null，非0，存在于某个集合中
Cardinality 是否恰好有足够的值 0-1-N
Time 所有事情是否都按顺序发生，是否在正确的时间，是否及时
  相对时间
  绝对时间
  并发问题
  

查一下反向关联
-------------------
  例如插入数据库一条记录，使用查找来验证是否真的插入了
  同时最好反向关联的原理是不一样的，确保不会被同时出现的错误所掩盖
  用其他手段交叉检查一下结果

一种算法可能因为性能原因被采用，测试它时可用 性能不佳但正确的算法 来验证新算法

强制错误条件发生
-------------------
Mock对象强制产生
内存耗光
磁盘用满
时钟出问题
网络不可用
系统过载
受限的调色板
分辨率过高或过低

是否满足性能要求
-------------------
Assert.IsTure(timer.ElapsedTime<3.0)


Mock对象
-------------------
利用断言可以 验证对象的状态，而 感知对象的行为 需要Mock来预期

应用场景
-------------------
真实对象具有不可确定的行为，股票行情
真实对象难以被创建
真实对象的某些行为很难被触发，网络错误
真实对象令程序运行很慢
真实对象有用户界面
测试需要询问真实对象如何被调用的，如回调函数
真实对象实际上并不存在

创建步骤
-------------------
__接口__来描述这个对象(提出依赖要求，针对接口编程)
产品代码实现个接口
以测试为目的，在mock对象中实现这个接口

评价测试
-------------------
自动化
调用测试自动化
检查结果自动化
彻底的
代码覆盖率
可重复
独立的
专业的
开发上的框架
管理上的流程，如不能进入下轮流程的代码：
不完整的代码，对其他文件的依赖
不能编译的代码
没有相应单元测试的代码
不能通过单元测试的代码
通过了自己的测试，但引起其他测试失败

测试的频率
-------------------
编写新的函数
修正BUG后
每次成功编译后
每次对版本控制的签入
定期的构建NAnt

对编程能力的提高
-------------------
设计
-------------------
面向测试的设计，更好的分离关注点
为了更好的测试，进行重构
测试类的不变性
结构化
数学不变性
数据一致性
测试驱动设计，改善接口的设计
无效参数的测试，得看是谁负责检查输入数据的有效性，不可信任域与可信任域

经验
-------------------
测试耗费的时间太多了，意味着将运行时间长的测试分离出来
测试总是失败？意味着程序的耦合度过深
单测能提供代码的快速反馈，小步前进，马上知道程序运行效果
接口测试的脚本可作为安全网，当接口实现修改时，能确保对接口以前客户代码没有影响
dubug的行为无法记录，但测试的脚本确能重放
对于动态语言，没有静态类型的编译，所以没有类型、签名等检查，当需要语义检查（断言，契约）时，单测保证语义正确，而且脚本就相关于文档

敏捷测试培训中有关单测
-------------------
单元测试需要验证的两个方面：状态，行为。当测试一个对象的方法时，需要验证方法的执行是否影响自己的 状态，是否会调用依赖对象的 行为

单元测试的控制点与检查点：
-------------------
控制点 包括直接输入（参数），间接输入（控制被调用函数的返回值）；
检查点 包括直接输出（返回值，状态），间接输出（行为）

测试替身分类：
-------------------
Dummy Object：主要用于类的构造或方法的调用需要一个符合类型的对象，但对该对象的状态或行为并不关心时；
Test Stub：测试对象利用它返回值，让测试对象期望的行为发生；
Test Spies：接收测试对象方法的调用，用于行为检查；
Mock Objects：即可充当stub，也可充当spy；
Fake Objects：生成一个专用的测试类，应用于测试对象依赖类还未实现或过于复杂时
在TDD中有一个FIRST原则(同样适用于单元测试的编写)

为什么要求测试运行时间少于1秒？主要为了使对象尽可能的无依赖。

通过 重构 的技术来提高可测性，如接口提取，依赖注入
-------------------
提高可测性：
-------------------
感知：感知某种方法调用产生的效果或影响（采用mock）；
分离：与应用的其他部份分离开来单独运行（解耦）