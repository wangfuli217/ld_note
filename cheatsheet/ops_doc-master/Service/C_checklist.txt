字符串
学习时间：1 .5 W（“ W ”周，下同）
知识点checklist
1、 strlen()函数的返回值是什么类型的？
2、 字符串strlen() 的值，是否和他占据的内存空间相同？
3、 你是否知道strcpy 函数存在的潜在风险？如何避免？
4、 如果一个字符串没有字符串结束符，而调用str 开头的库函数，会发生什么？
5、 Strcpy(),strcat(),strcmp(),strncpy(),strncat(),strncmp()内部到底是如何运行的？这些函数到底对源字符串和目标字符串做了些什么？你是否观察过它们运行时两个字符串内存的变化？
6、 上面这些函数使用时，各有哪些需要注意的地方？
7、 你会几种字符串查找操作？
8、 c语言中有字符串这个数据类型吗？
9、 对字符串进行操作的时候，是否为字符串结尾符预留存储位置？不然的话容易造成非常访问内存。

 

数组
学习时间：2W
知识点checklist
1、  你肯定知道，定义“int a[10]; ”， a[10] 这个元素是无效的。
2、  你知道几种数组初始化的方法？
3、  数组和指针有千丝万缕的联系而又不同，你是否对他们在不同情况下的使用进行过详细的总结？
4、  “int calendar[10][20]; ”，这是一个什么样的数组？它拥有 10 数组类型的元素，还是 20 个？
5、  “int a[10]; ”，数组名 a 在本质上是一个什么？你是否打印过 a 的值？
6、  你知道几种获取数组某元素的方法？
7、  指针和数组相同吗？什么时候相同？什么时候不同？
8、  用指针和下标访问数组元素，那种方式更快？

 

结构体
学习时间：1W
知识点checklist
1、 你知道什么是位域结构体吗？如何定义它？如何使用它？
2、 你知道字节对齐对结构体占用内存空间大小的影响吗？如何计算结构体占用内存的大小？

宏
学习时间：1W
知识点checklist
1、 你知道宏的本质是什么吗？函数？语句？类型定义？或者其他？
2、 你知道语言设计者为什么设计宏吗？这些原因目前是否仍然成立？
3、 你会设计带有参数的宏吗？
4、 你知道使用宏的参数的的时候的注意事项吗？
5、 你会设计带有可变参数的宏吗？
6、 你知道使用宏有什么劣势吗？
7、 你有没有更好的替代方案？
 
 
枚举
学习时间： 0.5 W
知识点checklist
1、 是否可以指定枚举中各项的值？
2、 如果不指定值，枚举的第一个值是多少？
3、 枚举的值是否可以是负数？
4、 定义枚举的时候，你是否专门定义了枚举的最小值和最大值？


Switch
学习时间： 0.5 W
知识点checklist
1、 switch(c)中的 c 的数据类型有哪些？
2、 你是否在所有的switch 中都加了 default 语句？
3、 是否在所有的case 中都加了 break 语句（一般情况的做法）？如果你不加 break ，将会发生什么？

 

Static
学习时间：1W
知识点checklist
1、  static的三个主要作用是什么？
2、  static的修饰的局部变量是保存在什么地方的？全局变量哪 ?
3、  static修饰的全局变量和函数，在其他的文件中是否可以访问？如何访问？
4、  你知道static 是 c 语言中实现封装和隐藏的利器吗？你是否经常使用？
5、  定义在不同源文件中的static 全局变量，编译器是否允许他们的变量名称相同？他们在内存中的地址是否相同？函数那？

 

const
学习时间：1W
知识点checklist
1、 你是否经常使用const 来表明不能够被更改的变量？
2、 你是否经常使用const 常量来代替宏？
3、 下面四种情况，你知道是各表示什么意思吗？
int  i_value= 10; 
const  int* pvalue = & i_value
int  const *pvalue = & i_value
int*  const  pvalue= & i_value
const  int* const  pvalue = & i_value
4、 你知道const 常量如何初始化吗？

Sizeof
学习时间：1W
知识点checklist
1、  对于字符数组，strlen 和 sizeof 的值是否相同？
2、  S izeof本质上是函数还是宏？
3、  S izeof的返回值是什么类型？

 

 

指针

学习时间：3W
知识点checklist
1、  “int *p; ” &p ， p ， *p 他们的值分别表示什么含义？
2、  你定义的指针初始化了没？
3、  你理解指针的指针的概念吗？你会使用吗？
4、  “int *pi_value;   pi_value  = 0x100000; ” pi_value + 1 的值是是多少？
5、  你会定义函数指针吗？
6、  你会使用函数指针调用函数吗？
7、  关于指针和数组，请参见知识点数组。



动态分配内存
学习时间：1W
知识点checklist
1、  动态分配的内存是保存在什么地方的？
2、  什么情况下使用动态分配内存？
3、  动态申请内存一定要释放，否则会内存泄露。你是否使用过内存检测工具？

 

 

函数
学习时间：1W
知识点checklist
1、  如何查看函数在内存中的地址？
2、  如何给一个函数指针赋值？
3、  你是否会定义可变入参函数
4、  你是否可以区分函数的形参与实参？
5、  如何定义函数名，以准确的表达函数的用途？
6、  你是否使用const 来修饰函数入参和返回值，以表的特定的含义？
7、  递归如何使用？

 

变量
学习时间：1W
知识点checklist
1、  全局变量，局部变量，常量分别保存在内存中的什么地方？
2、  不同类型的变量，你是否知道其作用域？
3、  全局变量和局部变量是否可以重名？你是否在这样做？
4、  局部变量在函数退出后是否有效，为什么？
5、  全局变量为什么不允许定义在头文件中？有何危害？

 

链接 （linux ）
学习时间：1W
知识点checklist
1、  链接位于编译过程的那个阶段？
2、  动态链接库和静态链接库使用时有何区别？
3、  如何 对 动态链接库 进行 动态加载 （不用重启程序而加载链接库）？
4、  动态链接有何优点？
5、  动态链接库中是否定义了非static 的全局变量？你是否知道这是一个非常危险的动作？
6、  动态库中的全局变量（非static ）和函数（非 static ）是否可以和上层全局变量和函数重名？重名后会发生什么事情？

 

 

运行时的数据结构 （linux ）
学习时间：1W
知识点checklist
1、 你知道什么是段的概念吗？
2、 可执行程序可以分为几个段？每个段保存的是什么内容？
3、 如何查看可执行程序各个段的大小？
4、 当函数被调用时发生了什么？
5、 你有没有试过程序的栈空间最大有多大？程序超过此大小会发生什么？
6、 你使用的系统的栈是向下生长的，还是向上生长的？

Include
学习时间： 0.5 W
知识点checklist
1、 如何避免对同一头文件的多次include ？

声明
学习时间： 1 W
知识点checklist
1、 什么是 声明 ，什么是定义？
2、 你是否会运用c 语言声明的优先级规则？



测试非static全局变量
测试程序如下：
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
const int g_int_a = 1000;
int main(){
	printf("g_int_a is %d./n", g_int_a);
		
		
	printf("g_int_a is %d./n", g_int_a);
		
	return 0;
		
}
编译，然后使用命令“size 可执行程序名”查看其段大小。
[root@ss test]# size test
   text    data     bss     dec     hex filename
   1229     280       8    1517     5ed test
之后，将全局变量g_int_a更改为非const，编译，在使用size命令查看：
[root@ss test]# size test
   text    data     bss     dec     hex filename
   1225     284       8    1517     5ed test
可以发现，test段（文本段）的大小少了四个字节，而data段（数据段）的大小增大了4个字节。
结论1：const修饰的全局变量，保存在文本段中。
结论2： const修饰的全局变量，无法通过变量名更改其值。
结论3： const修饰的全局变量由于保存在文本段中，所以它的值不可以通过指针的方式修改。


测试static全局变量 - 符合上面的三个结论。
static const int g_int_a = 1000;

测试static局部变量 - 符合上面的三个结论。
static const int g_int_a = 1000;

测试非static局部变量 -> const int g_int_a = 1000;
结论1：const修饰的局部变量，保存在堆栈段中。
结论2： const修饰的局部变量，无法通过变量名更改其值。
结论3： const修饰的局部变量，它的值不可以通过指针的方式修改。


减小作用域的一般原则
1、在循环开始之前再去初始化改循环里使用的循环变量，而不是在该循环所属的子程序的开始处初始化这些变量。
2、直到变量即将被使用时再为其赋值。把声明和定义放在使用之前。
3、把相关语句放在一起。减少变量的跨度和生存时间。
4、把相关的语句组提取成功单独的子程序。把一个长的子程序拆分为更小的、单独的子程序可以缩小变量的作用域。
5、开始时使用最严格的可见性，然后根据需要扩展变量的作用域。


