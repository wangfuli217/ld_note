cost修饰函数返回值
---------------------------------------
这个跟const修饰普通变量以及指针的含义基本相同：
(1) const int
const int func1();      无意义，因为参数返回本身就是赋值给其他的变量！

(2) const int*
const int* func2();     指针指向的内容不变。

(3) int *const
int *const func2();     指针本身不可变。

const修饰函数参数
---------------------------------------
(1) 传递过来的参数及指针本身在函数内不可变，无意义！
void func(const int var);  // 没有任何意义; 传递过来的参数不可变
void func(int *const var); // 没有任何意义; 指针本身不可变

(2) 参数指针所指内容为常量不可变
void StringCopy(char *dst, const char *src);
其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。
这就是加了const的作用之一。

(3) 参数为引用，为了增加效率同时防止修改。
void func(const A &a)
对于非内部数据类型的参数而言，象void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型
的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。
为了提高效率，可以将函数声明改为void func(A &a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临
时对象。但是函数void func(A &a) 存在一个缺点：
“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为
void func(const A &a)。
以此类推，是否应将void func(int x) 改写为void func(const int &x)，以便提高效率？完全没有必要，因为内部数
据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。


小结：对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &a)。
对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &x)。



const char *event_base_get_method(const struct event_base *eb);