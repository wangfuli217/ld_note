指针与const

与指针相关的const有四种：
const char * a;       //指向const对象的指针或者说指向常量的指针。
char const * a;       //同上
char * const a;       //指向类型对象的const指针。或者说常指针、const指针。
const char * const a; //指向const对象的const指针。

小结：如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
      如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。

具体使用如下：
(1) 指向常量的指针
const int *ptr;
*ptr = 10; //error
ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，
而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。
除此之外，也不能使用void*指针保存const对象的地址，必须使用const void*类型的指针保存const对象的地址。

const int p = 10;
const void * vp = &p;
void *vp = &p; //error
另外一个重点是：允许把非const对象的地址赋给指向const对象的指针。

将非const对象的地址赋给const对象的指针:
const int *ptr;
int val = 3;
ptr = &val; //ok

我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!

我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：

int *ptr1 = &val;
*ptr1=4;
cout<<*ptr<<endl;

小结：对于指向常量的指针，不能通过指针来修改对象的值。
也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。
允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。


常指针
const指针必须进行初始化，且const指针的值不能修改。
#include<iostream>
using namespace std;
int main(void){
    int num=0;
    int * const ptr=&num; //const指针必须初始化！且const指针的值不能修改
    int * t = &num;
    *t = 1;
    cout<<*ptr<<endl;
}
上述修改ptr指针所指向的值，可以通过非const指针来修改。
