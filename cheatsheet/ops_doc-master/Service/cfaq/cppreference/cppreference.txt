identifier(){
标识符: 可用于标识对象、函数、结构体、联合体、或枚举标签、枚举成员、 typedef 类型别名、标号或宏。
            每个标识符（除了宏）仅在程序的一部分中合法，这部分被称为作用域，而它们属于四种命名空间之一。
        一些标识符拥有链接，这会令它们出现于不同作用域或翻译单元时，指代同一实体。
        
保留标识符: 
下列标识符被保留，而且不可在程序中声明（这么做会引起未定义行为）：
1) 作为关键词的标识符不能用于其他目的。具体而言，不允许 #define 或 #undef 等同于关键词的标识符。
2) 所有以一个下划线开始的外部标识符。
3) 所有以一个下划线后随一个大写字母或另一下划线开始的标识符（这些保留标识符允许库使用大量幕后的非外部宏及函数）。
4) 标准库所定义的所有外部标识符（在有宿主环境中）。这表示不允许用户提供的外部名称匹配任何库名称，即使是声明等同于库函数的函数也不允许。
5) 声明为标准库为未来使用保留的标识符，即
函数名 
    <complex.h> 中， cerf 、 cerfc 、 cexp2 、 cexpm1 、 clog10 、 clog1p 、 clog2 、 clgamma 、 ctgamma 及其 -f 和 -l 后缀变体
    <ctype.h> 和 <wctype.h> 中，以 is 或 to 后随一个小写字母开始者
    <stdlib.h> 中，以 str 后随一个小写字母开始者
    <string.h> 中，以 str 、 mem 或 wcs 后随一个小写字母开始者
    <wchar.h> 中，以 wcs 后随一个小写字母开始者
    <stdatomic.h> 中，以 atomic_ 后随一个小写字母开始者
    <threads.h> 中，以 cnd_ 、 mtx_ 、 thrd_ 或 tss_ 后随一个小写字母开始者 
typedef 名 
    <stdint.h> 中，以 int 或 uint 开始并以 _t 结束者
    <stdatomic.h> 中，以 atomic_ 或 memory_ 后随一个小写字母开始者
    <threads.h> 中，以 cnd_ 、 mtx_ 、 thrd_ 或 tss_ 后随一个小写字母开始者 
宏名 
    <errno.h> 中，以 E 后随一个数字或大写字母开始者
    <fenv.h> 中，以 FE_ 后随一个大写字母开始者
    <stdint.h> 中，以 INT 或 UINT 开始并以 _MAX 、 _MIN 或 _C 结束者
    <stdint.h> 中，以 PRI 或 SCN 后随小写字母或字母 X 开始者
    <locale.h> 中，以 LC_ 后随一个大写字母开始者
    <signal.h> 中，以 SIG 或 SIG_ 后随一个大写字母开始者
    <time.h> 中，以 TIME_ 后随一个大写字母开始者
    <stdatomic.h> 中，以 ATOMIC_ 后随一个大写字母开始者 
枚举常量 
    <stdatomic.h> 中，以 memory_order_ 后随一个小写字母开始者
    <threads.h> 中，以 cnd_ 、 mtx_ 、 thrd_ 或 tss_ 后随一个小写字母开始者
所有其他标识符均可用，无需担心从一个编译器和库移动程序到另一个时有不期待的冲突。
注意： C++ 中，在任何位置有双下划线的标识符都受保留； C 中，只有以双下划线开始的标识符受保留。
}

scopes(){
C 程序中出现的每个标识符都仅在一些可能不连续的部分可见（即可使用），这些部分被称为其作用域。
在作用域内，标识符仅若在不同命名空间中，才可以指代多于一个实体。
C 拥有四种作用域：
    块作用域
    文件作用域
    函数作用域
    函数原型作用域

1. 嵌套作用域
    若相同标识符所命名的二个不同实体在同一时刻都在作用域中，且它们属于同一命名空间，则作用域被嵌套
(不允许其他形式的作用域重叠)，而内层作用域中的声明隐藏外层作用域中的声明
2. 块作用域
    任何在复合语句，包含函数体或出现于 if 、 switch 、 for 、 while 或 do-while 语句中的任何表达式、声明或语句 
(C99 起)，或在函数定义内的参数列表中声明的标识符的作用域，在声明点开始，在声明于其中的块或语句的结尾结束。
    块作用域对象默认无链接并拥有自动存储期。注意非 VLA 局部对象的存储期在进入块时开始，但在见到声明前，
该标识符不在作用域中且不能访问。
3. 文件作用域
    在任何块或参数列表外声明的任何标识符的作用域，在声明点开始，翻译单元尾结束。
文件作用域的标识符默认拥有外部链接和静态存储期。
4. 函数作用域
    声明于函数内部的标号(且只有标号)，在该函数中的所有位置(所有嵌套块中，其自身声明前后)都在作用域内。
注意：任何语句前的冒号字符前的标识符，若不用于其他用途，则隐式声明一个标号。
5. 函数原型作用域
    非函数定义的函数声明的参数类表中引入的名称的作用域，在函数声明器的结尾结束。
int f(int n, int a[n]); // n 在作用域中并指代第一参数
6. 声明点
    结构体、联合体及枚举标签的作用域，在声明该标签的类型指定符中的标签出现后立即开始。
结构体、联合体及枚举标签的作用域，在声明该标签的类型指定符中的标签出现后立即开始。
struct Node {
   struct Node* next; // Node 在作用域中并指代此 struct
};

枚举常量的作用域，在枚举项列表中其定义枚举项的出现后立即开始。
enum { x = 12 };
{
    enum { x = x + 1, // 新 x 在逗号前不在作用域中，初始化 x 为 13
           y = x + 1  // 新枚举项 x 现在在作用域中，初始化 y 为 14
         };
}

任何其他标识符的作用域，正好在其声明器结束后和初始化器前开始，若存在初始化器：
int x = 2; // 第一个 'x' 的作用域开始
{
    int x[x]; // 新声明的 x 的作用域在声明器 （ x[x] ）后开始。
              // 在声明器内，外层 'x' 仍在作用域中。
              // 这声明 2 个 int 的 VLA 数组。
}
 
unsigned char y = 32; // 外层 'y' 的作用域开始
{
    unsigned char y = y;
            // 内层 'y' 的作用域在初始化器（ = y ）前开始
            // 这不会以值 32 初始化内层 'y' ，
            // 这以其自身的不确定值初始化内层 'y'
}
 
unsigned long factorial(unsigned long n)
// 声明器结束， 'factorial' 从此点开始在作用域中
{
   return n < 2 ? 1 : n * factorial(n - 1); // 递归调用
}
作为特殊情况，非标识符声明的类型名的作用域，被认为正好假如在类型名内未省略标识符，则标识符会出现的位置之后开始。


C 中，循环体内的局部对象，能隐藏声明于 for 循环的初始化子句中的对象（其作用域为嵌套的），但 C++ 中不能如此。
不同于 C++ ， C 无结构体作用域：声明于 struct/union/enum 声明内的名称在结构体声明所在的相同作用域
struct foo {
    struct baz {};
    enum color {RED, BLUE};
};
struct baz b; // baz 在作用域中
enum color x = RED; // color 和 RED 在作用域中
}
Storage(){
C 中每个对象存在、拥有常地址、保有其最近一次存储值（除非其值不确定），对于 VLA 还有保有其大小 (C99 起)的程序执行部分，被称作该对象的生存期。
对于声明有自动、静态及线程存储期的对象，生存期等于其存储期（注意非 VLA 和 VLA 自动存储期的区别）。
对于拥有分配存储期的对象，其生存期始于分配函数的返回（包含从 realloc 返回），终于 realloc 或解分配函数的调用。注意因为分配的对象没有声明类型，首次访问该对象所用的左值表达式类型会成为其有效类型。
在生存期外访问对象是未定义行为。
}
Namespaces(){
在 C 程序中遇到标识符时，会查找定位引入该标识符，并且当前在作用域内的声明。若同一标识符的多个声明属于称作命名空间的相异类别，则 C 允许它们同时在作用域内：
1) 标号命名空间：所有声明为标号的标识符。
2) 标签名：所有声明为 struct 、 union 及枚举类型名称的标识符。注意所有这三种标签共享同一命名空间。
3) 成员名：所有声明为至少为一个 struct 或 union 成员的标识符。每个结构体和联合体引入它自己的这种命名空间。
4) 所有其他标识符，称之为通常标识符以别于 (1-3) （函数名、对象名、 typedef 名、枚举常量）。

在查找点，根据使用方式确定标识符所属的命名空间：
1) 作为 goto 语句运算数出现的标识符，会在标号命名空间中查找。
2) 跟随关键词 struct 、 union 或 enum 的标识符，会在标签命名空间中查找。
3) 跟随成员访问或通过指针的成员访问运算符的标识符，会在类型成员命名空间中查找，该类型由成员访问运算符左运算数确定。
4) 所有其他标识符，会在通常命名空间中查找。

注意
宏名不是任何命名空间的一部分，因为它们会在语义分析前，为预处理器所替换。
}

type(){
对象、函数和表达式拥有称为类型的属性，它确定存储于对象或表达式求值所得的二进制值的转译方式。
C 类型系统由下列类型组成：
    类型 void
    基本类型 
        类型 char
        有符号整数类型 
            标准： signed char 、 short 、 int 、 long 、 long long (C99 起)
            扩展：实现定义，例如 __int128 
        无符号整数类型 
            标准： _Bool 、 (C99 起)unsigned char 、 unsigned short 、 unsigned int 、 unsigned long 、 unsigned long long (C99 起)
            扩展：实现定义，例如 __uint128 
        浮点类型 
            实浮点类型： float 、 double 、 long double
            复数类型： float _Complex 、 double _Complex 、 long double _Complex
            虚数类型： float _Imaginary 、 double _Imaginary 、 long double _Imaginary
    枚举类型 
    派生类型 
        数组类型
        结构体类型
        联合体类型
        函数类型
        指针类型
        原子类型 
对于上面列出的每个类型，可以存在数种其类型的限定版本，对应 const 、 volatile 和 restrict 限定符的一、二或全部三个组合

类型组别
    对象类型：所有不是函数类型的类型
    字符类型： char 、 signed char 、 unsigned char
    整数类型： char 、有符号整数类型、无符号整数类型、枚举类型
    实数类型：整数类型和实浮点类型
    算术类型：整数类型和浮点类型
    标量类型：算术类型和指针类型
    聚合类型：数组类型和结构体类型
    派生声明器类型：数组类型、函数类型和指针类型
    
兼容类型
类型 char 不与 signed char 兼容，且不与 unsigned char 兼容。
}

C中每个对象、函数及表达式关联到一种类型。

C 风格注释通常用于注释大块文本或小片代码；
C++ 风格注释通常用于注释单行文本或代码；