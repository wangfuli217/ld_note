关键字：预处理指令 条件编译 多文件编程  extern

/* 预处理指令 */
#define 预处理指令用来定义宏

宏可以用来给数字起名字
用宏给数字起名字的语句不能包含赋值操作符

可以在编译命令中使用-D选项定义宏  /* gcc -DPI=3.14 名称.c */ 相当于#define PI 3.14

程序中有些数字在编写时无法确定，只有在编译的时候才能知道，
	这种数字就应该采用宏表示。

宏还可以给计算公式起名字
用宏的参数表示计算公式里的未知数字  /*  #define CIRCLE(r) 2*PI*r   */ 

宏的参数不一定代表数字，所以它没有类型名称

宏不能使用自己的存储区和函数进行数据传递
宏没有形式参数也没有用来存放返回值的存储区

能当作数字使用的宏必须编写成表达式   /* #define ABS(n) n>0?n:0-n */
宏的参数代表的就是函数的存储区，可以直接修改内容

#include<stdio.h>
#define ABS(n) n>0?n:0-n
#define NEG(n) n=0-n
void neg(int *p_num)
{
    *p_num=0- *p_num;       //要改变num 存储区里面的值  不是表面的值
}
int abs(int num)
{
    if(num>=0)
        return num;
    else
        return 0-num;
}
int main()
{
    int num = 0;
    printf("请输入一个整数：");
    scanf("%d",&num);
    printf("绝对值：%d\n",abs(num));
    printf("绝对值：%d\n",ABS(num));
    neg(&num);
    printf("num是%d\n",num);
    NEG(num);                    //计算了-9的相反数
    printf("num是%d\n",num);
    return 0;
}

结果：	请输入一个整数：9
	绝对值：9
	绝对值：9
	num是-9
	num是9

因为宏没有存储区用来存放返回值
	所以不能保证优先计算宏内部的操作符

因为宏没有形式参数，所以不能保证优先计算参数内部的操作符
	所有能当作数字使用的宏必须写在小括号里

不要把自增或自减的结果作为宏的参数使用

#是一个宏操作符，它可以把宏的参数转换成字符串字面值  /* #define STR(n) #n  */
##也是一个宏操作符，它可以把一个代表标识符的参数和其他连接成为新的标识符
	/*  #define LOCAL(n) l_##n  */   int num=0; int LOCAL(num)=0;
	结果  int l_num=0;

/* 条件编译 */
条件编译可以在编译的时候从几组语句中选择一组编译，忽略其他组
#ifdef/#ifndef...#else...#endif
以上结构可以在编译时根据一个宏是否被定义过 从两组语句中选择一组编译
如果最前面的预处理指令选择#ifdef 就表示它后面宏被定义过时 
	编译 前一组语句，否则编译 后一组语句
如果选择#ifndef刚好相反

#if...#elif(任意多次)...#else...#endif
以上结构也可以实现条件编译
这种结构可以根据任意逻辑表达式从多组语句中选择一组编译

/* 多文件编程 */
多文件编程时每个文件里可以包含多个函数
	一个函数只能属于一个文件

多文件编程步骤
1. 把所有函数分散在多个不同的源文件里
	(主函数通常单独放在一个文件里)
2. 为每个源文件编写配对的头文件 
	(主函数所在的文件不需要配对头文件)
	所有不分配内存的内容都可以写在头文件里
	头文件里至少应该包含配对源文件里的所有函数声明
3. 为每个源文件包含必要的头文件
	(配对头文件是必要头文件)
	如果源文件里使用了头文件中声明的函数则头文件也是必要头文件

可以在gcc命令后列出所有源文件名称，用这种方法可以编译多文件程序

可以把多文件程序的编译过程记录在Makefile里
	然后使用make工具根据Makefile文件内容对多文件程序进行编译
$vi Makefile

	main:02file.o one.o
    		gcc 02file.o one.o
	02file.o:02file.c
    		gcc 02file.c -c
	one.o:one.c
    		gcc one.c -c

$make
gcc one.c -c
gcc 02file.o one.o

应该把头文件内容包含在预处理指令中，
	这样可以保证不论源文件中多少次包含头文件都只会编译一次
	（多个源文件包含同一个头文件）
	#ifndef __ADD_H
	#define __ADD_H__
	int add(int,int);
	#endif    // __ADD_H__    //加上注释 知道了谁跟谁配对

头文件里使用的宏名称应该根据文件路径得到 (文件名就是路径 __ADD_H__  文件名)
也可以是 ADD_H

/* extern */
如果一个源文件里希望使用另外一个源文件里声明的全局变量
	就需要使用 extern 关键字再次声明那个变量

使用 extern 关键字声明变量的语句不会分配内存  
	就可以写在头文件里


预习：结构体 枚举 联合
作业：编写宏实现字符大小写之间的转换

#include<stdio.h>
#define CHR(ch) ((ch)>='a'&&(ch)<='z'?(ch)-'a'+'A':(ch)-'A'+'a')
int main()
{
    char ch=0;
    scanf("%c",&ch);
    printf("%c\n",CHR(ch));
    return 0;
}



