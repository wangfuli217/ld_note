关键字：算法的概念和评价  常用的查找算法  常用的排序算法

/*算法的概念和评价*/
算法就是对解题方案准确而又完整的描述，是一系列清晰的指令

评价标准
	时间复杂度（重点）
		主要描述算法的时间消耗与问题规模之间的函数关系；
	空间复杂度
		主要描述算法的空间消耗与问题规模之间的函数关系；
	正确性
		主要描述算法的执行结构是否满足要求；
	可读性
		主要描述算法本身是否便于阅读；
	健壮性
		主要描述算法对非正常输入的反应和处理能力；

描述方式
   	常见的算法描述方式主要有：自然语言、伪代码、结构化流程图、PAD图 ... ...

/*常用的查找算法*/
*线性查找算法（顺序查找算法）
1. 算法流程
	使用目标元素与样本数列中的第一个元素起依次进行比较，
	如果找到了与目标元素相等的元素则表示查找成功，
	或者与所有的样本元素全部比较完毕，
	也没有找到与目标元素相等的元素，则表示查找失败；
2. 算法评价
	平均时间复杂度O(N),对样本的有序性不敏感；


*二分查找算法(折半查找算法)
1. 算法流程
	假定样本数列中的所有元素从小到大依次进行排列，
	使用目标元素与样本数列中的中间元素进行比较，如果相等则查找成功；
	如果中间元素小于目标元素，则去中间元素的右边进行查找；
	如果中间元素大于目标元素，则去中间元素的左边进行查找；
	重复以上过程，直到找到满足条件的目标元素为止则表示查找成功，
	或者与需要
2. 算法评价
	平均时间复杂度O(lgN),要求样本元素必须有序；

//使用查找算法查找指定的目标元素
#include <stdio.h>

//自定义函数实现线性查找算法
int find(int arr[],int len,int data)
{
	int i = 0;
	for(i = 0; i < len; i++)
	{
		if(data == arr[i])
		{
			return i;//返回元素对应的下标
		}
	}
	return -1;//表示查找失败
}

//自定义函数实现二分查找算法
int find_binary(int arr[],int left,int right,int data)
{
	if(left <= right)
	{
		//1.计算中间元素的下标
		int p = (left + right) / 2;
		//2.使用目标元素与中间元素比较大小，相等返回
		if(data == arr[p])
		{
			return p;
		}
		//3.如果目标元素小于中间元素，则在左边查找
		else if(data < arr[p])
		{
			return find_binary(arr,left,p-1,data);
		}
		//4.如果目标元素大于中间元素，则在右边查找
		else
		{
			return find_binary(arr,p+1,right,data);
		}
	}
	return -1;//表示查找失败
}

int main(void)
{
	int arr[9] = {10,20,30,40,50,60,70,80,90};
	//int pos = find(arr,9,400);
	int pos = find_binary(arr,0,8,400);
	if(-1 != pos)
	{
		printf("查找目标元素成功，所在下标是：%d\n",pos); // 3
	}
	else
	{
		printf("目标元素不存在\n");
	}
	return 0;
}

/*常用的排序算法*/
*冒泡排序算法（重点）
1. 算法流程
	a.比较相邻位置的元素，如果第一个元素比第二个元素大，则交换两个元素；
	b.从最开始的一对相邻位置元素到最后一对相邻位置的元素做同样的工作，
	  经过这一步，最后的元素将是最大值；
	c.针对所有元素重复以上步骤，除了最后一个元素；
	d.持续每次对越来越少的元素重复以上步骤，直到没有元素需要交换为止；
2. 算法评价
	平均时间复杂度O(N^2),稳定的排序算法，对样本的有序性非常敏感；


*插入排序算法
1. 算法流程
	a.从第一个元素起，该元素可以认为已经有序；
	b.从第二个元素起取出，在已经有序的元素中从后向前进行扫描和比较；
	c.如果左边元素大于取出的元素，则将左边元素赋值到下一个位置上，也就是右移；
	d.如果左边元素小于等于取出的元素，则将取出的元素插入到左边元素的右边；
	e.重复步骤b,直到处理完毕所有元素为止；
2. 算法评价
	平均时间复杂度O(N^2),稳定，对样本的有序性非常敏感，但是赋值的次数比冒泡排序少，
	因此一般情况下略优于冒泡排序


*选择排序算法
1. 算法流程
	a.从第一个元素起依次取出，
	  假定取出的元素是最小值，并且使用变量min来记录该元素的下标
	b.使用min记录的最小值与后续所有元素依次进行比较，
	  如果后续元素中有比min记录的最小值还小的元素，
	  则重新记录该元素的下标到min中，也就是后续元素变成里min记录的最小值；
	c.直到min记录的最小值与后续所有元素比较完毕，
          交换min记录的最小值和最开始假定的最小值；
	d.重复以上过程，直到处理完毕所有元素为止；

2. 算法评价
	平均时间复杂度O(N^2),不稳定，对样本的有序性不敏感，
    	虽然比较次数比较多，但是交换的次数比较少，因此一般情况下略优于冒泡排序；


*快速排序算法
1. 算法流程
	a.从样本数列中选择中间元素作为基准值，单独保存起来；
	b.重组数列，将所有比基准值小的元素都放在基准值的左边，
	  将所有比基准值大的元素都放在基准值的右边，
	  与基准值相等的元素可以放在任意一边，这个过程叫做分组；
	c.以递归的方式对小于基准值的分组和大于基准值的分组分别进行分组排序；	

2. 算法评价
	平均时间复杂度O(NlogN),不稳定，对样本的有序性不敏感；

//编程实现各种排序算法
#include <stdio.h>

//实现冒泡排序算法
void bubble(int arr[],int len)
{
	int i = 0,j = 0;
	//1.使用循环来控制比较的轮数
	for(i = 1; i < len; i++)
	{
		//定义标志位
		int flag = 1;
		//2.使用循环来控制比较的元素下标范围
		for(j = 0; j < len-i; j++)
		{
			//3.如果左边元素大于右边元素，则交换
			if(arr[j] > arr[j+1])
			{
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
				flag = 0;
			}
		}
		if(1 == flag)
		{
			break;//跳出外层循环
		}
	}
}

//实现插入排序算法
void insert(int arr[],int len)
{
	int i = 0,j = 0;
	//1.使用循环将后续的元素依次取出
	for(i = 1; i < len; i++)
	{
		//2.将取出的元素单独保存起来，避免被覆盖
		int temp = arr[i];
		//3.使用取出的元素与左边元素依次进行比较，如果左边元素大于取出的元素，则左边元素右移
		for(j = i; arr[j-1] > temp && j >= 1; j--)
		{
			arr[j] = arr[j-1];
		}
		//4.直到左边元素不再大于取出元素，则插入取出元素到左边元素的右边
		//为了避免元素自己给自己赋值
		if(j != i)
		{
			arr[j] = temp;
		}
	}
}

//实现选择排序算法
void choose(int arr[],int len)
{
	int i = 0,j = 0;
	//1.使用循环将第一个元素起依次取出
	for(i = 0; i < len-1; i++)
	{
		//2.使用临时变量记录取出元素的下标
		int min = i;
		//3.使用min记录的最小值与后续元素依次比较
		for(j = i+1; j < len; j++)
		{
			//4.如果后续元素中有小于min记录最小值的元素，则重新记录后续的这个元素
			if(arr[j] < arr[min])
			{
				min = j;
			}
		}
		//5.直到使用min记录的元素与后续所有元素比较完毕为止，交换min记录元素与最开始假定的元素
		if(min != i)
		{
			int temp = arr[i];
			arr[i] = arr[min];
	    		arr[min] = temp;	
		}
	}
}

//实现快速排序算法
void quick(int arr[],int left,int right)
{
	//1.计算中间元素的下标，单独保存起来
	int p=(left+right)/2;
	int pivot=arr[p];
	//2.分别使用左右两边的元素，和基准值比较
	int i=0,j=0;
	for(i=left,j=right;i<j;)
	{
		//如果左边有元素，并且小于基准值，使用下一个元素与基准值比较
		while(i < p && arr[i]<pivot)
		{
			i++;
		}
		//如果左边有元素，但不再小于基准值，则将左边的元素移动到p指向的位置，p指向元素原来的位置
		if(i<p)
		{
			arr[p]=arr[i];
			p=i;
		}
		//如果右边有元素，并且大于基准值，使用下一个元素与基准值比较
		while(j>p && arr[j]>=pivot)
		{
			j--;
		}
		//如果右边有元素，但不再大于基准值，则将右边的元素移动到p指向的位置，p指向元素原来的位置
		if(j>p)
		{
			arr[p]=arr[j];
			p=j;
		}
	}
	//3.直到左右两边元素下标重合时放入基准值元素
	arr[p]=pivot;
	//4.分别对左右两边的分组以递归的方式进行再分组
	if(p-left>1)
	{
		quick(arr,left,p-1);
	}
	if(right-p>1)
	{
		quick(arr,p+1,right);
	}

}
int main(void)
{
	int arr[9] = {35,10,30,5,15,30,12,20,3};
	//调用排序算法进行排序
	//bubble(arr,9);
	//insert(arr,9);
	//choose(arr,9);
	quick(arr,0,8);
	//打印排序后的结果
	int i = 0;
	for(i = 0; i < 9; i++)
	{
		printf("%d ",arr[i]);
	}
	printf("\n");
	return 0;
}
















