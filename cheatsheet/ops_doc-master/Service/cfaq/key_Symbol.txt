宏定义 #define #undef
  1. 宏定义指令定义了一个标识符(宏名)及一个字符串, 在源程序中每次遇到该标识符时, 均以定义的字符串替换它(宏替换)
  2. 宏名和参数间不能有空格, 标识符和字符串间可有任意空格
  3. 字符串中应习惯对宏参数加上括号, 这样使用宏时, 如果实参是表达式，则不易出错
  4. 宏替换只作宏名和参数替换，不做计算，不做表达式求解
  5. 宏一旦被定义后, 其宏名即可成为其它宏定义的一部分
  6. 一条宏定义只能写在一行, 可以使用续行符

do{}while(0)
  
一、一般用法
   #：将宏参数变为字符串， 例如：#define STR(s) #s  "s的内容"
   ##：将两个宏参数贴合在一起， 例如：#define CONS(a, b) a##c##b  acb //a和b转换为对应的参数值
   @#: charizing 字符化操作符 -- 很少见使用
   
moosefs 的 cfg.c 文件有 "##" 实例。    #define _CONFIG_MAKE_PROTOTYPE(fname,type) type cfg_get##fname(const char *name,type def)
moosefs 的 massert.h 文件有 "#" 实例。 massert sassert passert eassert zassert

二、当宏参数是另外一个宏的时候：凡是宏定义中有#和##的地方宏参数不会展开，此时需
要多加一层中间转换宏
1, 非'#'和'##'的情况 
#define TOW       (2) 
#define MUL(a,b) (a*b) 

printf("%d*%d=%d\n", TOW, TOW, MUL(TOW,TOW)); 
这行的宏会被展开为： 
printf("%d*%d=%d\n", (2), (2), ((2)*(2))); 
MUL里的参数TOW会被展开为(2). 

2, 当有'#'或'##'的时候 
#define A           (2) 
#define STR(s)      #s 
#define CONS(a,b)   int(a##e##b) 

printf("int max: %s\n",   STR(INT_MAX));     // INT_MAX #include<climits> 
这行会被展开为： 
printf("int max: %s\n", "INT_MAX"); 

printf("%s\n", CONS(A, A));                // compile error  
这一行则是： 
printf("%s\n", int(AeA)); 

INT_MAX和A都不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏. 
加这层宏的用意是把所有宏的参数在这层里全部展开, 
那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数. 

#define A            (2) 
#define _STR(s)      #s 
#define STR(s)       _STR(s)           // 转换宏 
#define _CONS(a,b)   int(a##e##b) 
#define CONS(a,b)    _CONS(a,b)        // 转换宏 

printf("int max: %s\n", STR(INT_MAX));           // 
INT_MAX,int型的最大值，为一个变量 #include<climits> 
输出为: int max: 0x7fffffff 
STR(INT_MAX) -->   _STR(0x7fffffff) 然后再转换成字符串； 

printf("%d\n", CONS(A, A)); 
输出为：200 
CONS(A, A)   -->   _CONS((2), (2))   --> int((2)e(2)) 

moosefs 的init.h 中 有 "#" 的实例。
monit   的str.c  中 #define Str_join(dest, n, ...) _Str_join((dest), (n), ##__VA_ARGS__, 0)
redis   的sds.c 中
#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))

三、'#'和'##'的一些应用特例
1、合并匿名变量名 
#define   ___ANONYMOUS1(type, var, line)   type   var##line 
#define   __ANONYMOUS0(type, line)   ___ANONYMOUS1(type, _anonymous, line) 
#define   ANONYMOUS(type)   __ANONYMOUS0(type, __LINE__) 
例：ANONYMOUS(static int);   即: static int _anonymous70;   70表示该行行号； 
第一层：ANONYMOUS(static int);   -->   __ANONYMOUS0(static int, __LINE__); 
第二层：                         -->   ___ANONYMOUS1(static int, _anonymous, 
70); 
第三层：                         -->   static int   _anonymous70; 
即每次只能解开当前层的宏，所以__LINE__在第二层才能被解开； 

2、填充结构 
#define   FILL(a)    {a, #a} 

enum IDD{OPEN, CLOSE}; 
typedef struct MSG{ 
   IDD id; 
   const char * msg; 
}MSG; 

MSG _msg[] = {FILL(OPEN), FILL(CLOSE)}; 
相当于： 
MSG _msg[] = {{OPEN, "OPEN"}, 
               {CLOSE, "CLOSE"}}; 

3、记录文件名 
#define   _GET_FILE_NAME(f)    #f 
#define   GET_FILE_NAME(f)     _GET_FILE_NAME(f) 
static char   FILE_NAME[] = GET_FILE_NAME(__FILE__); 

4、得到一个数值类型所对应的字符串缓冲大小 
#define   _TYPE_BUF_SIZE(type)   sizeof #type 
#define   TYPE_BUF_SIZE(type)    _TYPE_BUF_SIZE(type) 
char   buf[TYPE_BUF_SIZE(INT_MAX)]; 
      -->   char   buf[_TYPE_BUF_SIZE(0x7fffffff)]; 
      -->   char   buf[sizeof "0x7fffffff"]; 
这里相当于： 
char   buf[11];

5 先看下面三条语句：
#define Conn(x,y) x##y
#define ToChar(x) #@x
#define ToString(x) #x

(1). ## 连接操作符
##表示连接(token pasting, or token concatenation，merge two tokens into one 
while expanding macros)。x##y表示什么？表示x连接y，举例说：

int n = Conn(123,456);
     ==> int n=123456;
char* str = Conn("asdf", "adf");
     ==> char* str = "asdfadf";

怎么样，很神奇吧！

需要注意的是，##的左右符号必须能够组成一个有意义的符号，否则预处理器会报错。

(2). #@ 字符化操作符
#@x只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单
字符参数名转换成字符，以一对单引用括起来其实就是给x加上单引号，结果返回是一个con
st char。 
举例说：

char a = ToChar(1);
     ==> char a='1';

做个越界试验

char a = ToChar(123);
     ==> char a='3';

但是如果你的参数超过四个字符，编译器就给给你报错了！error C2015: too many 
characters in constant ：P

(3). # 字符串化操作符
#表示字符串化操作符（stringification）。其作用是：将宏定义中的传入参数名转换成用
一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体
中的参数名前。说白了，他是给x加双引号：

char* str = ToString(123132);
     ==> char* str="123132";

如果你想要对展开后的宏参数进行字符串化，则需要使用两层宏。
#define xstr(s) str(s)
#define str(s) #s
#define foo 4
str (foo)
     ==> "foo"
xstr (foo)
     ==> xstr (4)
     ==> str (4)
     ==> "4"

s参数在str宏中被字符串化，所以它不是优先被宏展开。然而s参数是xstr宏的一个普通参
数，在被传递到str宏之前已经被宏展开。

(4). \ 行继续操作
行继续操作当定义的宏不能用一行表达完整时，可以用”\”（反斜线）表示下一行继续此宏
的定义。
注意:最后一行不要加续行符啊.
VC的预处理器在编译之前会自动将\与换行回车去掉（写成多行时，反斜杠后不能有空格，
否则编译器（ARM或VC）会报错！），这样一来既不影响阅读,又不影响逻辑,皆大欢喜.

(5). __VA_ARGS__
__VA_ARGS__宏用来接受不定数量的参数。例如：
#define eprintf(...) fprintf (stderr, __VA_ARGS__)
eprintf ("%s:%d: ", input_file, lineno)
    ==>  fprintf (stderr, "%s:%d: ", input_file, :lineno)
当__VA_ARGS__宏前面##时，可以省略参数输入。例如：
#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)
eprintf ("success!\n")
    ==> fprintf(stderr, "success!\n");
    
条件编译 #if，#ifdef, #ifndef, #elif，#else，#endif
  1. 条件编译指令可对程序源代码的各部分有选择地进行编译, 该过程称为条件编译
  2. 商业软件使用条件编译提供和维护某一程序的许多顾客版本
  3. #if指令后面的表达式在编译时求值, 因此必须是常量, 且不允许含有sizeof操作符, 虽然sizeof是编译时求值
  4. 在嵌套的条件编译中, #endif, #else 或 #elif 与最近 #if 或 #elif 匹配

#if defined(), #if !defined()
  1. #if defined() 相当于 #ifdef
  2. #if !defined() 相当于 #ifndef
  3. defined 应用范围更大，可以支持多个预编译变量的检查

#if ( !defined(_DEBUG) && defined(USE_MYLIB) )
    ......
#endif

    
C宏定义的简单总结
1，防止一个头文件被重复包含
#ifndef COMDEF_H
#define COMDEF_H
//头文件内容 …
#endif
2，重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。
typedef  unsigned long int  uint32;      ///< Unsigned 32 bit value
3，得到指定地址上的一个字节或字
#define  MEM_B( x )  ( *( (byte *) (x) ) )
#define  MEM_W( x )  ( *( (word *) (x) ) )
4，求最大值和最小值
#define  MAX( x, y )  ( ((x) > (y)) ? (x) : (y) )
#define  MIN( x, y )  ( ((x) < (y)) ? (x) : (y) )
5，得到一个field在结构体(struct)中的偏移量
#define FPOS( type, field )   ( (dword) &(( type *) 0)-> field )
6,得到一个结构体中field所占用的字节数
#define FSIZ( type, field ) sizeof( ((type *) 0)->field )
7，按照LSB格式把两个字节转化为一个word
#define  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
8，按照LSB格式把一个word转化为两个字节
#define  FLOPW( ray, val )
(ray)[0] = ((val) / 256);
(ray)[1] = ((val) & 0xFF)
9，得到一个变量的地址（word宽度）
#define  B_PTR( var )  ( (byte *) (void *) &(var) )
#define  W_PTR( var )  ( (word *) (void *) &(var) )
10，得到一个字的高位和低位字节
#define  WORD_LO(xxx)  ((byte) ((word)(var) & 255))
#define  WORD_HI(xxx)  ((byte) ((word)(var) >> 8))
11，返回一个比X大的最接近的8的倍数
#define RND8( x )       ((((x) + 7) / 8 ) * 8 )
12，将一个字母转换为大写
#define  UPCASE( c ) ( ((c) >= ’a' && (c) <= ’z') ? ((c) - 0×20) : (c) )
13，判断字符是不是10进值的数字
#define  DECCHK( c ) ((c) >= ’0′ && (c) <= ’9′)
14，判断字符是不是16进值的数字
#define  HEXCHK( c ) ( ((c) >= ’0′ && (c) <= ’9′) ||
((c) >= ’A' && (c) <= ’F') ||
((c) >= ’a' && (c) <= ’f') )
15，防止溢出的一个方法
#define  INC_SAT( val )  (val = ((val)+1 > (val)) ? (val)+1 : (val))
16，返回数组元素的个数
#define  ARR_SIZE( a )  ( sizeof( (a) ) / sizeof( (a[0]) ) )
17，对于IO空间映射在存储空间的结构，输入输出处理
#define inp(port)         (*((volatile byte *) (port)))
#define inpw(port)        (*((volatile word *) (port)))
#define inpdw(port)       (*((volatile dword *)(port)))
#define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))
#define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
18，使用一些宏跟踪调试
ANSI标准说明了五个预定义的宏名。它们是：
__LINE__
__FILE__
__DATE__
__TIME__
__STDC__
如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。
记住编译程序 也许还提供其它预定义的宏名。
是行连接符，会将下一行和前一行连接成为一行，即将物理上的两行连接成逻辑上的一行
__FILE__ 是内置宏 代表源文件的文件名
__LINE__ 是内置宏，代表该行代码的所在行号
__DATE__宏指令含有形式为月/日/年的串，表示源文件被翻译到代码时的日期。
源代码翻译到目标代码的时间作为串包含在__TIME__ 中。串形式为时：分：秒。
如果实现是标准的，则宏__STDC__含有十进制常量1。如果它含有任何其它数，则实现是非标准的。
可以定义宏，例如:
当定义了_DEBUG，输出数据信息和所在文件所在行
#ifdef _DEBUG
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
#else
#define DEBUGMSG(msg,date)
#endif
19，宏定义防止使用是错误
用小括号包含。
例如：#define ADD(a,b) （a+b）
用do{}while(0)语句包含多语句防止错误
例如：#define DO(a,b) a+b;
a++;
应用时：if(….)
DO(a,b); //产生错误
else
解决方法: 
#difne DO(a,b) do{a+b;a++;}while(0)
为什么需要do{…}while(0)形式?
总结了以下几个原因：
1)，空的宏定义避免warning:
#define foo() do{}while(0)
2)，存在一个独立的block，可以用来进行变量定义，进行比较复杂的实现。
3)，如果出现在判断语句过后的宏，这样可以保证作为一个整体来是实现：
#define foo(x)
action1();
action2();
在以下情况下：
if(NULL == pPointer)
    foo();
就会出现action2必然被执行的情况，而这显然不是程序设计的目的。
4)，以上的第3种情况用单独的{}也可以实现，但是为什么一定要一个do{}while(0)呢，看以下代码：
#define switch(x,y) {int tmp; tmp=x;x=y;y=tmp;}
if(x>y)
   switch(x,y);
else        //error, parse error before else
   otheraction();
在把宏引入代码中，会多出一个分号，从而会报错。
使用do{….}while(0) 把它包裹起来，成为一个独立的语法单元，从而不会与上下文发生混淆。同时因为绝大多数的编译器都能够识别do{…}while(0)这种无用的循环并进行优化，所以使用这种方法也不会导致程序的性能降低。
为什么很多linux内核中宏#defines用do { … } while(0)？
有很多原因：
（Dave Miller的说法）：
编译器对于空语句会给出告警，这是为什么#define FOO do{ }while(0);
给定一个基本块（局部可视域），定义很多局部变量；
（Ben Collins的说法）：
在条件代码中，允许定义复杂的宏。可以想像有很多行宏，如下代码
#define FOO(x)
printf(“arg is %sn”, x);
do_something_useful(x);
现在，想像下面的应用:
if (blah == 2)
FOO(blah);
展开后代码为:
if (blah == 2)
printf(“arg is %sn”, blah);
do_something_useful(blah);;
就像你看到的，if仅仅包含了printf（），而do_something_useful()调用是无条件调用。因此，如果用do { … } while(0)，结果是：
if (blah == 2)
do {
	printf(“arg is %sn”, blah);
	do_something_useful(blah);
} while (0);
这才是所期望的结果。
（Per Persson的说法）：
像 Miller and Collins指出的那样，需要一个块语句包含多个代码行和声明局部变量。但是，本质如下面例子代码：
#define exch(x,y) { int tmp; tmp=x; x=y; y=tmp; }
上面代码在有些时候却不能有效工作，下面代码是一个有两个分支的if语句：
if (x > y)
exch(x,y);               // Branch 1
else
do_something();      // Branch 2
展开后代码如下：
if (x > y)
{                // Single-branch if-statement!!!
	int tmp;            // The one and only branch consists
	tmp = x;           // of the block.
	x = y;
	y = tmp;
}
;                // empty statement
else                             // ERROR!!! “parse error before else”
do_something();
问题是分号（；）出现在块后面。解决这个问题可以用do{}while（0）：
if (x > y)
do {
int tmp;
tmp = x;
x = y;
y = tmp;
} while(0);
else
do_something();
（ Bart Trojanowski的说法）：
Gcc加入了语句解释，它提供了一个替代do-while-0块的方法。对于上面的解决方法如下，并且更加符合常理
#define FOO(arg) ({
typeof(arg) lcl;
lcl = bar(arg);
lcl;
})
这是一个奇怪的循环，它根本就只会运行一次，为什么不去掉外面的do{..}while结构呢？我曾一度在心里把它叫做“怪圈”。原来这也是非常巧妙的技巧。在工程中可能经常会引起麻烦，而上面的定义能够保证这些麻烦不会出现。下面是解释：
假设有这样一个宏定义
#define macro(condition)
if(condition) dosomething()
现在在程序中这样使用这个宏：
if(temp)
macro(i);
else
doanotherthing();
一切看起来很正常，但是仔细想想。这个宏会展开成：
if(temp)
if(condition) dosomething();
else
doanotherthing();
这时的else不是与第一个if语句匹配，而是错误的与第二个if语句进行了匹配，编译通过了，但是运行的结果一定是错误的。
为了避免这个错误，我们使用do{….}while(0) 把它包裹起来，成为一个独立的语法单元，从而不会与上下文发生混淆。同时因为绝大多数的编译器都能够识别do{…}while(0)这种无用的循环并进行优化，所以使用这种方法也不会导致程序的性能降低。

另一个讲解
这是为了含多条语句的宏的通用性
因为默认规则是宏定义最后是不能加分号的，分号是在引用的时候加上的
比如定义了一个宏fw(a,b)，那么在c文件里一定是这样引用
fw(a,b);
如果不用do…while，那么fw就得定义成:
#define fw(a,b) {read((a));write((b));}
那这样fw(a,b);展开后就成了:
{read(a);write(b);};
最后就多了个分号，这是语法错误
而定义成do…while的话，展开后就是:
do{read(a);write(b);}while(0);    完全正确
所以要写一个包含多条语句的宏的话，不用do…while是不可能的

7、调试宏：ASSERT()、VERIFY()、TRACE() 
   这三个宏在Debug环境下特别有效，常用于代码的跟踪调试。它们是否起作用取决于是否定义了预定义了宏 _DEBUG
   ASSERT ASSERT(booleanExpression) 
   说明： 计算变量的值。如果结构的值为0，那么此宏便打印一个诊断消息并且程序运行失败。
                        如果条件为非0，那么什么也不做。诊断消息的形式为： assertion failed in file in line 
   其中name是元文件名，num是源文件中运行失败的中断号。 
   在Release 版中，ASSERT不计算表达式的值也就不中断程序。
   
   如果必须计算此表达式的值且不管环境如何那么用VERIFY代替ASSERT。 这个宏通常原来判断程序中是否出现了明显非法的数据，
   如果出现了终止程序以免导致严重后果，同时也便于查找错误。
   ASSERT_VAILD 
   ASSERT_VAILD(pObject) 
   说明： 用于检测关于对象的内部状态的有效性。ASSERT_VALID调用此对象的AssertValid成员函数(把它们作为自己的变量来传递)。
   在 Release版中ASSERT_VALID什么也不做。
   在DEBUG版中，他检查指针，以不同于NULL的方式进行检查，并调用对象自己的 AssertValid成员函数。
   如果这些检测中有任何一个失败的话，那么他会以与ASSERT相同的方法显示一个警告的消息。
   
   VERIFY VERIFY(booleanExpression) 
   说明： 在 MFC的DEBUG版中，VERIFY宏计算它的变量值。如果结果为0，那么宏打印一个诊断消息并中止程序。
   如果条件不为0，那么什么工作也不作。诊断有如下形式：
   assertion failed in file in line 其中name是源文件的名字，num是在源文件中失败的中止行号。
   在 MFC的Release版中，VERIFY计算表达式值但不打印或中止程序。例如：如果表达式是个函数调用，那么调用成功。
   
   TRACE TRACE(exp) 说明： 把一个格式化字符串送到转储设备，
   例如，文件或调试监视器，功能上和printf相似，可以说就是调试环境下printf的一个拷贝。
   TRACE宏是一个 在程序运行时跟踪变量值的方便形式。在DEBUG环境中，TRACE宏输出到afxDump。
   在Release版中他不做任何工作。另外还有一组可以带参 数的相似的宏：TRACE0、TRACE1、TRACE2和TRACE3。
   提供格式如： TRACE0(exp) 
                TRACE1(exp,param1) 
                TRACE2(exp,param1,param2) 
                TRACE3(exp,param1,param2,param3) 与TRACE相似，但它把跟踪字符串放在代码段中，而不是DGROUP，
   因此使用少的DGROUP空间。这些宏的用法和printf类似

文件包含(#include)、条件编译(#ifdef、#else)、布局控制(#progma)以及宏替换(#define)。
