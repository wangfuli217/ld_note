
C 和 C++ 学习笔记
1.<Effective C++>   
2.<Effective STL>   
3.<C++ Primer:5 Edition>   
4.<Effective Modern C++>
5.《深度探索C++对象模型》侯捷翻译；
6.《c缺陷和陷阱》
7.《C和指针》Kenneth A.Reek著，徐波翻译
8.《程序员的自我修养---链接、装载与库》俞甲子，石凡，潘爱民 著；
9.《LINUX内核源代码情景分析》+《深入理解linux内核》+《LINUX内核完全剖析--基于0.12内核》；
10.《大话处理器-处理器基础知识读本》, 万木杨著，很好；
11.《C语言接口和实现》




0.C语言基础：
         0).全局变量初始化可以调用函数实现复杂的初始化, eg: int glo_i = initial();
          0).深刻理解if/else if/else 之间的跳转关系，如果if成立则不执行else if/else,有goto的效果，如果if/else if都不成立，才执行else;
          0). 对于 const/volatile 变量，定义对应的指针时也需要对应的修饰，const T*;  volatile T* ; 
          0).include头文件的本质就是文本拷贝；
          0)两个c文件都#define Name xx 不会导致Name重定义，不论xx是否相同；但如果一个c文件多次#define Name 则会导致重定义，不论xx是否相同 ；
           0).函数声明中的参数名字可以省略，函数定义时的参数名字(如果用不到也可以省略)其实可以和声明时的不同（当然，最好是保持一致），但是类型必须一致；
           0). 所有的C/C++程序都是以main()函数作为主线程入口，不论是多线程还是单线程，所以了解一个程序的框架应该从main()函数开始, macpsUt.bin的main函数在cpputest框架里面；
           0）.初始化与赋值的区别：初始化是在创建对象的同时赋予初值(eg:class a = b;)，而赋值是对象已经创建好了，销毁旧值，赋予新值(eg: a = b)；
           0). define 的作用域是从定义开始到本文件结束,如果2个头文件定义了相同名字，被同一个c文件包含，就会导致redefine;
           1）普通函数在.h文件定义需要加static inline，否则被多个文件包含会出现重复定义,
                在.hpp中如果在匿名namespace内定义函数，不需要static inline, 如果是有名namespace则需要加上static inline;
                模板函数放在头文件实现不需要static inline.

           2）好的风格是函数在.h声明，在.c实现；
           3）extern 与 static 不能同时修饰一个符号，但可以用一个函数包装static变量然后extern该函数；extern声明可以修饰变量函数。
           4）.在函数被调用前，如果定义了那没问题，如果声明了，那编译可以通过，如果在所有文件都未实现，那链接出问题；
           5）.调用一个其它文件定义的全局函数(非static)，要么include该头文件(因为函数的声明放在头文件里面)，要么extern声明该函数（其实不加extern，直接声明就可以用了），如果只用到了个别函数，用extern可以加快编译速度；
           6）.如果函数或全局变量在定义时或声明时加了static修饰，那其它c/cpp文件访问不到（include/extern都不行），如果一定要访问，那就提供非static接口；
              因此，如果想把函数定义为static，就不要放在接口文件里面(.h)，如果想提供接口，那就不要做成static的(C++类成员除外)；
           7）.对于static修饰的局部变量，在编译时就分配了静态内存，该变量只在函数初次调用时才会初始化，后面的调用不再初始化（忽略初始化代码行）。如果static没有显示初始化，对于整形变量默认为0；
           8）. extern 用在变量或者函数的声明前,用来告诉编译器“此符号是在其它文件定义的，要在本文件使用,如果在本文件既定义了变量又做了extern声明，那extern声明就没有意义；
           9）.可以在多个c文件定义同名的static全局变量和函数，不会冲突；
           10）.非static全局变量的值如果不显示初始化，那取值就是随机的；
           11).当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
           12).当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。
           13）.函数名是指向函数第一条指令的常量指针，类似数组名，函数名取地址在数值上等于函数名，但类型不同；
           14).全局变量定义：
            1）某个cpp文件定义了非static全局变量，并在头文件extern声明，在另外的C文件访问这个全局变量的方法有2种：1）extern;2)包含头文件；
            2）不能在头文件定义非static变量，否则包含该头文件的多个c文件会重复定义（但加了static后，不会重复定义，相当于每个cpp文件都定义了一个同名static变量-内存不同）；但不是好的编程风格；
            3）如果在头文件实现static函数，那包含头文件的源文件可以访问，相当于重新定义了一份，不会冲突；但不是好的编程风格；
              如果在.h文件声明static函数，.c文件实现，那包含头文件的其它原文件就会有问题，提示找不到实现（因为static符号不会添加到符号表，所以链接器找不到），
              C语言里面的函数不加static时默认就是全局函数，可以被其它模块直接调用，加了static反而不能被调用了，而C++是要static才能被直接调用；
            4）不同的c文件不能定义同名变量，会命名冲突，如果加上static后则可以，因为static变量只在本文件内可见，不同文件的static同名变量不会认为冲突；
          15).C++的类定义在.hpp文件中，被多个源文件包含时不叫重复定义，这就是类的特殊之处；
          15).在对指针做算术运算时，一定要注意指针的类型，偏移量=sizeof(point type)*数值；eg: u16* p++ 那么p就偏移了sizeof(u16)
          16）.当整型表达式中存在有符号类型和无符号类型时所有的操作数都默认自动转换为无符号类型。所以要先强制转换为有符号数后再运算；   
          17).如果if后面没有大括号{},那接下来的一行代码要受if条件约束，其余的代码跟if无关，必然会执行；
          18).数组在内存中的分配是连续的；
          19)符号& 放在函数定义声明里面表示引用，在实参前面表示取地址；int a;get(&a) => get(int*) ;void get(int&) => get(a);
          20)memset()是以字节为单位来处理的，因为内存的最小存储单位是字节，不过内存的读取单位取决于CPU的位数，在嵌入式系统中，结构体/数组，按CPU位数对齐非常重要；
          21)typedef用来自定义类型，使用typedef定义的符号是一种新的类型，具备定义变量的能力；eg:typedef u32 rbArray[4];
          22)求莫化简(mod):[ a%b 且 b=2^n ] 等价于 a&(b-1) ;
          23)循环不变式：理解循环代码；
          24).memmove 好于 memcpy;
          25).内存越界(数组下标越界)不一定会使系统挂掉，取决于被踩的内存是否有protected机制；
          26).c规定：数组初始化值的个数可少于数组元素个数.这时前面的按序初始化相应值, 后面的初始化为0(全局或静态数组)或为不确定值(局部数组);
          27).#define 可实现多个文件互斥包含功能”当包含A.h文件后，禁止包含B.h文件"的功能，方法是：在A.h文件中，如下，同样在B_H中也对应实现；
              #ifndef A_H
              #define A_H
              #define B_H
              #endif
          28).连接符(##): 用来动态定义变量，和宏结合使用，#define EXTERN_STATIC_OBJECT(type) \
                                                  extern u8 g_macObject##type##Pool[(type::type##_NumOf)][ALIGN_DW(sizeof(type))]     
          29).局部struct初始化，structA a={0} 等同于memset,但是只能置0，其它的值只能用memset;
              C++方式初始化struct: structA a={memberi:valuei,memberj:valuej};    只有在定义的时候可以用{}对多个字段同时初始化，其它时候只能逐个初始化；     
          30).#error 预编译命令，停止编译并打印错误
            #define ab "hello"
            #ifdef ab
            #error "ab has been defined."
            #endif
          31).预处理特性： 1)预定义的标准宏 __FILE__, __LINE__ __DATE__, __TIME__ 2).字符串化(#)，标记合并(##) ;3)
          32).大小端：以byte为单位的访问顺序，不是bit为单位；
          33).函数参数是const变量时也可以设置缺省值，但如果是引用则不能设置缺省值。
          34).定义函数指针并初始化为NULL：void (*funcPtr)(para)=0; 这个函数指针就是个全局符号，可以在其他cpp文件赋值，调用： funcPtr(para);
          35).空结构体struct:sizeof=0,在C++中sizeof=1,因为C++中的class如果不含任何成员，那sizeof=1;
          36).只有在C++中结构体中才能含有静态数据成员，而C中结构体中是不允许含有静态数据成员的;
          37).(void)params; 可以规避编译器对没使用的入参告警；
          38).#define 在给结构体数组赋值的时候经常用来表示某一元素的值，使得数组看上去很紧凑；
          39).struct: 在C语言必须(typedef struct MAC MAC)才可以用MAC定义变量，否则需要用struct MAC st; 而在C++里面不需要这样typedef也可以直接用MAC来定义变量；
          40).C里面的<string.h>对应到C++的<cstring>    , std::memset() 需要包含这个头文件；     
          41).可变参数(...)，一般用在函数重载的场景，这些参数是不限类型的，具体怎么解释参数类型取决于函数实现，C++中用同名函数重载来替代这种场景，C语言不支持重载；
               eg:C语言的库函数: int printf( const char* format, ...),函数实现中必须用(va_list/va_start/va_end)来获取参数;
          42).结构体成员大小(struct member): sizeof(((SUlUeDataEntry*)0)->member);       
          43).define/enum/const: define&enum定义常量不需要消耗内存，而const会消耗内存；
          44).const u32 var = (a<b)?a:b; 这里对const变量初始化，只能用?:，不能用if/else;




1.C++基础：
     0).异常：代码中要支持异常的话需要使用特殊的编译器版本，而且系统的所有模块都要统一支持，不能是单个模块支持异常，而且异常的调试缺乏有效的工具支持；
     0)如果成员函数内返回*this,说明支持连续调用 eg: stream<<str1<<str2;
     0).虚函数表：如果类里面有声明虚函数，则类会生成个虚函数表(funPtr vtable[offset], offset依赖虚函数的声明顺序)，这个表是类级别的，每个对象有1个指针指向这个表，所以一个包含虚函数但没有数据的class,sizeof(class)=4bytes，这个大小和虚函数个数无关；一个不包含虚函数也不含数据的class size=1bytes(非虚函数没有表，因为是编译期静态 bind);
注意:sizeof(class)其实是对象的大小，虚函数表本身占用的进程空间大小是获取不到的，只能人工计算；
     0).函数内的栈对象的构造和析构函数调用代码是由编译器生成的（前提是这些函数是public的），所以C++的汇编代码不太好看懂，因为编译器添加了很多hidden code;
     0).如果普通全局函数实现放在cpp文件，则被依赖的函数应该放在依赖它的函数的前面，否则会编译错误；
     0)如果函数形参是引用，那实参必须和形参保持一样的类型，eg:fun(const MSG* &) ; 实参定义const MSG* ptr = null; fun(ptr); is ok;  but MSG* ptr, fun(ptr) is wrong;
        因为形参是const&实参可以是左值和右值，而如果改成fun(MSG* &)只能接受左值（有名变量是左值，字面常量是右值），fun(MSG*&&)只能接受右值；
      0）前向声明(forward declare)：如果classA的member包含了classB的(pointer, reference, static obj) ,则可以用foward declare,  classA.hpp不需要包含classB.hpp；
      0).模板函数的定义也可以放在cpp文件，只要在cpp文件进行实例化就可以，比如用实参调用该函数，或者单独做实例化。
          模板类/函数 只有实例化后才会参与编译，所以对于一个不被使用的模板类，只声明不定义是可以的(普通函数只要不被调用，也可以只声明不定义的)；          
       0）编译出错的时候，除了error, 还会有提示note，note是指建议的修改方法。
      0).定义两个互相引用的类是允许的，这时需要借助第3个类来构造他们:A{A(B&);}; B{B(A&);} C{C():a(b),b(a){} };
       0).三目运算符与条件引用： auto &  i = (j > K) ? J : K;  这种情况只能用 ？：表达式，不能用if/else； 
       0).把数组传递给函数时，如果函数参数是引用类型，则不会转为指针，还是数组类型，如果参数是值类型，会自动转换为指针；
        0).static 可见性: 如果static是非成员变量，只在当前文件可见，一个线程可以有多份，且独立；而class内的static成员变量对所有文件可见，整个进程只有1份，不论多少线程；
            假如B/C都继承A，其中B，C各自定义了static成员变量且名字相同，那它们是内存独立的；假如A定义了static成员变量，那对A及A的所有派生类都是同一份；也就是说，static成员属性往下可共享，对父类和兄弟不可共享。
        0). 函数名其实是个常量，C++里面的成员函数是属于类的，不是对象的，可以赋值给函数指针，实际中可以把接口类的函数用static数组存储，然后派生类的对象可以虚调用；
        0）. 括号()的几种作用：提升计算优先级，函数调用，构造对象，类型转换；
        0). static变量默认都是进程级别的(包括全局的和成员变量)，与class继承体系无关， 如果要定义线程级别的static: __thread static int c;
         0).namespace: 匿名namespace相当于static, 在匿名namespace内定义函数不需要加上static inline, 不会导致重定义因为每个cpp文件都独立有一份，极力推荐大量使用namespace !! 
             曾经遇到一个编译错误：function has internal linkage but is not defined, 这是因为该函数的参数使用了定义在匿名namespace内的类型, 导致其它cpp文件无法通过extern使用该函数，把类型定义挪出匿名namespace就可以了。还遇到个问题，A.cpp文件的funcA内部访问了匿名namespace内的符号obj，而B.cpp调用了funcA, 本来是想验证B.cpp中的obj, 但结果不对，是因为funcA访问的符号只能是A.cpp看到的obj,  看不见B.cpp的obj;
总之：在使用匿名namespace时，最好不要和extern发生关系，否则容易风险;

         0).头文件包含顺序：如果新增classA,且classA用到了很多老的模块，那么classA.cpp应该先包含那些被依赖的头文件，最后才包含classA.hpp（而不是把classA.hpp放在最开始）,这样有助于编译器识别依赖的符号；
         1） 函数位置：当一个函数需要访问一个符号时，且这个符号属于某个类的成员，那这个函数就应该作为那个类的成员函数，因为成员函数就是为了访问成员数据的，反之亦然；
            如果要觉得增加的接口太多，那就干脆设置为友元函数；
         2） 不加::时，默认用全局的定义；
         3）在不同的类里面定义的相同结构体，不会冲突，因为属于不同的作用域，外部模块在使用类里面的结构体/枚举时，要加上class::限定； 另外， 外部模块无法访问类里面的枚举取值；
         4）引用：定义时必须赋值[赋值方式可以是=或者()]，且给引用赋值的不能是临时变量（栈变量也不行），所以，int getvalue()  //返回的是临时变量,不能赋值给类型为引用的变量， int& getvalue() //返回的是对全局变量的引用，可以赋值给类型为引用的变量；
               如果函数返回的是对栈变量的引用，尽管编译连接通过，但程序结果肯定是错误的；
               如果类成员是引用（当然是其它类的引用），那只能在构造函数的初始化列表里面赋值，不能在构造函数体中赋值；
               基类的成员可以引用派生类的成员（通过构造函数传递），这样基类就可以访问派生类的数据了，不过这不是好的编程风格；
               函数参数如果用到了缺省参数，那这个参数就不能定义为引用；
               可以把派生类对象作为入参赋值给基类&，效果类似于派生类对象指针赋值给基线指针；
         5)new/delete是C++编译器解析的，C++编译器负责把new分解为1）申请内存 + 调用构造函数初始化内存+转换指针类型； 把delete操作分解为：1）调用析构函数 + 2）释放内存；
              在用delete释放本对象前，先要把该对象里面的成员指针释放掉(如果该成员指针是由本类new出来的)，原则是：new的class负责delete,其它使用的class不能代替释放；
         6）static成员对象： 与全局对象（全局静态对象）一样，由OS负责构造和析构（进程运行前构造，退出后析构），当某个类A包含了static子对象B的话，在创建A对象时编译器是不会调用B的构造函数，释放A时也不会调用B的析构函数；
                         经过试验，可以在类里面定义本类的static对象，这时必须在类外初始化(不论static object是private/public)，初始化时会调用类的构造函数（即使构造函数是private的），这个动作在main函数之前执行；
                         static全局对象在main()之前构造，而局部static对象在函数被执行到时才调用构造函数；         
         7）类成员可以为本类的指针或static对象（必须在类外初始化，否则相当于没有这个static对象），但不能是自身的非static对象，也不能是自身的引用，可以是别的类的引用；
         8）必须对任何 const成员变量 或 引用类型成员变量 或者 没有默认构造函数的子对象 在构造函数初始化列表里面赋值。
         9）符号命名： 包含了： namespace + class + function name + function parameters(type+number);与文件名无关，因此，cpp中的实现和.hpp中的声明之所以能对应上本质是因为符号名称是一致的，文件名其实可以不同，但建议相同；
                   如果两个源文件中定义了一样的符号，并且同时参与链接，那连接阶段会报错，除非能够限制连接器的搜索范围；
         10)static之所以可以隐藏符号，是因为编译器不会把static 符号放进符号表里面，这样连接器就找不到；
         11)hpp文件与cpp文件的作用: hpp文件的作用体现在编译阶段，告诉引用该头文件的源文件编译可以通过，cpp文件的作用体现在链接阶段，让链接器可以找到对应的符号；
            每个源文件都会生成符号表（本模块实现的函数或定义的变量）和重定向表（引用的外部函数和变量），连接器将所有符号表组成一张全局符号表，然后为每个重定向表去全局符号表中查找，找不到或者找到不止一个都会报错；
        12） static成员变量可以由static函数和非static成员函数访问，static成员函数只能访问全局变量或者static成员变量；
        13)函数重载： C++编译器通过函数名和函数参数,末尾const来区分（与返回类型无关，不要通过返回类型来区分函数），这其实就是C++中符号命名的规则,函数尾部是否带const编译器可以区分，返回类型带const则无法区分；
        14)类的大小： 由本类的数据成员和继承过来的数据成员，加上指向函数列表的指针，指针的个数取决于直接父类的个数，虚函数的类会稍大一些；
        15)函数对象：如果类重载了操作符operator()，那这个类定义的对象就可叫函数对象，可以通过 object(***)的方式来实现类似函数调用，函数对象用于函数参数中可实现模板函数，提高代码复用；
            eg: TUeIndex operator()(paramter) const { return uePsIndex; } 其中operator()是个整体（函数名），再后面的()是函数参数；
                  函数对象：首先是对象，同时具备函数样子，本质上就是类里面重载了operator();一个类里面可以重载多个operator();模板函数：参数是个函数对象&&模板，可以调用不同的类里面的函数；
                    template<class FuncT>
                    void addFuncTemplate(int a, int b, FuncT& func) //模板函数：参数func是个函数对象，可以调用不同的类里面的函数，不过函数的入参必须相同；
                    {
                      func(a,b);
                    }
        16)成员函数调用：一个类的成员函数调用本类的其它成员函数，直接调用和通过this调用是一样的，this其实是隐藏了的,如果调用的是虚函数，则最终调用的是this真实所指对象的函数,eg:classsA{this->func();}, this = DerivedB;则func是B里面的，不是A里面的；
           成员函数类型：1)如果是static: void(*)(); 2)non-static:void(A::*)(); 区别是否需要有class::
        17)模板：如果不确定模板参数的数据类型，就用template<typename T>,如果确定是个class，就用template<class C>,尽管在模板定义语法中关键字class与typename的作用完全一样,但这是好的编程风格;
           模板类的成员函数的实现必须放在.hpp文件中；模板成员函数的实现也必须放在.hpp文件中(符号存在于被实例化的.o文件中)，因为放在cpp文件中编译器没法实例化；
           如果模板类包含static数据，然后特化出了2个不同的类，那么这2个类的static数据在内存上是完全独立的，没任何关系。

        18).尽量不要在构造函数内使用this指针及通过this调用成员函数；
        19).enum: 我们产品中的enum是int32的，最高位一定是符号位，在定义bit变量时需要特别注意；
             C++标准规定把一个超出enum的最大值强转为enum，结果是undefined的,enum内存分配只要能容纳所有的enum值就行，不一定是4个bytes,取决于编译器；不过:1byte<= sizeof(enmu)<=sizeof(int);
            http://www.cnblogs.com/ymy124/archive/2012/02/24/2366481.html
        20)类的const成员变量: http://blog.csdn.net/whz_zb/article/details/6875639
            只有static const integral data member(静态整型常量数据成员,int/char)才能在类内初始化，但如果是数组，只能在类外(cpp文件)初始化;  
            static const VS const member: 前者在类外初始化（在程序main函数执行前），且与对象实例无关，后者在构造函数初始化列表中赋值，每个对象实例可以有不同的值； 
            非静态的常量数据成员必须在构造函数的初始化列表中初始化;
            静态非常量数据成员只能在类外(类的实现文件)初始化;
            非静态非常量数据成员可以在初始化列表或者构造函数体中初始化；
        21)const成员函数只能调用const成员函数，返回类型必须是const&, http://blog.sina.com.cn/s/blog_4366aa320100cknr.html
        22)const_cast<type&>(variable): 只能通过引用或指针来修改const对象值,且只对结构体/类有效，对基本类型无效(int/char)。http://blog.csdn.net/lwbeyond/article/details/6213382
            const_cast 去除const属性，static_cast<const Type&>可增加const属性，这两个组合可以实现non-const函数复用const函数的代码；
        23)dynamic_cast，支持派生类指针到基类指针的转换（C++编译器默认就该支持啊？）,反过来它就不支持了，会导致编译错误，这种转换是最安全的转换;
            reinterpret_cast 支持任何转换，它是最不安全的转换;   
            static_cast:  编译时做的转换，可用于基类指针强制转换为派生类指针； 
            C++中一般用static_cast代替C语言类型转换；
        24)数组引用：添加成员变量为对外部模块的引用，且是一个数组内存(在构造函数的初始化列表中初始化):   TUePsIndex  (&m_delayedUeFd)[MAX_NUM_OF_PUSCH_RECEIVE_REQ];
             建议在函数传递数组参数时尽量用T (&arr)[NUM]，不要传递pointer;
        25)获取成员变量偏移地址: #define OFFSET(s, m)   (u32)&(((s*)0)->m)        其中m是结构体s的成员;
        26)如果枚举enum定义在classA{enum {i,j}}里面，那访问时必须指明classA::i  否则访问不到；
        
        28).定义数组对象时，类型可以是基类，元素值是派生对象，eg: ClassBase array[]={ClassDriveObject1,ClassDriveObject2};   

        30).#if #elif #endif  : 预编译时候的if,不能用来判断表达式结果？？ eg: #if MACRO_XXX #endif;  #if !MACRO_XXX #endif;
        31).在C++中，const常量是否占据存储空间取决于是否有引用该常量地址的代码。C++对于const变量默认为内部链接(在其他文件中看不到本文件定义的const变量)，因此const常量定义放在头文件中，被多个cpp文件包含也不会出现链接错误。
        32).自定义数组类型: typedef u8 Array[10];  那么Array就是一个type了，可以定义数组变量，eg: Array arr;
           typedef u8 Tbl[2][3]; Tbl arr={**};Tbl*ptr=&arr; return (*ptr)[0][0];
           Tbl arrA;Tbl arrB;const u8(*arrPtr[2])[2][3] = {&arrA,&arrB};

        34).构造函数：功能是初始化内存，当进入到构造函数时，说明对象内存(及继承对象&子对象)已经有了，这时就可以访问子对象内存了，即使还没有对子对象进行构造初始化；
            初始化列表a(b)解释：1)如果a是基本类型(eg:pointer,int)则表示赋值a=b;2)如果a是对象，则表示调用a的构造函数，b是入参,a(b,c)那肯定是构造；3)a引用b;
        35).子对象/对象指针/引用: 如果定义为子对象那就说明本类是创建者，如果定义为指针，那既可以由本类创建(选择合适的时机)，也可以由其他类创建，更灵活，如果是引用那必须要改构造函数且非本类创建；
        36).在类的构造函数体或初始化列表中可以访问任何class成员，只不过不宜做逻辑运算；构造函数对成员初始化应该为无效值，这样更安全；
        37).static const u8 i=0;  but u8 static const i=0 will cause error"storage class is not first"
        38).C++类设计：新增成员尽量为引用或者子对象，不要用指针，因为指针的赋值时机不能控制，很容易导致架构腐化，而引用只能在构造阶段赋值，可以保持架构；
        39).static 成员函数不能在尾部加const修饰符；
        40).operator,有两种用法，一种是（操作符重载,eg:operator +/() ），必须有返回值； 一种是（隐式转换）,eg:operator int()，不需要返回类型；
            operator 类型名(): 隐式转换，它没有返回类型（但是内含return语句），因为类型名就代表了它的返回类型。
            operator bool() const { return isValid(); } 如果类里面重载了bool(),那可以这样使用if(!object)，属于隐式转换；
            void operator()(int in) :操作符重载,实现函数对象；
            u32 operator%(const u32 rhs) const ：重载%运算符，这样对象实例可以直接参与取模运算；
            operator u16() const 实现class object-->u16自动隐式转换(注意函数声明中没有返回值)；反过来如果要u16--->class,通过单参数构造函数实现；           
            将A-->B的2种方式:1)在A类里面operator B();2)在B里面实现构造函数：B(const A&);
            ++object:Xsfn& operator++()  { return advance(1); } 
            object++:Xsfn operator++(int )  { Xsfn oldXsfn(xsfn); ++*this; return oldXsfn; }
        41).如果ClassA包含B/C 2个pointer，且C又引用到了B的成员变量，那么B应该放在A的初始化列表里面new，C应该放在A的构造函数体里面new,这样可以保证顺序是对的；
        42).命名空间内的class前置声明方式: namespace sch{ namespace ca {class TbmCtrl ;} }
              命名空间内的frind class 声明方式: friend class ::macps::ul::sch::TestUlLoadControl;
            eg使用空间内具体类: using sch::ca::TbmCtrl;  eg使用某空间内所有定义: using namespace sch;//sch本身是一个命名空间
            头文件里面不要直接using整个namespace容易导致命名冲突，建议自定义类型 using mytype = xxx;
        43).命名空间(namespace):在处理多个同名符号(函数，变量，结构体，类定义)时特别有用，重构代码的初步阶段可以利用namespace，这样可以在改变符号定义时不改变调用代码；
        44).Derived-class里面只有方法，没有新增数据时，可以用派生类对象赋值给基类对象，Base array[]={Derive1(),Derive2()} ， 但是这样做多态性就失效了；
        45).define宏函数与inline函数的区别：前者的形参是没有类型的，只有参数名字，而后者必须有参数类型，所以inline更安全;复杂的宏函数里面一般都调用了inline子函数；
        46).C++ 类如果只有方法，没有数据，size=1,不是0;
        47).变量修改程度递减: const--->xxx---->mutable---->volatile(表示同时被多个core修改，告诉编译器必须从ddr读取，不能缓存)
        48).class object memset:在C++里面，一个纯粹的struct可以memset,但是不要对一个位于继承体系的class object做memset,否则会把这个object的虚函数表给破坏掉,千万不要这样：memset(this,0,sizeof(*this));
        49).非成员函数：可以在cpp文件里面定义static非成员函数，被本文件里面其它的类成员函数调用；
        50).消息内存释放：在嵌入式系统，一般是消息发送方调用平台接口申请内存，消息处理方在处理完消息后负责释放内存；
        51).void* : 万能的类型转换（多态），建议尽量少用；
        52).this->: 用来显示告知是在调用本类的成员变量（而不是临时变量）；
        53).C++引用与指针： 如果某个算法策略支持online change,那么就只能定义一个基类指针，不能定义为基类引用；
        54).构造函数重载：在重构代码的时候很有用；
        55).栈对象：1）如果是匿名的，那生命期只有一行代码，classA(*)生成匿名对象，本行执行完后立马析构；2）如果是有名对象，classA obj(*)那有效期是该函数返回后；
        56).C++中不能重载&& || ,(逗号) &(取址) 这些操作符 ; 不过  operator*, operator-> 是可以的；
             eg: T& operator*(){return *m_pointer;}  eg: T* operator->(){return m_pointer;}
            operator< (**)参数不能都是指针类型，举例：operator<(NodePtr p1, NodePtr p2)会报错，改成:operator<(Node p1, Node p2)就可以了；
        57).解引用: Type* ptr=NULL; Type& obj=*ptr; 不会导致编译出错，但是会导致undefined behaviour,不一定会crash（反而更加危险）,不过sizeof(*ptr)是合理的。
        58）C++里面使用this->来区分是成员还是外部符号是一种好的风格，不要使用m_来区分成员变量
        59) 不同命名空间里的函数，即使一模一样的实现也不会导致重定义；
        60) 不同路径下可以有同名的源文件，不会导致编译问题(.obj不要输出在一个目录)，只要它们的符号不要重定义；
        61）ClassA obj(); 创建有名对象，有效期是当前作用域； ClassA() 创建了一个匿名对象，有效期只限当前这一行代码，当前代码执行完立即就析构了；

2.数据结构基础： 1).处理一个链表时(插入，删除，循环等)，至少需要考虑3种情况能否正常进行：链表空、只有1个节点，只有2个节点，（如果是循环，从任意节点开始是否都能完成）；
                 2).数组--> 栈、队列(ring buffer+尾部索引+元素个数)、矩阵(2维数组)、
                    散列表(hash函数映射为数组下标，如果冲突再加一个函数或者用链表数组);
                    映射(MAP):将A类型的元素群映射到B类型，可用结构体数组表征，typedef struct{A,B}map[10];
                    集合(set)：二进制数组，集合中的元素对应数组中某个元素(整型变量)的其中1bit,eg:100 RB 用 uint32 RBView[4], RBView[j/32] |= 0x1<<(j%32);等价于 RBView[j>>5] |= 0x1<<(j&0xffe0);
                    集合的交(并)可以通过按位运算&(|)求得,非常方便；
                 3).链表-树-图 这3者本质上都是节点连接，链表：前后只有1个节点，树：前面1个节点，后面多个节点，图：前面，后面多个节点，还有可能是闭环，另外，图具有边的属性(长度，代价，时间等);

0.代码执行耗时： 代码行数，cache大小及速度，CPU频率，流水线技术，算法本身效率。
1.Linux下的动态链接库(也叫共享库)是.so文件；不同so文件里面的同名全局变量是否同一块内存取决于生成动态库so时的share选项;
  1）编译：得到libs.o(源文件s.c)  ：   gcc -fPIC -g -c s.c -o libs.o
  2）链接：得到动态库libs.so  ：    gcc -g -shared -Wl,-soname,libs.so -o libs.so libs.o -lc
  3)链接so文件，得到可执行文件ts(ts.c调用了so里面的函数) ：    gcc -g ts.c -o ts -L. -ls
  4)linux下的动态连接库装载规则：当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。如果不想被覆盖，则需要通过gcc编译和链接参数控制导出哪些符号；
  5).map文件，控制哪些符号需要动态导出；.sym文件，控制符号静态导出； 在装载动态库时，只有动态导出的符号会被加入全局符号表；
  6).动态共享库Linux-so(windows-dll); 静态库Linux-a(windows-lib);

1.进程与变量： 不同进程的内存空间是完全独立的，同一个进程的不同线程共享全局内存和堆内存，而寄存器和栈内存是线程私有的；
   比如产品里面的全局变量，在每个core上面都是独立的，因为每个arm/dsp core是一个进程, 所以要在每个core上都对全局变量赋值。很容易犯的错误是有1个core处理了消息，其它core没有处理导致该core上的全局变量没有赋值。如果要通过变量地址来共享信息，必须保证双方在同一个进程空间或者这块地址就是内核分配的shareMemory或者是实模式下的物理地址，否则会core dump.

2. 类外实现成员函数时，别忘了在前面加classname:: 否则提示unresolved;

3.singleton:1)singleton 类的构造函数和析构函数都建议设为private的，这样可以阻止外部模块随意创建和释放对象；这时需要提供个接口来创建singleton对象;
            2)singleton 类的析构函数里面最好把static成员指针设为NULL，解释：既然能进入到析构函数，说明已经调用了delete，也就是这块内存已经被释放了，所以必须要置为NULL，否则外部模块有可能获取到的是野指针;
            3)在singleton类中，static函数可以间接通过访问static指针来访问本类的非static成员，这时的非static成员内存其实是确定的了；

4. static 功能：限制变量的作用域和存储域（及有效期），及访问方式(class::)；   
   static对于类成员与非类成员具体作用是有区别的:
   1)对于非类的普通static变量/函数，只能在定义的模块内被直接访问（函数，文件等等），如果其他模块要间接访问，可以提供函数接口（不能在其他cpp文件直接extern）；
   2）对于类static成员变量/函数，外部模块可以通过classname::的形式访问(public下)，static成员函数在实现时不使用，只在声明时使用；
   类成员可以通过public/privat关键字来控制访问权限，非类成员则通过static来控制访问权限，加了static后只在本文件内访问；
   static优势：可以节省内存，实现不同对象（包括基类派生类）间内存共享，但这时就不能随便删除内存了，
   (1) 类的static成员函数没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。不能访问非static成员变量及函数；
   （2）为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。
   （3）局部static变量也是放在全局静态内存的；
   4）static全局变量和普通的全局变量都是存储在全局静态内存，只不过加了static后，作用域变成文件级了，所以说，static最主要的功能是隐藏；
   5）非static函数可以访问static成员；    static成员函数要通过classname::的方式访问，不能用对象p->的方式；
   6）构造函数和析构函数里面绝对不要去操作static成员变量,static成员变量的赋值要么在初始化时，要么提供个接口函数类似单实例创建；
   7）
   8)共享so文件里的全局变量最好定义为static，这样就不会和其它的模块冲突；
   9)文件内的static全局变量不能被外部模块直接extern,但可以提供个非static的接口来给外部模块间接访问这个static变量；
   10)***如果基类中定义了static成员变量，所有子孙派生类和该基类定义的所有对象均共享这唯一的一份内存， 因为这个变量根本就不存在于对象中!! 所以，在基类中不能随便定义static成员；
   11）static变量位于静态内存，所以整个程序运行期间都有效；
   如果在模板类中定义了static变量，那么用不同的模板参数在实例化类时这个变量的内存是不同的，因为得到的是2个不同的类；
   成员变量如果不加static，在new对象时占用堆内存（当然也可以显示让他指向静态内存），如果加static占用静态内存（这时在编译代码时就分配了），跟创建对象没有关系；
   static成员内存只有一份，不论创建多少个对象，因此必须放在类外初始化，不能在构造函数中初始化：1）构造函数必须创建对象才跑到，而static变量内存早就有了；2）建立多个对象时会再初始化，把前面的值给覆盖掉；
   static类成员变量内存共享是指在进程内共享，不同进程间是独立的，没法共享，不过，线程内可以共享；
   特别注意：static 成员函数在类体外实现时，绝对不能再加上static关键字了，否则编译错误；
          也就是说，static是一种声明时的关键字（因为外部模块需要知道是否static），实现时不再使用(virtual也是声明关键字)；inline关键字正好相反，Inline是实现时的关键字（外部模块不需要知道是否inline）；



5. 类的普通成员函数和static成员一样，也是属于类，不属于对象，只有一份（在创建对象前就有了），所以在调用非static成员函数(包括构造和析构)时编译器会将对象地址（this指针）传给这个函数来找到对应的数据(每个非static函数的第1个参数其实就是this指针)，
   不同对象修改的是各自的数据，
   所以类的大小与成员函数个数没有关系（不过虚函数会增加类的大小），对象的内存布局：本类的数据成员+指向本类的函数列表的指针+基类1数据成员+指向基类1函数列表的指针+基类2数据成员+指向基类2函数列表的指针+。。。
   另外，每个对象其实就是个结构体变量，对象嵌套就是结构体嵌套，只有数据才会占用对象的内存；
   创建对象的过程：1）分配堆内存；2）调用构造函数初始化对象数据； 所以，在构造函数里面是可以调用成员函数且这个函数可以访问成员数据（只不过这时的数据是垃圾值），如下已测试通过：
   class A
    {
    public:
        A()
        {
            a = get();//这时get得到的是垃圾值
        }
        int get()
        {           
            return a;
        }
        int a;
    };
   CUlCoreCellContext::cellUp()
   {
     m_cellPtr = new ULPS_POOLID CUlCoreCell(mCelId,this)//this =  CUlCoreCellContext* 注意this是当前所在的成员函数cellUp的第1个入参，类型是当前成员函数所属类；
   }

6.restrict : 告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,也就是说在本函数内只能通过这个指针来访问某块内存；
而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行pipeline操作,
比如func(restrict int* ptrA,restrict int* ptrB)//这样编译器就知道ptrA/ptrB肯定是指向两块不同的内存，所以可以优化，如果不加restrict,那编译器会认为ptrA/ptrB可能指向同一块内存，不敢优化；
编译器在for循环时能进行pipeline并行操作最关键的是在循环开始前就非常明确的知道每个循环需要访问的内存地址，这个地址不依赖于上一次循环，
比如数组操作就可以使用pipeline,但链表操作就不行，且每个循环是独立处理的；


7.volatile: “随时可变”,告诉编译器必须每次都要从内存读取最新的变量值，不让编译器做优化； 与 restrict 作用正好相反；
             volatile 一般用来修饰寄存器，线程共享变量；
             一个函数参数既可以是const也可以是volatile，同时用这两个关键字 意味着本函数不会去修改这个参数，但存在其它函数去修改这个值,所以是随时可变的；

7.explicit ：让用户在创建对象时必须显示调用构造函数，防止隐秘的类型转换,
     class obj = arg;//隐式调用构造函数，当构造函数包含1个参数，且没有声明explicit时 才可以这样，否则必须显示调用构造函数class obj(args);
  原则上应该在所有的带1个参数的构造函数前加explicit关键字(如果不带参数或者多个参数则不需要加)，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。
  C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 1 是个构造器 ，2 是个默认且隐含的类型转换操作符。
  单参数构造函数可以实现其他类型到本类的转换，
  而Opertor type()const{}成员函数可以实现本类对象转为其它type类，eg: operator u16() const{return xsfn}； so Xsfn sfn, u16 v=sfn;
7.const: "只读",是说在当前模块范围内只读，其它模块还是可以修改的； 如 int a;const int * p = &a,是说不能通过*p来修改a的值，但a的值是可以被修改的；         
         用const修饰的成员函数不能改变本对象的成员变量，不能调用本类的非const成员函数，也不能调用成员对象所属类的非const函数，但是可以调用其它不相关类的非const成员函数。
         const成员函数可以修改本类的 mutable 和 static 类型的成员变量.可以修改非本类家族的其它类数据(如函数参数)；
         const对象只能调用const函数，非const对象优先调用非const函数，其次才调用const函数；const对象是从构造函数完成之后，析构函数之前这段时间内保持const属性；
  mutable: 被mutable修饰的成员变量可以在const成员函数里面被修改，应用场景：增加新成员，需要在const函数里面修改，不影响原来的接口(保持const修饰),要求mutable变量对外部模块不可感知;     
  mutable: should be used when we are changing "internal" state of const object, while "externally observable" state remains unchanged. 
     TBoolean CCellContextServices::storeTempUeContext( CCellContext* const p_cellContext, CUeContext* const p_ueContext ) const
     {
        return p_cellContext->storeUeContext(p_ueContext);//storeUeContext 是CCellContext类的非const成员函数；
     }

8.register(寄存器): 这个关键字已经过时了。 只有局部非static变量和形参可以定义为寄存器变量（一般是整形变量），其他（如全局变量）不行。一个计算机系统中的寄存器数目是有限的，不能定义任意多个寄存器变量。
                  这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。
                  其次，因为register变量不存放在内存中，所以不能用“&”来获取register变量的地址。
8. 宏定义: #define SECONDS_PER_YEAR   (60 * 60 * 24 * 365)UL  预处理器将为你计算常数表达式的值，因此写出计算过程会更清晰而没有代价；
   #define MIN(A,B)    ((A) <=  (B) ? (A) : (B))   least = MIN(*p++, b); 说明用宏定义函数是有副作用的，最好用Inline;
   inline int MIN(int a,int b) //inline定义的函数一般是有返回值的，而define定义的函数:1)如果有return，那不能作为一个值来使用；2）如果要作为值来使用，那就是一个不带return的复合表达式;比如(a <=  b ? a : b);
   
   8.1)宏定义还可以用来快捷访问嵌套结构体里面的成员；
   8.2)用define定义函数时，建议将语句块放入do{..}while(0),同时在调用处加上;号，当宏参数有赋值，递增递减时，要小心了；
   8.3)宏的一个独特优势：可以使用##合并宏参数得到新变量；
   8.4)宏定义的函数，入参是没有类型的；

8.C++运算符优先级: ++的优先级高于*, <<移位的优先级非常低，  *iter++和{*iter , ++iter} 效果一样；
          逻辑与(&&)高于逻辑或(||);
  
8.运算符：1)()括号运算符用于4种场景：提升表达式优先级，函数调用，对象构造，类型转换；
          2)sizeof:用于计算变量或类型的大小，给编译器使用的；
          3)!用于逻辑求反，~用于按位求反,^按位异或(当且仅当1个1时结果为1)；
          4) a>=b, b<=a,不能写成 b=<a;

9.使用前缀++和使用后缀++都可以达到同样的效果时，我们应该用前缀++，这是因为后缀++会产生临时对象，性能不如前缀++，特别是自定义的大型对象就更应该尽量使用前缀++了。 
10.namespace : 1)可以在多个文件定义相同名字的 namespace ，相当于这个namespace是它们的并集；另外，namespace可以嵌套；
   2)可以在不同的namespace定义相同名字的变量/函数/类名(这样可以对外提供相同的接口，有利于外部模块演进)，如果同时被一个外部文件包含，那在调用函数时就要指定用哪个命名空间;
   3)派生类和基类所属的namespace可以不一致，在继承时声明基类命名空间就行;
   4)匿名namespace(C++):作用类似于C语言的static，限制符号作用域为当前文件，这样不同文件的同名符号不会冲突,eg:namespace{int globalVar;} 使用的时候直接用:globalVar=1;
   std是C++里面定义的命名空间，C不支持；
   当被测试对象含有#ifdef 宏时，可以通过namespace的方法来分解对象，避免重定义，遍历测试所有分支；

11. 下面例子中，派生类继承并实例化了模板类，
typedef CDatabase< ::macps::dl::pre::FastNodeData, ::macps::dl::pre::UserData> CDataBaseBaseClassDl;
class CDatabaseDl : public CDataBaseBaseClassDl
{
};
12.static 类成员在类外初始化（注意这时不能再加static关键字了），如果没有=号，说明初始化为0；
初始化格式 ：<数据类型><类名>::<静态数据成员名>=<值>  ，static数组成员在初始化时可以不赋值；
下面的例子中， UserStorage 是命名空间， m_nodeArrayFast 是类 CDatabase （2个参数的模板类）的static成员，其类型是 CNodeFast （1个参数的模板类）；
template <class F, class S> UserStorage::CNodeFast<F> UserStorage::CDatabase<F, S>::m_nodeArrayFast[];

13.模板类: 模板成员函数声明和实现一般都放在.hpp文件中，（这个头文件是在包含它的cpp文件中被编译的），模板类里可以包含虚函数，但这个虚函数不能带模板参数；
          由同一个模板类实例化得到的不同类之间没有任何关系；
          模板类可以定义对象(指针)： 如下面的m_userStorage：从下面可以看出，如果类的成员有模板对象，那本类也必须是模板类；
           template <class ueDataType, CellResourceGroupContextType crgType>
           class CCellResourceGroups{CDatabase<ueDataType>*  m_userStorage; }  参数ueDataType是包含成员m_userStorage的那个上层类CCellResourceGroups传进来的;
          模板类可以定义函数参数：  void SetUserStorage(CDatabase<ueDataType>* userStorage)，
             在调用该函数时，通过实参自动特例话： SetUserStorage(iUserStorage);其中 CDatabase<CDlUserData>* iUserStorage；
          模板类中的参数，可以直接当做变量用在成员函数中，如 CCellResourceGroups：：isEnable{return ISTRUE(UpLink == crgType) ? m_sharingMode == DLandUL : m_sharingMode != None;}                     
          template <class ueDataType, CellResourceGroupContextType crgType>
          模板参数可以很多个，每个由"类型+参数"构成，模板参数可用作函数返回类型；
          模板是C++多态性的一种表现；
          参数特例话时机： 模板参数在派生其它类或者定义对象时实例化模板参数；
          模板成员函数的实现如果要放在cpp文件，那在cpp文件里面就要将模板实例化，这不是一种好的编程风格；
   模板函数： 模板函数的模板参数不一定要用于修饰函数参数，可用于定义函数内局部变量；
   例如删除一个对象指针：         
              template <class C>
              void DeleteObject(C *& pObject)
              {
                assert(pObject);
                delete pObject;
                pObject = NULL;
              }

13.inline:   http://www.cnblogs.com/berry/articles/1582702.html
            成员函数直接在类里面实现就自动变成inline了（这时不必加inline关键字）,inline函数的实现建议放在hpp文件中，如果放在cpp文件中，被其它文件调用的话有些编译器会报错；
             虽然inline函数的实现既可以放在cpp文件，也可以放在hpp文件的类体外(建议此种风格)，在实现时必须加上inline，在声明时可以不加，
             对于非inline函数，只能把实现放在.cpp文件，不能放在.hpp文件，否则，这个头文件在被多个文件包含时，会出现重复定义；
             构造函数、析构函数的实现最好放在.cpp文件中，不要放在类体内(不要变成inline函数)；
             当内联函数被应用在代码库的时候，如果内联函数改变，用户必须重新编译他们的代码以反映这种改变。然而对于一个非内联函数，用户仅仅需要重新链接就可以了。
             virtual函数不能设置为Inline函数，因为编译期间无法决定调用哪个函数；
             如果inline函数被函数指针调用，那编译器会生成一个outline的函数;
             Inline函数如果要支持调试，那可以在调试版本中废除inline关键字；
             inline缺点：如果inline函数改变实现，那所有调用代码必须重新编译才能使用新的实现，反之如果是non-inline函数，只需要重新连接就可以了；
14.inline: 这个关键字不能乱用，有时候会导致编译不过，因为在调用点展开后不一定能看见相应的定义范围了；严格意义上讲，inline定义的函数不是真的函数，因为编译器会自动展开；
   inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。也就是说，一个函数是否inline，要看实现的时候是否用了这个关键字；


13.纯虚函数举例：  virtual u64 createSortCriteria (u32 crg, u32 index) = 0;如果要求派生类必须提供这个接口，且本类不能创建实例，则可定于为纯虚函数；
   类A里的纯虚函数可以被类A的其它函数调用，尽管类A没有实现；
   尽管classA里面声明了某函数为纯虚函数，在该类的cpp文件中仍然可以为纯虚函数提供定义；

15.内存区别（堆，栈，全局静态存储，常量存储，自由存储）：  http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html
   栈内存：系统会自动分配和释放，但内存空间有限；
   堆内存：由malloc/new申请，free/delete释放，系统不会自动分配和释放的，所以如果申请后，不主动释放就会一直存在直到程序退出；
         嵌入式系统尽量少用动态内存分配（会造成内存碎片，然后会导致分配大块内存失败）；修改方法：成员对象 = 1.改成对象指针 + 2.指针指向全局静态内存 + 3.手动调用构造函数；   
         静态内存：1）优点：可以连续分配大的内存块；2）缺点：如果某个特性关闭，内存也需要占用，导致浪费； 但是因为DDR内存比较便宜，所以还是用静态内存比较好；
         动态内存：1）优点：如果跑不到，就不需要分配内存，节省一点；2）缺点：导致碎片，大的内存分配失败，容易导致泄漏；
   全局/静态存储区（global&static）： 系统自动分配（在程序编译时就分配好）,系统自动释放(在程序退出时)，所以整个程序运行期间是一直存在的；
   常量存储区：只读内存，位于静态存储区，程序退出时释放；

16.C++支持多态性。1）编译时多态是通过函数重载和运算符重载实现的 ，2）运行时多态性是通过使用继承和虚函数实现的，虚函数的多态性取决于调用这个函数的对象(指针)；
               3）引用和指针类似，基类引用可以指向派生类，实际调用的函数由virtual多态性决定；   
    重载： 对于自定义函数,可使用缺省参数来达到某一程度的“重载”等功能，缺省参数只能放在函数声明中，对外部模块可见； 
   虚函数virtual原理：先根据指针类型找到对应的类（如果基类中不存在该接口则编译报错），然后再根据该函数是否虚函数来决定是否调用真实所指对象的函数；
   当某个派生类没有覆盖虚函数时，逆序向上找到第一个重新定义的函数。如果派生类覆盖了基类实现，但是基类不是virtual函数，那一旦进入基类后接下来调用的是基类函数，而非派生类（即使指向派生类对象）；   
   eg:classBase{funA{funB;}; virtual funB{}}; classD:classBase{funB{;}};那么classD的对象如果调用funA则是classBase的funA，然后调用funB时发现是virtual，再调用classD::funB;
   总结：决定调用哪个函数不是根据指针指向的地址，而是指针类型。 记住“只有在基类指针 指向派生类时多态性才会起作用”。http://blog.csdn.net/ring0hx/article/details/1605254
       通过基类指针只能调用基类中声明过的函数，不能调用在派生类中新增加的函数（因为编译器根据指针类型只会在基类中寻找调用函数）；
   重载举例: void operator() (int a, int b);

16.继承： 每个派生类对象都含有其基类对象的所有非静态数据成员以及本类中声明的非静态数据成员,还有指向每个类的函数列表的指针。
        如果派生类定义了和基类一样的符号（变量或者函数），那本类的把基类的给覆盖了，默认操作本类的符号，但基类的仍然隐示存在，通过：：可以访问到；
   虚继承(virtual public)：在这种机制下只有一个共享的基类子对象被继承而无论该基类在派生层次中出现多少次。主要是防止基类对象在后面的派生类中被重复包含，这种情况出现在菱形派生体现中；
   class D:public B,C; class B:virtual public A;class C:virtual public A;如果不使用虚继承那D类将包含2个A类的子对象，用了之后则只有1份A；B和C中包含的A对象是独立的；
   protected继承是没有实际意义的，private继承有特殊用途，一般用public继承；
   派生类中可以放开基类函数的访问权限(private/protected -> public)，需要拷贝基类函数实现，相当于覆盖了基类函数的实现；

16.封装：封装非常有利于代码重构和演进，比如构造函数如果直接对外提供，那外部可以创建任意个对象，如果通过接口提供给外部，则可以通过控制接口的实现来达到控制对象的创建次数，比如singleton;

17.C++中struct与class区别：1)成员默认属性;2）默认继承权限，前者是public,后者是private;3）class可以定义模板参数，而Struct不行；除此之外，没有任何区别；
   风格建议:如果只有数据没有方法，还是定义为struct比较好；

19.虚函数(virtual)： 如果认为一个类不会作为基类，则没有必要使用虚函数；反之，如果这个类作为基类，一定把析构函数做成虚函数，这样派生类的析构函数也自动成了虚函数。如果后来才把某个类作为基类，也要记得修改该类为虚析构函数；
   虚析构函数：virtual的目的是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象，这时会先调用派生类的析构函数，再调用基类的析构函数，如果没有声明为虚函数，则只析构基类，因为指针类型是基类的。
   如果类A析构函数是non-virtual的，如果要继承A的话，可以使用派生类定义指针，不能使用基类A定义的指针指向派生类对象，否则会delete不干净，导致内存泄露；
   析构函数:non-virtual, 如果指针类型是派生类，delete指针时，派生类的析构函数先调用，然后逆序调用各个基类的析构函数。
   构造函数不能是虚函数，而且构造函数里面如果调用了虚函数，最终调的是本类的函数（此时多态性失效）；
   纯虚函数： 如果派生类不去实现它，那派生类仍然是一个抽象类，不能实例化，不过可以定义抽象类的指针；
   这个关键字只在最顶层的基类函数声明时使用；
   如果基类中的函数声明为virtual,那后面的所有派生类的这个函数都自动变成virtual，不论是否被覆盖，都无法取消,virtual是不能被干掉的；

19.抽象类： 一般将构造函数设为protected权限,不能用抽象类定义对象，但可以定义一个抽象类的指针和引用，通过指针和引用，可以指向并访问派生类对象，进而访问派生类的成员。

20.构造函数顺序总是如下：(基类)---(子对象)---(自己)  举例参考:    http://blog.csdn.net/bresponse/article/details/6914155
   1）.基类构造函数。且根据派生表中声明的顺序(而不是初始化列表的顺序)； 这是自动调用的，与构造函数是否虚函数没有关系；如果构造函数带有参数，则需要手动调用才能给参数赋值；
      需要在初始化列表中把参数传递给基类构造函数, :BaseClass(***)
   2）.子对象的构造函数。且根据对象声明的顺序； 这里的子对象不包括继承过来的（因为基类的子对象在基类构造函数中已经被调用了）；
      特别注意：如果成员是对象指针（或者引用），那么不会调用构造函数，另外，不会调用static子对象的构造函数，这块由OS来负责；
      需要在初始化列表中把参数传递给子对象, :memberObject(***)     
   3）.派生类本身的构造函数。 
   4）定义对象指针时，不会调用构造函数，只有用new为对象指针分配内存时才调用构造函数，对象指针的赋值方式有两种：1）构造函数；2）提供接口给外部模块调用，为其赋值或者触发singerton创建；
     所以成员设置为子对象与对象指针是有区别的：前者会自动调用构造函数，而后者需要手动分配内存并手动调用构造函数；
   5)默认构造函数是public的，函数体为空，如果显示定义了任何构造函数，则编译器不会再提供默认构造函数；
   6)构造函数中的初始化列表与{}是分开执行的，初始化列表是为基类/成员对象提供构造参数的，要先执行，然后才执行本构造函数体{}的代码；
   8)构造函数是不能直接显示调用的，即使在成员函数里面也不行，因为这样会产生临时对象且是对临时对象进行初始化，而非对指定的对象初始化，如果一定要对已经创建的对象来调用构造函数做初始化，就用: new (objectAddress) Constructor();
   9)默认构造函数的一个非常重要的作用就是不用初始化，这一点可以使得添加新成员对象容易而且不用修改已知类的构造函数， 重载构造函数可以实现互斥功能(eg:tdd/fdd config)；
   7）C++类四个默认public函数---构造函数（不带参数）、析构函数、拷贝函数、赋值函数，每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。
    A(void); // 缺省的无参数构造函数,无返回值，不能被显示调用；举例：A a;等效于A a();等效于 A a=A(); 都是只调用1次构造函数；
    A(const A &a); // 缺省的拷贝构造函数，举例： 1).Class objB(objA);2)Class objB=objA,注意这里调用的是拷贝构造函数，而非赋值=函数，因为是在创建新对象；
    ~A(void){return;}; // 缺省的默认析构函数(非virtual)，可以被显示调用；
    A & operate =(const A &a){return *this;}; // 缺省的赋值函数,eg: objB=objA,注意这里调用的才是赋值=函数，因为objB已经创建了；
    A(para);    举例：objB=para 等效于 objB=A(para), 先调用构造函数(创建临时对象)再调用赋值=函数； A objB = A(para);则只调用1次构造函数；
   8).一般接口类里面只包含protected virtual 析构函数 及 public virtual 接口函数；

21.析构函数顺序正好相反，（最先析构自己）-->(成员对象)--->(基类)； 即使所有类的析构函数都不是虚函数，也会自底向上析构（）， 也就说自底向上析构是不依赖virtual的；
   本析构调用完后也会自动调用成员对象和基类的析构函数；
   特别注意：如果成员是对象指针，且在本类的构造函数中用new分配了内存，那么必须在析构函数中手动调用delete来释放这块内存，否则内存泄露；
   如果成员对象指针的内存不是在本类new的，那就不需要delete，只在析构中赋值为NULL即可，这样可以避免重复释放内存；总之：原则是谁分配谁释放!!!
   讨论：析构函数是在delete时调用的，之后就会释放内存，这块内存很有可能立刻被别人使用并修改，那析构函数里做的工作还有意义吗？

22.指针： *p 语法解析：先找到p指向的内存，然后根据(*p)的类型获取内容；切记：是根据(*p)的类型，不是p的类型；
        p+1 解析：先找到p指向的内存，然后根据(*p)的类型在那块内存上偏移；
23.内存知识：
    1）内存分配未成功，却使用了它。 对策：分配内存后立即检查内存指针是否为NULL；
    2）内存分配虽然成功，但是尚未初始化就引用它。 对策：分配内存成功后立马初始化；
    3）内存分配成功并且已经初始化，但操作内存时越界，特别是数组下标越界；
    4）忘记了释放内存，造成内存泄露。动态内存的申请与释放必须配对，防止内存泄漏,但是重复释放内存同样会导致程序崩溃；
    5）释放了内存却继续使用它：
      5.1）对象关系太复杂，搞不清楚是否释放了内存，这时应该优化数据结构；
      5.2）使用free或delete释放了内存后，没有将指针设置为NULL，导致产生“野指针”，不过在使用free/delete前也要检查是否NULL；
      5.3）函数返回指向临时内存（如“栈内存”）的指针或者引用;
    6）.指针消亡了，并不表示它所指的内存会被自动释放。反之，内存释放了，并不表示指针会消亡或者成了NULL指针，只是说这块内存被操作系统回收，可以分配给其它用户，但内存的地址还是客观存在的；
    7）“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。

24.“野指针”的成因主要有两种:
    1)指针定义后没有被初始化，这时指针不是null,而是有值的，只不过会乱指一气，所以如果类成员里面有指针，必须在构造函数里面为其赋值，一般赋值为NULL；
    2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针；


25.数组： 1）数组大小2种方式确定：a）定义时显示指出大小；b）定义时通过赋值表达式隐示给定大小；
       2）注意当函数参数定义为数组时，该参数其实是个指针，不是真的数组，所以参数中指定数组大小是没有意义的；
       3）局部数组占用临时栈内存（不会默认初始化），全局数组占用全局内存（会默认初始化）；
       4)char p[]="hello";  char* q="hello"; 前者系统只分配一块内存给数组，存储的内容是hello,而后者系统分配2块内存，常量内存存储hello,栈内存存储q;所以p[0]='X'是ok的，而q[0]='X'就不行；

26.程序退出时，所用内存会被操作系统回收，不过嵌入式系统程序一般不会退出，除非断电；   
27.1)new/delete不是库函数，是C++的运算符，由编译器处理，类似sizeof();
      malloc与free是C++/C语言的标准库函数，前者在创建删除对象时除了分配内存外还要调用构造、析构函数(编译器会产生相关的代码)；而后者不会；相同点是：都操作堆内存，而且必须配对使用；
   2)void free( void * p ); 系统知道分配了多少（cookie记录了），所以也知道需要释放多少内存；如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。
   3)void * malloc(size_t size);//在调用malloc时要显式地进行类型转换，将void * 转换成所需要的指针类型;malloc的“()”中使用sizeof运算符是良好的风格;
   4)如果用new创建对象数组，那么必须要有无参构造函数，而且用delete释放对象数组时，要delete []p,如果写成delete p就相当于delete p[0]；
   int *p1 = (int *)malloc(sizeof(int) * length); //注意，如果输入是0，会得到一个有效的指针，而非null;
   int *p2 = new int[length];//new内置了sizeof、类型转换和类型安全检查功能,new数组时返回的地址类型是元素的类型；
   5）memset(void*, value, size)操作单位是字节;
   6)new在申请内存时其实是调用了Operator new(里面又调用了malloc),所以如果在类里面重载了operator new,就可以控制如何给对象申请内存；
   7)delete[]p, 如果改成delete p,那么其实是不会内存泄露的，只不过只调用了一次析构函数；

28.引用与指针区别：1）引用的绑定关系是终身制的（普通引用在定义时必须确定关系，必须赋值，类成员在构造函数中必须确定关系），此后对引用的操作都是改变值，不改变关系；而指针可以改指向别的内存；   
               2）如果成员变量是引用，那必须在初始化列表中对该变量初始化，不能在构造函数体{}中初始化；

29. 条件编译,  利用条件编译(#ifdef) + (#define) 可以达到编译器多态(重载类，变量、函数的目的（对不同的模块有不同的定义）)；
    #if (defined(A) && defined (B))
    #  define MPWF_PDSCH_XFER_METHOD     4
    #elif (defined(C) || defined(D))
    #  define MPWF_PDSCH_XFER_METHOD     3
    #else
       #error "No  defined !"    如果不满足前面的条件就停止编译，一般用于调试；
    #endif
      #if   MPWF_PDSCH_XFER_METHOD == 3  字面常量可用于预编译时期的条件判断
      #elif MPWF_PDSCH_XFER_METHOD == 4
      #endif
    ///////////////////【#ifndef   等效于 #if !defined()】【#define】【#undef】【#if !defined() && !defined()】
    #ifdef  【或者 #if defined(A) 】 和
    #else
    #endif
    /////////////////注意， 【#define A 空白 】有2层含义：1）A被定义过，这样在判断#ifdef A时为真； 2）把A替换为空白，也就是把这个关键字给废掉；
      #if (defined(FSM4_RTM) && (defined(FSM4_RTM_LINUX) || defined(FSM4_RTM_TARGET)))
    注意： #ifdef (SCT) 会导致编译不过，不能带(),只有defined后面才能带();
    /////////////////////////////////////
    嵌套ifdef条件编译举例(特别注意#与后面的空格)：
    #if    defined(ARCHITECTURE_arm_fzm_k2) (特别注意#后面没空格)
    #  if defined(ARCHITECTURE_arm_cortexa15_rt) (特别注意#后面有空格)
    #    ifdef MACPS_FSMR4_2DSP_DEPLOYMENT
    #    else
    #    endif
    #  else
    #  endif
    #  else
    #  endif
    /////////////////////////////////
    #if !defined(MPWF_PDSCH_XFER_METHOD) //#  define MPWF_PDSCH_XFER_METHOD 4
        #error "MPWF_PDSCH_XFER_METHOD not defined"       
    #elif MPWF_PDSCH_XFER_METHOD == 1
        #error "PDSCH send request over CDMA (QMSS DMA), i.e. QmPacket DMA, not supported any more"
    #elif MPWF_PDSCH_XFER_METHOD == 2
        #error "PDSCH send request over SRIO Type9 not supported any more"
    #elif MPWF_PDSCH_XFER_METHOD == 4
    #endif
    /////////////////////////////////
30.位操作举例：      #define BIT3 (0x1<<3)     a |= BIT3;  a &= ~BIT3;
31. 关键字typedef用法举例, typedef 和 #define 的格式正好相反，前者要定义的在后面，后者要定义的在前面；
    typedef用来定义复杂数据结构(eg:类)，define一般用来定义整形表达式；
    typedef是在编译阶段处理，#define是在预处理阶段；
    #define的作用域：从定义点开始直到#undef,或文件结束，不受定义所在的作用域约束(class/fun/namespace)，#define放在class内外效果是一样的，因为预处理器意识不到作用域的；
    typedef的作用域：取决于放置的作用域，受(class/fun/namespace)的约束；
  typedef struct Node//只有C语言需要typedef，这样Node,NodePointer就可以用来定义变量了；
  {
   int data;
   struct Node* p;
  }Node,*NotePointer; 
  或者
  struct Node
  {
  };
  typedef struct Node Node;
  typedef void (CDlPsMeasHandler::*GetMeasureFun)(void);定义指向CDlPsMeasHandler成员函数的指针；
  举例：caller实现如下：
  caller(CDlPsMeasHandler* obj,GetMeasureFun fun) //给fun赋值的必须是CDlPsMeasHandler的成员函数；
  {
    (obj->*fun)();
  }


32. #define SENTINEL  0xFFFF      无分号，文件级作用域；
    const u16  SENTINEL = 0xFFFF; 有分号，受定义模块约束；而且，不能在同一个文件里面对同一个符号使用这两种方法，否则编译提示：expected unqualified-id before numeric constant

33.C++语法(extern "C")  : 1)用于C++与C模块交互，且源文件事先已用编译器处理，头文件提供给外部待编译（如果都使用同一种编译器就不存在这个问题），一般在“C头文件”里面或者“C++源文件包含C头文件”的时候使用；
                 2）这个语法是告诉C++编译器和链接器采用C语言的方式来处理符号（函数，变量，头文件等），方便被C模块使用，或者使用C模块的符号，场景举例：C++模块提供接口给C模块使用，或者C++模块使用来自C模块的接口；
                 3)C++的语法支持extern "C" 和extern； 而C语言只支持extern，所以C语言中不能直接include声明了extern "C"的hpp文件,会编译出错的；
                 4）如果C++写的函数 想被 C编译器调用，应该这样做：在C++的源文件cpp中用extern "C"来修饰需要对外提供的接口，使得输出C的符号，然后在C的原文件包含头hpp文件； 这也意味着C++源码不能使用C不支持的特性（比如重载）；
                 5）如果想C写的函数 被 C++调用，这样做：在C头文件中如下处理（因为C源文件事先用C编译器做成DLL了，只对外提供.h文件，这样做，DLL就可以同时被C、C++编译器调用了，C++编译器定义了__cplusplus）：
                       如果C头文件没有像下面这样做，也可以在C++源文件用extern "C" {#include "c.h"}来包含c头文件，告诉C++编译器用C的方式来处理这个头文件；
                    #ifdef __cplusplus  //用C++编译器时这个为true,C编译器为false;
                    extern "C" { 
                    #endif 
                    ........             
                    #ifdef __cplusplus 
                    } 
                    #endif
                 6）C++写的代码被C++编译器调用，如果要使用这个语法，那提供和使用接口的两方要同时使用才行；
                 7）总结：.c/cpp文件是自己用编译器事先编好的，不会提供给别人的，.h/.hpp文件是提供给外部的接口，会和外部模块一起编译，所以，在.c/cpp文件中需要考虑c/c++编译器两种情况；
                 8）参考 ：  http://songpengfei.iteye.com/blog/1100239
34.编译与链接： 编译就是生成一堆符号（用C或者C++的方式），链接就是在不同obj文件间进行符号匹配与对接，所以如果代码是用不同编译器编译的，在链接的时候就会出现找不到符号的现象；

35.C++连接符##： ##的作用就是把俩个字符串连接起来形成新的标识符（变量）； #的作用是将参数转为字符串并用""引起来， 当然预编译宏里的#有特殊的含义；
   eg1：
   #define USE_STATIC_OBJECT(type,numOf,init) \   
   typedef enum { type##_Initializer = init, type##_NumOf = numOf } Enum##type
   eg2:
   #define str(out) #out     宏函数里的参数只是个形参（也是需要赋值的），只不过是没有类型的形参；     
   printf(str(zzz));
   打印模板参数（打印类名）：  cout<<typeid(classname).name()<<endl; 包含<iostream>

36.类的访问权限(private/protected)：如果类定义了private成员变量/函数，那么这个private成员只能被本类和友元类访问，派生类无法直接访问（虽然派生类拥有它），要访问的话只能通过基类的其它protected/public的接口访问；
   protected是专门为派生类访问基类提供的关键字，另外，如果某个类的构造函数定义为private，那意味着无法创建对象，也无法作为基类了；
   总之：1）一个类要访问另一个类的私有成员，只有通过接口或者友元声明；2）.一个模块能否访问某个符号要看"直接定义这个符号的类"与"当前模块所属类"的关系！！！！！

37.friend: 可以把一个普通函数或者类A的某个成员函数声明为B类的友元函数（在类B中添加声明就够了），这时这个函数就可以访问B类的私有成员及私有成员函数了； 当你想把一个函数放在某个类里面，又想很方便的调用(不依赖于对象实例)，那就声明为friend，比如operator<;   
   友元类friend：友元类A的所有成员函数都是另一个类B的友元函数，都可以访问类B中的所有成员（包括私有成员和保护成员），一般来说，是把B类对象作为A的成员函数入参或者作为A的子对象；
   友元类的声明:friend class ; 比如：遥控器可以设置为电视机的友元类；
   建议：如果把某个函数fun设置为A的友元类，那该函数fun最好不要是public的，否则类A的private数据都能被外界访问到了，就没有意义了；
   只有A本身有friend权限，A的派生类无friend权限访问B，但A的派生类可以调用A的函数来访问B的私有成员；朋友A可以访问B的私有成员及B的派生类的这个成员，前提是这个成员不被B的派生类覆盖；
   默认友元：如果在类A里面定义了类B，那么类B默认就是类A的友元，可以访问类A的所有成员；
   friend&&namespace: eg:一个全局命名空间的class C要访问一个namespace A里面的class B的private成员i，那必须用friend class ::C, ::不能省掉；
                        class C; //前置声明
                        namespace A{
                            class B{
                            friend class ::C; //必须加上全局作用域，否则friend失效；
                            private:i
                            };
                            }

38. 编译步骤：
    1）.预处理,把没用的代码删掉，预处理是根据#的声明顺序来的，从文件开始到末尾，不区分#include还是#define还是#ifdef;
    2）.将C/C++转换成汇编语言,生成文件.s[编译器]，注意只对源文件编译，而且各个源文件是独立并行编译的；.h文件当被源文件包含时才会参与编译，所有.h文件的问题都是在编译某个C/cpp文件时才有的；
    3）.由汇编变为目标代码(机器代码)生成.o的文件和符号列表[汇编器]
    4）.连接目标代码,进行符号匹配，生成可执行程序exe或者lib/so库文件[链接器]，把调用不到的函数给删掉；
    5）.注意在上述过程中，编译器会自动做一些代码优化；   

39:作用域符号(::)有3个场景：全局，类，名字空间； 
            通过classname::fun()这种形式访问成员函数有3种情况：1）fun()是static函数；2）派生类函数调用基类函数；3）获取本类的成员函数地址；
            ::globalfun，如果：：前面没有任何限定则表示使用全局符号；
            如果类的成员函数和全局函数的原型完全相同，那在类里面默认使用的是当前类的成员函数，C++原则是：当前作用域会覆盖全局作用域；

40.static_cast:  编译时做的转换，比如可用于基类指针强转换为派生类指针；static_cast 的类型转换能力虽然较dynamic_cast弱，但是更安全。 
                 基类指针指向派生类对象时，用该指针只能调用基类中定义过的函数，如果要调用只在派生类中的新函数，必须先用static_cast转换为派生类指针才行；
   eg: CUlCommonSchCellContext* cellContext = static_cast<CUlCommonSchCellContext*>(cellContextPtr); 注意<>()都不能少

41.class声明： class A; 经过这样提前声明后(在需要用到A的其它类的头文件中)，接下来就可以用A来定义指针和引用（不能用来定义对象），但仅仅限于定义（也可以作为右值使用），不能做任何操作（如果操作，会报错"invalid use of incomplete type"），
             这样做的好处是不需要包含A的头文件了，可以防止头文件相互包含；另一个比较有效的解除依赖的方法是把函数实现从头文件移动CPP文件，然后在CPP里面包含需要的类头文件；

42.编译问题：
   1.遇到undefine reference问题可以去.o文件里面看下是否有这个符号,另外，可能是这个类型在代码中被typedef了；
   2.redefinition: 一般是某个源文件包含了具有定义交集的多个头文件导致的，如果在两个独立的模块空间内重复定义（没有交集），其实是不会有问题的；
   3.检测所有函数，是否漏掉了return;
43.位段：结构体里面使用位段可以节省内存。 如果不使用位段，结构体大小=成员个数*成员最大长度？ 另外，使用位段可以方便写代码，但不会提高CPU的执行效率；
   struct A
    {
     u32 i  :10;
     u32 j  :22;
    }   
44 联合(union): 1)实现消息的多态；2). Union可用来做格式转换（这时每个成员大小都是一样的）。
    所有成员存储在相同的位置，互斥关系，联合的大小取决于最大的成员；典型用法如下：
    struct A
    {
      enum{} type;
      union
      {       
      };//如果不取名字，那可以直接访问union里面的成员，代码更简洁；
    };



46.#pragma: 指示编译器完成一些特定的动作，每个编译器对#pragma的实现不同，在一个编译器中有效在别的编译器中可能无效；
            #pragma DATA_SECTION(".macUlRingBuffer") 自定义数据段，段名为""里面的内容，接下来就可以在链接脚本中将这个段映射到指定的内存块(fast,slow)；
            注意，这个内存指定是编译期的，只有采用静态链接时才有效(包括.lcf文件)，对于动态链接是无效的，所以产品里的dsp可以指定内存，而arm不能指定(.so)，arm下由cpu来动态cache;
            #pragma DATA_ALIGN(64) 将内存块的起始地址设置为64字节对齐，但后面结构体是否对齐就要看结构体本身是否64字节了；
            #pragma CODE_SECTION(".macBufferStatusBundler") 自定义代码段；
            #pragma warning(disable:4507;once:4385;error:164) 不显示4507号警告信息，4385号警告信息仅报告一次，把164号警告信息作为错误对待；
            #pragma message("output") 在编译时输出打印信息，可以和#ifdef结合使用来判断某个宏是否激活；
            #pragma GCC diagnostic ignored "-Wsign-conversion" 忽略这类问题            

47.重构： 1）当一个类的成员只包含1个子对象时，这个类可以被干掉了，用子对象类来替代；
48.make: 使用-n 开关，可预演make过程，并不会真的执行make过程；

49.placement new:
  将对象放到指定内存，而不是从heap里面分配内存（会调用该类的构造函数）:    new  (bufPtr) class(**);
  m_ulMeasHandler = NEW_STATIC_OBJECT(CUlPsMeasHandler) CUlPsMeasHandler(m_ulLaMain);
  #define NEW_STATIC_OBJECT(type) new (g_macObject##type##Pool)//其中g_macObject##type##Pool是个数组buffer;
  #define DEFINE_STATIC_OBJECT(type) u8 g_macObject##type##Pool[ALIGN_DW(sizeof(type))];//使用place new时需要对buffer做地址对齐；
  传递给“placement new”操作符的指针所指向的内存区域必须足够大，并且要考虑地址自然对齐；


	1. new： c++操作符，编译器会分解为3步：1)先调用operator new分配内存，2)再调用构造函数初始化，3)再返回地址并转换类型;


  当重载new时，实际上只替换了第1步，后面2步编译器还是会做的，当重载delete时，编译器仍然会先调用析构函数，然后调用我们的delete,但是不会释放内存了;
重载的new和库函数的new原型是一样的，但是不会导致重定义，这是编译器故意的。重载的new/delete最好是作为类的成员函数(隐式static)，仅对这个类可见。
  operator new： 要实现不同的内存分配行为，应该重载operator new， operator new 重载时必须同时重载operator delete;
                eg： void* operator new(size_t); //标准的new, 这里的参数是由编译器调用sizeof(object)来赋值的，对应标准delete：  void operator delete(void *p) 创建对象： Object*p= new Object();
                    void* operator new(size_t size,void* pMemory)//这便是所谓的placement new, void operator delete(void *p){memset(p,0,sizeof(Object));}
                    这时创建堆对象只能用Object*p =new(pMemory) Ojbect();
  placement new： 只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。   因此在删除该对象时，只需要调用对象的析构函数，不需释放空间。
                总结：如果要用placement new, 必须要重载operator new/delete, 否则程序行为不可控;
   如果基类里面重载了operator new,派生类可以用如下方式恢复成全局的标准new:
        void* operator new(size_t size){return ::operator new(size);}
        void operator delete(void* p){::operator delete(p);}
51).operator类型转换:template <typename T> class Msg {
                                T *p; 
                                operator T&() { return *p; } 把Msg类型转换为T&
                                }//Msg<Req> request;Req& load(request);
52)性能performance提升方式: 如果某些判断不需要每次都做，那可以1).如果是函数选择，可以用函数指针的方式在知道配置的时候设置下，后面就不需要反复判断；
                       2）如果是内存选择，可以增加个中间内存，在知道配置的时候把选中的内存拷贝过去，以后就有中间内存了；           
53)C++设计:ClassA:public InterfaceB,public InterfaceC 如果ClassD仅仅想用ClassA的InterfaceB功能而不是全部，那么就应该增加InterfaceB*,而不是ClassA*;                           
54)C++设计:改造函数为类的一个常用技巧是把赋值precondition转换为构造函数，把body转换为成员函数;eg: Fddcode(comm::Msg) template <typename PAYLOAD> class Msg
55)compile/ld error: undefined reference: may forget to add class:: before function implementation;
56） // make sure ueData is the last item in the msg
  MACPS_COMPILE_TIME_ASSERT(offsetof(typeof(msg), ueData) + sizeof(msg.ueData) == sizeof(msg));
57).C++ function pointer sample:
  {void MyClass::memberFunc(AA);
  void (MyClass::*funcP)(AA);
  funcP = &MyClass::memberFunc; //Note the &
  (this->*funcP)(AA);}
58).C++static function pointer sample:
  {static void function(AA);
  typedef void (FunType)(AA);
  FunType* funcP;
  funcP = function;
  funcP(AA);}
59).继承与覆盖：
    1.指针Type决定了能看到的接口，而不是取值；
    2.派生类尽管只重写基类的某个函数(无论是否virtual)，但基类的所有同名函数都会被覆盖，如果不想被覆盖，需要在派生类声明：using BaseClass:funcName;
    3.尽量不要在派生类override基类函数，而是只增加新的函数； 
60).在同一个cpu core里面， static对象只有一份实例；
61).数组大小字节对齐： __attribute__(( aligned(__alignof__(type)) ));   
    u8 g_macObject##type##Pool[(type::type##_NumOf)][sizeof(type)] __attribute__(( aligned(__alignof__(type)) ));
62).__typeof__   一般用在宏定义中，获取宏参数的类型；eg:__typeof__(para)x 声明变量x,类型和para一样，   eg: __typeof(*x)__ p; 声明p为x所指向的类型；
    #ifndef TYPECAST   
    #define TYPECAST(a) (__typeof__(a))
    #define UNSIGNED_UNUSED(value)  (TYPECAST(value)(sizeof(value) == 1 ? 0xff : sizeof(value) == 2 ? 0xffff : ~0u))
    #endif
63).template: 0.模板参数其实就是个占位符，定了一个规则，只要满足这个规则的对象/函数/变量都可以作为实参；
              1.外层类的模板参数可以用于内层嵌套class: template<T>classA{class B{T}; };
                模板参数类型可以是class,typename,或基本类型int,bool,enum,对于基本类型在特化时必须用const量；
              2.模板参数可用于未知长度的处理（比如定义未知长度数组，处理未知长度loop），并在实例化时自适应；template<const u8 length> classA(int (&array）[length])
              3.在派生类中增加模板参数可用来批量产生派生类，而拥有共同的基类；
              4.类的模板参数需要在<>显示赋值,而成员函数的模板参数不需要显示赋值，会根据传入的实参自动赋值；
              5.模板类特化重新实现可以覆盖原模板类，可以只特化部分模板参数；
              template<u32 NUM, bool isSmall = NUM <= 32> class BitSet{yyy} 在特化参数NUM时，必须传递个Const数值;
              template<u32 NUM> class BitSet<NUM, true> : public BitSet<NUM, false> { xxx } 为什么类名相同不会报错？

64).字节对齐宏定义： #define ALIGN_DW(a) (((a) + 7) & (u32)(~7)) //8bytes, (x&~7) <==> (8*(x/8))
                #define ALIGN_W(a) (((a) + 3) & ~3)              //4bytes
65).校验字段在结构体的位置:
#define ISAR_MEMBER_ASSERT(STRUCT,FIELD,OFFSET) \
typedef char STRUCT ## _ ## FIELD[(offsetof(STRUCT,FIELD)==OFFSET)?1:-1];
#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))

66).校验结构体大小: ISAR_STRUCT_ASSERT(SWmpCellContainer,15312)
#define ISAR_STRUCT_ASSERT(STRUCT,SIZE) \
typedef char STRUCT ## ___size___[(sizeof(STRUCT)==SIZE)?1:-1];               
67).宏函数+case用于提取不同结构体里的特定字段（因为宏函数的参数没有类型，只有名字，而switch-case可以实现映射关系），如果用C++则可以用类模板来实现；
  #define GETMEMBER( MSGID, MSGSTRUCT, MEMBER, MSGDATA,OUTPUT) \
  case MSGID: \
  {\
    OUTPUT = (MSGDATA == GLO_NULL) ? INVALID_ID : (static_cast<MSGSTRUCT*>(MSGDATA))->MEMBER;\
    break;\
  }
  TCellId GetMsgCellId(void* msg)
  {
    TCellId cellid = INVALID_CELL_ID;
    switch (AaSysComMsgGetId(msg))
    {
      GETMEMBER(PS_CELL_SETUP_REQ_MSG, PS_CellSetupReq, lnCelId, AaSysComMsgGetPayload(msg), cellid);//cellid=PS_CellSetupReq.lnCelId
      GETMEMBER(PS_CELL_SETUP_RESP_MSG, PS_CellSetupResp, cellId, AaSysComMsgGetPayload(msg), cellid);//cellid=PS_CellSetupResp.cellId
    default:
      break;
    }
    return cellid;
  }
68).嵌入式系统全局数组内存经典定义：
 #define LENGTH            0x10000
 #pragma DATA_SECTION(globalBuffer, ".mydatasection")指定生成数据段名字,同时在lcf文件增加(.mydatasection > EXT_MEM_DATA_NONCACHE)
 #pragma DATA_ALIGN(globalBuffer, 8) 要求8字节对齐
 u8 globalBuffer[LENGTH];
 注意，这个内存指定是编译期的，只有采用静态链接时才有效(.lcf内存映射文件只有生成.lib才有用)，对于动态链接是无效的，所以产品里的dsp可以指定内存，而arm不能指定(.so)，arm下由cpu来动态cache;
69).比较xsfn在时间轴上的先后（考虑10240翻转）:
static inline bool xsfnGt(u32 a, u32 b)  //a > b (a is more advanced in time.Prerequisite for correct results is that the XSFNs are not more than 10240/2 apart)
{
  i32 diff = (i32)a - (i32)b;
  return ( a>b && diff<10240/2 ) || ( a<b && diff<-10240/2 );
}
static inline bool xsfnLt( u32 a, u32 b ) { return  xsfnGt( b, a ); }  //a<b
static inline bool xsfnGE( u32 a, u32 b ) { return !xsfnLt( a, b ); }  //a>=b
static inline bool xsfnLE( u32 a, u32 b ) { return !xsfnGt( a, b ); }  //a<=b
70).placement new code example:内存字节对齐
struct NbUlPsControllerPool
{
  u8 nbUlPreScheduler[ALIGN_W(sizeof(NbUlPreScheduler))];
};
#pragma DATA_SECTION("wmpPsStaticObject_NbUlPreSch")
NbUlPsControllerPool nbPool __attribute__((aligned(16)));
nbUlPreScheduler= new(nbPool.nbUlPreScheduler)NbUlPreScheduler();
71)函数类名字： declareUeToCatm,Holder,container,builder,
72)如果函数的某个参数需要传入true，可以定义个有意义的局部常量=true,传入这个变量，而不是直接传入true;
73)文件域static变量与成员变量比较：1）相同点：都可以在成员函数间传递数据；2）不同点：成员变量是对象级的，内存与对象个数成比例，而static变量是对象间共享的，所以尽量避免使用static变量，
   当且仅当static变量当做瞬时变量使用时，才可以在对象间共享以节省内存（也是static优点）；

74)C++函数种类：1)普通成员函数；2)static成员函数；3)friend函数（非成员）；4)全局static函数（非成员，只在cpp文件）；5)全局非static函数（位于namespace内）；
75)C++全局函数重载：全局函数和成员函数一样，都可以重载，然后可以用模板函数来调用这些重载函数，达到多态目的：
   template<typename T>
   bool printStructTemplate(void)
  {
    T& C;
    printStruct(C);//printStruct(TypeA);printStruct(TypeB);
  }   
  template <typename T1,typename T2>
  void parseRingBuffer()
  {
    printStructTemplate<T1>();//模板函数调用模板函数
  }

76).static对象：1)如果A.cpp文件和B.cpp文件分别定义了一个同名的static对象，那内存是独立的，因为作用域只在该文件，且不会进入符号表；
              2)如果A.cpp文件定义了一个static对象，且定义了一个非static函数来访问它，那么其他cpp文件可以通过extern函数声明来间接访问这个static对象，当然实际中不建议这样做；
              3)如果class里面定义了一个static对象（singleton实例），且提供了static成员函数访问，那A,B模块通过class::getStaticObj得到的内存是否同一份取决于
                 A,B模块是否在同一个进程，如果AB同进程（不同线程）则内存一样，如果AB不同进程(不同的bin文件)，则内存不同，因为static内存是进程级别的；   

77).模板函数举例：这里func可以是函数对象，也可以是类的static函数（但不能是类的非static函数），只要其接口接收2个参数(type(storage[index]),任意类型参数)；
  template<class Function, class Param>//模板参数 Param 其实就是个占位符，可以代表任意类型
  void foreach(const Function func, Param param)
  {
    for (u16 index = 0; index < Num; index++)
    {
      func(storage[index], param);//
    }
  }                 

78).模板参数实现多层次继承: classA<classB> 表示classA继承classB,以此类推，可用classA<classB<classC>>实现classA继承classB,而classB继承classC.
  template<typename T>
  classA: public T {}
79).看一个成员函数被外部还是自身类调用，只需要看它的public/private 属性即可；
80）通过对象指针调用函数： 包含2种信息，类型和值，类型决定了能看到的接口类型，virtual和值决定了调用哪个具体实现，非virtual函数的调用在编译期确定，
      每个成员函数内的this指针的类型就是这个函数所在的类，和virtual无关；

81）封装C语言函数为C++函数对象,eg:
    struct Function
    {
     T operator() (T arg1, T arg2)
     {
          return c_function(arg1,arg2);
     }
    }
   usage: Function fun;fun(arg1, arg2);



83)后置，前置运算符使用场景: 实际中一般后置运算符用的更多，因为后置是指 “先操作当前位置再改变指针” ；
    a)如果操作当前位置，再后移 ，用 func(iter++);
    b)如果操作当前位置，再前移，用 func(iter--);
     c)如果直接操作后一个位置，用 func(++iter);
    d)如果直接操作前一个位置，func(--iter);

84).对象构造与类型转换：
   Class obja (arg); //这是explicit调用构造函数
   Class obja = arg; //这是implicit调用构造函数，只有构造函数没有加explicit且支持单参数时 才可以；也可看做：类型转换；
   Class obj; //定义对象，使用无参构造函数
   Class obj(); //定义对象，使用无参构造函数，有时候会被某些编译器看做 “函数声明”


85)C++函数与C函数间的转换：C函数和C++对象的转换
   C函数只能访问用户传来的参数，而C++函数还可以访问内部数据（保存在对象里面）；把函数对象传递给STL算法本质是传递了一个函数地址出去（&operator()）同时还可以传递其它信息（对象里面）；
   void Cfun(arg1, arg2)--->obj.fun(arg1): 把参数封装到对象，然后把函数作为成员函数，原来的参数可以通过构造函数/成员函数的方式注入；
   obj.fun(arg1) --->void Cfun(T* obj, arg1);  增加1个参数为对象指针，其它参数不变，这样Cfun不是成员函数了，但是仍然可以通过obj*来访问原来的数据；
   obj.fun(arg1) --->void Cfun( arg1,arg2);   或者：把对象的属性都以参数的方式传入；

86)回调函数 callback实现方式：
   C语言里面一般是用struct保存回调函数和函数参数；
   C++里面可以用1)std::function<> = std::bind(memfunc, &obj, arg) , 优点是不需要引入继承，可以保存不同类的函数，这些函数的原型相同;
         2)virtual_memFunc+Base*, 这种方式等同于C语言，把对象和接口都保存，把接口类的Virtual函数和派生类实例保存（type是Base*），使用继承多态;
         3)static成员函数+对象指针，因为static成员函数本质上就是C函数，与类型无关，可以和C函数一样保存；

87.extern 关键字与可见性：1)A.cpp用extern引用B.cpp符号后，会加入到重定向表，等链接时匹配符号，对于静态链接没有问题，不论A.cpp和B.cpp是否在同一个lib.a，只要在同一个bin就行， 但是如果A.cpp和B.cpp不在同一个.bin文件那有问题。
     2）如果A.cpp和B.cpp分别编译到A.so, B.so ， 进程采用动态链接（运行时加载so的方式），尽管在同一个进程中，如果B.so设置了符号对外隐藏(hidden)，那A.so不能使用B.so符号，如果设置B.so符号对外可见，也要保证B.so先于A.so加载才行，最好的做法是编译在同一个.so里面。


	1. 3种方式设置符号对其它模块隐藏：1) static或者匿名namespace;   2)__attribute__((visibility ("hidden"))); 3)set symbol as local in export list; 

 
89.对全局数组初始化： 利用一个专门的Initial class  定义一个全局对象，把全局数组作为参数注入构造函数（模板函数），在构造函数内初始化；                      

90.namespace与static,const 全局变量：
    a)如果在hpp文件定义全局变量，不属于任何namespace, 被多个源文件包含时会导致重定义；但是如果这个变量被static  或者  const修饰，则不会导致重定义；
    b)如果这个全局变量放在某个有名字的namespace内,  和 a) 规则一样。
    c)如果这个全局变量放在匿名namespace, 不会导致重定义（无论是否加static const）,这时每个源文件都有一份独立的内存；
       不要用extern去访问那些使用了static/anonymous namespace变量的函数，极容易混淆内存；
    d)如果在A.cpp中定义了namespace mimo{int i = 1;} B.cpp文件需要访问i , 可以：在A.hpp文件namespace mimo{extern int i;} ，然后B.cpp包含A.hpp , cout<<mimo::i ;
       不能直接：extern int mimo::i; 会编译错误。


91.集合Set/Bitmap/数组： 如果集合元素是连续的整数，那集合可以转为Bitmap，如果Hash(key)不冲突，则集合可以退化为数组（否则要用数组链表），集合的频繁操作是查询和更新，所以实现为二叉搜索树。


92.C++成员函数作为参数传入C函数的技巧： 把成员函数定义为static函数，同时定义一个对象参数，这样在static函数内部就可以调用该对象的成员函数了；
  pthread_create(&pthreadId_, NULL, &func, this);    static void func(ClassA* );
  void func(classA* obj) { obj->memfuncA();}

93.多重继承：把派生类实例地址赋值给基类指针时，地址可能会调整，这个调整动作发生在RTTI运行时;
