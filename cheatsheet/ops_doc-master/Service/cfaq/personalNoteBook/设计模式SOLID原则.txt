
S.O.L.I.D:   single responsibility单一职责, Open-close开闭, Liskov substitution继承替代, Interface segregation接口隔离, Dependency Inversion依赖倒置（面向接口）;

《设计模式-可复用面向对象软件的基础》第1章引言总结的非常好。面向对象：目的是复用，手段是模块化，关键技术是抽象。

http://blog.csdn.net/zhengzhb/article/details/7348707
http://blog.csdn.net/jfkidear/article/category/1084900

面向对象：用OOP编程之前，先分析事物的区别是  属性的不同还是  行为的不同，如果只是属性不同 则表现为 不同的对象实例，如果是行为不同，则表现为不同的方法和类；
                 也可以把行为抽象为属性，比如把Ihandle设置为成员变量，这样不同的对象实例就表现为不同的行为了，这时是把行为的多态委托给其它类系，而不是本类，这叫：多态委托，
                 “多态委托”好处是对用户隐藏复杂度，用户看不见Ihandle类继承体系，只能看见一个包装类，包装类的函数实现其实是委托Ihandle来处理的；
                 最开始出现的类应该是用户层面的，提供的接口是用户直接使用的，然后在此基础上扩展挖掘出实现层面的类；

理解设计模式最好的办法是记住对应的例子；
设计模式就是封装变化，隔离不变与变化；
计算机的任何问题都可以通过增加中间件来解决；

C++面向对象设计方法：回调(bind/function)， 静态（STL模板泛型），动态OOP(继承多态)，基于Policy的设计方法（泛型+继承：modern c++ design）,
eg: template<typename T> classA:private T{}，其中function<>的方式最好，只要求接口形式，对接口名字没有要求，而其他的都要求方法名一致（会导致重载）。

软件设计原则： 关注点分离

设计模式中很多模式都包含了“递归”，也就是说不仅函数可以递归，class也可以递归；

设计模式就三个准则：1）组合优于继承，2）依赖于接口而不是实现，3）高内聚，低耦合；
   面向接口编程的技术本质是：用interface, root class来定义对象类型，不用derived class,因为一个继承体系对外呈现的类型就是root class;
                                             包含2部分内容：1）接口实例化，设计模式是factory，这时需要看见派生类;  2)使用接口，这时只看见基类接口，完全看不见派生类；
                                             好处是：重构类的继承体系时，可以不影响外部模块；也叫duck typing.
                                              C++11提供了std::function,可以做到只关注接口，忽略Class类型，也不用继承；

面向对象编程注重的是：1）数据和其行为的打包封装，2）接口和实现的解耦。
C++的3大特性里面最有用的是封装，封装才能复用，继承和多态尽量少用，好处不大但会增加系统复杂度； 尽量用组合代替多重继承；继承是为了对象之间动态切换，比如TcpSocket和UdpSocket虽然可以抽取一个Socket基类，但是不存在切换的场景，所以没必要故意抽取一个基类(徒增复杂度)，直接让用户使用TcpSocket/UdpSocekt就好了；

实际中用的最多的就是：工厂模式，如果类成员是对象指针，其实在类的初始化列表里面也可以调用工厂函数来创建对象。

1.工厂模式: 本质上是把对象创建的过程进行了封装，create()函数内根据条件创建不同的对象，可以和模板类结合；
  对使用者来说，需要调用子类来创建想要的对象；
  复杂对象适合使用工厂模式，而简单对象，如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
  工厂模式一般结合模板类使用；


2.LSP原则：里斯替代原则：任何使用基类的地方都可以用子类替换，如果替换后不对，那说明接口设计违背了这一原则；也就是说，基类中定义的接口必须对所有派生类适用；

3.OCP:开放封闭原则：基类或者框架只能增加功能，不能修改，通过派生类或者组合实现新功能。
  产品代码的switch-case消息处理可以改成查表的方式(map)，这样在新增消息类型的时候就只需要在表中增加一项，不用修改代码（避免增加case分支），这种改进体现的思想就是尽量把代码的复杂度转移到数据中（UNIX哲学的表示原则），进一步的改进是：框架提供一个接口(addItem(pair<msgid, callbackfunc>))，这样新增消息类型时只要调用接口，不需要改任何代码了，这种设计就是OCP原则！也体现了依赖倒置原则，这种调用关系是一种松耦合，也是消息中间件的基本思想；

4.ISP:接口隔离原则：将基类接口分解为多个类，让子类只依赖于它用到的那个类，，一个类对另外一个类的依赖性应当是建立在最小的接口上的，如果某个子类只用到了基类中的某几个接口，而不关心其它的接口，也不想去实现其它无关的接口，
      那么可以将基类分解成多个类，把这些接口拆分到不同的类里面，让类变小，而不是越变越大；
      多重继承就体现了接口隔离： class : public InterfaceA,InterfaceB,InterfaceC
      eg:A拆成B/C, 然后A:public B,C; 那么原来使用A的地方可以不修改，这是一种偷懒的做法，更好的方法是对原来使用A的地方也进行拆分，分别使用B/C来定义对象（尽管赋值相同）；
5.DIP：依赖倒置原则:高层模块不应该依赖低层模块；抽象不应该依赖细节；核心思想是"高层模块面向接口编程",而不是面向具体实现；
                本质：面向接口编程，做法：定义实例类型时用顶层接口类(root class type)，不用具体派生类；
                现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。
6.SRP:单一职责原则：不要存在多于一个导致类变更的原因.只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则.
      单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。


5.抽象类和接口类的区别：
    表面上看：1.抽象类可以给出一些成员的实现，而接口不包含任何成员的实现
．           2.抽象类的抽象成员可被子类部分实现，而接口的成员需要实现类完全实现
．           3.一个类只能继承一个抽象类，但可继承多个接口类；
    深层次：  1 .类是对对象的抽象，抽象类是对类的抽象（类相关性），接口是对行为的抽象（行为相关性）
．           2.对于行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类
．    从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类； 而接口是根本不知子类的存在，方法如何实现还不确定，预先定义形式。
    抽象类往往是通过 重构 得来的，是自底而上抽象出来的，而接口则是自顶向下设计出来的。     

6.传递依赖关系有三种方式，1）接口传递，2)构造方法传递;3)setter方法传递。

7.继承的缺点：当父类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。增加了父类与子类的耦合。
  继承是白箱复用，组合是黑箱复用，基于组合的设计会有更多的对象，而有较少的类；

7.继承的类型：对一个继承体系，它的类型就是root class的类型，也是对外呈现的类型，面向接口编程就是只用root class类型，不用下层的class;


8.当你用组合时，发现绝大部分函数都只是拷贝，那应该改为继承；
  当年用继承时，发现只用到了部分接口，或者需要大量修改原有实现，那应该用组合；
  用继承意味着需要以父类的身份被调用，用组合那就必须以自己的身份被调用；

8.OO设计原则：1）面向接口编程，只用root class/interface来定义变量；
           2）尽量用组合，不用继承，设计模式体现了这点，即使要用继承，一般也是用来继承接口类，而非继承实现类；

9.代码复用的3个方式：组合，模板参数，继承。           


10.State模式的经典场景是大量的状态机，比如电梯调度;

11.观察者模式：Observer最重要的方法：register/remove/Notify-->update(); Observer内有个容器保存对象列表，被通知的对象提供update()接口;

12.Proxy代理模式：经典场景RPC调用；

12.build模式： 核心是一个build类提供多个set()方法接收参数，然后存起来，用于创建（其它）对象时注入到构造函数，应用场景：构造函数需要大量重载，输入参数组合情况比较多；

13.对象创建型模式: 一般以FactoryMethod开始，当发现需要更大的灵活性时候，再向其他模式演化(Prototype,AbstractFactory),
原型模式(prototype)就是事先创建好一些静态对象，然后再从这些对象clone出新的对象，所以需要有一个virtual clone()接口，这种模式用在RPC中，根据消息typename(string)查找原型，然后由原型clone出对象，这种机制就叫反射；

14.composite设计模式(文件夹模式)：必须有一个最基础的类可以独立构造，然后构造出组合类，比如文件夹中的文件就是基础类；
     组合设计模式和Decorate模式很像，区别是：组合设计模式体现的是聚合关系，I,A,B, 其中B包含了 I 的集合列表vector<I*>;
     共同点是：类图关系表现为递归， I派生B，B又包含I（实际是I的派生类）；
     Decorate模式I,A,B,其中B包含单个I 成员， 通过嵌套构造，可以达到叠加装饰效果： B3(B2(B1(A))); 举例： Java的inputstream/FileInputStream/ByteArrayInputStream;

15.Adaptor模式：最佳应用场景，自适应接口变化，不想对第3方代码产生强依赖，下面这个类设计图非常好，来自<clean code: craftmanship>图8-2, 
解释：通信控制器是我们在开发的代码，future是第3方模块，还未开发完成，提供的接口也不清晰， 为了避免对它产生强依赖，我们自己定义了内部接口interface, 通过FakeTransmitter来测试我们的代码，当第3方代码就绪时，我们只需要新增个Adapter类来调用他们，这个设计的好处是：并行开发，控制影响和边界；

