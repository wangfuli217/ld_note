
***********************************************************CMocka*********************************************
1.内存泄露与内存溢出
内存泄露(memory leak)：程序中向系统申请的内存在程序结束之后都没有释放
内存溢出(memory overflow)：程序申请内存时，系统没有足够的内存提供，最终导致溢出
2.编译时如果需要define变量，使用-D选项 eg:gcc -c malloc -o allo.o -D UNIT_TESTING
3.需要使用cmocka的库函数，请在源文件中包含以下头文件
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>s
#include <cmocka.h>
4.nm gcc工具可以查看列出目标文件的符号清单 eg:nm -a allo.o 

cmocka的使用
编译时需指定cmocka库，gcc source.c -lcmocka -L /usr/local/lib
也可以在编译的时候包含cmocka.c

如果需要使用到cmocka里面的内存检测工具，在编译时源文件不应添加stdlib.h，直接使用cmocka的头文件
编译时指定-D UNIT_TESTING

cmocka的main函数，中的测试函数参数应为void **state,不应该为void,测试函数是指test_fun，comcka_unit_test(test_fun)
静态函数的测试方法，在源文件中使用
#ifdef UNITTEST 
#define static
#endif//UNITTEST
将static置空，然后再测试文件头文件内extern unit_test();即可应用
将函数返回值提前预设并压栈will_return(fun_c, value)
在fun_c中使用mock_type(type)返回栈中的值,PS：type为C语言中常用数据类型，int double等
will_return 和 mock_type总是成对出现
一般都用于模拟函数中
对于系统调用open read write connect
有时需要对系统调用进行模拟
此时可用函数指针指向动态库符号（dynamic library symbol)系统调用在德地址，实现系统调用
void*dlsym(void*handle,constchar*symbol)
在dlopen（）函数以指定模式打开指定的动态链接库文件，并返回一个句柄给dlsym（）的调用进程。使用dlclose（）来卸载打开的库。
编译时加-ldl，链接到对应库

Unit Test 总结
单元测试是软件开发必不可少的环节，单元测试属于白盒测试
软件测试的分类：
基于软件结构与算法来划分
1.白盒测试（结构测试/程序员测试）
2.黑盒测试（功能测试/数据驱动测试）

基于是否执行被测软件
1.静态测试
2.动态测试

基于测试的不同阶段来划分
1.单元测试（模块测试）,接口测试，路径测试
2.集成测试 ，接口，路经，功能，性能
3.系统测试 功能，性能，健壮性，稳定性，压力测试
4.验收测试 ，由用户执行

单元测试又称为模块测试，主要对软件的最小单元进行测试，软件的设计的最小单元
C：函数	Java：类
单元测试的模块往往是不可执行的，需要额外的测试驱动程序

单元测试的名词：
1。驱动模块：可以调用被测模块的单元
2。桩函数：用以被被测函数调用的函数
3。测试用例：是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，
以便测试某个程序路径或核实是否满足某个特定需求。个人理解：就是我们编写
的测试函数test_leak_memory.c

单元测试的目的

1.为模块正常运行而设计
证明测试环境和被测单元是可用的
3.为正向测试而设计
证明设计规格说明书中对应的功能和性能指标是否能够实现
5.为逆向测试而设计
证明软件没有做不应该做的事情
7.为满足特殊需求而设计
从系统的性能、安全性、保密性的角度为具有这些要求的系统制订的测试用例
9.为代码覆盖而设计

单元测试的类型
1.模块接口测试
2.模块局部数据结构测试
3.模块边界条件测试
4.模块中所有独立执行通路测试
5.模块的各条错误处理通路测试
6.模块的非法测试
7.代码重用测试	
8.系统兼容测试

代码覆盖：
程序中代码被执行的比例
代码覆盖的度量
1.函数覆盖：每一个函数是否被执行
2.语句覆盖(行覆盖)：每一条语句是否被执行
3.分支覆盖：每一个判定分支是否被执行
4.条件覆盖
5.路径覆盖（条件组合覆盖），让条件覆盖中的每一种组合都出现一次

单元测试工具：cmocka
可源码安装
代码覆盖率：gcov
sudo apt-get -y install python-pip
sudo pip install gcovr

cmocka的使用
1.内存操作检查：cmkcka使用_test_malloc _test_alloc _test_free等代替malloc alloc free等，检测内存泄露
2.模拟函数中的返回值；模拟对象是mocka的特点，也是擅长点
3.函数输入检查值；
4.不同类型的宏定义验证
5.系统调用模拟
6.强大的assert断言验证

cmocka API：
1.Running Tests 是整个测试的运行函数
2.Standard Assertions 对标准assert的一种替换方案，防止测试被assert打断
3.Checking Parameters 用于对函数参数的检测
4.Mock Objects 用于mock对象，常用作mock函数的返回，实现方式与Checking Parameter类似
5.Dynamic Memory Allocation 用于对内存的检测
6.Assert Macros 包含了常用的断言
单元测试的问题定位
1.Assert结果与预期不符
解决：根据测试结果对照源码和测试用例逐步定位
2.段错误：
解决：代码中加printf逐步进行调试
gdb调试
3.内存泄露
解决：对照内存申请与释放的代码逐步定位

但愿测试应该注意
不能修改源码，最多添加头文件

GlusterFS Source
expect_assert_failure(fun);这个函数断言函数func调用会失败返回
一般与REQUIRE(p) ENSURE(p)配合使用,这两个宏也是一种断言
测试某个函数时,一定要对其返回值进行断言判断,判断其实否执行预期的结果

test_func_unittest.c中尽量将func的头文件放在cmocka头文件的上头

mock返回指定类型的用mock_type(type); 与注入函数will_return(func, val);
而返回任意类型mock()，与注入函数will_return_always(func, val)配对

代码覆盖率工具:gcovr
其实glusterfs代码在make check编译时已经带有-lcmock --coverage等参数所以编译出的代码直接
测试其代码覆盖率
gcovr使用
gcovr只能通过可执行程序去测试代码覆盖率，就是说只有代码是不能测试代码覆盖率的
也不是所有的可执行程序都可作为测试
只有通过特定的参数编译出来的二进制文件才可测试
source:coverage.c
如果要测试coverage.c的覆盖率
编译 gcc  -fprofile-arcs -ftest-coverage -fPIC -O0 coverage.c -o main
就可生成可执行程序main
这时就可用gcovr工具来测试覆盖率
查看当前目录下的代码覆盖率（测试结果排除unittest代码）
sudo gcovr -r .  -e .*unittest.* 
查看当前目录下的分支覆盖率（测试结果排除unittest代码）
sudo gcovr -r . –b -e .*unittest.* 
输出为HTML格式的概览结果（测试结果排除unittest代码）
sudo gcovr -r . -e .*unittest.* --html -o thunderfs_unittest_general.html
输出为HTML格式的详细结果（测试结果排除unittest代码）
sudo gcovr -r . -e .*unittest.* --html --html-details -o thunderfs_unittest_detail.html 












***********************************************************GoogleTest*********************************************
GoogleTest:简称gtest,是google针对c/c++的一个UnitTest工具，其对Windows，Linux，Mac都支持，是一款免费开源的单元测试framework
获取gtest源码:git clone  git@github.com:google/googletest.git
目录feature:
make:针对Unix/Linux平台的测试库，进入目录make命令生成静态库.a文件，便于之后测试编译引用
msvc:主要针对Windows平台的VistualC++
xcode:主要针对Mac平台的Xcode
codegear:Borland C++ Builder和自动工具脚本（不推荐使用）另一种C++平台
CMakeLists.txt：Google Test根目录中的CMake（推荐）。
include:gtest的头文件目录（重要）
src:单元测试所需要的源文件（重要）
test:
samples:gtest给出的几个测试用例样本samples~sample10



以下是make/Makefile文件的内容，从以下内容可大概分析出gtest的使用以及其运行原理:
# A sample Makefile for building Google Test and using it in user
# tests.  Please tweak it to suit your environment and project.  You
# may want to move it to your project's root directory.
#
# SYNOPSIS:
#
#   make [all]  - makes everything. //make命令生成目标文件
#   make TARGET - makes the given target. //可make不同target生成指定的目标文件
#   make clean  - removes all files generated by make. //清除当前目录生成的所有文件Makefile文件除外
# Please tweak the following variable definitions as needed by your
# project, except GTEST_HEADERS, which you can use in your own targets
# but shouldn't modify. 
#除了GTEST_HEADERS变量外，其他变量你都可以修改，你可以使用，但是不应该修改目标的内容

# Points to the root of Google Test, relative to where this file is.
# Remember to tweak this if you move this file.
#..是gtest的根目录，但是只是相对当前目录而言，如果你的Projice Dirtroy改变了
#此目录也要作出相应的修改
GTEST_DIR = .. 

#此目录是用户的源文件目录，放着待测得源文件(xxx_src.cc)，也可以放单元测试的源文件(zzz_unittest.cc)
# Where to find user code.
USER_DIR = ../samples

# Flags passed to the preprocessor.
# Set Google Test's header directory as a system directory, such that
# the compiler doesn't generate warnings in Google Test headers.
#标志传递给预处理器。 将Google Test的头目录设置为系统目录，以便编译器不会在Google测试头中生成警告。
CPPFLAGS += -isystem $(GTEST_DIR)/include

# Flags passed to the C++ compiler.
#C++编译选项，可自己修改
CXXFLAGS += -g -Wall -Wextra -pthread

# All tests produced by this Makefile.  Remember to add new tests you
# created to the list.
#这就是你生成的单元测试所生成的目标文件(可执行文件)，如果有多个，可生成列表形式(以下针对samples/sample1.cc的单元测试)
TESTS = sample1_unittest

# All Google Test headers.  Usually you shouldn't change this
# definition.
#所有Gtest的所需头文件，不应该去修改它
GTEST_HEADERS = $(GTEST_DIR)/include/gtest/*.h \
                $(GTEST_DIR)/include/gtest/internal/*.h
# House-keeping build targets.
#需要构建(生成)的目标，如果有多个，可写成列表
all : $(TESTS)
#需要清理的文件
clean :
	rm -f $(TESTS) gtest.a gtest_main.a *.o
#构建公共库(gtest.a and gtest_main.a.)
# Builds gtest.a and gtest_main.a.
# Usually you shouldn't tweak such internal variables, indicated by a
# trailing _.
#以下是gtest所需的源文件，不应该去修改
GTEST_SRCS_ = $(GTEST_DIR)/src/*.cc $(GTEST_DIR)/src/*.h $(GTEST_HEADERS)
# For simplicity and to avoid depending on Google Test's
# implementation details, the dependencies specified below are
# conservative and not optimized.  This is fine as Google Test
# compiles fast and for ordinary users its source rarely changes.
#以下是生成公共库(静态库.a)所需要的实现细节，公共库就在于解决用户只用关心自己的测试用例部分
#而不用关心gtest的实现细节(gtest.a gtest_main.a)
gtest-all.o : $(GTEST_SRCS_)
	$(CXX) $(CPPFLAGS) -I$(GTEST_DIR) $(CXXFLAGS) -c \
            $(GTEST_DIR)/src/gtest-all.cc
gtest_main.o : $(GTEST_SRCS_)
	$(CXX) $(CPPFLAGS) -I$(GTEST_DIR) $(CXXFLAGS) -c \
            $(GTEST_DIR)/src/gtest_main.cc
gtest.a : gtest-all.o
	$(AR) $(ARFLAGS) $@ $^
gtest_main.a : gtest-all.o gtest_main.o
	$(AR) $(ARFLAGS) $@ $^
# Builds a sample test.  A test should link with either gtest.a or
# gtest_main.a, depending on whether it defines its own main()
# function.
#以下才是用户应该修改的地方，以下是测试用例的产生的编译过程，一个完整的单元测试，应该
#包含源文件(sample1.cc)和测试用例源文件(sample1_unittest.cc)，sample1_unittest.cc才是我们应该
#设计的内容
sample1.o : $(USER_DIR)/sample1.cc $(USER_DIR)/sample1.h $(GTEST_HEADERS)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $(USER_DIR)/sample1.cc
sample1_unittest.o : $(USER_DIR)/sample1_unittest.cc \
                     $(USER_DIR)/sample1.h $(GTEST_HEADERS)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $(USER_DIR)/sample1_unittest.cc
sample1_unittest : sample1.o sample1_unittest.o gtest_main.a
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -lpthread $^ -o $@
*/

Gtest 的基本概念:
断言:

每一种单元测试工具都会提供一套断言工具，断言测试是一种最简单高效且使用最多
的值判断方式
gtest的断言结果可分为三类:
1.成功
2.非致命失败
3.致命失败(发生致命失败，程序终止执行，其他则继续执行)

Google Test断言是类似函数调用的宏，当断言失败时，Google Test会打印断言的源文件和行号位置以及失败消息。也可以自定义打印信息
ASSERT_EQ(x.size(), y.size())
以ASSERT_* 开头的是致命性故障：在条件失败时会终止当前功能，这也存在一个问题，程序可能会因为中止运行而没用回收资源，导致内存泄露
以EXPECT_* 开头的是非致命性故障不会中止当前功能。只是产生提示信息。

通常EXPECT_* 是首选，因为它们允许在测试中报告多于一个故障。但是，ASSERT_*如果在有争议的断言失败时继续执行，则应该使用它。

由于一个失败的ASSERT_*返回从当前的功能立即，可能跳过清理代码之后，它可能会导致空间泄漏。根据漏洞的性质，它可能或可能不是
值得修复的 - 所以请记住，如果除了断言错误之外还有一个堆检查器错误。

如果需要自定义的失败消息，只需使用<<运算符或者这样的运算符的序列将其流入宏:
ASSERT_EQ(x, y) << "x should eq y";
只有在ASSERT失败时会输出失败信息

基础断言:
Fatal assertion	Nonfatal assertion	Verifies
判断真假(True or Flase)
致命的断言					非致命性断言				     验证
ASSERT_TRUE(condition);		EXPECT_TRUE(condition);		condition is true
ASSERT_FALSE(condition);	EXPECT_FALSE(condition);	condition is false

二进制值比较判断:
致命的断言				非致命性断言				验证
ASSERT_EQ(val1 ,val2);	EXPECT_EQ(val1 ,val2);	val1 == val2
ASSERT_NE(val1 ,val2);	EXPECT_NE(val1 ,val2);	val1 != val2
ASSERT_LT(val1 ,val2);	EXPECT_LT(val1 ,val2);	val1 < val2
ASSERT_LE(val1 ,val2);	EXPECT_LE(val1 ,val2);	val1 <= val2
ASSERT_GT(val1 ,val2);	EXPECT_GT(val1 ,val2);	val1 > val2
ASSERT_GE(val1 ,val2);	EXPECT_GE(val1 ,val2);	val1 >= val2

字符串比较

该组中的断言比较了两个C字符串。如果要比较两个string对象，用途EXPECT_EQ，EXPECT_NE以及等来代替。

致命的断言						非致命性断言					验证
ASSERT_STREQ(str1 ,str2);	EXPECT_STREQ(str1, _str_2);			两个C字符串具有相同的内容
ASSERT_STRNE(str1 ,str2);	EXPECT_STRNE(str1 ,str2);			两个C字符串有不同的内容
ASSERT_STRCASEEQ(str1 ,str2);	EXPECT_STRCASEEQ(str1 ,str2);	两个C字符串具有相同的内容，无视情况
ASSERT_STRCASENE(str1 ,str2);	EXPECT_STRCASENE(str1 ,str2);	两个C字符串具有不同的内容，忽略了这种情况

一个简单的测试用例:
gtest中的测试用例用TEST()函数来实现
要创建一个测试：

使用TEST()宏定义和命名测试函数，这些是不返回值的普通C ++函数。在此函数中，连同要包含的任何有效的C ++语句，
请使用各种Google Test断言来检查值。测试结果由断言决定; 如果测试中的任何断言失败（致命或非致命），或者测试崩溃，
则整个测试失败。否则，它成功了。
TEST(test_case_name, test_name) {
 ... test body ...
}
TEST(test_case_name, test_name)。第一个参数是测试用例的名称，第二个参数是测试用例中的测试名称。这两个名称必须是有效的C ++
标识符，并且它们不应包含下划线（_）。第一个参数应该由被测试的函数名称加Test字段，第二个参数可以是测试类型说明
int Factorial(int n); // Returns the factorial of n 这是一个返回n的阶乘的函数
以下是一个测试用例:
// Tests factorial of 0.
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(1, Factorial(0));
}
//该测试用例为测试Factorial函数，测试类型为0值测试

Test Fixtures
 