https://www.geeksforgeeks.org/data-structures/

https://www.zhihu.com/question/34442401

https://linux.cn/article-7480-1.html

https://www.cse.unr.edu/~bebis/CS308/ # ppt
https://github.com/yuankang/notes


datastruct  宏模式：crosstool\cheatsheet\ops_doc-mstaer\Service\ds\macro
datastruct  侵入模式：crosstool\cheatsheet\ops_doc-mstaer\Service\ds\intrusive
datastruct  libubox-平衡树模式：crosstool\cheatsheet\ops_doc-mstaer\Service\ds\libubox-avl
datastruct  hash表 模式：crosstool\cheatsheet\ops_doc-mstaer\Service\ds\libdict
datastruct  unity自测试 模式：crosstool\cheatsheet\ops_doc-mstaer\Service\ds\unity\ds

https://en.wikibooks.org/wiki/Data_Structures/All_Chapters
https://www.sanfoundry.com/1000-data-structure-questions-answers/ # Data Structures Using C 1000 Problems and Solutions
https://www.includehelp.com/python/ # register

# 时间复杂度的排序
O(1) < O(log(n)) < O(n) < O(n^2) < O(n^3) < O(2^n)

1. 数据结构操作
数据结构           |                                时间复杂度                                                            | 空间复杂度
                   | 平均                                              | 最差                                             | 最差
                   | 访问       | 搜索       | 插入       |  删除      | 访问       | 搜索       | 插入       | 删除      |
Array              | O(1)       | O(n)       | O(n)       | O(n)       | O(1)       | O(n)       | O(n)       | O(n)      | O(n)      
Stack              | O(n)       | O(n)       | O(1)       | O(1)       | O(n)       | O(n)       | O(1)       | O(1)      | O(n)      
Singly-Linked List | O(n)       | O(n)       | O(1)       | O(1)       | O(n)       | O(n)       | O(1)       | O(1)      | O(n)      
Doubly-Linked List | O(n)       | O(n)       | O(1)       | O(1)       | O(n)       | O(n)       | O(1)       | O(1)      | O(n)      
Skip List          | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(n)       | O(n)       | O(n)       | O(n)      | O(nlog(n))
Hash Table         | -          | O(1)       | O(1)       | O(1)       | -          | O(n)       | O(n)       | O(n)      | O(n)      
Binary Search Tree | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(n)       | O(n)       | O(n)       | O(n)      | O(n)      
Cartesian Tree     | -          | O(log(n))  | O(log(n))  | O(log(n))  | -          | O(n)       | O(n)       | O(n)      | O(n)      
B-Tree             | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n)) | O(n)      
Red-Black Tree     | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n)) | O(n)      
Splay Tree         | -          | O(log(n))  | O(log(n))  | O(log(n))  | -          | O(log(n))  | O(log(n))  | O(log(n)) | O(n)      
AVL Tree           | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n))  | O(log(n)) | O(n)  

2. 数组排序算法
算法                 | 时间复杂度                                          | 空间复杂度
                     | 最佳            | 平均            | 最差            | 最差
Quicksort            | O(n log(n))     | O(n log(n))     | O(n^2)          | O(log(n))       
Mergesort            | O(n log(n))     | O(n log(n))     | O(n log(n))     | O(n)            
Timsort              | O(n)            | O(n log(n))     | O(n log(n))     | O(n)            
Heapsort             | O(n log(n))     | O(n log(n))     | O(n log(n))     | O(1)            
Bubble Sort          | O(n)            | O(n^2)          | O(n^2)          | O(1)            
Insertion Sort       | O(n)            | O(n^2)          | O(n^2)          | O(1)            
Selection Sort       | O(n^2)          | O(n^2)          | O(n^2)          | O(1)            
Shell Sort           | O(n)            | O((nlog(n))^2)  | O((nlog(n))^2)  | O(1)            
Bucket Sort          | O(n+k)          | O(n+k)          | O(n^2)          | O(n)            
Radix Sort           | O(nk)           | O(nk)           | O(nk)           | O(n+k)   

3. 图操作
节点 / 边界管理      | 存储            | 增加顶点        | 增加边界        | 移除顶点       | 移除边界        | 查询
Adjacency list       | O(|V|+|E|)      | O(1)            | O(1)            | O(|V| + |E|)   | O(|E|)          | O(|V|)          
Incidence list       | O(|V|+|E|)      | O(1)            | O(1)            | O(|E|)         | O(|E|)          | O(|E|)          
Adjacency matrix     | O(|V|^2)        | O(|V|^2)        | O(1)            | O(|V|^2)       | O(1)            | O(1)            
Incidence matrix     | O(|V| ? |E|)    | O(|V| ? |E|)    | O(|V| ? |E|)    | O(|V| ? |E|)   | O(|V| ? |E|)    | O(|E|) 

4. 堆操作               
                        | 时间复杂度
                        | Heapify    | 查找最大值 | 分离最大值 | 提升键    | 插入       | 删除       | 合并
Linked List (sorted)    | -          | O(1)       | O(1)       | O(n)      | O(n)       | O(1)       | O(m+n)     
Linked List (unsorted)  | -          | O(n)       | O(n)       | O(1)      | O(1)       | O(1)       | O(1)       
Binary Heap             | O(n)       | O(1)       | O(log(n))  | O(log(n)) | O(log(n))  | O(log(n))  | O(m+n)     
Binomial Heap           | -          | O(1)       | O(log(n))  | O(log(n)) | O(1)       | O(log(n))  | O(log(n))  
Fibonacci Heap          | -          | O(1)       | O(log(n))  | O(1)      | O(1)       | O(log(n))  | O(1) 


linear(){
模块一：线性结构
	连续存储	数组
	离散村粗	链表
	
	链表的分类
    排序
        无序链表
        有序链表
	单链表
		单链表是用户不断申请存储单元和改变链接关系而得到的一种特殊数据结构。
		链表建立的过程是结点申请空间、结点得到数据、结点加入链表的循环处理过程。
	    头插法 右不动	"写文件的行顺序和读文件的行顺序相反"
		将链表的左边称为链头，右边称为链尾。
		头插法建单链表是将链表右端看成固定，链表不断向左延伸。
		头插法最先得到的是尾结点。
	    尾插法 左不动	"写文件的行顺序和读文件的行顺序相同"
		将链表的左边称为链头，右边称为链尾。
		尾插法建单链表是将链表左端看成固定，链表不断向右延伸。
		尾插法最先得到的是头结点。

	双链表
	环形链表

	线性结构的两种常见形式一	栈      特点:先进后出(FILO)
	线性结构的两种常见形式二	队列    特点:先进先出(FIFO)

	环形结构的两种常见形式一	环形链表	双向,无最大空间限制(内存占满为止).
	环形结构的两种常见形式二	环形队列	单向,有最大空间限制.

	专题：递归
	1.求1+2+3+...+n的和
	2.求阶乘
3.汉诺塔
}

nolinear(){
模块二：非线性结构
树
	定义：// ???

	分类：
		一般树
		二叉树
			歪斜树
			满二叉树
			完全二叉树
		森林


	二叉树的5个性质：
1.二叉树中阶层为l的阶层上,最多有2的l-1(l>=1)次方个结点.
2.高度为h的二叉树最多有2的h(h>=1)次方减1个结点.
3.含有m个叶子结点,n个度为2结点的二叉树,存在n = m + 1的关系.
4.有n个结点的完全二叉树的高度为,以2为底n的对数取小在加1└log2n┘ + 1.
5.对含有n个结点的完全二叉树,从上到下从左到右进行1至n的编号,则任意编号i存在下面4种关系.
	1.若i=1,则该结点是二叉树的根.
	2.若i!=1,则编号为└i/2┘的结点为其父结点.
	3.若2i>n,则该结点无左子结点.否则编号为2i的结点为其左子结点.
	4.若2i+1>n,则该结点无右子结点.否则编号为2i+1的结点为其右子结点.


	树的存储：
		二叉树的存储
			连续存储(完全二叉树)
				优点：查找/判断某个结点的父子结点速度快
				缺点：耗用内存空间较大
			链式存数(不是用链表存储)
				----------------
				|  头结点指针  |
				|--------------|
				|指针|数据|指针|
				----------------
		
		普通树的存储
			双亲表示法
				求父结点方便
			孩子表示法
				求子结点方便
			双亲孩子表示法
				求父子结点都方便
			二叉树表示法
				把一个普通树转化为二叉树的方法：
					设法保证任意一个结点的
						左指针域指向它的第一个孩子结点
						右指针域指向它的下一个兄弟结点
					注：普通树转化为二叉树后，该二叉树的根结点都没有右子树

		森林的存储
			二叉树表示法
				把森林转化为二叉树的方法：
					把每棵树的根结点看成是兄弟几点，然后
					设法保证任意一个结点的
						左指针域指向它的第一个孩子结点
						右指针域指向它的下一个兄弟结点

	二叉树的操作
		遍历
			前序遍历
				先访问根结点
				再前序遍历左子树
				再前序遍历右子树

			中序遍历
				先中序遍历左子树
				再访问根结点
				再中序遍历右子树

			后序遍历
				先中序遍历左子树
				再中序遍历右子树
				再访问根结点

		已知两种遍历序列求原始二叉树
			知道前序和中序，可以求原始二叉树
			知道中序和后序，可以求原始二叉树
			知道前序和后序，不能求原始二叉树

	树的应用
		树是数据库中一种数据组织的重要形式
		操作系统父子进程的关系，就是一棵树
		面向对象语言中类的继承关系，也是一棵树
		赫夫曼树

图 // ???
	广度遍历
深度遍历
}
search_sort(){
查找和排序
查找：
	顺序查找
	折半查找
排序：
	冒泡
	快速排序	重要
	插入
	选择
	归并排序

排序和查找的关系
	排序是查找的前提
排序是重点
}


编辑（edit）：将存在某种媒体上的数据经过计算机复制到另一媒体时，对输入的数据逐一检查，其目的在于改变数据的存储形式和效率，以便后面的处理。
排序（sort）：将数据根据某一键值，以某种顺序排序后输出，其目的在于方便其他方面的数据处理。
归并（merge）：将两种以上相同性质的文件数据归并在一起。
分配（distribute）：将一个文件的数据按照某一基准分配在两个以上的存储体，其目的在于方便各个分配的文件能独自处理。
建档（generate）：根据某些条件规格，配合某些已存在的文件，再产生一个新的且有利用价值的文件。
更新（update）：根据数据的变动来更新主档案，以保持主档案的正确与完整性。
计算（compute）：将读取的文件数据，依据规定方法计算处理。
链表（list）：是一种数据的集合，也就是一系列的数据存储于内存，以某种关系来连接这些相关联的数据。
查找（search）：输入一个键值到数据表中进行对照，找出具有相同键值的数据。
查询（inquiry）：根据数据项的键值或条件，到主档案中找出符合该条件或键值相同的数据，依照用户指定的方法输出。
其它处理：分类（classifying）、摘要（summarizing）、变换(transmission)。

# 'if', 'and', 'with(in)', 'has', 'us(ing|e)', 'on(ly)', 'then', 'for', 'of'
# grammar, numbers (i.e.  decimal digit sequences) and strings

Event:     | Failure state:              | Success state:
---------------------------------------------------------------------
action     | "Action failed"             | "Action done"
checksum   | "Checksum failed"           | "Checksum succeeded"
bytein     | "Download bytes exceeded"   | "Download bytes ok"
byteout    | "Upload bytes exceeded"     | "Upload bytes ok"
connection | "Connection failed"         | "Connection succeeded"
content    | "Content failed",           | "Content succeeded"
data       | "Data access error"         | "Data access succeeded"
exec       | "Execution failed"          | "Execution succeeded"
fsflags    | "Filesystem flags failed"   | "Filesystem flags succeeded"
gid        | "GID failed"                | "GID succeeded"
icmp       | "Ping failed"               | "Ping succeeded"
instance   | "Monit instance changed"    | "Monit instance changed not"
invalid    | "Invalid type"              | "Type succeeded"
link       | "Link down"                 | "Link up"
nonexist   | "Does not exist"            | "Exists"
packetin   | "Download packets exceeded" | "Download packets ok"
packetout  | "Upload packets exceeded"   | "Upload packets ok"
permission | "Permission failed"         | "Permission succeeded"
pid        | "PID failed"                | "PID succeeded"
ppid       | "PPID failed"               | "PPID succeeded"
resource   | "Resource limit matched"    | "Resource limit succeeded"
saturation | "Saturation exceeded"       | "Saturation ok"
size       | "Size failed"               | "Size succeeded"
speed      | "Speed failed"              | "Speed ok"
status     | "Status failed"             | "Status succeeded"
timeout    | "Timeout"                   | "Timeout recovery"
timestamp  | "Timestamp failed"          | "Timestamp succeeded"
uid        | "UID failed"                | "UID succeeded"
uptime     | "Uptime failed"             | "Uptime succeeded"


Array(){
顺序表还需要实时记录以下 2 项数据
1. 顺序表申请的存储容量；
2. 顺序表的长度，也就是表中存储数据元素的个数；
建立顺序表需要
1. 给 head 动态数据申请足够大小的物理空间；
2. 给 size 和 length 赋初值；
}
Array(){
数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。
优点：
1、按照索引查询元素速度快
2、按照索引遍历数组方便
缺点：
1、数组的大小固定后就无法扩容了
2、数组只能存储一种类型的数据
3、添加，删除的操作慢，因为要移动其他的元素。
适用场景：
频繁查询，对存储空间要求不大，很少增加和删除的情况。
}
Stack(){
    栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 
栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。
    栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。
}
Queue(){
因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。
}
List(){
链表中每个数据的存储都由以下两部分组成：
1. 数据元素本身，其所在的区域称为数据域；
2. 指向直接后继元素的指针，所在的区域称为指针域；

头指针：一个普通的指针
节点：链表中的节点又细分为头节点、首元节点和其他节点：
  头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。
  首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。
  其他节点：链表中其他的节点；
  
链表插入元素
同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：
  插入到链表的头部（头节点之后），作为首元节点；
  插入到链表中间的某个位置；
  插入到链表的最末端，作为链表中最后一个数据元素；
  
从链表中删除数据元素需要进行以下 2 步操作：
    将结点从链表中摘下来;
    手动释放掉结点，回收被结点占用的存储空间;

查找链表元素
    在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，
直至比对成功或遍历至链表最末端的 NULL（比对失败的标志）。

链表更新元素
    更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。
}

List(){
链表的优点：
链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；
添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；

缺点：
因为含有大量的指针域，占用空间较大；
查找元素需要遍历链表来查找，非常耗时。

适用场景：
数据量较小，需要频繁增加，删除操作的场景
}


Tree(){
https://github.com/dunwu/algorithm-tutorial
https://github.com/Fivever/Fivever.github.io

https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)

# 1. Binary trees 
Binary search tree (BST) · Van Emde Boas tree · Cartesian tree · Top Tree · T-tree
# 2. Self-balancing binary search trees 
Red-black tree · AVL tree · AA tree · Splay tree · Scapegoat tree · Treap
# 3. B-trees 
B+ tree · B*-tree · UB-tree · 2-3 tree · 2-3-4 tree · (a,b)-tree · Dancing tree · Htree · Bx-tree
# 4. Tries 
Suffix tree · Radix tree · Ternary search tree
# 5. Binary space partitioning (BSP) trees 
Quadtree · Octree · kd-tree (implicit) · VP-tree
# 6. Non-binary trees 
Exponential tree · Fusion tree · Interval tree · PQ tree · Range tree · SPQR tree
# 7. Trees used in computer graphics 
R-tree · X-tree · Segment tree
# 8. Other trees 
Heap · Hash tree · Finger tree · Metric tree · Cover tree · BK-tree · Doubly-chained tree · Expectiminimax tree · iDistance
}
Tree(){
树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。它具有以下的特点：
    每个节点有零个或多个子节点；
    没有父节点的节点称为根节点；
    每一个非根节点有且只有一个父节点；
    除了根节点外，每个子节点可以分为多个不相交的子树；
    
    二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，
所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。
扩展：
二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，
}

Hash(){
    散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，
通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。
    记录的存储位置=f(key)
哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。
}

heap(){
堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：
    堆中某个节点的值总是不大于或不小于其父节点的值；
    堆总是一棵完全二叉树。
将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。
堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。
    (ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，
满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，

因为堆有序的特点，一般用来做数组中的排序，称为堆排序。
}
Graph(){
    图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、
邻接表、十字链表、邻接多重表、边集数组等存储结构，
}

https://linux.cn/article-7707-1.html
heap(binary){
libuv     tree
libevent  array
moosefs   rundelay.c merger.c (array)
一个(最大)二叉堆是一个具有最大堆特性的完全二叉树。
1. 完整二叉树: 每一层都是二叉树 都被填满 ，除了最低/最下面的一层，并且所有的最底层顶点都尽力向左靠拢。
2. 最大二叉堆特性: 每个顶点的父元素 - 除了根元素 - 都比当前元素的值要大。这种定义比下面这种更容易验证：
   一个顶点的值 - 除了叶顶点 - 必须必它的一个或者两个子元素要大。
    
    二叉堆是可用于实现高效优先队列ADT的数据结构之一。在优先队中，每一个元素都有一个优先级并且
一个高优先级的元素总是比低优先级的先出头（如果有一样的优先级，像普通队列一样先进先出）。

    优先队 (PQ) 抽象数据结构 (ADT) 和普通的队列 ADT 差不多, 但是它多了以下两个主要操作:
    Enqueue(x): 放一个新元素 (键值) x 进去优先队 (相同顺序)，
    y = Dequeue(): 返回已经在优先队里的有着最高优先级（键值）的元素 y 如果存在并列情况，返回先入队的那个。
    也就是说像一个正常的 Queue 那样 先进先出(FIFO)
    
    五(5)种标准的最大二叉堆操作：
    Insert(v) - O(log N)
    ExtractMax() - O(log N)
    Create(A) - O(N log N) 版本
    Create(A) - O(N) 版本
    HeapSort() - O(N log N)
    
    Insert ： ShiftUp BubbleUp IncreaseKey
    ExtractMax(): ShiftDown BubbleDown  Heapify 
    
    到这里为止，我们有一个数据结构可以高效实现优先队ADT的两个主要操作：
    Enqueue(x), 可以用 Insert(x) 它花费 O(log N) 的时间
    y = Dequeue(), 可以用 y = ExtractMax() 它花费 O(log N) 的时间.
    然而用二叉堆的话 我们可以做一些其他的操作。
    
    更快的版本 Create(A) 操作是 Robert W. Floyd 在 1964年发明的。 
它利用了紧凑数组的优势 = 完整的二叉树和所有的叶元素（顶点的一半）生来就是最大二叉堆。 
然后这个操作只从最后一个内顶点一路回到根元素来修复最大二叉堆特性（如果必要的话）。
    
    尽管 HeapSort() 在最好/平均/最坏 情况下的时间复杂度都是 θ(N log N) ，它真的是最好的用比较元素的方法来实现的排序算法吗？
}

hash(){
散列是一种算法（通过散列函数），将大型可变长度数据集（称为键，不一定是整数）映射为固定长度的较小整数数据集。
哈希表是一种数据结构，它使用哈希函数有效地将键映射到值（表或地图ADT），以便进行高效的搜索/检索，插入和/或删除。
散列表广泛应用于多种计算机软件中，特别是关联数组，数据库索引，缓存和集合。

ADT表必须至少支持以下三种操作，并且尽可能高效：
    搜索（v） - 确定v是否存在于ADT中，
    插入（v） - 将v插入ADT，
    删除（v） - 从ADT中删除v。
哈希表是这个表ADT的一个可能的好实现
}


openssl(){
openssl 提供的命令，命令强调的输出，数据结构强调的是外部接口吧。


1. 对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。
对称密钥加密(英语：Symmetric-key algorithm)又称为对称加密、私钥加密、共享密钥加密，
公开密钥加密(英语：public-key cryptography，又译为公开密钥加密)，也称为非对称加密(asymmetric cryptography)，
一种密码学算法类型，在这种密码学方法中，需要一对密钥.一个是私人密钥，另一个则是公开密钥。

2. 非对称加密算法有RSA、Elgamal、背包算法、Rabin、D-H、ECC(椭圆曲线加密算法)。
}