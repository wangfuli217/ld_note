!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
CONNECTION_PORT	test/test.c	17;"	d	file:
DEFAULT_BACKLOG	test/test.c	18;"	d	file:
DEFAULT_PORT	echo-server.c	11;"	d	file:
DEFAULT_PORT	example.c	11;"	d	file:
DEFAULT_PORT	example2.c	12;"	d	file:
DEFAULT_UV_SUGGESTED_SIZE	test/test.c	19;"	d	file:
PIPENAME	echo-server.c	14;"	d	file:
PIPENAME	echo-server.c	16;"	d	file:
PIPENAME	echo-server.c	18;"	d	file:
PIPENAME	example.c	14;"	d	file:
PIPENAME	example.c	16;"	d	file:
PIPENAME	example.c	18;"	d	file:
PIPENAME	example2.c	15;"	d	file:
PIPENAME	example2.c	17;"	d	file:
PIPENAME	example2.c	19;"	d	file:
TESTING_UV_MSG_FRAMING	test/test.c	40;"	d	file:
UVTRACE	uv_msg_framing.c	4;"	d	file:
UVTRACE	uv_msg_framing.c	6;"	d	file:
UV_MSG_FRAMING_H	uv_msg_framing.h	2;"	d
UV_MSG_STATIC	uv_send_message.c	6;"	d	file:
UV_MSG_TRANSIENT	uv_send_message.c	7;"	d	file:
alloc_buffer	echo-server.c	/^void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {$/;"	f
alloc_buffer	example.c	/^void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {$/;"	f
alloc_buffer	example2.c	/^void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {$/;"	f
alloc_buffer	test/test.c	/^void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {$/;"	f
alloc_called	test/test.c	/^int alloc_called;$/;"	v
alloc_cb	uv_msg_framing.h	/^   uv_alloc_cb alloc_cb;$/;"	m	struct:uv_msg_s
alloc_size	uv_msg_framing.h	/^   int alloc_size;$/;"	m	struct:uv_msg_s
async_next_step	test/test.c	/^uv_async_t async_next_step;$/;"	v
barrier	test/test.c	/^uv_barrier_t barrier;$/;"	v
buf	test/test.c	/^    uv_buf_t buf;$/;"	m	struct:__anon1	file:
buf	uv_msg_framing.h	/^   char *buf;$/;"	m	struct:uv_msg_s
buf	uv_msg_framing.h	/^   uv_buf_t buf[2];$/;"	m	struct:uv_msg_send_s
check_msg	test/test.c	/^void check_msg(char *base, int size, char letter) {$/;"	f
cleanup	test/test.c	/^void cleanup() {$/;"	f
client_loop	test/test.c	/^uv_loop_t *client_loop;$/;"	v
create_test_msg	test/test.c	/^void create_test_msg(void *base, int size, char letter) {$/;"	f
data	uv_msg_framing.h	/^      void *data;$/;"	m	union:uv_msg_s::__anon3
data	uv_msg_framing.h	/^      void *data;$/;"	m	union:uv_msg_send_s::__anon4
data	uv_send_message.c	/^      void *data;$/;"	m	union:send_message_s::__anon2	file:
expected_suggested_size	test/test.c	/^int expected_suggested_size;$/;"	v
expected_suggested_size2	test/test.c	/^int expected_suggested_size2;$/;"	v
filled	uv_msg_framing.h	/^   int filled;$/;"	m	struct:uv_msg_s
free_buffer	echo-server.c	/^void free_buffer(uv_handle_t* handle, void* ptr) {$/;"	f
free_buffer	example.c	/^void free_buffer(uv_handle_t* handle, void* ptr) {$/;"	f
free_buffer	example2.c	/^void free_buffer(uv_handle_t* handle, void* ptr) {$/;"	f
free_buffer	test/test.c	/^void free_buffer(uv_handle_t* handle, void* ptr) {$/;"	f
free_called	test/test.c	/^int free_called;$/;"	v
free_cb	uv_msg_framing.h	/^   uv_free_cb free_cb;$/;"	m	struct:uv_msg_s
free_fn	uv_send_message.c	/^   uv_free_fn free_fn;$/;"	m	struct:send_message_s	file:
get_msg_size	test/test.c	/^int get_msg_size(void *msg) {$/;"	f
go_to_next_step	test/test.c	/^void go_to_next_step(uv_async_t *handle) {$/;"	f
main	echo-server.c	/^int main() {$/;"	f
main	example.c	/^int main() {$/;"	f
main	example2.c	/^int main() {$/;"	f
main	test/test.c	/^int main() {$/;"	f
memdup	uv_send_message.c	/^static void * memdup(void *source, int size) {$/;"	f	file:
msg	uv_send_message.c	/^   void *msg;$/;"	m	struct:send_message_s	file:
msg_read_cb	uv_msg_framing.h	/^   uv_msg_read_cb msg_read_cb;$/;"	m	struct:uv_msg_s
msg_send_cb	uv_send_message.c	/^   send_message_cb msg_send_cb;$/;"	m	struct:send_message_s	file:
msg_size	uv_msg_framing.h	/^   int msg_size;     \/* in network order! *\/$/;"	m	struct:uv_msg_send_s
next_alloc_size	test/test.c	/^int next_alloc_size;$/;"	v
next_alloc_size2	test/test.c	/^int next_alloc_size2;$/;"	v
next_msg_letter	test/test.c	/^int next_msg_letter;$/;"	v
on_close	echo-server.c	/^void on_close(uv_handle_t *handle) {$/;"	f
on_close	test/test.c	/^void on_close(uv_handle_t *handle) {$/;"	f
on_connect	example.c	/^void on_connect(uv_connect_t *connect, int status) {$/;"	f
on_connect	example2.c	/^void on_connect(uv_connect_t *connect, int status) {$/;"	f
on_connect	test/test.c	/^void on_connect(uv_connect_t *connect, int status) {$/;"	f
on_msg_received	echo-server.c	/^void on_msg_received(uv_msg_t *client, void *msg, int size) {$/;"	f
on_msg_received	example.c	/^void on_msg_received(uv_msg_t *client, void *msg, int size) {$/;"	f
on_msg_received	example2.c	/^void on_msg_received(uv_msg_t *client, void *msg, int size) {$/;"	f
on_msg_received	test/test.c	/^void on_msg_received(uv_msg_t *client, void *msg, int size) {$/;"	f
on_msg_sent	echo-server.c	/^void on_msg_sent(send_message_t *req, int status) {$/;"	f
on_msg_sent	example.c	/^void on_msg_sent(uv_write_t *req, int status) {$/;"	f
on_msg_sent	example2.c	/^void on_msg_sent(send_message_t *req, int status) {$/;"	f
on_new_connection	echo-server.c	/^void on_new_connection(uv_stream_t *server, int status) {$/;"	f
on_new_connection	test/test.c	/^void on_new_connection(uv_stream_t *server, int status) {$/;"	f
on_walk	test/test.c	/^void on_walk(uv_handle_t *handle, void *arg) {$/;"	f
on_write_complete	test/test.c	/^void on_write_complete(uv_write_t *req, int status) {$/;"	f
pipe	uv_msg_framing.h	/^      uv_pipe_t pipe;$/;"	m	union:uv_msg_s::__anon3
print_bytes	test/test.c	/^void print_bytes(char *oper, unsigned char *data, int size) {$/;"	f
reader_start	test/test.c	/^void reader_start(void *arg) {$/;"	f
reader_thread	test/test.c	/^uv_thread_t reader_thread;$/;"	v
recvd_called	test/test.c	/^int recvd_called;$/;"	v
req	test/test.c	/^    uv_write_t req;$/;"	m	struct:__anon1	file:
req	uv_msg_framing.h	/^      uv_write_t req;$/;"	m	union:uv_msg_send_s::__anon4
req	uv_send_message.c	/^      uv_msg_send_t req;$/;"	m	union:send_message_s::__anon2	file:
run_tests	test/test.c	/^int run_tests() {$/;"	f
send_data	test/test.c	/^void send_data(uv_stream_t* stream, char *data, int size) {$/;"	f
send_message	example.c	/^void send_message(uv_msg_t* socket, char *msg, int size, uv_write_cb write_cb) {$/;"	f
send_message	uv_send_message.c	/^int send_message(uv_msg_t *socket, char *msg, int size, uv_free_fn free_fn, send_message_cb send_cb, void *user_data) {$/;"	f
send_message_cb	uv_send_message.c	/^typedef void (*send_message_cb) (send_message_t *req, int status);$/;"	t	file:
send_message_completed	uv_send_message.c	/^static void send_message_completed(uv_write_t *wreq, int status) {$/;"	f	file:
send_message_s	uv_send_message.c	/^struct send_message_s {$/;"	s	file:
send_message_t	uv_send_message.c	/^typedef struct send_message_s send_message_t;$/;"	t	typeref:struct:send_message_s	file:
sendersocket	test/test.c	/^uv_msg_t  *sendersocket;$/;"	v
server_loop	test/test.c	/^uv_loop_t *server_loop;$/;"	v
stop_reader	test/test.c	/^uv_async_t stop_reader;$/;"	v
stop_reader_cb	test/test.c	/^void stop_reader_cb(uv_async_t *handle) {$/;"	f
tcp	uv_msg_framing.h	/^      uv_tcp_t tcp;$/;"	m	union:uv_msg_s::__anon3
test_coalesced_and_fragmented_messages	test/test.c	/^void test_coalesced_and_fragmented_messages() {$/;"	f
timer	test/test.c	/^uv_timer_t timer;$/;"	v
timer_cb	test/test.c	/^void timer_cb() {$/;"	f
uv_free_cb	uv_msg_framing.h	/^typedef void (*uv_free_cb)(uv_handle_t* handle, void* ptr);$/;"	t
uv_free_fn	uv_send_message.c	/^typedef void (*uv_free_fn) (void *ptr);$/;"	t	file:
uv_msg_init	uv_msg_framing.c	/^int uv_msg_init(uv_loop_t* loop, uv_msg_t* handle, int stream_type) {$/;"	f
uv_msg_read_cb	uv_msg_framing.h	/^typedef void (*uv_msg_read_cb)(uv_msg_t* stream, void *msg, int size);$/;"	t
uv_msg_read_start	uv_msg_framing.c	/^int uv_msg_read_start(uv_msg_t* stream, uv_alloc_cb alloc_cb, uv_msg_read_cb msg_read_cb, uv_free_cb free_cb) {$/;"	f
uv_msg_s	uv_msg_framing.h	/^struct uv_msg_s {$/;"	s
uv_msg_send	uv_msg_framing.c	/^int uv_msg_send(uv_msg_send_t *req, uv_msg_t *socket, void *msg, int size, uv_write_cb write_cb) {$/;"	f
uv_msg_send_s	uv_msg_framing.h	/^struct uv_msg_send_s {$/;"	s
uv_msg_send_t	uv_msg_framing.h	/^typedef struct uv_msg_send_s   uv_msg_send_t;$/;"	t	typeref:struct:uv_msg_send_s
uv_msg_sent	uv_msg_framing.c	/^static void uv_msg_sent(uv_write_t *req, int status) {$/;"	f	file:
uv_msg_t	uv_msg_framing.h	/^typedef struct uv_msg_s        uv_msg_t;$/;"	t	typeref:struct:uv_msg_s
uv_stream_msg_alloc	uv_msg_framing.c	/^void uv_stream_msg_alloc(uv_handle_t *handle, size_t suggested_size, uv_buf_t *stream_buf) {$/;"	f
uv_stream_msg_free_buffer	uv_msg_framing.c	/^void uv_stream_msg_free_buffer(uv_msg_t *uvmsg) {$/;"	f
uv_stream_msg_read	uv_msg_framing.c	/^void uv_stream_msg_read(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf) {$/;"	f
uv_stream_msg_realloc	uv_msg_framing.c	/^int uv_stream_msg_realloc(uv_handle_t *handle, size_t suggested_size) {$/;"	f
wait_reader	test/test.c	/^void wait_reader() {$/;"	f
waiting_reader	test/test.c	/^int waiting_reader;$/;"	v
write_req_t	test/test.c	/^} write_req_t;$/;"	t	typeref:struct:__anon1	file:
