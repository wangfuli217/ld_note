!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
CFLAGS	Makefile	/^CFLAGS := $(warning-flags) $(optim-flags)$/;"	m
HEAP_FOR_EACH	heap.h	69;"	d
HEAP_H	heap.h	18;"	d
HEAP_H	hptest.h	32;"	d
LENGTH	hptest.c	12;"	d	file:
NDEBUG	heap_test.c	19;"	d	file:
NOT_IN_HEAP	hptest.h	34;"	d
User	queue/queue_test.c	/^typedef struct User {$/;"	s	file:
User	queue/queue_test.c	/^} User;$/;"	t	typeref:struct:User	file:
__heap_extract_min	hptest.h	/^static inline struct heap_node* __heap_extract_min(heap_prio_t higher_prio,$/;"	f
__heap_link	hptest.h	/^static inline void __heap_link(struct heap_node* root,$/;"	f
__heap_merge	hptest.h	/^static inline struct heap_node* __heap_merge(struct heap_node* a,$/;"	f
__heap_min	hptest.h	/^static inline void __heap_min(heap_prio_t higher_prio, struct heap* heap,$/;"	f
__heap_reverse	hptest.h	/^static inline struct heap_node* __heap_reverse(struct heap_node* h)$/;"	f
__heap_union	hptest.h	/^static inline void __heap_union(heap_prio_t higher_prio, struct heap* heap,$/;"	f
__uncache_min	hptest.h	/^static inline void __uncache_min(heap_prio_t higher_prio, struct heap* heap)$/;"	f
add_token	hptest.c	/^static void add_token(struct heap* heap, struct token* tok)$/;"	f	file:
add_token_ref	hptest.c	/^static void add_token_ref(struct heap* heap, struct token* tok,$/;"	f	file:
add_tokens	hptest.c	/^static void add_tokens(struct heap* heap, struct token* tok, int len)$/;"	f	file:
age	queue/queue_test.c	/^  int age;$/;"	m	struct:User	file:
allocated	heap.h	/^    size_t allocated;           \/* Max 'n' before 'array' must be enlarged. *\/$/;"	m	struct:heap
array	heap.h	/^    struct heap_node **array;   \/* Data in elements 1...n, element 0 unused. *\/$/;"	m	struct:heap	typeref:struct:heap::heap_node
bad	hptest.c	/^struct token bad[] = {$/;"	v	typeref:struct:token
bin	Makefile	/^bin := $(basename $(sources))$/;"	m
check_heap	heap_test.c	/^check_heap(const struct heap *heap, const uint32_t priorities[], size_t n)$/;"	f	file:
child	hptest.h	/^	struct heap_node* 	child;$/;"	m	struct:heap_node	typeref:struct:heap_node::heap_node
commands	heap_test.c	/^static const struct ovs_cmdl_command commands[] = {$/;"	v	typeref:struct:ovs_cmdl_command	file:
compare_uint32s	heap_test.c	/^compare_uint32s(const void *a_, const void *b_)$/;"	f	file:
degree	hptest.h	/^	unsigned int 		degree;$/;"	m	struct:heap_node
element	heap_test.c	/^struct element {$/;"	s	file:
element_from_heap_node	heap_test.c	/^element_from_heap_node(const struct heap_node *node)$/;"	f	file:
factorial	heap_test.c	/^factorial(int n_items)$/;"	f	file:
float_down	heap.c	/^float_down(struct heap *heap, size_t i)$/;"	f	file:
float_up	heap.c	/^float_up(struct heap *heap, size_t i)$/;"	f	file:
float_up_or_down	heap.c	/^float_up_or_down(struct heap *heap, size_t i)$/;"	f	file:
full_pri	heap_test.c	/^    uint32_t full_pri;$/;"	m	struct:element	file:
head	hptest.h	/^	struct heap_node* 	head;$/;"	m	struct:heap	typeref:struct:heap::heap_node
heap	heap.h	/^struct heap {$/;"	s
heap	hptest.h	/^struct heap {$/;"	s
heap_change	heap.c	/^heap_change(struct heap *heap, struct heap_node *node, uint32_t priority)$/;"	f
heap_clear	heap.c	/^heap_clear(struct heap *heap)$/;"	f
heap_count	heap.h	/^heap_count(const struct heap *heap)$/;"	f
heap_decrease	hptest.h	/^static inline void heap_decrease(heap_prio_t higher_prio, struct heap* heap,$/;"	f
heap_delete	hptest.h	/^static inline void heap_delete(heap_prio_t higher_prio, struct heap* heap,$/;"	f
heap_destroy	heap.c	/^heap_destroy(struct heap *heap)$/;"	f
heap_empty	hptest.h	/^static inline int heap_empty(struct heap* heap)$/;"	f
heap_init	heap.c	/^heap_init(struct heap *heap)$/;"	f
heap_init	hptest.h	/^static inline void heap_init(struct heap* heap)$/;"	f
heap_insert	heap.c	/^heap_insert(struct heap *heap, struct heap_node *node, uint32_t priority)$/;"	f
heap_insert	hptest.h	/^static inline void heap_insert(heap_prio_t higher_prio, struct heap* heap,$/;"	f
heap_is_empty	heap.h	/^heap_is_empty(const struct heap *heap)$/;"	f
heap_is_leaf__	heap.h	/^heap_is_leaf__(const struct heap *heap, size_t idx)$/;"	f
heap_left__	heap.h	/^heap_left__(size_t idx)$/;"	f
heap_max	heap.h	/^heap_max(const struct heap *heap)$/;"	f
heap_node	heap.h	/^struct heap_node {$/;"	s
heap_node	heap_test.c	/^    struct heap_node heap_node;$/;"	m	struct:element	typeref:struct:element::heap_node	file:
heap_node	hptest.h	/^struct heap_node {$/;"	s
heap_node_in_heap	hptest.h	/^static inline int heap_node_in_heap(struct heap_node* h)$/;"	f
heap_node_init	hptest.h	/^static inline void heap_node_init(struct heap_node* h, void* value)$/;"	f
heap_node_init_ref	hptest.h	/^static inline void heap_node_init_ref(struct heap_node** _h, void* value)$/;"	f
heap_node_value	hptest.h	/^static inline void* heap_node_value(struct heap_node* h)$/;"	f
heap_parent__	heap.h	/^heap_parent__(size_t idx)$/;"	f
heap_peek	hptest.h	/^static inline struct heap_node* heap_peek(heap_prio_t higher_prio,$/;"	f
heap_pop	heap.h	/^heap_pop(struct heap *heap)$/;"	f
heap_prio_t	hptest.h	/^typedef int (*heap_prio_t)(struct heap_node* a, struct heap_node* b);$/;"	t
heap_raw_change	heap.h	/^heap_raw_change(struct heap_node *node, uint32_t priority)$/;"	f
heap_raw_insert	heap.c	/^heap_raw_insert(struct heap *heap, struct heap_node *node, uint32_t priority)$/;"	f
heap_raw_remove	heap.c	/^heap_raw_remove(struct heap *heap, struct heap_node *node)$/;"	f
heap_rebuild	heap.c	/^heap_rebuild(struct heap *heap)$/;"	f
heap_remove	heap.c	/^heap_remove(struct heap *heap, struct heap_node *node)$/;"	f
heap_right__	heap.h	/^heap_right__(size_t idx)$/;"	f
heap_swap	heap.c	/^heap_swap(struct heap *a, struct heap *b)$/;"	f
heap_take	hptest.h	/^static inline struct heap_node* heap_take(heap_prio_t higher_prio,$/;"	f
heap_union	hptest.h	/^static inline void heap_union(heap_prio_t higher_prio,$/;"	f
idx	heap.h	/^    size_t idx;$/;"	m	struct:heap_node
layout	hptest.c	/^struct token layout[] = {$/;"	v	typeref:struct:token
line	hptest.c	35;"	d	file:
main	hptest.c	/^int main(int argc __attribute__((unused)), char**  argv __attribute__((unused)))$/;"	f
main	queue/queue_test.c	/^int main() {$/;"	f
min	hptest.h	/^	struct heap_node*	min;$/;"	m	struct:heap	typeref:struct:heap::heap_node
n	heap.h	/^    size_t n;                   \/* Number of nodes currently in the heap. *\/$/;"	m	struct:heap
name	queue/queue_test.c	/^  char* name;$/;"	m	struct:User	file:
next	hptest.h	/^	struct heap_node* 	next;$/;"	m	struct:heap_node	typeref:struct:heap_node::heap_node
next_permutation	heap_test.c	/^next_permutation(uint32_t *a, int n)$/;"	f	file:
node	queue/queue_test.c	/^  QUEUE node;$/;"	m	struct:User	file:
optim-flags	Makefile	/^optim-flags := -O0 -g3$/;"	m
parent	hptest.h	/^	struct heap_node* 	parent;$/;"	m	struct:heap_node	typeref:struct:heap_node::heap_node
print_heap	heap_test.c	/^print_heap(const char *name, struct heap *heap)$/;"	f	file:
prio	hptest.c	/^	int prio;$/;"	m	struct:token	file:
priority	heap.h	/^    uint32_t priority;$/;"	m	struct:heap_node
put_node	heap.c	/^put_node(struct heap *heap, struct heap_node *node, size_t i)$/;"	f	file:
ref	hptest.h	/^	struct heap_node**	ref;$/;"	m	struct:heap_node	typeref:struct:heap_node::heap_node
reverse	heap_test.c	/^reverse(uint32_t *a, int n)$/;"	f	file:
shuffle	heap_test.c	/^shuffle(uint32_t *p, size_t n)$/;"	f	file:
sources	Makefile	/^sources := $(wildcard *.c)$/;"	m
str	hptest.c	/^	const char* str;$/;"	m	struct:token	file:
swap	heap_test.c	/^swap(uint32_t *a, uint32_t *b)$/;"	f	file:
swap_nodes	heap.c	/^swap_nodes(struct heap *heap, size_t i, size_t j)$/;"	f	file:
test_heap_insert_delete_every_order	heap_test.c	/^test_heap_insert_delete_every_order(struct ovs_cmdl_context *ctx OVS_UNUSED)$/;"	f	file:
test_heap_insert_delete_reverse_order	heap_test.c	/^test_heap_insert_delete_reverse_order(struct ovs_cmdl_context *ctx OVS_UNUSED)$/;"	f	file:
test_heap_insert_delete_same_order	heap_test.c	/^test_heap_insert_delete_same_order(struct ovs_cmdl_context *ctx OVS_UNUSED)$/;"	f	file:
test_heap_insert_delete_same_order_with_dups	heap_test.c	/^test_heap_insert_delete_same_order_with_dups(struct ovs_cmdl_context *ctx OVS_UNUSED)$/;"	f	file:
test_heap_main	heap_test.c	/^test_heap_main(int argc, char *argv[])$/;"	f	file:
test_heap_raw_delete	heap_test.c	/^test_heap_raw_delete(struct ovs_cmdl_context *ctx OVS_UNUSED)$/;"	f	file:
test_heap_raw_insert	heap_test.c	/^test_heap_raw_insert(struct ovs_cmdl_context *ctx OVS_UNUSED)$/;"	f	file:
test_insert_delete__	heap_test.c	/^test_insert_delete__(struct element *elements,$/;"	f	file:
test_insert_delete_raw__	heap_test.c	/^test_insert_delete_raw__(struct element *elements,$/;"	f	file:
title	hptest.c	/^struct token title[] = {$/;"	v	typeref:struct:token
token	hptest.c	/^struct token {$/;"	s	file:
token_cmp	hptest.c	/^static int token_cmp(struct heap_node* _a, struct heap_node* _b)$/;"	f	file:
tokens1	hptest.c	/^struct token tokens1[] = {$/;"	v	typeref:struct:token
tokens2	hptest.c	/^struct token tokens2[] = {$/;"	v	typeref:struct:token
value	hptest.h	/^	void*			value;$/;"	m	struct:heap_node
warning-flags	Makefile	/^warning-flags := \\$/;"	m
