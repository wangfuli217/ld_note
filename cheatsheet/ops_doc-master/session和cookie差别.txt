-----------------  定义 -----------------
什么是 Cookie 和 Session ?
    HTTP Cookie(也叫 Web Cookie或浏览器 Cookie)是服务器发送到用户浏览器并保存
在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器
上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 
使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。
Cookie 主要用于以下三个方面：
    会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)
    个性化设置(如用户自定义设置、主题等)
    浏览器行为跟踪(如跟踪分析用户行为等)

什么是 Session
    Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需
的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象
中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 
超时失效时会话结束。

Cookie 和 Session 有什么不同？
    作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。
    存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况
下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
    有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 
一般失效时间较短，客户端关闭或者 Session 超时都会失效。
    隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登
录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie
要好一些。
    存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于Cookie。

-----------------  Cookie 和 Session 关联 -----------------
为什么需要 Cookie 和 Session，他们有什么关联？
说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的
(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时
候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那
这套机制的实现就需要 Cookie 和 Session 的配合。
那么 Cookie 和 Session 是如何配合的呢？我画了一张图大家可以先了解下。


浏览器                              服务器
   |     -     第一次请求            ->|  创建Session
   |     <- 返回Session ID           - |
   |                                   |
   |     - 第二次请求，带Cookie信息 -> | 根据SessionID判断属于哪个用户，执行操作
                                       |

    用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session，
请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器
返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 
属于哪个域名。
    当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如
果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根
据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，
如果找到 Session 证明用户已经登录可执行后面操作。
    根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统
也是根据此原理来验证用户登录状态。

    如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制
就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的
一份客户档案，客户来访的时候只需要查询客户档案表就可以了。Session生成后，只要用户
继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，
服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。
如果超过了超时时间没访问过服务器，Session就自动失效了。

-----------------  Cookie  -----------------
    既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了Cookie
如何保障整个机制的正常运转?
第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可
以在请求的地址后面拼接 xxx?SessionID=123456...。
第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用
于 Web 端做用户状态管理。
Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token
机制和 Cookie 和 Session 的使用机制比较类似。
当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回
给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。

-----------------  分布式 Session  -----------------
如何考虑分布式 Session 问题？
    在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户
请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题?
分布式 Session 一般会有以下几种解决方案：
    Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，
这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分
发到服务器 B 的现象。
    Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 
Session 的所有内容序列化，然后广播给所有其它节点。
    共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管
理，保障分发到每一个服务器的响应结果都一致。
    
    
-----------------  Token  -----------------
    HTTP请求都是以无状态的形式对接。即HTTP服务器不知道本次请求和上一次请求是否有关联。
所以就有了Session的引入，即服务端和客户端都保存一段文本，客户端每次发起请求都带着，
这样服务器就知道客户端是否发起过请求。
    这样，就导致客户端频繁向服务端发出请求数据，服务端频繁的去数据库查询用户名和密码
并进行对比，判断用户名和密码正确与否。而Session的存储是需要空间的，频繁的查询数据库
给服务器造成很大的压力。
    在这种情况下，Token应用而生。
    Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当客户端第一次访问
服务端，服务端会根据传过来的唯一标识userId，运用一些算法，并加上密钥，生成一个Token，
然后通过BASE64编码一下之后将这个Token返回给客户端，客户端将Token保存起来(可以通过
数据库或文件形式保存本地)。下次请求时，客户端只需要带上Token，服务器收到请求后，
会用相同的算法和密钥去验证Token。
    最简单的Token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，
由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接
Token请求服务器)。
    使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：
  客户端使用用户名跟密码请求登录
  服务端收到请求，去验证用户名与密码
  验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
  客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者数据库里
  客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
  服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
    APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，
以某种方式比如随机生成32位的字符串作为Token，存储到服务器中，并返回Token到APP，
以后APP请求时，凡是需要验证的地方都要带上该Token，然后服务器端验证Token，成功返回
所需要的结果，失败返回错误信息，让他重新登录。对于同一个APP同一个手机当前只有一个Token；
手机APP会存储一个当前有效的Token。其中服务器上Token设置一个有效期，每次APP请求的时候都
验证Token和有效期。
    
-----------------  跨域请求  -----------------
如何解决跨域请求？Jsonp 跨域的原理是什么？
    说起跨域请求，必须要了解浏览器的同源策略，同源策略/SOP（Same origin policy）
是一种约定，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功
能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指"协议+域
名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。
    解决跨域请求的常用方法是
        通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。
        通过 Jsonp 跨域
        其它跨域解决方案
    重点谈一下 Jsonp 跨域原理。浏览器的同源策略把跨域请求都禁止了，但是页面中的 
<script><img><iframe>标签是例外，不受同源策略限制。Jsonp 就是利用 <script> 标签
跨域特性进行跨域数据访问。
    JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一
段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参
数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已
经成功传输到客户端了。
    JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求。
    以上就是有关 Cookie 和 Session 常见的面试点，不知道有多少同学可以在面试中准
确回答所有问题。