内存管理
	进程中的内存区域划分
		代码区 只读常量区 全局区 BSS段 堆 栈
	内存地址从小到大分别是:代码区 只读常量区 全局区 BSS段 堆区 栈区  环境变量及命令行参数,其中堆区和栈区没有明确的分割线，可以适当地调整

字符串存储形式之间的比较
	对于一个存储常量字符串的字符指针和字符数组来说，字符指针可以改变指向，不可以改变指向的内容，而字符数组可以改变指向的内容，不可以改变指向
	对于一个存储常量字符串的动态内存空间来说，其中指向该内存空间的指针，既可以改变指向，又可以改变内容

虚拟内存管理技术
	Unix/Linux系统中的内存都是虚拟内存管理技术来进行管理的，即:每个进程都有0~4G的内存地址(虚拟的，并不是真实存在的),由操作系统负责把内存地址和真实的物理内存映射起来，因此，不同进程的内存地址看起来是一样的，但是所对应的物理内存是不一样的
	其中0~4G的虚拟地址空间分为:用户空间 和 内核空间；用户空间是指0~3G的虚拟地址空间，而内核空间指3G～4G的虚拟地址空间；用户程序运行在用户空间，内核空间只有系统内核才能访问，用户程序不能直接访问内核空间，不过内核提供了一些系统函数负责从用户空间切换到内核空间
	内存地址的基本单位是字节，内存映射的基本单位是内存页，目前主流的操作系统中一个内存页是4kb(4096字节)

段错误的由来
	scanf函数 缺少&
		scanf("%d",num);
	空指针/野指针
		int *pi=NULL;  空指针
		int *pi		;  野指针
		scanf("%d",pi);   极可能引发段错误
	试图使用一个没有经过映射的虚拟地址可能引发段错误

使用malloc申请动态内存的特性	
	使用malloc内存的注意事项
			使用malloc申请动态内存时，可能还需要额外的12个字节来存储一些用于管理动态内存的信息，比如内存的大小等等
			malloc函数底层采用链表的形式去处理多个内存块，也就是需要保存有关下一个/上一个内存块的信息
			使用malloc申请的动态内存时，千万不要越界访问，因为极有可能破坏管理信息，从而引发段错误
	使用malloc申请内存的一般映射规则
		一般来说，使用malloc申请比较小的动态内存时，操作系统会一次性分配33个内存页，从而提高效率
		#include<unistd.h>
		getpid()-获取当前进程的进程号
		cat /proc/进程号/maps -查看指定进程的内存分配情况
	一般来说，使用malloc申请比较大的内存时，系统会默认分配34个内存而页，当申请的内存真如过34个内存页时，则系统会再次分配33个内存页（也就是按照33个内存页的整数倍进行分配）
	使用free释放动态内存时，进程还保留33个内存页备用，直到进程结束，主要是为了提高效率

内存处理的相关函数
	getpagesize函数
		函数功能
			主要用于获取当前系统中一个内存页的大小，一般为4KB
	sbrk函数
		#include<unistd.h>
		void *sbrk(intptr_t increment);
		函数功能
			主要用于按照参数指定的大小调整内存块的大小，如果参数大于0表示申请内存，如果参数等于0表示获取内存块的当前末尾位置，如果参数小于0表示释放内存，成功返回释放之前的内存块地址，失败返回-1
		sbrk操作内存的一般规则
		申请比较小的内存时，一般会默认分配1个内存页时，申请的内存超过1个内存页时，会再次分配1个内存页，释放内存时，释放完毕后剩余的内存如果在1个内存页内则一次性释放一个内存页
		brk函数
		int brk(void *addr);
		函数功能
			表示操作内存的末尾地址到参数指定的位置，如果参数指定的位置大于当前的末尾位置，则申请内存，如果参数指定的位置小于当前的末尾位置，则释放内存
		注意
			使用sbrk函数申请内存比较方便，释放内存不太方便，使用brk函数释放内存比较方便，申请有内存不太方便，所以一般使用sbrk函数和brk函数搭配使用，sbrk函数专门申请，brk函数专门释放


作业
	使用sbrk函数申请内存，使用brk函数释放内存，首先申请一个int类型的内存空间，存放整数100，再分配一个double类型的内存空间，存放数据3.14；再申请一个长度为10的字符串空间，存放"hello",打印上面内存中的三个数据，最后释放所有内存空间

明日预报
	内存管理
	文件操作
