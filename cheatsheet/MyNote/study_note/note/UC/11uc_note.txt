采用消息队列实现进程间的通信(重点)
	概念
		使用不同的进程将发送的数据打包成具体格式的消息,然后将消息放入到消息队列中,使用其他进程从消息队列中取出消息,从而实现进程间的通信

使用消息队列通信的流程
	1.获取key值,使用ftok函数
	2.创建/获取消息队列,使用msgget函数
	3.发送消息/接收消息,使用msgsnd和msgrcv函数
	4.如果不再使用消息队列,使用msgctl函数删除消息队列

函数的解析
	ftok函数
	   #include <sys/types.h>
       #include <sys/ipc.h>
       key_t ftok(const char *pathname, int proj_id);
	　　	第一个参数:字符串的路径,要求存在并且可以访问
			第二个参数:项目ID,要求非0
			函数功能:根据路径和项目ID,要生成一个key_t类型的key值,生成的key提供给后续函数使用
			注意:
				使用相同的路径和相同的项目ID会生成相同的KEY值
	msgget函数
		#include <sys/types.h>
	    #include <sys/ipc.h>
        #include <sys/msg.h>
	    int msgget(key_t key, int msgflg);
			第一个参数:key值,ftok函数的返回值
			第二个参数:标志
				IPC_CREAT - 创建
				IPC_EXCL - 与IPC_CREAT搭配使用,如果存在则创建失败
				0 - 获取已存在的IPC结构(消息队列)
			函数功能:主要用于创建/获取消息队列,返回队列的ID
			注意:
				如果需要创建一个新的消息队列时,那么需要在参数msgflg中指定新队列的权限,如:0644
	msgsnd函数
	    #include <sys/types.h>
		#include <sys/ipc.h>
	    #include <sys/msg.h>
        int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
			第一个参数:消息队列的ID,msgget函数的返回值
			第二个参数:消息的首地址(消息从哪里来)
						struct msgbuf
						{
							long mtype; 消息的类型,必须大于0
							char mtext[1];消息的数据内容,可以是其他结构
						}
			第三个参数:消息的大小,主要指消息内容的大小,不包括消息的类型
			第四个参数:发送消息的标志,直接给0即可
			函数功能:主要用于将指定的消息发送到指定的消息队列中
	msgrcv函数
		ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
			第一个参数:消息队列的ID,msgget函数的返回值
			第二个参数:消息的首地址(将接收到的消息存到哪里去)
			第三个参数:消息的大小
			第四个参数:消息的类型
				0 - 读取消息队列中的第一条消息
				>0 - 读取消息队列中第一个类型为msgtyp的消息
				<0 - 读取消息队列中消息类型<=msgtyp绝对值的类型最小的消息
			第五个参数:消息的标志,给0即可
			函数功能:从指定的消息队列中接收消息,成功返回实际读取到的数据大小,失败返回-1

	msgctl函数 
		  #include <sys/types.h>
		  #include <sys/ipc.h>
	      #include <sys/msg.h>
	      int msgctl(int msqid, int cmd, struct msqid_ds *buf);
		  第一个参数:消息队列的ID,msgget函数的返回值
		  第二个参数:具体的命令
				IPC_RMID - 删除消息队列,此时第三个参数给NULL即可
		  第三个参数:结构体指针
		  函数功能:表示对指定的消息队列执行指定的操作

相关命令
	ipcs -q		查看当前系统中存在的消息队列
	ipcrm -q ID	删除指定的消息队列

综合小项目
	项目名称
		银行账户管理系统(模拟ATM的功能)
	项目功能
		开启  销户	存款 取款  查询  转账  
	项目架构
		采用C/S架构(Client/Server 客户端/服务器)进行设计
		
		客户端:
			首先提供一个界面,供用户选择具体的业务,将用户的选择发送给服务器进行处理,等待处理完毕之后,将处理结果显示给用户
		服务器:
			接收客户端发来的具体业务,通过访问数据库来实现真正的业务处理,然后将处理结果发送给客户端
	项目的分析
		客户端和服务器之间的通信问题如何解决?
			采用两个消息队列实现通信:
				消息队列1:客户端 =>服务器
				消息队列2:服务器 =>客户端
		如何区分不同的业务 
			采用不同的消息类型来代表不同的业务
				8种消息类型:6个业务类型+成功+失败
		账户和消息的数据类型
			账户信息:账号,账户名称,账户密码,余额
			消息的数据类型:消息的类型 + 账户消息
		客户端的功能分析
			1.提供界面,使用printf函数打印
			2.针对用户的选择去实现不同的功能
			  使用scanf函数和switch-cast多分支结构
			3.要求用户输入用户名,密码以及余额,账号由系统自动生成
			4.增加消息类型,打包成一个完整的消息,发送给消息队列一
			5.等待服务器的处理结果,并且将结果打印显示给客户
		服务器的功能分析
			1.创建和删除消息队列
			2.从消息队列1中接收消息,然后补充完整帐户的信息,也就是自动生成账号
			3.访问数据库保存账户消息,实现开户功能,采用文件处理,每个账户对应一个文件,账号作为文件名
			4.更改消息的类型,将消息发送到客户端,也就是消息队列二

项目的要求
	1.要求编程实现开户的功能
	2.实现所有的功能
	3.采用多文件的方式进行编写,支持Makefile文件

项目提示
	vi bank.h 实现结构体的类型定义以及各种宏定义
	vi client.c	实现客户端界面的打印,以及用户的输入等
	vi server.c	实现消息队列的创建和删除等等
	vi dao.c	实现各种文件操作的功能
	...

			
