私有继承和保护继承
	私有继承用于将基类中的公有成员变为子类的私有成员,防止从子类的外部访问基类的公有部分
	保护继承用于将基类中的公有成员变为子类的保护成员,只防止与子类无关的外部类型访问基类的公有部分,子类的子类不受限制
	私有继承和保护继承不具有截然性,不允许隐式低向上造型

多继承/钻石继承和虚继承
	多继承
		名字冲突:作用域限定,通过using声明构成重载
		类型转换:隐式的向上造型和静态的向下造型,编译器都会计算指针的偏移量,保证指针或引用的类型与其实际指向的对象的类型严格一致
	钻石继承:公共基类---------汇聚子类
		数据不一致:在汇聚子类对象中的多个中间基类子对象中各存在一份公共基类子对象的实例,沿着不同的继承路径,访问该实例会得到不同的数据拷贝
	虚继承:公共基类子对象在汇聚子类对象中只存在一份例,且为所有中间基类子对象所共享
		继承方式:virtual
			汇聚子类的构造函数(包括拷贝构造函数)需要显示指明公共基类子对象的初始化方式,否则该子对象将按照缺少方式初始化
		内存模型:虚指针->虚基类表->虚基类子对象相对于中间基类子对象的偏移量


虚函数和多态
	基本概念
		如果将基类中的某个成员函数声明为虚函数,那么其子类中与该函数具有相同函数原型的成员函数就也是虚函数,并且与基类中的版本构成覆盖关系.这时,通过一个指向子类对象的基类指针,或者一个引用子类对象的基类引用,调用虚函数,实际被调用的是子类中的覆盖版本,而非基类中的原始版本,这种语法现象谓之多态
	
	覆盖的条件
		成员函数+虚函数+签名相同
		返回基本类型或者对象:必须相同
		返回类类型指针或者引用:允许协变
	多态的条件
		虚函数和覆盖+指针(包括this)/引用
		在构造和析构函数中调用自己的虚函数没有多态性

纯虚函数,抽象类,纯抽象类
	纯虚函数:...=0;
	抽象类:包含纯虚函数的类,不能实例化对象
	纯抽象类:全部成员函数都是(构造和析构除外)都是纯虚函数

虚函数表和动态绑定
	运行时类型信息(RTTI)
		1.dynamic_cast
		2.typeid

虚析构函数
	当delete一个指向子类对象的基类指针时,实际被调用的是子类的析构函数,而子类的析构函数在完成子类资源的释放以后,会自动调用基类的析构函数,从而保证所有的资源都能得到正确的释放,不会发生内存泄漏
