构造函数和初始化表
	构造函数可以重载
		通过构造参数的差别区分不同的对象初始化方式
	重载解析规则
		类型匹配,数据安全,最小工作量
	特殊的构造函数
		缺省构造函数(无参构造函数)
			表示对象的缺省状态
			可以不带参数,也可以带有缺省参数
			编译器在示定义任何构造函数时会提供缺省构造函数
		类型转换构造函数(单参构造)
			用一种类型的对象作为源对象构造出另一种类型的对象
			这种类型转换缺省按照隐式方式进行,如需要显式加上explicit关键字
		拷贝构造函数
			用一种类型的对象作为源对象构造出同类型的另一个对象--对象克隆
			编译器在未定义拷贝构造函数时会提供缺省拷贝构造函数
			调用拷贝构造函数的时机
				直接构造对象副本
					A a1;
					A a2(a1);
					A a3=a2;
				以值的形式传递参数
				从函数中返回对象(可能会被编译器优化掉)
		初始化表
			语法形式
			必须使用初始化表的场合
				必须以有参方式初始化成员子对象
				包含常量或者引用类型的成员变量
			对于内置类型,如int,float这种类型,在初始化表和构造函数中赋值没有多大区别,但若是类类型,最好使用初始化表,因为这样少调用一次默认构造函数
			
			从概念上来讲，构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段
			初始化阶段
				所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中
			计算阶段
				一般用于执行构造函数体内的赋值操作。
			成员变量的初始化顺序由其在类中被声明的顺序,而与其在初始化表中出现的顺序无关--------尽量避免成员变量在初始化过程中的相互依赖,如果避免不了,用注释说明

this指针与常函数
	this指针
		本质:类的非静态成员函数(包括构造和析构函数)包含一个隐藏的形式参数,该参数指向调用该成员函数(或者正在被构造和析构)的对象,该指针名为this,在成员函数中对成员变量和其它成员函数的访问实际上都是通过this指针实现的
	使用
		区分成员变量和同名的局部或全局变量
		从成员函数内部以参数形式向外传递调用对象自身
		从成员函数内部向调用者返回调用对象的自引用或自拷贝

常函数
	形式:...(形参表) const {...}
	const关键字修饰该成员函数的this指针参数
	特性
		在常函数中不能修改成员变量,除非该成员变量带有mutable关键字
		在常函数中只能调用常函数

同一个类中,签名相同的成员函数常版本和非常版本构成重载关系,常对象(也包括常引用和常指针)选择常版本,非常对象选择非常版本,但是如果没有非常版本,非常对象也可以选择常版本
	
析构函数
	原型
		~类名(void){...},没有参数,不能重载
	调用
		栈:右"}"调用
		堆:delete或者delete[]调用
	功能
		释放资源
		善后处理
缺省析构函数
对象销毁过程
	子类析构代码->析构成员子对象->析构基类子对象->释放内存
