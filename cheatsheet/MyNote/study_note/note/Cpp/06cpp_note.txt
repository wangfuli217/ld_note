class A {
public:
    void foo (void) const { this->x=10; }
// void foo (A const* this) { ... }
    void bar (void) { ... }
// void bar (A* this) { ... }
    int x;
};
A const a (...);
a.foo ();
A::foo (&a); // &a - A const*
a.bar ();
A::bar (&a); // &a -> A const* -X> A*， 报错
---------------------------------
A a (...);
a.foo ();
A::foo (&a); // &a - A* -隐式-> A const*
a.bar ();
A::bar (&a); // &a - A*，完美匹配
---------------------------------
void foo (Point3D p3) { ... }
void bar (Point3D const& p3) { ... }
Point2D p2 (...);
foo (p2);
bar (p2); // p2->Point3D匿名
---------------------------------
void foo (int x) { ... }
foo (3.14);
void bar (int const& x) { ... }
bar (3.14); // 
----------------------------------
int foo (void) {
   double x = 1.23;
   return x;
}
int a, b, c;
a = b + foo ();
              ------------
              int <匿名>
double d = ...;
int i = d;
-----------------------
int i;
int j = i;
int& r = i;
-----------------------
int i;
int foo (void) {
   return i;
}
int& bar (void) {
   return i;
}
cout << foo () << endl;
               ------
               int <匿名>
cout << bar () << endl;
               ------
               int& <匿名>
char const* p = "abc";
*p = 'A'; // 编译错误
char* p = "abc";
*p = 'A'; // 运行段错误
char p[] = "abc";
*p = 'A';
char const p[] = "abc";
*p = 'A'; // 编译错误
string str;
str = "hello";
              -类型转换构造-> string对象
^                                              |
 +--------拷贝赋值------------+
string str="hello world";
string str ("hello world");
clsss string {
public:
     string (char const* p) { ... }
};
int i;
i = i;
class Student {
//string m_name;
//char m_name[256];
   char* m_name; // 必须考虑深拷贝
   int m_age;
};
一、拷贝构造和拷贝赋值
1.浅拷贝和深拷贝
1)浅拷贝：针对类的指针型成员变量，在获得对象副本时只复制指针本身，而没有复制指针的目标。导致在对象被析构时引发double free异常，同时导致多个对象因引用相同的资源而发生耦合。
2)深拷贝：不复制指针，而是令目标对象拥有独立的资源，该资源的内容从源对象中复制。
3.缺省的拷贝构造函数和拷贝赋值运算符函数
1)如果没有为一个类显式定义拷贝构造函数和拷贝赋值运算符函数，编译器会为其提供缺省版本，但是缺省版本只做浅拷贝。
2)如果一个类拥有指针形式的成员变量，并用该指针维护动态分配的内存资源，那么就应该为该类定义支持深拷贝的拷贝构造函数和拷贝赋值运算符函数。
4.实现深拷贝
1)拷贝构造：T::T (T const& that) {}
分配资源，复制内容
2)拷贝赋值：T& operator= (T const& rhs) {}
防止自赋值、分配新资源、释放旧资源、复制新内容、返回自引用
5.建议
1)谨慎使用指针型成员；
2)尽量避免通过对象传参和返回；
3)实在不行，将拷贝构造和拷贝赋值私有化，防止无用；
4)拷贝构造和拷贝赋值的逻辑应该一致。
class A {
   A m_a;
};
sizeof (A) 
class A {
   B m_b;
};
class B {
   A m_a;
};
A a;
二、静态成员和单例模式
1.静态成员
1)静态成员是属于类的，而不属于对象。
2)静态成员变量：不包含在对象中，也不参与类型字节数的计算，具有进程级生命期，保存进程的静态存储区(数据区/BSS区)，必须在类的外部定义和初始化。
3)静态成员函数：没有this指针，不能有常属性，只能访问静态成员变量或调用静态成员函数。
4)无论是静态成员变量，还是静态成员函数，既可以通过对象访问，也可以通过类访问（类名::静态成员名），前提是满足访问控制属性的约束。
2.单例模式
1)设计一种类型，该类型的对象在进程中只允许存在一份实例。
2)禁止外部创建、内部创建唯一实例、公有访问接口。
3)构造函数私有化、静态成员变量、用于获取对象引用的成员函数。
4)饿汉方式：启动创建、线程安全、资源效率不高。
5)懒汉方式：用时创建、线程风险、资源效率较高。
三、成员指针
1.成员变量指针
1)定义和初始化
类型 类名::*成员指针 = &类名::成员变量;
int A::*p1 = &A::m_d;
p1中存放的是m_d在A中偏移地址。
2)解引用
对象.*成员指针
a.*p1
对象指针->*成员指针
pa->*p1
2.成员函数指针
1)定义和初始化
返回类型 (类名::*成员函数指针) (形参表) =
    &类名::成员函数;
int (A::*pfn) (int) = &A::foo;
2)调用
(对象.*成员函数指针) (实参表)
(a.*pfn) (5)
(对象指针->*成员函数指针) (实参表)
(pa->*pfn) (5)
3.静态成员的指针与普通指针一样。
4.对所有的成员指针的初始化或赋值，受访问控制属性的限制。