异常
	问题
		返回值:层层判断,流程复杂,局部对象能被构构
		远程中转:(setjmp/longjmp):一步到位,流程简单,局部对象可能造成内存泄漏
		异常:一步到们,流程简单,局部对象都会在函数堆栈的辗转开解过程中被析构,不会出现内存泄漏

	语法
		throw异常对象
		try{
			可能引发异常语句
		}
		catch(异常类型1& ex){
			异常处理
		}
		catch(...)
		{
		}
	流程
		异常说明
			返回类型 函数名(形参表)[const] throw(异常类型1,异常类型2...);
				如果函数抛出了异常说明以外的异常,该异常无法被此函数的调用者捕获
				throw()表示不抛出任何异常,而没有异常说明则表示可以抛出任何异常
				如果函数的声明和定义分开写,那么声明和定义中的异常说明必须一致
				如果希望产生有效的覆盖,子类中的函数不能比基类中的函数说明抛出更多的异常
			构造函数抛出异常
				构造函数可以抛出异常,而且构造函数也只能通过异常来通知调用者构造过程中的意外
				凡是在构造过程中抛出异常的对象,都是不完整对象,这样的对象其析构函数永远不会被调用,因此有必要在构造函数抛出异常之前,手动释放动态分配的资源
			析构函数中不要抛出异常,而且还要防止所调用的函数向外抛出异常
