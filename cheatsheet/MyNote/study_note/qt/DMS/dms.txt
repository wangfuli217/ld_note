项目:DMS数据采集系统
	项目背景介绍
	项目开发流程
		需求分析
			按照软件工程的要求,复核用户的需求,得到用户的认可
			面向业务人员,用户化的需求文档
			面向设计人员,专业化的需求文档
			用例,事件流,异常流,前置条件,后置条件
			演示程序(demo)
		概要设计
			针对需求拟定系统框架
			面向过程的主框架,关注需求中的事件流
			面向对象的主框架,关注对象在事件中所扮演的角色
			读取->文件,形成->记录
			事件  数据  事件  数据
			概要设计阶段最主要的任务:找对象
			理论:根据需求事件流中的名词和动词找对象,名词通常表示了对象的属性,而对词则体现了对象的行为
			实践:以事件为核心,事件由对象触发,责任分配,关注行为---接口驱动
				 以数据为核心,关注属性---模型驱动
				 以异常为核心,关注各种意外情况---异常驱动
			综合使用以上三种设计模型,在不同的阶段,或者不同的场合下选择最合适的驱动模型
			输出:<<概要设计说明书>>,<<研发计划>>

		详细设计
			根据对象的行为和属性,设计类图
			对类分配责任,设计类的主要成员函数
			通过时序验证成员函数支持事件流的完整性
			设计类的成员变量:前置条件,后置条件,中间变量
			细化类成员的类型,参数,返回值,函数名,访控属性,常属性
			设计成员函数的内部流程------活动图或状态图
			根据异常流设计异常处理系统
			其它细节:构造函数,析构函数,支持深拷贝的拷贝构造和拷贝赋值,运算符重载,等待
			通过继承和多态引入抽象,降低耦合度,提高代码的弹性
			套用现成的设计模式
			输出:<<详细设计文档>>
		编写代码,内部测试
		测试验证,修改错误
		产品发布,工程实施

		项目总结
			瀑布+迭代
			敏捷开发,极限编程


数据采集客户机
	用例描述
		数据采集客户机备份并读取登录日志文件,形成匹配日志记录,通过网络发送给数据采集服务器
	参与者
		系统管理员,数据采集客户机,日志读取器,日志发送器,绘制用例图
	基本事件流
		备份系统日志(/var/adm/wtmpx),产生备份文件,以系统日期和时间为后缀,如:wtmpx.20150623161523
		读取备份文件,产生登入登出日志记录:登录名,登录IP,登录进程PID,登入或登出的时间
		根据登录名,登录IP和登录进程PID是否一致来匹配登入和登出记录,除了包含以上三个信息外,还需要包含登入,登出和在线的时间段
		根据服务器的IP地址和端口号,建立TCP连接
		将第三步所形成的匹配日志记录发送到服务器
	异常事件流
		备份系统日志失败,终止采集
		读取备份文件失败,终止采集
		匹配登入登出日志记录时,发现有以下二种情况无法成功匹配
		A 有登入无登出,将匹配失败的登入记录保存为登入文件,以备下次匹配
		B 有登出无登入,系统上线前,登入记录已丢失,不予处理
		连接失败或者发送过程中失败,将未发出的匹配日志记录保存到失败文件,以备下次重发
	前置条件
		原始日志文件的路径/var/adm/wtmpx
		登入文件路径:<可执行程序所在目录>/logins.dat
		连接或发送失败文件路径:<可执行程序所在目录>/fail.dat
		服务器的ID地址(192.168.0.23)和端口(8888)号
	后置条件
		日志读取器:匹配日志记录集
		日志发送器:匹配日志数据包
	类图
	时序图
	活动图或状态图
	编程实现

数据采集服务器
	用例描述
		数据采集服务器通过网络接收数据采集客户机上传的匹配日志记录,保存到数据库中
	参与者
		系统管理员,数据采集服务器,服务器套接字,客户线程,日志队列,存储线程,数据访问对象,数据库
	绘制用例图
	事件流
		接收匹配日志记录
			建立服务器侦听套接字
			等待并接受客户机的连接请求
			为该客户机创建客户线程,接收其上传的匹配日志记录
			将接收到的匹配日志记录压入日志队列
		保存匹配日志记录
			创建存储线程
			创建数据访问对象,建立与数据库的连接
			监视日志队列,从中弹出匹配日志记录
			将匹配日志记录通过数据访问对象保存到数据库中
			销毁数据访问对象,关闭与数据库的连接

---------------------------------------------------------------------------------
通过条件变量解决生产者-------消费者问题
	生产者:产生数据的线程
	消费者:消耗数据的线程
	通过缓冲区隔离生产者和消费者,与二者直连相比,避免相互等待,提高运行效率
	生产快于消费,缓冲区满,撑死
	消费快于生产,缓冲区空,饿死
	条件变量可以让调用线程在满足特定条件的情况下暂停,直到由于该条件的消失而被唤醒
	1.初始化条件变量
		int pthread_cond_init(pthread_cond_t* cond,const pthread_condattr_t* attr)
		pthread_cond_t cond=PTHREAD_COND_INITIALIZER;
	2.销毁条件变量
		int pthread_destroy(pthread_cond_t* cond);
	3.等待条件变量
		int pthread_cond_wait(pthread_cond_t* cond,pthread_mutex_t* mutex);
	4.唤醒条件变量
		int pthread_signal(pthread_cond_t* cond);
		int pthread_broadcast(pthread_cond_t* cond);
	当使用pthread_broadcase函数唤醒等待条件的线程时需要注意,一个线程被从条件变量中唤醒以后,在其重新获得先前释放的互斥锁之前,其它线程有可能执行锁区间的代码,因此从pthread_cond_wait函数中返回以后有必要对导致该线程睡入条件变量的条件再做一次判断
	if->while
---------------------------------------------------------------------------------
	异常事件流
