可维护	可扩展	可复用	灵活性好

单一职责原则(SRP	Single Responsibility Principle):	就一个类而言,应该仅有一个引起它变化的原因
开放-封闭原则(ocp	The	Open-Closeed Principle):		是说软件实体(类,模块,函数等待)应该可以扩展,但是不可修改
依赖倒转原则:											抽象不应该依赖于细节,细节应该依赖于抽象
														高层模块不应该依赖低层模块,两个都应该依赖抽象
里氏代换原则(LSP):										子类必须能够替换掉它们的父类型
														一个软件实体如果使用的是一个父类的话,那么一定适用于其子类,而且它察觉不出父类对象和子类对象的区别
														也就是说,在软件里,把父类都替换成它的子类,程序的行为没有变化
迪米特法则(LoD):										如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用,如果其中一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用 
合成/聚合复用原则(CARP):								尽量使用合成/聚合,尽量不要使用类继承

委托是一种引用方法的类型,一旦为委托分配了方法,委托将与该方法具有完全相同的行为,委托方法的使用可以像其他任何方法一样,具有参数和返回值,委托可以看作是函数的抽象

1.简单工厂模式(Factory)		如简单计算器实现
	通过输入的参数,工厂实例化出合适的对象,通过多态,返回父类(通常是指针或引用)
2.策略模式(Strategy)		如商场计费系统,打折,返现,正常模式
	定义了算法家庭,分别封装起来,让它们之间可以互相替换,此模式让算法的变化,不会影响到使用算法的客户
	策略模式封装了变化
	和工厂模式的区别:
		工厂模式里用户最终使用的是工厂“生产”出来的类的对象，策略模式里用户最终使用的是“配置”了某一策略的Context对象
		工厂模式是策略模式的一种,只不过工厂模式用来创建对象
3.装饰模式(Decorator)		如给人搭配服饰
	动态地给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成子类更为灵活
	为已有功能动态地添加更多功能的一种方式
4.代理模式(Proxy)			如WebService
	为其他对象提供一种代理以控制对这个对象的访问
5.工厂方法模式(Factory Method)
	定义一个用于创建对象的接口,让子类决定实例化哪一个类,工厂方法使一个类的实例化延迟到其子类
6.原型模式(Prototype)		如c++的浅拷贝和深拷贝
	用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象
7.模板方法模式(TemplateMethod)
	定义一个操作中的算法的骨架,而将一些步骤延迟到子类中.模板方法使用子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
8.外观模式(Facade)
	为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更加容易使用
	对于复杂逻辑,可以将其封装在一个外观类中,调用类只要知道外观类接口即可调用复杂逻辑
9.建造者模式也叫生成器模式(Builder)		如画一个小人,头,手,脚
	将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
	主要用于创建一些复杂的对象,这些对象内部构建间的建造顺序通常是稳定的,但对象内部的构建通常面临着复杂的变化
10.观察者模式也叫发布/订阅(Publish/Subscribe)模式
	定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个主题对象,这个主题对象在状态发生变化时,会通知所有观察者对象,使它们能够自动更新自己
	所做的工作其实就是在解除耦合,让耦合的双方都依赖于抽象,而不是依赖于具体
	可以由委托事件技术来替代,各有优劣
11.抽象工厂模式(Abstract Factory)
	提供一个创建一系统相关或相互依赖对象的接口,而无需指定它们具体的类
12.状态模式(State)
	当一个对象的内存状态改变时允许改变其行为,这个对象看起来像是改变了其类
	主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况,把状态的判断逻辑转移到表示不同状态的一系列类中,可以把复杂的逻辑简化
13.适配器模式(Adapter)
	将一个类的接口转换成客户希望的另外一个接口,Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
14.备忘录模式(Memento)
	在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样以后就可将该对象恢复到原先保存的状态
15.组合模式(Composite)
	将对象组合成树形结构以表示'部分-整体'的层次结构,组合模式使得用户对单个对象和组合对象的使用具有一致性
16.迭代器模式(Iterator)
	提供一种方法顺序访问一个聚合对象中各个元素,而又不暴露该对象的内部表示
17.单例模式(Singleton)
	保证一个类仅有一个实例,并提供一个访问它的全局访问点
18.桥接模式(Bridge)
	将抽象部分与它的实现部分分离,使它们都可以独立地变化,例如手机品牌与手机软件的分离
	实现系统可能有多角度分类,每一种分类都有可能变化,那么就把这种多角度分离出来让它们独立变化,减少它们之间的耦合
19.命令模式(Command)
	将一个请求封装为一个对象,从而使可用不同的请求对客户进行参数化,对请求排除或记录请求日志,以及可撤销的操作
20.职责链模式(Chain of Responsibility)
	使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系,将这个对象连成一个链,并沿着这条链传递该请求,直到有一个对象处理它为止
21.中介者模式(Mediator)
	用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互
22.享元模式(Flyweight)
	运用共享技术有效地支持大量细粒度的对象
23.解释器模式(Interpreter)
	给定一个语言,定义它的语法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子
24.访问者模式(Visitor)
	表示一个作用于某对象结构中的各元素的操作,它使得可以在不改变各元素的类的前提下定义作用于这些元素的操作
	目的是要把处理从数据结构分离出来
