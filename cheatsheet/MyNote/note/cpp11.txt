static_cast <new_type> (expression)  		静态转换,最接近c风格的转换,但是在无关类的指针转换上,有安全性的提升
dynamic_cast <new_type> (expression)  		动态转换,确保指针的转换是合适完整的,有两个重要的约束条件,一是要求new_type为指针或引用,二是下行转换时要求基类是多态的(基类中至少包含一个虚函数),可以识别出不安全的下行转换,但不抛出异常,而是将转换的结果置为NULL,当待转换指针或者目标指针是void *时,总认为是安全的,但类也必须是多态的
reinterpret_cast <new_type> (expression)  	重解释转换,是"最不安全"的,两个没有任何关系的类指针之间都可以转换,要求new_type是指针或引用,可以将一个整数转换成地址(指针),这种转换是底层的,有较强的平台依赖性,可移植性差
const_cast <new_type> (expression)  		将常量转换成非常量,这个转换并不转换常量本身,即expression还是常量,只是它返回的结果是非常量了
rtti(run time type information)				运行时信息,机制是为每个类型产生一个type_info类型的数据,可以使用typeid随时查询一个变量的类型,头文件<typeinfo>,typeid会返回相应的type_info数据,type_info数据的name成员函数可以返回类型的名字,在c++11中,又增加了hash_code这个成员函数,返回该类型唯一的哈希值,以供程序员对变量的类型随时比较
											dynamic_cast也用到了rtti,rtti会带来一些运行时的开销,g++可通过选项-fno-rttion来关闭

虚函数表指针	vfptr		只要函数前有virtual关键字,则其和其子类都含有此指针,多重继承时可能含有多个虚函数指针,多重继承下,子类的虚函数表与第一个父类的虚函数表合并
虚基类表指针	vbptr		只要在继承前加virtual关键字,则子类和子类派生的类都有此指针,虚继承的引入将对象模型变得十分复杂,除了每个基类和公共基类的虚函数表指针(比纯粹的多重继承多了一个虚函数表指针)需要记录外,每个虚拟继承了公共基类的子类还需要记录一个vbtable的虚基类表指针
							虚继承表第一项记录着当前子对象相对与虚基类表指针的偏移,第二项记录公共基类相对于虚基类表指针的偏移,第三项还不知(图上看到填0)
							
为什么条件变量还要使用互斥锁?
	这是为了应对线程1在调用pthread_cond_wait()但线程1还没有进入wait cond的状态的时候,此时线程2调用了 cond_singal 的情况.如果不用mutex锁的话,这个cond_singal就丢失了.加了锁的情况是,线程2必须等到 mutex 被释放（也就是 pthread_cod_wait() 释放锁并进入wait_cond状态 ,此时线程2上锁） 的时候才能调用cond_singal.
							
内存对齐:
	第1个数据存放在offset为0的地方
	以后每个数据成员存放在该成员大小或子成员大小(如数组,结构体)的整数倍开始的地方
	结构体作为成员要从其内部最大元素大小的整数倍开始
	结构体大小必须是内部最大成员大小的整数倍,不是的要补齐
加了#pragma packet(n)
	如果n大于变量本身字节数,那么偏移量用默认的
	如果n小于变量本身字节数,那么偏移量为n的倍数
	对于结构体,如果n大于所有成员变量所占用的字节数,总大小按默认的补齐,否则必须按n的倍数补齐
	
int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；	//在多线程环境中,有些事仅需要执行一次,功能：本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。


1.双尖括号错误-由于c++98/03中采用最长匹配解析规则,编译器会在解析符号时尽可能多地"吸收"符号,这样,在模板解析时,编译器会将原本是"模板的模板"识别为右移,已被修正
	例: vector<list<int>>	veclist;	//c++11中有效,c++98/03中无效
	
2.枚举错误-在c++98/03中,枚举会退化为整型,因此常会与其他的枚举类型混淆,c++11中引入了新的"强类型枚举"
	例:	enum class color {red,blue,green};
		int x=color::red;	//c++98/03中允许,c++11中错误,不存在color->int的转换
		color y=7;			//c++98/03中允许,c++11中错误,不存在int->color conversion的转换
		color z=red;		//c++98/03中允许,c++11中错误,red不在作用域内
		color c=color::red;	//c++98/03中错误,c++11中允许
	
3.预定义宏
	c++11与c99兼容的宏:
		__STDC_HOSTED__				如果编译器的目标系统中包含完整的标准C库,那么这个宏就定义为1,否则为0
		__STDC__					C编译器通常用这个宏的值来表示编译器的实现是否和C标准一致,c++11标准中这个宏是否定义以及定成什么值由编译器决定
		__STDC_VERSION__			C编译器通常用这个宏来表示所支持的C标准的版本,如1999mmL,c++11标准中这个宏是否定义以及定义成什么值由编译器来决定
		__STDC_ISO_10646__			这个宏通常定义成一个yyyymmL格式的整数常量,例如199712L,用来表示C++编译环境符合某个版本的ISO/IEC 10646标准
		__func__					函数名,很多编译器其实早已实现此特性,现在已加入c++11标准,在c++11中,__func__可以使用在结构体或类的初始化列表中,不过将__func__作为函数参数默认值是不允许的,这是因为在函数声明时,__func__尚未定义
			其实编译器做的工作如下
				const char * hello(){return __func__}  ======>  const char *hello(){static const char* __func__="hello";return __func__}
		_Pragma(字符串字面量)		相当于以前的#pragma(),他是一个操作符,和sizeof差不多,例:
			#pragma(once) ==>  相当于头文件中的
				#ifndef THIS_HEADER 
				#define THIS_HEADER
				//一些头文件的定义
				#endif
			现在只要写成_Pragma("once");
		__cplusplus					宏,表明是否在c++环境下,通常是一个long整形值,例:199711L,201103L
		static_assert(bool,"erpr")	静态断言,编译时检查,断言表达式的结果必须是在编译时期可以计算的表达式,即必须是常量表达式,assert只在运行时起作用,#error只在预处理时起作用,在发布正式软件时,可以定义宏NDEBUG来使assert被定义为一个(static_cast<void> (0))

4.异常改变=>表示函数不抛出异常的throw()被新的noexcept异常声明取代,与throw()不同的是,如果noexcept修饰的函数抛出了异常,编译器可以选择直接调用std::terminate()终止函数运行
	例: void excpt_func() noexcept;
		void excpt_func() noexcept (常量表达式);   //常量表达式的结果会被转换成一个bool类型的值,该值如果为true,表示函数不抛出异常,反之,则有可能抛出异常
	noexcept也可以作为一个操作符,例:
		template<class T>
		void func() noexcept(noexcept(T())){}	//func是一个noexcept函数,是否抛出异常由后面表达式决定,第二个noexcept是一个操作符,其参数是一个有可能抛出异常的表达式,返回false,反之返回true

5.快速初始化成员变量
	在C++98中,支持了在类中使用等号"="赋初始值的方式,称之为"就地声明",但是也只支持静态常量的整形和枚举型(g++还能支持double,这是g++的自形扩展)
	在c++11中,支持"="和花括号{}进行就地的非静态成员变量初始化,如struct init{int a=1;double b {1.2};},但其和()并非等价,在类里使用string("hello")还是会导致编译出错,要使用string{"hello"}
	对于非常量的静态成员变量,和c++98保持一致,到头文件以外去定义它
	在c++98中,对非静态成员变量使用sizeof是非法的(对于静态成员或者对象的实例是合法的),c++11中是合法的,如class people{int handle},sizeof(people::handle)在c++11中是合法的,在c++98中可以通过sizeof((people*)0->handle)来获得

6.friend改进
	在c++98中,声明友元类必须friend class 类名,在c++11中可以省去class,即friend 类名,还可以支持friend 类的别名(如typedef定义的别名)
	这点小小的改进可以使得在类模板中使用友元,如
	template <typename> class People{friend T;};
	
7.使用using来定义类型别名,和typedef定义类型的别名一样
	例: using myInt=int;using myVector=vector<int>;
  用using比typedef更灵活,可以模板式地使用using关键字
	例: template<typename T> using MapString=std::map<T,char*>;
  使用using声明来将基类的构造函数(或其他函数)引用到子类,避免透传,c++11标准继承构造函数被设计为跟派生类中的各种默认构造函数一样,是隐式声明的,这意味着如果一个继承构造函数不被相关代码使用,编译器不会为其产生真正的函数代码,更加节省目标代码空间
  有的时候,基类构造函数会有默认值,对于继承构造函数来讲,参数的默认值是不会被继承的,事实上,默认值会导致基类产生多少构造函数的版本
  继承构造函数有时可能会冲突,这通常是由于继承于多个类,构造函数签名又一致时发生,这时可以在子类中显式定义发生冲突的构造函数,阻止隐式生成相应的继承构造函数来解决冲突
  如果基类的构造函数是私有的或者子类是虚继承基类的,那么就不能在子类中声明继承构造函数,而且一旦使用了继承构造函数,那么编译器不会再为子类生成默认的构造函数
	例: using A::A			//使用基类的构造函数
	
8.使用final关键字来阻止函数继续被重写,是使派生类不可覆盖它所修饰的虚函数,若派生类继续重写,则编译出错

9.使用override关键字来使子类必须重载与父类中同名,函数签名一样的函数,若拼写或参数类型与父类不一致,则编译出错

10.c++98中类模板可以有默认参数,但是函数模板不可以,c++11中函数模板也可以有默认参数,不过与类模板不同的是,类模板默认参数必须从右至左的规则来指定,而对于函数模板并不是必须的

11.外部模板-当函数模板或类模板在2个不同的cpp中实例化后,会造成代码重复的问题(链接器会帮助我们只保留一份代码),但是这样,编译器要做实例化的工作,链接器要做代码移除的工作,太过冗余
	例:extern template void fun<int>(int)		//外部模板声明,其他地方必须要显示实例化
	
12.在c++98中用匿名的全局结构体或者局部的结构体都是无法作为类模板和函数模板的实参的,在c++11中取消了这一限制,但匿名类型的声明不能在模板实参位置
	例:MyTemplate<struct {int a;}>t   			//这种是错误的
	
13.委派构造函数,是在构造函数的初始化列表位置进行构造,委派的,称在初始化列表中调用"基准版本"的构造函数为委派构造函数,被调用的"基准版本"则为目标函数,就是指委派函数将构造的任务委派给了目标构造函数
   委派函数不能有初始化列表,即构造函数不能同时委派和使用初始化列表,注意别形成委托环
   
14.移动构造函数-移动语义(移为己用)--比如返回一个类的函数会在返回时调用拷贝构造函数,外面再调用一次拷贝构造函数,若拷贝构造函数里有new内存且比较大,就会造成性能上的浪费,可以使用移动构造函数使得外面的局部对象"偷走"临时对象的堆内存
   C++11中,右值是由2个概念组成的,将亡值(返回右值引用T&&函数返回值,std::move的返回值是将亡值)和纯右值(纯右值就是c++98中右值的概念,lambda表达式,临时变量值,1+3,'a'都是纯右值),所有的值必属于左值,将亡值,纯右值三者之一
   右值引用就是对一个右值进行的引用,右值引用是不能绑定到任何的左值的,存在的最大价值就是移动语义和转发: 例 T&& a=ReturnValue();    //假设ReturnValue返回的是一个右值,就声明了一个名为a的右值引用
   c++98中的引用就是左值引用,无论是声明一个左值引用还是右值引用,都必须立即进行初始化,左值引用是具名变量值的别名,右值引用是不具名变量(匿名)的别名,也可使用常量左值引用(万能引用)来引用右值,也可同样将一个右值的生命期延长,不过相比于右值引用,常量左值引用在余生只能是只读的
   std::move(参数)		//强制将一个左值转换为右值引用,头文件<utility>,基本相当于static_cast<T&&>(lvalue);
   <type_traits>中定义了3相模板类,is_rvalue_reference,is_lvalue_reference,is_reference供判断是否左值引用,右值引用,引用,可通过模板类成员value来判断,还可使用is_move_constructible,is_trivially_move_constructible,is_nothrow_move_consturctible,仍然是使用value成员来判断是否可移动的
   std::move_if_noexcept	//当移动构造函数没有noexcept修饰时,返回一个左值引用使变量可以使用拷贝构造,当移动构造函数有noexcept修饰时,返回右值引用,使变量可以使用移动语义
   
15.引用折叠
	typedef const int T;
	typedef T& TR;
	TR& v=1;		//该声明在c++98中会导致编译错误
	引用折叠的规则是只要在类型中出现了左值引用,则折叠为左值引用,都为右值引用才为右值引用
	引用折叠规则可以实现完美转发(不需要额外开销,如拷贝,考虑目标函数接收能力,如只接收左值或右值,转发过程要保证这一点)
	forward()		//将一个左值转换为右值,和move差别并不大,是为了让每个名字对应不同的用途
	为什么要用move和forward函数?  因为在c++11中,可以接受右值的右值引用本身是个左值
	
16.c++11中,标准将explicit的使用范围扩展到了自定义类型转换操作符上,以支持所谓的"显式转换",意味着只有在直接构造目标类型或显示类型转换的时候可以使用该类型,拷贝构造和非显式类型转换不被允许,通过赋值表达式和函数参数进行转换的问题就会暴露出来

17.列表初始化
	int b[] {2,4,5};								//c++98失败,c++11通过
	vector<int> c{1,3,5};							//c++98失败,c++11通过
	map<int,float> d={{1,1.0f},{2,2.0f},{5,3.2f}};	//c++98失败,c++11通过
	这样一来,自动变量和全局变量的初始化在c++11中被丰富了,3和4也可用于获取堆内存
	1.等号加上赋值表达式		int a=3+4
	2.等号加上花括号列表初始化	int a={3+4}
	3.圆括号式的表达式列表		int a(3+4)
	4.花括号式的表达式列表		int a{3+4}
	若要自定义类支持列表初始化,要包含<initializer_list>头文件,并且声明一个以initialize_list<T>模板类为参数的构造函数即可,同样的,函数参数也可使用列表初始化
	还可直接在函数末返回 		return {1,3}   构造成什么取决于返回类型
	使用列表初始化还可在编译时检查有无类型收窄,有的话编译会报错,而使用等号或圆括号初始化则不会检查,列表初始化是c++11中唯一一种可以防止类型收窄的初始化方式
	
18.POD类型(plain old data)
	通常用于说明类型的属性,plain表示pod是个普通的类型,old体现了与c的兼容性,将pod划分为两个基本概念的合集
	1.平凡的(trivial)				
		拥有平凡的默认构造函数和析构函数,拥有平凡的拷贝构造函数,拥有平凡的拷贝赋值,不过可以用default关键字显式地声明缺省版本的构造函数,使类型恢复"平凡化"
		不能包含虚函数或虚基类
		template<typename T> struct std::is_trivial;		//可以帮助判断一个类或结构或内置类型是事平凡的,头文件<type_traits>,is_trivial里的成员value可以帮助判断
	2.标准布局的(standard layout)	
		所有非静态成员有相同的访问权限
		在类或者结构体继承时,满足2种情况之一,一:派生类中有非静态成员,且只有一个仅包含静态成员的基类,二:派生类没有非静态成员,基类有非静态成员,即非静态成员只要同时出现在基类和子类中,就不是标准布局的,多重继承也会导致类型布局的变化,所以一旦非静态成员出现在多个基类中,派生也不属于标准布局的
		类中第一个非静态成员的类型与基类不同(原因是因为c++要求类型相同的对象必须地址不同,而c++标准允许如果基类中没有成员,派生类的第一个成员与基类共享地址,这样可以节省空间)
		没有虚函数和虚基类
		所有非静态数据成员均符合标准布局类型,其基类也符合标准布局类型,这是一个递归的定义
		template<typename T> struct std::is_standard_layout;	//value成员可以判断是否标准布局,头文件<type_traits>
	所以,对于POD而言,在c++11中定义就是平凡的和标准布局两方面
		template<typename T> struct std::is_pod;				//value成员可以判断是否POD类型,头文件<type_traits>
	POD的好处?
		字节赋值,可以安全地使用memset和memcpy对POD类型进行初始化和拷贝等操作
		提供对c内存布局兼容,c++程序可以与c函数进行相互操作,因为POD类型的数据在C与C++间的操作总是安全的
		保证了静态初始化的安全有效,静态初始化在很多时候能够提高程序的性能,而POD类型的对象初始化往往更加简单
	
19.非受限联合体
	在c++98中,若在union中加了了一个非POD类型,静态成员,或引用成员都是无法通过编译的
	c++11规定,任何非引用类型都可以成为联合体的数据成员,这样的联合体即所谓的非受限联合体,还允许在非匿名联合体中拥有静态成员,包括静态函数
	c++98中,会自动对在联合体中未成初始化列表中出现的成员赋0,这种初始化会带来疑问,因为在任何时刻,联合体都只有一个成员是有效的,在c++11中,为了减少这样的疑问,标准会默认删除一些非受限联合体的默认函数
		例:非受限联合体有一个非POD成员,而该非POD成员拥有非平凡的构造函数,那么非受限联合体成员的默认构造函数将被编译器删除,其他特殊成员函数,如默认拷贝,拷贝赋值,析构函数也遵从此规则,结果就是编译失败
	
20.用户自定义自面量
	可定义一个后缀标识的操作符,后缀必须以_开头
	RGBA operator "" _C(const char* col,size_t n)		//这个函数会解析以_C为后缀的字符串,并返回一个RGBA的临时变量,也可用于数值
	c++11中声明字面量操作有一定的规则
		如果字面量为整形数,那么字面量操作符函数只接受unsigned long long或者const char*为其参数,当unsigned long long无法容纳该字面量的时候,编译器会自动将该字面量转化为以'\0'为结束符的字符串,并调用以const char*为参数的版本进行处理
		如果字面量为浮点数,则字面量操作符函数只接受long double或者const char*为参数,调用规则同整形一样
		如果字面量为字符串,则字面量操作符函数只接受const char*,size_t为参数(已知长度的字符串)
		如果字面量为字符,则字面量操作符函数只可接受一个char为参数
	
21.内联名字空间
	c++98标准不允许在不同的名字空间中对模板进行特化
	关键字inline namespace可以声明一个内联的名字空间,内联的名字空间允许在父名字空间定义或物化子名字空间的模板,同样,内联的名字空间里的名字在父名字空间里也变得可见了,名字空间的内联会破坏该名字空间本身具有的的封装性
	ADL(Argument-Dependent name Lookup),参数关联名称查找,这个特性允许编译器在名字空间内找不到函数名称的时候,在参数的名字空间内查找函数名字
	
22.SFINEA(substitution failure is not an error)-匹配失败不是错误
	这条规则表示的是对重载的模板的参数进行展开的时候,如果展开导致了一些类型不匹配,编译器并不会报错
	在c++11中,表达式中没有出现"外部于表达式本身"的元素,比如说发生一些模板的实例化,或者隐匿地产生一些拷贝构造函数的话,这样的类模板都不会产生SFINFA失败(即编译器报错)
	
23.auto类型推导
	auto在以前c++98中表示自动存储期的意思,现在被赋予了新的含义,即类型自动推导,auto并非一种类型声明,而一个类型声明时的"占位符",编译器在编译时期会将auto替代为变量实际的类型
	例: atuo name="world\n";		//会被推导为char *
		auto z;						//无法推导,无法通过编译,auto声明的变量必须被初始化,以使编译器能够从其初始化表达式推导出其类型
	const变量与volatile变量(cv限制符->cv-qualifier)可以与auto关键字一起使用,不过声明为auto的变量并不能从其初始化表达式中带走cv限制符,需要自己加上cv限制符,引用和指针除外除外
	同一个赋值语句中,auto可以用来声明多个变量,但这些变量类型必须一致,否则编译报错,事实上,只有第一个变量用于auto类型推导,然后推导出的数据类型被用作于其他变量
	不过auto也不是万能的,atuo也有限制
		auto不能作为函数的形参类型
		auto非静态成员变量(无法通过编译)
		auto数组(无法通过编译)
		auto模板参数(实例化时)   无法通过编译
		
24.decltype类型推导
	declytype总是以一个普通的表达式作为参数,返回该表达式的类型,编译时进行,可以重用匿名类型,加强模板泛型能力,能带走cv限制符
	int i;decltype(i) j=0;			//表示j的类型和i相同
	decltype限制
		int a;decltype(a) i=0; //通过  decltype((a)) i;  //编译失败
		1.如果a是一个没有带括号的标记符表达式或者类成员访问表达式,那么decltype(a)就是a所命令的实体的类型,如果a是一个被重载的函数,则会导致编译时错误
		2.否则,假设a的类型是T,如果a是一个将亡值,那么decltype(a)为T&&
		3.否则,假设a的类型是T,如果a是一个左值,则decltype(a)为T&
		4.否则,假设a的类型是T,则decltype(a)为T
	标记符表达式:基本上,所有除去关键字,字面量等编译器需要使用的标记之外的程序员自定义的标记都可以是标记符,而单个标记符就是标记符表达式
	例: int arr[4]; 那么arr是一个标记符表达式,arr[3]+0,arr[3]等都不是标记符表达式
	与auto相同的是会忽略一些冗余的符号,如推导出来本来就是引用,decltype(a) &i=j; 若j已经引用类型,则i前面的&会被忽略,不过decltype后的*不会被忽略,auto会忽略
	
25.追踪返回类型
	typename<typename T1,typename T2>
	decltype(t1+t2) sum(T1 &t1,T2 &t2)		//不会通过编译,因为在使用decltype时,t1,t2尚未声明,编译器是从左到右,从上到下读符号的
	{
		return t1+t2;
	}
	auto sum(T1 &t1,T2 &t2) -> decltype(t1+t2){}	//追踪返回类型,这样就实现了返回类型后置
	
26.基于范围的for循环
	for循环后括号内容分为两部分,第一部分为用于迭代的变量,第二部分表示迭代的范围
	int arr[5]={1,2,3,4,5};for(int e:arr) cout<<e<<endl;		//若要修改arr的值,则将int e改为int &e引用就可以了
	
27.强类型枚举
	以前的c++98中,枚举有几个缺点如下:
		非强类型作用域
		允许隐匿转换为整形
		占用存储空间及符号性不确定(windows下都是无符号整型,linux下是有符号)
	声明强类型枚举->enum class,有以下几个优势,enum class与enum struct没有任何区别
		强作用域,强类型枚举成员的名称不会被输出到其父作用空间
		转换限制,强类型枚举成员的值不可以与整形隐式地相互转换
		可以指定底层类型,强类型枚举默认的底层类型为int,但也可以显式地指定底层类型,具体方法为在枚举名称后面加上": type",type可以是除wchar_t以外的任何整形
	对非强类型枚举进行了扩展,使得非强类型枚举也可以使用": type"来指定底层使用的类型,第二个扩展是作用域,除了在父作用域有效,也可以使用 className:enumNam 来使用枚举
	匿名enum class是强类型作用域的,所以什么也做不了,enum struct不同
	
28.智能指针
	auto_ptr缺点:拷贝时返回一个左值,不能调用delete [],两个auto_ptr不能同时拥有一个对象等,因此在c++11中被废弃了
	c++11中使用unique_ptr,shared_ptr,weak_ptr
	unique_ptr  	与所指对象内存绑定紧密,不能和其他unique_ptr共享所指对象内存,仅能通过move函数来转移,转移成功,原来的unique_ptr就推动了对象内存的所有权
		从实现来说,unique_ptr是一个删除了拷贝构造函数,保留了移动构造函数的指针封装类型
	shared_ptr		允许多个该智能指针共享地拥有同一个堆分配对象的内存,在实现上采用了引用计数,一旦一个shared_ptr调用了reset也不一定释放内存,而是在计数为0时释放内存
	weak_ptr		它可以指向shared_ptr分配的内存,却并不拥有该内存,即不影响shared_ptr的引用计数,使用weak_ptr成员lock,则可返回一个其指向内存的shared_ptr对象,且在所指对象无效时,返回一个nullptr,一般用于解除循环引用问题(相互引用)
	
29.垃圾回收机制
	基于引用计数的垃圾回收器
		主要使用系统记录对象被引用(引用,指针)的次数,当对象被引用的次数为0时,该对象即可被视作"垃圾"而回收,实现简单,不会造成程序暂停,因此被认作"副作用"较小,比较验证处理"环形"引用,因此带来的额外开销也不小,实用上有一些限制
	基于跟踪处理的垃圾回收器
		产生跟踪对象的关系图,然后进行垃圾回收,使用跟踪方式的垃圾回收算法主要有以下几种
			标记-清除(Mark-Sweep)	将正在使用的对象视为根对象,从根对象开始查找它们所引用的堆空间,并在这些堆空间上做标记,当标记结束后,所有被标记的对象就是可达对象或活对象,没有被标记的对象被认为是垃圾,在第二步的清扫阶段会被回收掉,特点是活的对象不会被移动,但是其存在会出现大量内存碎片的问题
			标记-整理(Mark-Compact)	这个算法和标记清除一样,但是标记完之后,不再遍历所有对象的垃圾了,而是将活的对象向"左"对齐,这就解决了内存碎片的问题,因此,程序中所有对堆内存的引用都必须更新
			标记-拷贝(Mark-Copy)	这种算法将堆分为两部分,From和To,刚开始系统只从From的堆空间里分配内存,当From分配满的时候系统开始垃圾回收,从From堆找出所有活的对象,拷贝到To的空间里,这样一来,From里全剩垃圾,To里是紧凑排列的,接着From和To交换一下角色即可
									这种算法对堆的利用率只有一半,而且只是标记-整理的另一种实现而已
	c++11做到了最小垃圾回收的支持(由于指针的灵活性,无法完全支持垃圾回收)
	对"安全"的指针的定义,使用c++中的术语来说,安全派生(safely derived)的指针,安全派生的指针是指向由new分配的对象或其子对象的指针,安全派生指针的操作包括:
		在解引用的基础上引用,比如:&*p
		定义明确的指针操作,比如:p+1
		定义明确的指针转换,比如:static_cast<void *>(p)
		指针和整形之间的reinterpret_cast,比如:reinterpret_cast<intptr_t>(p)		//intptr_t是C++11中可选择实现的一个类型,其长度等于平台上的指针长度
	c++11中最小垃圾回收支持是基于安全派生指针这个概念的,可以通过get_pointer_safety函数查询来确认编译器是否支持这个特性,原型如下
		pointer_safety get_pointer_safety() noexcept  //如果返回值为pointer_safety::strict则表明编译器支持最小垃圾回收及安全派生指针这个概念,如果为pointer_safety::relax或是pointer_safety::preferred,则表明编译器不支持
	void declare_reachable(void *p)	//将某个指针声明为可达的,即使他的所有指针都对回收器不可见
	template<class T> T* undeclare_reachable(T *p) noexcept;	//可以取消上面的可达声明
	有时会在一大片连续内存上进行指针式操作,为了让垃圾回收器不关心该区域,可以使用以下函数
		void declare_no_pointers(char *p,size_t n) noexcept;
		void undeclare_no_pointers(char *p,size_t n) noexcept;
	c++11中的最小垃圾回收仅限于new分配的内存,malloc分配的内存总被认为是可达的,即无论何时垃圾回收器都不予回收,目前基本上编译器连最小垃圾回收机制也不支持
	
30.常量表达式
	const修饰的是运行时的常量不变性,而不是编译时,如const变量就无法在数组,枚举,switch-case中使用
	c++11使用constexpr来修饰编译时常量表达式,这样,上面举的几个例子都可通过编译
	constexpr修饰函数返回值,此函数即为常量表达式函数,常量表达式函数的要求非常严格:
		函数体只有单一的return语句(即只有一条代码,不过一些不产生实际代码的语句可以使用,如static_assert,using,typedef等也不会造成问题)
		函数必须返回值(不能是void函数)
		在使用前必须已有定义
		return返回语句表达式中不能使用非常量表达式的函数,全局数据,且必须是一个常量表达式
	constexpr不能用于修饰自定义类型,需要自定义常量构造函数,在构造函数前加上constexpr即可,常量表达式的构造函数有也约束:
		函数体必须为空
		初始化列表只能由常量表达式来赋值
	constexpr不允许作用于virtual函数
	c++11标准规定,对常量表达式应该至少支持512层递归
	
31.变长模板
	例: template<typename... Elements> class tuple;			//...表示该参数是变长的,std::tuple<>是实际存在的类,Elements被称作是一个"模板参数包",这是一种新的模板参数类型
	一个模板参数包在推导时被认为是模板的单个参数,为了使用模板参数包,需要将其解包,在c++11中,这是通过一个包扩展的表达式来完成的
	例: template<typename... A> class Template: private B<A...>{};	//表达式A...就是一个包扩展
	真实使用例子:
		template<typename... Elements> class tuple;		//变长模板的声明
		template<typename Head,typename... Tail>:private tuple<Tail...>	//该偏特化版本会一直递归下去到边界条件
		{
			Head head;
		};
		template<> class tuple<> {};		//边界条件
	还可以写变长参数的函数模板,标准要求函数参数包必须唯一,且是函数的最后一个参数(模板参数没有这样的要求)
	标准定义了以下7种参数包可以展开的位置
		表达式
		初始化列表(列表初始化)
		基类描述列表
		类成员初始化列表
		模板参数列表
		通用属性列表
		lambda函数的捕捉列表
	private B<A>...和private B<A...>是不一样的,前者会产生多重继承,后者会派生于多参数的模板类,函数中也按照相同的方式扩展
	新操作符sizeof...,sizeof后面有三个点,作用是计算参数包中的参数个数
	
32.原子操作
	原子操作就是多线程中"最小的且不可并化的操作",在以前要借助互斥锁,头文件<cstdatomic>,也可以是<atomic>因为c11也支持原子操作,所以直接包含了c11的头文件
		atomic_bool			bool
		atomic_char			char
		atomic_schar		signed_char
		atomic_uchar 		unsigned_char
		atomic_int			int
		atomic_uint			unsigned int
		atomic_short		short
		atomic_ushort		unsigned short
		atomic_long			long
		atomic_ulong		unsigned long
		atomic_llong		long long
		atomic_ullong		unsigned long long
		atomic_char16_t		char16_t
		atomic_char32_t		char32_t
		atomic_wchar_t		wchar_t
	atomic类型的拷贝构造,移动构造,operator =是被禁止的,只能从模板参数进行构造
	更为普通的是使用atomic类模板,可以定义出任意需要的原子类型:std::atomic<T> t;只能从模板参数类型中进行构造,不允许原子类型进行拷贝构造,移动构造,以及使用operator =等
	内存模型:指令在cpu中并不一定是按照顺序执行的,如果总是按顺序执行的,则称为强顺序的(strong ordered),如果不是,刚称为弱顺序的(weak ordered,通常这样的执行顺序是超标量的流水线,即一个时钟周期里发射多条指令而产生的)
	现实中,X86以及SPARC(TSO模式)都被看作是强顺序内存模型的开台,而Alpha,PowerPC,Itanlium,ArmV7是弱顺序的,通常需要在汇编指令中加一条所谓的内存栅栏命令,PowerPC上就有一条sync内存栅栏命令,sync之前的指令肯定在sync之后的指令之前运行,这对PowerPC的性能影响很大
	在高级语言和机器指令之间还有一层隔离,即编译的优化,所以X86上调试代码也不一定是强顺序的,编译器可以优化指令的顺序
	c++11中的原子操作总是保证了顺序一致性,这样对于X86平台来说,禁止了编译器对原子类型变量间的重排优化;而对于PowerPc这样的平台来说,不仅禁止了编译器的重排优化,还插入了大量的内存栅栏,对性能造成了很大的伤害
	c++11给出的解决方式是让程序员为原子操作指定所谓的内存顺序memory_order,有以下7种类型
		memory_order_relaxed	不对执行顺序做任何保证
		memory_order_acquire	本线程中,所有后续的读操作必须在本条原子操作完成后执行
		memory_order_release	本线程中,所有之前的写操作完成后才能执行本条原子操作
		memory_order_acq_rel	同时包含memory_order_acquire和memory_order_release标记
		memory_order_consume	本线程中,所有后续的有关本原子类型的操作,必须在本条原子操作完成之后执行
		memory_order_seq_cst	全部存取都按顺序执行
	要采用上述的内存模型,必须使用atomic类中的load,store等函数
	
33.线程局部存储(TLS,thread local storage)
	如errorNo若在多个线程中共享,则可能会隐藏一些错误信息,在全局或者静态变量前加上thread_local即可声明一个TLS变量,每个线程都拥有独立的拷贝
	例: int thread_local errCode;	//其值将在线程开始时初始化,线程结束后,该值不再有效
	TLS变量的内存究竟是在程序一开始就被分配还是在线程开始运行时分配,或者两者都支持,c++11标准允许编译器自行选择静态分配或是动态分配
	terminate	头文件<exception>,没有被捕捉到的异常就会导致terminate函数的调用,此外,如果声明了函数noexcept,如果抛出了异常,也会调用terminate,只要c++程序中出现了非程序员预期的行为,就有可能调用terminate,terminate在默认情况下,是调用abort函数,不过可以通过set_terminate函数来改变默认的行为,不会调用析构函数
	exit		会正常调用自动变量的析构函数,并且还会调用atexit注册的函数,这跟main函数结束时的清理工作是一样的,注册的函数被调用的顺序与其注册的顺序相反,有时在程序正常结束或者线程中调用exit会很慢,因为他要做一些析构和atexit注册的函数,事实上,操作系统回收更快,他只是将内存标为未使用即可
	quick_exit	c++11标准引入的新函数,并不执行析构而只是使程序终止,与abort不同的是,quick_exit与exit同属正常退出,abort属异常退出,可能系统还会调用coredump等辅助进行问题分析,此外,at_quick_exit注册的函数也可以在quick_exit的时候被调用

34.nullptr
	nullptr是有类型的,代表指针空值,nullptr_t是由typedef decltype(nullptr) nullptr_t;定义来的,使用nullptr_t必须包含头文件<cstddef>,因为nullptr是关键字,而nullptr_t是推导来的原因
	nullptr仅可以隐式转换成指针类型,所以不会有重载时使用NULL调用问题的bug,不要对nullptr取地址,会编译失败
	此外,nullptr在作为模板参数时并不能正确地被推导为指针类型,需要显示地转换
	例:template<T> void g(T* t){} g(nullptr);是会编译失败的,需要使用g((float*)nullptr)会推导出T=float
	
35.默认函数
	在c++中声明的自定义的类,编译器会默认帮助生成一些未自定义的函数,这样的函数称为默认函数
		构造函数,拷贝构造函数,拷贝赋值函数,移动构造函数,移动拷贝函数,析构函数
		operator,;operator &;operator &&;operator *;operator ->;operator ->*;operator new;operator delete;
	一但在自定义类中声明了构造函数就可能导致这个类不再是POD类型的,可以在默认函数定义或者声明时加上 "= default",显式地指示编译器生成该函数的默认函数版本
	有时,不需要拷贝构造函数或其他函数,在c++98中是将其声明为private,不过在友元类中可能出现麻烦,友元类如果需要拷贝构造,而如果只是简单声明不实现的话会报错,c++11中采用在函数定义或声明后加上"= delete",会使编译器不生成函数的缺省版本,一旦缺省版本被删除了,那么重载他也是非法的
	=deafult与=delete不仅仅局限在类的定义之内,也可以在类之外声明,在类之外显式指定是有好处的,可以对一个class在多个cpp中实现不同的版本
	explicit不要与=delete一起使用,会导致一些很难查找的问题,隐式转换还是会发生,显示构造被删除了
	
36.lambda表达式
	语法如下:	[capture](parameters) mutable -> return-type{statement};
	[capture]		捕捉列表,捕捉列表总是出现在lambda开始处,事实上,[]是lambda引出符,捕捉列表能够捕捉上下文中的变量以供lambda使用
	(parameters)	参数列表,与普通的参数列表一致,如果不需要参数传递,则可以连同括号()一起省略
	mutable			修饰符,默认情况下,lambda函数总是一个const函数,mutable可以取消其常量性,在使用该修饰符时,参数列表不可省略,即使参数为空
	->return-type	返回类型,用追踪返回类型的形式声明函数的返回类型,不需要返回值的时候可以连同符号->一起省略,此外,在返回类型明确的情况下,也可以省略该部分,让编译器对返回类型进行推导
	捕捉列表:
		[var]表示值传递方式捕捉变量var
		[=]表示值传递方式捕捉所有父作用域变量(包括this)
		[&var]表示引用传递捕捉变量var
		[&]表示引用传递捕捉所有父作用域变量(包括this)
		[this]表示值传递方式捕捉当前的this指针
	只能捕捉父作用域的自动变量,捕捉任何非自动变量(如静态变量)都会导致编译器报错
	以前c++中的operator()是一种仿函数,在现阶段,lambda可以视为仿函数的一种造价形式,lambda函数默认在c++11中是内联的
	lambda的类型被定义为"闭包"的类,严格上地讲,lambda并非函数指针,不过c++11却允许lambda表达式向函数指针的转换,前提是lambda没有捕捉任何变量,且函数指针反示的函数原型必须跟lambda有着相同的调用方式,指针无法转换为lambda
	
37.数据对齐
	使用修饰符alignas来重新设定一个数据结构的对齐方式,以前可使用编译器的扩展__attribute__来描述(GNU的),必须是2的倍数
	如:
		struct alignas(32) ColorVector		//指定ColorVector对齐到32字节的地址边界
		{	
			double r;
			double g;
			double b;
			double a;
		}
	alignof(ColorVector)将返回32,alignof是一个操作符,返回的值是一个size_t类型的整形常量,如果sizeof一样
	c++11还内建了std::align函数来动态地根据指定的对齐方式调整数据块的位置,原型如下
	void *align(std::size_t alignment,std::size_t size,void* &ptr,std::size_t&space);  //该函数在ptr指向的大小为space内存中进行对齐方式的调整,将ptr开始的size大小的数据调整为按alignment对齐
	
38.通用属性
	c++11中的通用属性使用了左右双中括号的形式,可以作用于类型,变量,名称,代码块等,既可以写在声明的起始处,也可以写在声明的标识符之后
	[[ attribute-list ]]
	在现有的c++11标准中,只预定义了两个通用属性,分别是[[ noreturn ]]和[[carries_dependency]],noreturn用于标识不会将控制流返回给调用函数的函数,不是指没有返回值的函数,编译器就可以优化在这个函数调用之后的代码不生成,这与__attribute__(noreturn)有区别
	[[carries_dependency]]跟并行情况下的编译器优化有关,事实上,主要是为了解决弱内存模型平台上使用memory_order_consume内存顺序的枚举问题,既可以标识函数参数,也可以标识函数返回值,标识函数参数时,表示数据依赖随着参数传递进入函数,即不需要产生内存栅栏,表示函数返回值时,表示数据依赖随着返回值传递出函数,同样也不需要产生内存栅栏
	
39.unicode支持
	在c++98中一般使用wchar_t来表示中文,但wchar_t可以为8,16,32位,由编译器决定,可移植性低
	char16_t	用于存储UTF-16编码的unicode数据
	char32_t	用于存储UTF-32编码的unicode数据
	至于utf-8编码的unicode数据,c++11还是使用8字节宽度的char类型数组来保存
	常量字符串前缀:u8表示utf-8编码,u表示utf-16编码,U表示utf-32编码,还声明了一些简明的方式,在字符串中用'\u'加4个16进制数编码的Unicode位(UTF-16)来标识一个Unicode字符
	字符转换函数头文件<cuchar>
	
40.原生字符串字面量
	即所见即所得,不需要加\t,\r等转义字符,只需要在字符串前加入前缀R,并在引号中使用左右括号
	例:R"(hello \n \t)"
	对于unicode字符串,也可使用此方式,对应前缀u8R,uR,UR,不过要注意的是\u就不能使用了